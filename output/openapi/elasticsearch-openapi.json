{
  "openapi": "3.0.3",
  "info": {
    "title": "Elasticsearch Request & Response Specification",
    "license": {
      "name": "Apache 2.0",
      "url": "https://github.com/elastic/elasticsearch-specification/blob/main/LICENSE"
    },
    "version": ""
  },
  "paths": {
    "/_async_search/{id}": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get async search results",
        "description": "Retrieve the results of a previously submitted asynchronous search request.\nIf the Elasticsearch security features are enabled, access to the results of a specific async search is restricted to the user or API key that submitted it.",
        "operationId": "async-search-get",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the async search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "Specifies how long the async search should be available in the cluster.\nWhen not specified, the `keep_alive` set with the corresponding submit async request will be used.\nOtherwise, it is possible to override the value and extend the validity of the request.\nWhen this period expires, the search, if still running, is cancelled.\nIf the search is completed, its saved results are deleted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "typed_keys",
            "description": "Specify whether aggregation and suggester names should be prefixed by their respective types in the response",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion_timeout",
            "description": "Specifies to wait for the search to be completed up until the provided timeout.\nFinal results will be returned if available before the timeout expires, otherwise the currently available results will be returned once the timeout expires.\nBy default no timeout is set meaning that the currently available results will be returned without any additional wait.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/async_search._types:AsyncSearchDocumentResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.7.0"
      },
      "delete": {
        "tags": [
          "search"
        ],
        "summary": "Delete an async search",
        "description": "If the asynchronous search is still running, it is cancelled.\nOtherwise, the saved search results are deleted.\nIf the Elasticsearch security features are enabled, the deletion of a specific async search is restricted to: the authenticated user that submitted the original search request; users that have the `cancel_task` cluster privilege.",
        "operationId": "async-search-delete",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the async search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_async_search/status/{id}": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get the async search status",
        "description": "Get the status of a previously submitted async search request given its identifier, without retrieving search results.\nIf the Elasticsearch security features are enabled, use of this API is restricted to the `monitoring_user` role.",
        "operationId": "async-search-status",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the async search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "Specifies how long the async search needs to be available.\nOngoing async searches and any saved search results are deleted after this period.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/async_search.status:StatusResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.11.0"
      }
    },
    "/_async_search": {
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run an async search",
        "description": "When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field. Partial results become available following the sort criteria that was requested.\n\nWarning: Asynchronous search does not support scroll or search requests that include only the suggest section.\n\nBy default, Elasticsearch does not allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.\nThe maximum allowed size for a stored async search response can be set by changing the `search.max_async_search_response_size` cluster level setting.",
        "operationId": "async-search-submit",
        "parameters": [
          {
            "$ref": "#/components/parameters/async_search.submit#wait_for_completion_timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_alive"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_on_completion"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyzer"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#default_operator"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#df"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#explain"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#lenient"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#preference"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#request_cache"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#routing"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#search_type"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stats"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stored_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_field"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_text"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#terminate_after"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_scores"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#typed_keys"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#version"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_includes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#q"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#from"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/async_search.submit"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/async_search.submit#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/{index}/_async_search": {
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run an async search",
        "description": "When the primary sort of the results is an indexed field, shards get sorted based on minimum and maximum value that they hold for that field. Partial results become available following the sort criteria that was requested.\n\nWarning: Asynchronous search does not support scroll or search requests that include only the suggest section.\n\nBy default, Elasticsearch does not allow you to store an async search response larger than 10Mb and an attempt to do this results in an error.\nThe maximum allowed size for a stored async search response can be set by changing the `search.max_async_search_response_size` cluster level setting.",
        "operationId": "async-search-submit-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/async_search.submit#index"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#wait_for_completion_timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_alive"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_on_completion"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyzer"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#default_operator"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#df"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#explain"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#lenient"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#preference"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#request_cache"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#routing"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#search_type"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stats"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stored_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_field"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_text"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#terminate_after"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_scores"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#typed_keys"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#version"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_includes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#q"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#from"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/async_search.submit"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/async_search.submit#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_autoscaling/policy/{name}": {
      "get": {
        "tags": [
          "autoscaling"
        ],
        "summary": "Get an autoscaling policy",
        "description": "NOTE: This feature is designed for indirect use by Elasticsearch Service, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/cloud/current/ec-autoscaling.html"
        },
        "operationId": "autoscaling-get-autoscaling-policy",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "the name of the autoscaling policy",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/autoscaling._types:AutoscalingPolicy"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.11.0"
      },
      "put": {
        "tags": [
          "autoscaling"
        ],
        "summary": "Create or update an autoscaling policy",
        "description": "NOTE: This feature is designed for indirect use by Elasticsearch Service, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/cloud/current/ec-autoscaling.html"
        },
        "operationId": "autoscaling-put-autoscaling-policy",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "the name of the autoscaling policy",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/autoscaling._types:AutoscalingPolicy"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.11.0"
      },
      "delete": {
        "tags": [
          "autoscaling"
        ],
        "summary": "Delete an autoscaling policy",
        "description": "NOTE: This feature is designed for indirect use by Elasticsearch Service, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/cloud/current/ec-autoscaling.html"
        },
        "operationId": "autoscaling-delete-autoscaling-policy",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "the name of the autoscaling policy",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.11.0"
      }
    },
    "/_autoscaling/capacity": {
      "get": {
        "tags": [
          "autoscaling"
        ],
        "summary": "Get the autoscaling capacity",
        "description": "NOTE: This feature is designed for indirect use by Elasticsearch Service, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.\n\nThis API gets the current autoscaling capacity based on the configured autoscaling policy.\nIt will return information to size the cluster appropriately to the current workload.\n\nThe `required_capacity` is calculated as the maximum of the `required_capacity` result of all individual deciders that are enabled for the policy.\n\nThe operator should verify that the `current_nodes` match the operatorâ€™s knowledge of the cluster to avoid making autoscaling decisions based on stale or incomplete information.\n\nThe response contains decider-specific information you can use to diagnose how and why autoscaling determined a certain capacity was required.\nThis information is provided for diagnosis only.\nDo not use this information to make autoscaling decisions.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/cloud/current/ec-autoscaling.html"
        },
        "operationId": "autoscaling-get-autoscaling-capacity",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "policies": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingDeciders"
                      }
                    }
                  },
                  "required": [
                    "policies"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.11.0"
      }
    },
    "/_bulk": {
      "put": {
        "tags": [
          "document"
        ],
        "summary": "Bulk index or delete documents",
        "description": "Perform multiple `index`, `create`, `delete`, and `update` actions in a single request.\nThis reduces overhead and can greatly increase indexing speed.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To use the `create` action, you must have the `create_doc`, `create`, `index`, or `write` index privilege. Data streams support only the `create` action.\n* To use the `index` action, you must have the `create`, `index`, or `write` index privilege.\n* To use the `delete` action, you must have the `delete` or `write` index privilege.\n* To use the `update` action, you must have the `index` or `write` index privilege.\n* To automatically create a data stream or index with a bulk API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n* To make the result of a bulk operation visible to search using the `refresh` parameter, you must have the `maintenance` or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nThe actions are specified in the request body using a newline delimited JSON (NDJSON) structure:\n\n```\naction_and_meta_data\\n\noptional_source\\n\naction_and_meta_data\\n\noptional_source\\n\n....\naction_and_meta_data\\n\noptional_source\\n\n```\n\nThe `index` and `create` actions expect a source on the next line and have the same semantics as the `op_type` parameter in the standard index API.\nA `create` action fails if a document with the same ID already exists in the target\nAn `index` action adds or replaces a document as necessary.\n\nNOTE: Data streams support only the `create` action.\nTo update or delete a document in a data stream, you must target the backing index containing the document.\n\nAn `update` action expects that the partial doc, upsert, and script and its options are specified on the next line.\n\nA `delete` action does not expect a source on the next line and has the same semantics as the standard delete API.\n\nNOTE: The final line of data must end with a newline character (`\\n`).\nEach newline character may be preceded by a carriage return (`\\r`).\nWhen sending NDJSON data to the `_bulk` endpoint, use a `Content-Type` header of `application/json` or `application/x-ndjson`.\nBecause this format uses literal newline characters (`\\n`) as delimiters, make sure that the JSON actions and sources are not pretty printed.\n\nIf you provide a target in the request path, it is used for any actions that don't explicitly specify an `_index` argument.\n\nA note on the format: the idea here is to make processing as fast as possible.\nAs some of the actions are redirected to other shards on other nodes, only `action_meta_data` is parsed on the receiving node side.\n\nClient libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.\n\nThere is no \"correct\" number of actions to perform in a single bulk request.\nExperiment with different settings to find the optimal size for your particular workload.\nNote that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.\nIt is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.\nFor instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.\n\n**Client suppport for bulk requests**\n\nSome of the officially supported clients provide helpers to assist with bulk requests and reindexing:\n\n* Go: Check out `esutil.BulkIndexer`\n* Perl: Check out `Search::Elasticsearch::Client::5_0::Bulk` and `Search::Elasticsearch::Client::5_0::Scroll`\n* Python: Check out `elasticsearch.helpers.*`\n* JavaScript: Check out `client.helpers.*`\n* .NET: Check out `BulkAllObservable`\n* PHP: Check out bulk indexing.\n\n**Submitting bulk requests with cURL**\n\nIf you're providing text file input to `curl`, you must use the `--data-binary` flag instead of plain `-d`.\nThe latter doesn't preserve newlines. For example:\n\n```\n$ cat requests\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n$ curl -s -H \"Content-Type: application/x-ndjson\" -XPOST localhost:9200/_bulk --data-binary \"@requests\"; echo\n{\"took\":7, \"errors\": false, \"items\":[{\"index\":{\"_index\":\"test\",\"_id\":\"1\",\"_version\":1,\"result\":\"created\",\"forced_refresh\":false}}]}\n```\n\n**Optimistic concurrency control**\n\nEach `index` and `delete` action within a bulk API call may include the `if_seq_no` and `if_primary_term` parameters in their respective action and meta data lines.\nThe `if_seq_no` and `if_primary_term` parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.\n\n**Versioning**\n\nEach bulk item can include the version value using the `version` field.\nIt automatically follows the behavior of the index or delete operation based on the `_version` mapping.\nIt also support the `version_type`.\n\n**Routing**\n\nEach bulk item can include the routing value using the `routing` field.\nIt automatically follows the behavior of the index or delete operation based on the `_routing` mapping.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n**Wait for active shards**\n\nWhen making bulk calls, you can set the `wait_for_active_shards` parameter to require a minimum number of shard copies to be active before starting to process the bulk request.\n\n**Refresh**\n\nControl when the changes made by this request are visible to search.\n\nNOTE: Only the shards that receive the bulk request will be affected by refresh.\nImagine a `_bulk?refresh=wait_for` request with three documents in it that happen to be routed to different shards in an index with five shards.\nThe request will only wait for those three shards to refresh.\nThe other two shards that make up the index do not participate in the `_bulk` request at all.",
        "operationId": "bulk-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#list_executed_pipelines"
          },
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          },
          {
            "$ref": "#/components/parameters/bulk#require_data_stream"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Bulk index or delete documents",
        "description": "Perform multiple `index`, `create`, `delete`, and `update` actions in a single request.\nThis reduces overhead and can greatly increase indexing speed.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To use the `create` action, you must have the `create_doc`, `create`, `index`, or `write` index privilege. Data streams support only the `create` action.\n* To use the `index` action, you must have the `create`, `index`, or `write` index privilege.\n* To use the `delete` action, you must have the `delete` or `write` index privilege.\n* To use the `update` action, you must have the `index` or `write` index privilege.\n* To automatically create a data stream or index with a bulk API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n* To make the result of a bulk operation visible to search using the `refresh` parameter, you must have the `maintenance` or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nThe actions are specified in the request body using a newline delimited JSON (NDJSON) structure:\n\n```\naction_and_meta_data\\n\noptional_source\\n\naction_and_meta_data\\n\noptional_source\\n\n....\naction_and_meta_data\\n\noptional_source\\n\n```\n\nThe `index` and `create` actions expect a source on the next line and have the same semantics as the `op_type` parameter in the standard index API.\nA `create` action fails if a document with the same ID already exists in the target\nAn `index` action adds or replaces a document as necessary.\n\nNOTE: Data streams support only the `create` action.\nTo update or delete a document in a data stream, you must target the backing index containing the document.\n\nAn `update` action expects that the partial doc, upsert, and script and its options are specified on the next line.\n\nA `delete` action does not expect a source on the next line and has the same semantics as the standard delete API.\n\nNOTE: The final line of data must end with a newline character (`\\n`).\nEach newline character may be preceded by a carriage return (`\\r`).\nWhen sending NDJSON data to the `_bulk` endpoint, use a `Content-Type` header of `application/json` or `application/x-ndjson`.\nBecause this format uses literal newline characters (`\\n`) as delimiters, make sure that the JSON actions and sources are not pretty printed.\n\nIf you provide a target in the request path, it is used for any actions that don't explicitly specify an `_index` argument.\n\nA note on the format: the idea here is to make processing as fast as possible.\nAs some of the actions are redirected to other shards on other nodes, only `action_meta_data` is parsed on the receiving node side.\n\nClient libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.\n\nThere is no \"correct\" number of actions to perform in a single bulk request.\nExperiment with different settings to find the optimal size for your particular workload.\nNote that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.\nIt is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.\nFor instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.\n\n**Client suppport for bulk requests**\n\nSome of the officially supported clients provide helpers to assist with bulk requests and reindexing:\n\n* Go: Check out `esutil.BulkIndexer`\n* Perl: Check out `Search::Elasticsearch::Client::5_0::Bulk` and `Search::Elasticsearch::Client::5_0::Scroll`\n* Python: Check out `elasticsearch.helpers.*`\n* JavaScript: Check out `client.helpers.*`\n* .NET: Check out `BulkAllObservable`\n* PHP: Check out bulk indexing.\n\n**Submitting bulk requests with cURL**\n\nIf you're providing text file input to `curl`, you must use the `--data-binary` flag instead of plain `-d`.\nThe latter doesn't preserve newlines. For example:\n\n```\n$ cat requests\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n$ curl -s -H \"Content-Type: application/x-ndjson\" -XPOST localhost:9200/_bulk --data-binary \"@requests\"; echo\n{\"took\":7, \"errors\": false, \"items\":[{\"index\":{\"_index\":\"test\",\"_id\":\"1\",\"_version\":1,\"result\":\"created\",\"forced_refresh\":false}}]}\n```\n\n**Optimistic concurrency control**\n\nEach `index` and `delete` action within a bulk API call may include the `if_seq_no` and `if_primary_term` parameters in their respective action and meta data lines.\nThe `if_seq_no` and `if_primary_term` parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.\n\n**Versioning**\n\nEach bulk item can include the version value using the `version` field.\nIt automatically follows the behavior of the index or delete operation based on the `_version` mapping.\nIt also support the `version_type`.\n\n**Routing**\n\nEach bulk item can include the routing value using the `routing` field.\nIt automatically follows the behavior of the index or delete operation based on the `_routing` mapping.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n**Wait for active shards**\n\nWhen making bulk calls, you can set the `wait_for_active_shards` parameter to require a minimum number of shard copies to be active before starting to process the bulk request.\n\n**Refresh**\n\nControl when the changes made by this request are visible to search.\n\nNOTE: Only the shards that receive the bulk request will be affected by refresh.\nImagine a `_bulk?refresh=wait_for` request with three documents in it that happen to be routed to different shards in an index with five shards.\nThe request will only wait for those three shards to refresh.\nThe other two shards that make up the index do not participate in the `_bulk` request at all.",
        "operationId": "bulk",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#list_executed_pipelines"
          },
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          },
          {
            "$ref": "#/components/parameters/bulk#require_data_stream"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      }
    },
    "/{index}/_bulk": {
      "put": {
        "tags": [
          "document"
        ],
        "summary": "Bulk index or delete documents",
        "description": "Perform multiple `index`, `create`, `delete`, and `update` actions in a single request.\nThis reduces overhead and can greatly increase indexing speed.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To use the `create` action, you must have the `create_doc`, `create`, `index`, or `write` index privilege. Data streams support only the `create` action.\n* To use the `index` action, you must have the `create`, `index`, or `write` index privilege.\n* To use the `delete` action, you must have the `delete` or `write` index privilege.\n* To use the `update` action, you must have the `index` or `write` index privilege.\n* To automatically create a data stream or index with a bulk API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n* To make the result of a bulk operation visible to search using the `refresh` parameter, you must have the `maintenance` or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nThe actions are specified in the request body using a newline delimited JSON (NDJSON) structure:\n\n```\naction_and_meta_data\\n\noptional_source\\n\naction_and_meta_data\\n\noptional_source\\n\n....\naction_and_meta_data\\n\noptional_source\\n\n```\n\nThe `index` and `create` actions expect a source on the next line and have the same semantics as the `op_type` parameter in the standard index API.\nA `create` action fails if a document with the same ID already exists in the target\nAn `index` action adds or replaces a document as necessary.\n\nNOTE: Data streams support only the `create` action.\nTo update or delete a document in a data stream, you must target the backing index containing the document.\n\nAn `update` action expects that the partial doc, upsert, and script and its options are specified on the next line.\n\nA `delete` action does not expect a source on the next line and has the same semantics as the standard delete API.\n\nNOTE: The final line of data must end with a newline character (`\\n`).\nEach newline character may be preceded by a carriage return (`\\r`).\nWhen sending NDJSON data to the `_bulk` endpoint, use a `Content-Type` header of `application/json` or `application/x-ndjson`.\nBecause this format uses literal newline characters (`\\n`) as delimiters, make sure that the JSON actions and sources are not pretty printed.\n\nIf you provide a target in the request path, it is used for any actions that don't explicitly specify an `_index` argument.\n\nA note on the format: the idea here is to make processing as fast as possible.\nAs some of the actions are redirected to other shards on other nodes, only `action_meta_data` is parsed on the receiving node side.\n\nClient libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.\n\nThere is no \"correct\" number of actions to perform in a single bulk request.\nExperiment with different settings to find the optimal size for your particular workload.\nNote that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.\nIt is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.\nFor instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.\n\n**Client suppport for bulk requests**\n\nSome of the officially supported clients provide helpers to assist with bulk requests and reindexing:\n\n* Go: Check out `esutil.BulkIndexer`\n* Perl: Check out `Search::Elasticsearch::Client::5_0::Bulk` and `Search::Elasticsearch::Client::5_0::Scroll`\n* Python: Check out `elasticsearch.helpers.*`\n* JavaScript: Check out `client.helpers.*`\n* .NET: Check out `BulkAllObservable`\n* PHP: Check out bulk indexing.\n\n**Submitting bulk requests with cURL**\n\nIf you're providing text file input to `curl`, you must use the `--data-binary` flag instead of plain `-d`.\nThe latter doesn't preserve newlines. For example:\n\n```\n$ cat requests\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n$ curl -s -H \"Content-Type: application/x-ndjson\" -XPOST localhost:9200/_bulk --data-binary \"@requests\"; echo\n{\"took\":7, \"errors\": false, \"items\":[{\"index\":{\"_index\":\"test\",\"_id\":\"1\",\"_version\":1,\"result\":\"created\",\"forced_refresh\":false}}]}\n```\n\n**Optimistic concurrency control**\n\nEach `index` and `delete` action within a bulk API call may include the `if_seq_no` and `if_primary_term` parameters in their respective action and meta data lines.\nThe `if_seq_no` and `if_primary_term` parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.\n\n**Versioning**\n\nEach bulk item can include the version value using the `version` field.\nIt automatically follows the behavior of the index or delete operation based on the `_version` mapping.\nIt also support the `version_type`.\n\n**Routing**\n\nEach bulk item can include the routing value using the `routing` field.\nIt automatically follows the behavior of the index or delete operation based on the `_routing` mapping.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n**Wait for active shards**\n\nWhen making bulk calls, you can set the `wait_for_active_shards` parameter to require a minimum number of shard copies to be active before starting to process the bulk request.\n\n**Refresh**\n\nControl when the changes made by this request are visible to search.\n\nNOTE: Only the shards that receive the bulk request will be affected by refresh.\nImagine a `_bulk?refresh=wait_for` request with three documents in it that happen to be routed to different shards in an index with five shards.\nThe request will only wait for those three shards to refresh.\nThe other two shards that make up the index do not participate in the `_bulk` request at all.",
        "operationId": "bulk-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#index"
          },
          {
            "$ref": "#/components/parameters/bulk#list_executed_pipelines"
          },
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          },
          {
            "$ref": "#/components/parameters/bulk#require_data_stream"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Bulk index or delete documents",
        "description": "Perform multiple `index`, `create`, `delete`, and `update` actions in a single request.\nThis reduces overhead and can greatly increase indexing speed.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To use the `create` action, you must have the `create_doc`, `create`, `index`, or `write` index privilege. Data streams support only the `create` action.\n* To use the `index` action, you must have the `create`, `index`, or `write` index privilege.\n* To use the `delete` action, you must have the `delete` or `write` index privilege.\n* To use the `update` action, you must have the `index` or `write` index privilege.\n* To automatically create a data stream or index with a bulk API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n* To make the result of a bulk operation visible to search using the `refresh` parameter, you must have the `maintenance` or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nThe actions are specified in the request body using a newline delimited JSON (NDJSON) structure:\n\n```\naction_and_meta_data\\n\noptional_source\\n\naction_and_meta_data\\n\noptional_source\\n\n....\naction_and_meta_data\\n\noptional_source\\n\n```\n\nThe `index` and `create` actions expect a source on the next line and have the same semantics as the `op_type` parameter in the standard index API.\nA `create` action fails if a document with the same ID already exists in the target\nAn `index` action adds or replaces a document as necessary.\n\nNOTE: Data streams support only the `create` action.\nTo update or delete a document in a data stream, you must target the backing index containing the document.\n\nAn `update` action expects that the partial doc, upsert, and script and its options are specified on the next line.\n\nA `delete` action does not expect a source on the next line and has the same semantics as the standard delete API.\n\nNOTE: The final line of data must end with a newline character (`\\n`).\nEach newline character may be preceded by a carriage return (`\\r`).\nWhen sending NDJSON data to the `_bulk` endpoint, use a `Content-Type` header of `application/json` or `application/x-ndjson`.\nBecause this format uses literal newline characters (`\\n`) as delimiters, make sure that the JSON actions and sources are not pretty printed.\n\nIf you provide a target in the request path, it is used for any actions that don't explicitly specify an `_index` argument.\n\nA note on the format: the idea here is to make processing as fast as possible.\nAs some of the actions are redirected to other shards on other nodes, only `action_meta_data` is parsed on the receiving node side.\n\nClient libraries using this protocol should try and strive to do something similar on the client side, and reduce buffering as much as possible.\n\nThere is no \"correct\" number of actions to perform in a single bulk request.\nExperiment with different settings to find the optimal size for your particular workload.\nNote that Elasticsearch limits the maximum size of a HTTP request to 100mb by default so clients must ensure that no request exceeds this size.\nIt is not possible to index a single document that exceeds the size limit, so you must pre-process any such documents into smaller pieces before sending them to Elasticsearch.\nFor instance, split documents into pages or chapters before indexing them, or store raw binary data in a system outside Elasticsearch and replace the raw data with a link to the external system in the documents that you send to Elasticsearch.\n\n**Client suppport for bulk requests**\n\nSome of the officially supported clients provide helpers to assist with bulk requests and reindexing:\n\n* Go: Check out `esutil.BulkIndexer`\n* Perl: Check out `Search::Elasticsearch::Client::5_0::Bulk` and `Search::Elasticsearch::Client::5_0::Scroll`\n* Python: Check out `elasticsearch.helpers.*`\n* JavaScript: Check out `client.helpers.*`\n* .NET: Check out `BulkAllObservable`\n* PHP: Check out bulk indexing.\n\n**Submitting bulk requests with cURL**\n\nIf you're providing text file input to `curl`, you must use the `--data-binary` flag instead of plain `-d`.\nThe latter doesn't preserve newlines. For example:\n\n```\n$ cat requests\n{ \"index\" : { \"_index\" : \"test\", \"_id\" : \"1\" } }\n{ \"field1\" : \"value1\" }\n$ curl -s -H \"Content-Type: application/x-ndjson\" -XPOST localhost:9200/_bulk --data-binary \"@requests\"; echo\n{\"took\":7, \"errors\": false, \"items\":[{\"index\":{\"_index\":\"test\",\"_id\":\"1\",\"_version\":1,\"result\":\"created\",\"forced_refresh\":false}}]}\n```\n\n**Optimistic concurrency control**\n\nEach `index` and `delete` action within a bulk API call may include the `if_seq_no` and `if_primary_term` parameters in their respective action and meta data lines.\nThe `if_seq_no` and `if_primary_term` parameters control how operations are run, based on the last modification to existing documents. See Optimistic concurrency control for more details.\n\n**Versioning**\n\nEach bulk item can include the version value using the `version` field.\nIt automatically follows the behavior of the index or delete operation based on the `_version` mapping.\nIt also support the `version_type`.\n\n**Routing**\n\nEach bulk item can include the routing value using the `routing` field.\nIt automatically follows the behavior of the index or delete operation based on the `_routing` mapping.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n**Wait for active shards**\n\nWhen making bulk calls, you can set the `wait_for_active_shards` parameter to require a minimum number of shard copies to be active before starting to process the bulk request.\n\n**Refresh**\n\nControl when the changes made by this request are visible to search.\n\nNOTE: Only the shards that receive the bulk request will be affected by refresh.\nImagine a `_bulk?refresh=wait_for` request with three documents in it that happen to be routed to different shards in an index with five shards.\nThe request will only wait for those three shards to refresh.\nThe other two shards that make up the index do not participate in the `_bulk` request at all.",
        "operationId": "bulk-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#index"
          },
          {
            "$ref": "#/components/parameters/bulk#list_executed_pipelines"
          },
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          },
          {
            "$ref": "#/components/parameters/bulk#require_data_stream"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      }
    },
    "/_cat/aliases": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get aliases",
        "description": "Get the cluster's index aliases, including filter and routing information.\nThis API does not return data stream aliases.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or the Kibana console. They are not intended for use by applications. For application consumption, use the aliases API.",
        "operationId": "cat-aliases",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.aliases#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cat.aliases#local"
          },
          {
            "$ref": "#/components/parameters/cat.aliases#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.aliases#200"
          }
        }
      }
    },
    "/_cat/aliases/{name}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get aliases",
        "description": "Get the cluster's index aliases, including filter and routing information.\nThis API does not return data stream aliases.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or the Kibana console. They are not intended for use by applications. For application consumption, use the aliases API.",
        "operationId": "cat-aliases-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.aliases#name"
          },
          {
            "$ref": "#/components/parameters/cat.aliases#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cat.aliases#local"
          },
          {
            "$ref": "#/components/parameters/cat.aliases#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.aliases#200"
          }
        }
      }
    },
    "/_cat/allocation": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get shard allocation information",
        "description": "Get a snapshot of the number of shards allocated to each data node and their disk space.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications.",
        "operationId": "cat-allocation",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.allocation#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.allocation#local"
          },
          {
            "$ref": "#/components/parameters/cat.allocation#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.allocation#200"
          }
        }
      }
    },
    "/_cat/allocation/{node_id}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get shard allocation information",
        "description": "Get a snapshot of the number of shards allocated to each data node and their disk space.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications.",
        "operationId": "cat-allocation-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.allocation#node_id"
          },
          {
            "$ref": "#/components/parameters/cat.allocation#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.allocation#local"
          },
          {
            "$ref": "#/components/parameters/cat.allocation#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.allocation#200"
          }
        }
      }
    },
    "/_cat/component_templates": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get component templates",
        "description": "Get information about component templates in a cluster.\nComponent templates are building blocks for constructing index templates that specify index mappings, settings, and aliases.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the get component template API.",
        "operationId": "cat-component-templates",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.component_templates#local"
          },
          {
            "$ref": "#/components/parameters/cat.component_templates#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.component_templates#200"
          }
        },
        "x-state": "Added in 5.1.0"
      }
    },
    "/_cat/component_templates/{name}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get component templates",
        "description": "Get information about component templates in a cluster.\nComponent templates are building blocks for constructing index templates that specify index mappings, settings, and aliases.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the get component template API.",
        "operationId": "cat-component-templates-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.component_templates#name"
          },
          {
            "$ref": "#/components/parameters/cat.component_templates#local"
          },
          {
            "$ref": "#/components/parameters/cat.component_templates#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.component_templates#200"
          }
        },
        "x-state": "Added in 5.1.0"
      }
    },
    "/_cat/count": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get a document count",
        "description": "Get quick access to a document count for a data stream, an index, or an entire cluster.\nThe document count only includes live documents, not deleted documents which have not yet been removed by the merge process.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the count API.",
        "operationId": "cat-count",
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.count#200"
          }
        }
      }
    },
    "/_cat/count/{index}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get a document count",
        "description": "Get quick access to a document count for a data stream, an index, or an entire cluster.\nThe document count only includes live documents, not deleted documents which have not yet been removed by the merge process.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the count API.",
        "operationId": "cat-count-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.count#index"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.count#200"
          }
        }
      }
    },
    "/_cat/fielddata": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get field data cache information",
        "description": "Get the amount of heap memory currently used by the field data cache on every data node in the cluster.\n\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the nodes stats API.",
        "operationId": "cat-fielddata",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.fielddata#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.fielddata#fields_"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.fielddata#200"
          }
        }
      }
    },
    "/_cat/fielddata/{fields}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get field data cache information",
        "description": "Get the amount of heap memory currently used by the field data cache on every data node in the cluster.\n\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the nodes stats API.",
        "operationId": "cat-fielddata-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.fielddata#fields"
          },
          {
            "$ref": "#/components/parameters/cat.fielddata#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.fielddata#fields_"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.fielddata#200"
          }
        }
      }
    },
    "/_cat/health": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get the cluster health status",
        "description": "IMPORTANT: CAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use the cluster health API.\nThis API is often used to check malfunctioning clusters.\nTo help you track cluster health alongside log files and alerting systems, the API returns timestamps in two formats:\n`HH:MM:SS`, which is human-readable but includes no date information;\n`Unix epoch time`, which is machine-sortable and includes date information.\nThe latter format is useful for cluster recoveries that take multiple days.\nYou can use the cat health API to verify cluster health across multiple nodes.\nYou also can use the API to track the recovery of a large cluster over a longer period of time.",
        "operationId": "cat-health",
        "parameters": [
          {
            "in": "query",
            "name": "time",
            "description": "The unit used to display time values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ts",
            "description": "If true, returns `HH:MM:SS` and Unix epoch timestamps.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.health:HealthRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get CAT help",
        "description": "Get help for the CAT APIs.",
        "operationId": "cat-help",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/_cat/indices": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get index information",
        "description": "Get high-level information about indices in a cluster, including backing indices for data streams.\n\nUse this request to get the following information for each index in a cluster:\n- shard count\n- document count\n- deleted document count\n- primary store size\n- total store size of all shards, including shard replicas\n\nThese metrics are retrieved directly from Lucene, which Elasticsearch uses internally to power indexing and search. As a result, all document counts include hidden nested documents.\nTo get an accurate count of Elasticsearch documents, use the cat count or count APIs.\n\nCAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use an index endpoint.",
        "operationId": "cat-indices",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.indices#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.indices#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cat.indices#health"
          },
          {
            "$ref": "#/components/parameters/cat.indices#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/cat.indices#pri"
          },
          {
            "$ref": "#/components/parameters/cat.indices#time"
          },
          {
            "$ref": "#/components/parameters/cat.indices#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.indices#200"
          }
        }
      }
    },
    "/_cat/indices/{index}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get index information",
        "description": "Get high-level information about indices in a cluster, including backing indices for data streams.\n\nUse this request to get the following information for each index in a cluster:\n- shard count\n- document count\n- deleted document count\n- primary store size\n- total store size of all shards, including shard replicas\n\nThese metrics are retrieved directly from Lucene, which Elasticsearch uses internally to power indexing and search. As a result, all document counts include hidden nested documents.\nTo get an accurate count of Elasticsearch documents, use the cat count or count APIs.\n\nCAT APIs are only intended for human consumption using the command line or Kibana console.\nThey are not intended for use by applications. For application consumption, use an index endpoint.",
        "operationId": "cat-indices-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.indices#index"
          },
          {
            "$ref": "#/components/parameters/cat.indices#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.indices#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cat.indices#health"
          },
          {
            "$ref": "#/components/parameters/cat.indices#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/cat.indices#pri"
          },
          {
            "$ref": "#/components/parameters/cat.indices#time"
          },
          {
            "$ref": "#/components/parameters/cat.indices#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.indices#200"
          }
        }
      }
    },
    "/_cat/master": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get master node information",
        "description": "Get information about the master node, including the ID, bound IP address, and name.\n\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the nodes info API.",
        "operationId": "cat-master",
        "parameters": [
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.master:MasterRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/ml/data_frame/analytics": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get data frame analytics jobs",
        "description": "Get configuration and usage information about data frame analytics jobs.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get data frame analytics jobs statistics API.",
        "operationId": "cat-ml-data-frame-analytics",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/data_frame/analytics/{id}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get data frame analytics jobs",
        "description": "Get configuration and usage information about data frame analytics jobs.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get data frame analytics jobs statistics API.",
        "operationId": "cat-ml-data-frame-analytics-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/datafeeds": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get datafeeds",
        "description": "Get configuration and usage information about datafeeds.\nThis API returns a maximum of 10,000 datafeeds.\nIf the Elasticsearch security features are enabled, you must have `monitor_ml`, `monitor`, `manage_ml`, or `manage`\ncluster privileges to use this API.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get datafeed statistics API.",
        "operationId": "cat-ml-datafeeds",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_datafeeds#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/datafeeds/{datafeed_id}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get datafeeds",
        "description": "Get configuration and usage information about datafeeds.\nThis API returns a maximum of 10,000 datafeeds.\nIf the Elasticsearch security features are enabled, you must have `monitor_ml`, `monitor`, `manage_ml`, or `manage`\ncluster privileges to use this API.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get datafeed statistics API.",
        "operationId": "cat-ml-datafeeds-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_datafeeds#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/anomaly_detectors": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get anomaly detection jobs",
        "description": "Get configuration and usage information for anomaly detection jobs.\nThis API returns a maximum of 10,000 jobs.\nIf the Elasticsearch security features are enabled, you must have `monitor_ml`,\n`monitor`, `manage_ml`, or `manage` cluster privileges to use this API.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get anomaly detection job statistics API.",
        "operationId": "cat-ml-jobs",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_jobs#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/anomaly_detectors/{job_id}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get anomaly detection jobs",
        "description": "Get configuration and usage information for anomaly detection jobs.\nThis API returns a maximum of 10,000 jobs.\nIf the Elasticsearch security features are enabled, you must have `monitor_ml`,\n`monitor`, `manage_ml`, or `manage` cluster privileges to use this API.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get anomaly detection job statistics API.",
        "operationId": "cat-ml-jobs-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_jobs#job_id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_jobs#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/trained_models": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get trained models",
        "description": "Get configuration and usage information about inference trained models.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get trained models statistics API.",
        "operationId": "cat-ml-trained-models",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#size"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_trained_models#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/ml/trained_models/{model_id}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get trained models",
        "description": "Get configuration and usage information about inference trained models.\n\nIMPORTANT: CAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get trained models statistics API.",
        "operationId": "cat-ml-trained-models-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#model_id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#size"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_trained_models#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/nodeattrs": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get node attribute information",
        "description": "Get information about custom node attributes.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the nodes info API.",
        "operationId": "cat-nodeattrs",
        "parameters": [
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.nodeattrs:NodeAttributesRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/nodes": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get node information",
        "description": "Get information about the nodes in a cluster.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the nodes info API.",
        "operationId": "cat-nodes",
        "parameters": [
          {
            "in": "query",
            "name": "bytes",
            "description": "The unit used to display byte values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Bytes"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "full_id",
            "description": "If `true`, return the full node ID. If `false`, return the shortened node ID.",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_unloaded_segments",
            "description": "If true, the response includes information from segments that are not loaded into memory.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "time",
            "description": "Unit used to display time values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.nodes:NodesRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/pending_tasks": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get pending task information",
        "description": "Get information about cluster-level changes that have not yet taken effect.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the pending cluster tasks API.",
        "operationId": "cat-pending-tasks",
        "parameters": [
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "time",
            "description": "Unit used to display time values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.pending_tasks:PendingTasksRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/plugins": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get plugin information",
        "description": "Get a list of plugins running on each node of a cluster.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the nodes info API.",
        "operationId": "cat-plugins",
        "parameters": [
          {
            "in": "query",
            "name": "include_bootstrap",
            "description": "Include bootstrap plugins in the response",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.plugins:PluginsRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/recovery": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get shard recovery information",
        "description": "Get information about ongoing and completed shard recoveries.\nShard recovery is the process of initializing a shard copy, such as restoring a primary shard from a snapshot or syncing a replica shard from a primary shard. When a shard recovery completes, the recovered shard is available for search and indexing.\nFor data streams, the API returns information about the streamâ€™s backing indices.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the index recovery API.",
        "operationId": "cat-recovery",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.recovery#active_only"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#detailed"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.recovery#200"
          }
        }
      }
    },
    "/_cat/recovery/{index}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get shard recovery information",
        "description": "Get information about ongoing and completed shard recoveries.\nShard recovery is the process of initializing a shard copy, such as restoring a primary shard from a snapshot or syncing a replica shard from a primary shard. When a shard recovery completes, the recovered shard is available for search and indexing.\nFor data streams, the API returns information about the streamâ€™s backing indices.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the index recovery API.",
        "operationId": "cat-recovery-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.recovery#index"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#active_only"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#detailed"
          },
          {
            "$ref": "#/components/parameters/cat.recovery#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.recovery#200"
          }
        }
      }
    },
    "/_cat/repositories": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get snapshot repository information",
        "description": "Get a list of snapshot repositories for a cluster.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the get snapshot repository API.",
        "operationId": "cat-repositories",
        "parameters": [
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.repositories:RepositoriesRecord"
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 2.1.0"
      }
    },
    "/_cat/segments": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get segment information",
        "description": "Get low-level information about the Lucene segments in index shards.\nFor data streams, the API returns information about the backing indices.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the index segments API.",
        "operationId": "cat-segments",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.segments#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.segments#local"
          },
          {
            "$ref": "#/components/parameters/cat.segments#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.segments#200"
          }
        }
      }
    },
    "/_cat/segments/{index}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get segment information",
        "description": "Get low-level information about the Lucene segments in index shards.\nFor data streams, the API returns information about the backing indices.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the index segments API.",
        "operationId": "cat-segments-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.segments#index"
          },
          {
            "$ref": "#/components/parameters/cat.segments#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.segments#local"
          },
          {
            "$ref": "#/components/parameters/cat.segments#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.segments#200"
          }
        }
      }
    },
    "/_cat/shards": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get shard information",
        "description": "Get information about the shards in a cluster.\nFor data streams, the API returns information about the backing indices.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications.",
        "operationId": "cat-shards",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.shards#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.shards#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cat.shards#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.shards#200"
          }
        }
      }
    },
    "/_cat/shards/{index}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get shard information",
        "description": "Get information about the shards in a cluster.\nFor data streams, the API returns information about the backing indices.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications.",
        "operationId": "cat-shards-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.shards#index"
          },
          {
            "$ref": "#/components/parameters/cat.shards#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.shards#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cat.shards#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.shards#200"
          }
        }
      }
    },
    "/_cat/snapshots": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get snapshot information",
        "description": "Get information about the snapshots stored in one or more repositories.\nA snapshot is a backup of an index or running Elasticsearch cluster.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the get snapshot API.",
        "operationId": "cat-snapshots",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.snapshots#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cat.snapshots#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cat.snapshots#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.snapshots#200"
          }
        },
        "x-state": "Added in 2.1.0"
      }
    },
    "/_cat/snapshots/{repository}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get snapshot information",
        "description": "Get information about the snapshots stored in one or more repositories.\nA snapshot is a backup of an index or running Elasticsearch cluster.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the get snapshot API.",
        "operationId": "cat-snapshots-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.snapshots#repository"
          },
          {
            "$ref": "#/components/parameters/cat.snapshots#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cat.snapshots#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cat.snapshots#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.snapshots#200"
          }
        },
        "x-state": "Added in 2.1.0"
      }
    },
    "/_cat/tasks": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get task information",
        "description": "Get information about tasks currently running in the cluster.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the task management API.",
        "operationId": "cat-tasks",
        "parameters": [
          {
            "in": "query",
            "name": "actions",
            "description": "The task action names, which are used to limit the response.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "detailed",
            "description": "If `true`, the response includes detailed information about shard recoveries.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "nodes",
            "description": "Unique node identifiers, which are used to limit the response.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "parent_task_id",
            "description": "The parent task identifier, which is used to limit the response.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "time",
            "description": "Unit used to display time values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the task has completed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.tasks:TasksRecord"
                  }
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_cat/templates": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get index template information",
        "description": "Get information about the index templates in a cluster.\nYou can use index templates to apply index settings and field mappings to new indices at creation.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the get index template API.",
        "operationId": "cat-templates",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.templates#local"
          },
          {
            "$ref": "#/components/parameters/cat.templates#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.templates#200"
          }
        },
        "x-state": "Added in 5.2.0"
      }
    },
    "/_cat/templates/{name}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get index template information",
        "description": "Get information about the index templates in a cluster.\nYou can use index templates to apply index settings and field mappings to new indices at creation.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the get index template API.",
        "operationId": "cat-templates-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.templates#name"
          },
          {
            "$ref": "#/components/parameters/cat.templates#local"
          },
          {
            "$ref": "#/components/parameters/cat.templates#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.templates#200"
          }
        },
        "x-state": "Added in 5.2.0"
      }
    },
    "/_cat/thread_pool": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get thread pool statistics",
        "description": "Get thread pool statistics for each node in a cluster.\nReturned information includes all built-in thread pools and custom thread pools.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the nodes info API.",
        "operationId": "cat-thread-pool",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.thread_pool#time"
          },
          {
            "$ref": "#/components/parameters/cat.thread_pool#local"
          },
          {
            "$ref": "#/components/parameters/cat.thread_pool#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.thread_pool#200"
          }
        }
      }
    },
    "/_cat/thread_pool/{thread_pool_patterns}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get thread pool statistics",
        "description": "Get thread pool statistics for each node in a cluster.\nReturned information includes all built-in thread pools and custom thread pools.\nIMPORTANT: cat APIs are only intended for human consumption using the command line or Kibana console. They are not intended for use by applications. For application consumption, use the nodes info API.",
        "operationId": "cat-thread-pool-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.thread_pool#thread_pool_patterns"
          },
          {
            "$ref": "#/components/parameters/cat.thread_pool#time"
          },
          {
            "$ref": "#/components/parameters/cat.thread_pool#local"
          },
          {
            "$ref": "#/components/parameters/cat.thread_pool#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.thread_pool#200"
          }
        }
      }
    },
    "/_cat/transforms": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get transform information",
        "description": "Get configuration and usage information about transforms.\n\nCAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get transform statistics API.",
        "operationId": "cat-transforms",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.transforms#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#from"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#h"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#s"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#time"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.transforms#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_cat/transforms/{transform_id}": {
      "get": {
        "tags": [
          "cat"
        ],
        "summary": "Get transform information",
        "description": "Get configuration and usage information about transforms.\n\nCAT APIs are only intended for human consumption using the Kibana\nconsole or command line. They are not intended for use by applications. For\napplication consumption, use the get transform statistics API.",
        "operationId": "cat-transforms-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.transforms#transform_id"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#from"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#h"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#s"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#time"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.transforms#200"
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_ccr/auto_follow/{name}": {
      "get": {
        "tags": [
          "ccr"
        ],
        "summary": "Get auto-follow patterns",
        "description": "Get cross-cluster replication auto-follow patterns.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-auto-follow.html"
        },
        "operationId": "ccr-get-auto-follow-pattern-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ccr.get_auto_follow_pattern#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ccr.get_auto_follow_pattern#200"
          }
        },
        "x-state": "Added in 6.5.0"
      },
      "put": {
        "tags": [
          "ccr"
        ],
        "summary": "Create or update auto-follow patterns",
        "description": "Create a collection of cross-cluster replication auto-follow patterns for a remote cluster.\nNewly created indices on the remote cluster that match any of the patterns are automatically configured as follower indices.\nIndices on the remote cluster that were created before the auto-follow pattern was created will not be auto-followed even if they match the pattern.\n\nThis API can also be used to update auto-follow patterns.\nNOTE: Follower indices that were configured automatically before updating an auto-follow pattern will remain unchanged even if they do not match against the new patterns.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-auto-follow.html"
        },
        "operationId": "ccr-put-auto-follow-pattern",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the collection of auto-follow patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "remote_cluster": {
                    "description": "The remote cluster containing the leader indices to match against.",
                    "type": "string"
                  },
                  "follow_index_pattern": {
                    "$ref": "#/components/schemas/_types:IndexPattern"
                  },
                  "leader_index_patterns": {
                    "$ref": "#/components/schemas/_types:IndexPatterns"
                  },
                  "leader_index_exclusion_patterns": {
                    "$ref": "#/components/schemas/_types:IndexPatterns"
                  },
                  "max_outstanding_read_requests": {
                    "description": "The maximum number of outstanding reads requests from the remote cluster.",
                    "type": "number"
                  },
                  "settings": {
                    "description": "Settings to override from the leader index. Note that certain settings can not be overrode (e.g., index.number_of_shards).",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  },
                  "max_outstanding_write_requests": {
                    "description": "The maximum number of outstanding reads requests from the remote cluster.",
                    "type": "number"
                  },
                  "read_poll_timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "max_read_request_operation_count": {
                    "description": "The maximum number of operations to pull per read from the remote cluster.",
                    "type": "number"
                  },
                  "max_read_request_size": {
                    "$ref": "#/components/schemas/_types:ByteSize"
                  },
                  "max_retry_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "max_write_buffer_count": {
                    "description": "The maximum number of operations that can be queued for writing. When this limit is reached, reads from the remote cluster will be deferred until the number of queued operations goes below the limit.",
                    "type": "number"
                  },
                  "max_write_buffer_size": {
                    "$ref": "#/components/schemas/_types:ByteSize"
                  },
                  "max_write_request_operation_count": {
                    "description": "The maximum number of operations per bulk write request executed on the follower.",
                    "type": "number"
                  },
                  "max_write_request_size": {
                    "$ref": "#/components/schemas/_types:ByteSize"
                  }
                },
                "required": [
                  "remote_cluster"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      },
      "delete": {
        "tags": [
          "ccr"
        ],
        "summary": "Delete auto-follow patterns",
        "description": "Delete a collection of cross-cluster replication auto-follow patterns.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-auto-follow.html"
        },
        "operationId": "ccr-delete-auto-follow-pattern",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the auto follow pattern.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/{index}/_ccr/follow": {
      "put": {
        "tags": [
          "ccr"
        ],
        "summary": "Create a follower",
        "description": "Create a cross-cluster replication follower index that follows a specific leader index.\nWhen the API returns, the follower index exists and cross-cluster replication starts replicating operations from the leader index to the follower index.",
        "operationId": "ccr-follow",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the follower index",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "Sets the number of shard copies that must be active before returning. Defaults to 0. Set to `all` for all shard copies, otherwise set to any non-negative value less than or equal to the total number of copies for the shard (number of replicas + 1)",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "leader_index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "max_outstanding_read_requests": {
                    "type": "number"
                  },
                  "max_outstanding_write_requests": {
                    "type": "number"
                  },
                  "max_read_request_operation_count": {
                    "type": "number"
                  },
                  "max_read_request_size": {
                    "type": "string"
                  },
                  "max_retry_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "max_write_buffer_count": {
                    "type": "number"
                  },
                  "max_write_buffer_size": {
                    "type": "string"
                  },
                  "max_write_request_operation_count": {
                    "type": "number"
                  },
                  "max_write_request_size": {
                    "type": "string"
                  },
                  "read_poll_timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "remote_cluster": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "follow_index_created": {
                      "type": "boolean"
                    },
                    "follow_index_shards_acked": {
                      "type": "boolean"
                    },
                    "index_following_started": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "follow_index_created",
                    "follow_index_shards_acked",
                    "index_following_started"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/{index}/_ccr/info": {
      "get": {
        "tags": [
          "ccr"
        ],
        "summary": "Get follower information",
        "description": "Get information about all cross-cluster replication follower indices.\nFor example, the results include follower index names, leader index names, replication options, and whether the follower indices are active or paused.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html"
        },
        "operationId": "ccr-follow-info",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of index patterns; use `_all` to perform the operation on all indices",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "follower_indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ccr.follow_info:FollowerIndex"
                      }
                    }
                  },
                  "required": [
                    "follower_indices"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.7.0"
      }
    },
    "/{index}/_ccr/stats": {
      "get": {
        "tags": [
          "ccr"
        ],
        "summary": "Get follower stats",
        "description": "Get cross-cluster replication follower stats.\nThe API returns shard-level stats about the \"following tasks\" associated with each shard for the specified indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html"
        },
        "operationId": "ccr-follow-stats",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of index patterns; use `_all` to perform the operation on all indices",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ccr._types:FollowIndexStats"
                      }
                    }
                  },
                  "required": [
                    "indices"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/{index}/_ccr/forget_follower": {
      "post": {
        "tags": [
          "ccr"
        ],
        "summary": "Forget a follower",
        "description": "Remove the cross-cluster replication follower retention leases from the leader.\n\nA following index takes out retention leases on its leader index.\nThese leases are used to increase the likelihood that the shards of the leader index retain the history of operations that the shards of the following index need to run replication.\nWhen a follower index is converted to a regular index by the unfollow API (either by directly calling the API or by index lifecycle management tasks), these leases are removed.\nHowever, removal of the leases can fail, for example when the remote cluster containing the leader index is unavailable.\nWhile the leases will eventually expire on their own, their extended existence can cause the leader index to hold more history than necessary and prevent index lifecycle management from performing some operations on the leader index.\nThis API exists to enable manually removing the leases when the unfollow API is unable to do so.\n\nNOTE: This API does not stop replication by a following index. If you use this API with a follower index that is still actively following, the following index will add back retention leases on the leader.\nThe only purpose of this API is to handle the case of failure to remove the following retention leases after the unfollow API is invoked.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html"
        },
        "operationId": "ccr-forget-follower",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "the name of the leader index for which specified follower retention leases should be removed",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "follower_cluster": {
                    "type": "string"
                  },
                  "follower_index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "follower_index_uuid": {
                    "$ref": "#/components/schemas/_types:Uuid"
                  },
                  "leader_remote_cluster": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_shards": {
                      "$ref": "#/components/schemas/_types:ShardStatistics"
                    }
                  },
                  "required": [
                    "_shards"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.7.0"
      }
    },
    "/_ccr/auto_follow": {
      "get": {
        "tags": [
          "ccr"
        ],
        "summary": "Get auto-follow patterns",
        "description": "Get cross-cluster replication auto-follow patterns.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-auto-follow.html"
        },
        "operationId": "ccr-get-auto-follow-pattern",
        "responses": {
          "200": {
            "$ref": "#/components/responses/ccr.get_auto_follow_pattern#200"
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_ccr/auto_follow/{name}/pause": {
      "post": {
        "tags": [
          "ccr"
        ],
        "summary": "Pause an auto-follow pattern",
        "description": "Pause a cross-cluster replication auto-follow pattern.\nWhen the API returns, the auto-follow pattern is inactive.\nNew indices that are created on the remote cluster and match the auto-follow patterns are ignored.\n\nYou can resume auto-following with the resume auto-follow pattern API.\nWhen it resumes, the auto-follow pattern is active again and automatically configures follower indices for newly created indices on the remote cluster that match its patterns.\nRemote indices that were created while the pattern was paused will also be followed, unless they have been deleted or closed in the interim.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-auto-follow.html"
        },
        "operationId": "ccr-pause-auto-follow-pattern",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the auto follow pattern that should pause discovering new indices to follow.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/{index}/_ccr/pause_follow": {
      "post": {
        "tags": [
          "ccr"
        ],
        "summary": "Pause a follower",
        "description": "Pause a cross-cluster replication follower index.\nThe follower index will not fetch any additional operations from the leader index.\nYou can resume following with the resume follower API.\nYou can pause and resume a follower index to change the configuration of the following task.",
        "operationId": "ccr-pause-follow",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the follower index that should pause following its leader index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_ccr/auto_follow/{name}/resume": {
      "post": {
        "tags": [
          "ccr"
        ],
        "summary": "Resume an auto-follow pattern",
        "description": "Resume a cross-cluster replication auto-follow pattern that was paused.\nThe auto-follow pattern will resume configuring following indices for newly created indices that match its patterns on the remote cluster.\nRemote indices created while the pattern was paused will also be followed unless they have been deleted or closed in the interim.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ccr-auto-follow.html"
        },
        "operationId": "ccr-resume-auto-follow-pattern",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the auto follow pattern to resume discovering new indices to follow.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/{index}/_ccr/resume_follow": {
      "post": {
        "tags": [
          "ccr"
        ],
        "summary": "Resume a follower",
        "description": "Resume a cross-cluster replication follower index that was paused.\nThe follower index could have been paused with the pause follower API.\nAlternatively it could be paused due to replication that cannot be retried due to failures during following tasks.\nWhen this API returns, the follower index will resume fetching operations from the leader index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html"
        },
        "operationId": "ccr-resume-follow",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the follow index to resume following.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "max_outstanding_read_requests": {
                    "type": "number"
                  },
                  "max_outstanding_write_requests": {
                    "type": "number"
                  },
                  "max_read_request_operation_count": {
                    "type": "number"
                  },
                  "max_read_request_size": {
                    "type": "string"
                  },
                  "max_retry_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "max_write_buffer_count": {
                    "type": "number"
                  },
                  "max_write_buffer_size": {
                    "type": "string"
                  },
                  "max_write_request_operation_count": {
                    "type": "number"
                  },
                  "max_write_request_size": {
                    "type": "string"
                  },
                  "read_poll_timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_ccr/stats": {
      "get": {
        "tags": [
          "ccr"
        ],
        "summary": "Get cross-cluster replication stats",
        "description": "This API returns stats about auto-following and the same shard-level stats as the get follower stats API.",
        "operationId": "ccr-stats",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "auto_follow_stats": {
                      "$ref": "#/components/schemas/ccr.stats:AutoFollowStats"
                    },
                    "follow_stats": {
                      "$ref": "#/components/schemas/ccr.stats:FollowStats"
                    }
                  },
                  "required": [
                    "auto_follow_stats",
                    "follow_stats"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/{index}/_ccr/unfollow": {
      "post": {
        "tags": [
          "ccr"
        ],
        "summary": "Unfollow an index",
        "description": "Convert a cross-cluster replication follower index to a regular index.\nThe API stops the following task associated with a follower index and removes index metadata and settings associated with cross-cluster replication.\nThe follower index must be paused and closed before you call the unfollow API.\n\nNOTE: Currently cross-cluster replication does not support converting an existing regular index to a follower index. Converting a follower index to a regular index is an irreversible operation.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/xpack-ccr.html"
        },
        "operationId": "ccr-unfollow",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the follower index that should be turned into a regular index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_search/scroll": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a scrolling search",
        "description": "IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the `search_after` parameter with a point in time (PIT).\n\nThe scroll API gets large sets of results from a single scrolling search request.\nTo get the necessary scroll ID, submit a search API request that includes an argument for the `scroll` query parameter.\nThe `scroll` parameter indicates how long Elasticsearch should retain the search context for the request.\nThe search response returns a scroll ID in the `_scroll_id` response body parameter.\nYou can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.\nIf the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.\n\nYou can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.\n\nIMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results"
        },
        "operationId": "scroll",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a scrolling search",
        "description": "IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the `search_after` parameter with a point in time (PIT).\n\nThe scroll API gets large sets of results from a single scrolling search request.\nTo get the necessary scroll ID, submit a search API request that includes an argument for the `scroll` query parameter.\nThe `scroll` parameter indicates how long Elasticsearch should retain the search context for the request.\nThe search response returns a scroll ID in the `_scroll_id` response body parameter.\nYou can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.\nIf the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.\n\nYou can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.\n\nIMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results"
        },
        "operationId": "scroll-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "delete": {
        "tags": [
          "search"
        ],
        "summary": "Clear a scrolling search",
        "description": "Clear the search context and results for a scrolling search.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results"
        },
        "operationId": "clear-scroll",
        "requestBody": {
          "$ref": "#/components/requestBodies/clear_scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/clear_scroll#200"
          }
        }
      }
    },
    "/_search/scroll/{scroll_id}": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a scrolling search",
        "description": "IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the `search_after` parameter with a point in time (PIT).\n\nThe scroll API gets large sets of results from a single scrolling search request.\nTo get the necessary scroll ID, submit a search API request that includes an argument for the `scroll` query parameter.\nThe `scroll` parameter indicates how long Elasticsearch should retain the search context for the request.\nThe search response returns a scroll ID in the `_scroll_id` response body parameter.\nYou can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.\nIf the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.\n\nYou can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.\n\nIMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results"
        },
        "operationId": "scroll-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll_id"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a scrolling search",
        "description": "IMPORTANT: The scroll API is no longer recommend for deep pagination. If you need to preserve the index state while paging through more than 10,000 hits, use the `search_after` parameter with a point in time (PIT).\n\nThe scroll API gets large sets of results from a single scrolling search request.\nTo get the necessary scroll ID, submit a search API request that includes an argument for the `scroll` query parameter.\nThe `scroll` parameter indicates how long Elasticsearch should retain the search context for the request.\nThe search response returns a scroll ID in the `_scroll_id` response body parameter.\nYou can then use the scroll ID with the scroll API to retrieve the next batch of results for the request.\nIf the Elasticsearch security features are enabled, the access to the results of a specific scroll ID is restricted to the user or API key that submitted the search.\n\nYou can also use the scroll API to specify a new scroll parameter that extends or shortens the retention period for the search context.\n\nIMPORTANT: Results from a scrolling search reflect the state of the index at the time of the initial search request. Subsequent indexing or document changes only affect later search and scroll requests.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results"
        },
        "operationId": "scroll-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll_id"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "delete": {
        "tags": [
          "search"
        ],
        "summary": "Clear a scrolling search",
        "description": "Clear the search context and results for a scrolling search.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/paginate-search-results.html#scroll-search-results"
        },
        "operationId": "clear-scroll-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/clear_scroll#scroll_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/clear_scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/clear_scroll#200"
          }
        }
      }
    },
    "/_pit": {
      "delete": {
        "tags": [
          "search"
        ],
        "summary": "Close a point in time",
        "description": "A point in time must be opened explicitly before being used in search requests.\nThe `keep_alive` parameter tells Elasticsearch how long it should persist.\nA point in time is automatically closed when the `keep_alive` period has elapsed.\nHowever, keeping points in time has a cost; close them as soon as they are no longer required for search requests.",
        "operationId": "close-point-in-time",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/_types:Id"
                  }
                },
                "required": [
                  "id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "succeeded": {
                      "description": "If `true`, all search contexts associated with the point-in-time ID were successfully closed.",
                      "type": "boolean"
                    },
                    "num_freed": {
                      "description": "The number of search contexts that were successfully closed.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "succeeded",
                    "num_freed"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_cluster/allocation/explain": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Explain the shard allocations",
        "description": "Get explanations for shard allocations in the cluster.\nFor unassigned shards, it provides an explanation for why the shard is unassigned.\nFor assigned shards, it provides an explanation for why the shard is remaining on its current node and has not moved or rebalanced to another node.\nThis API can be very useful when attempting to diagnose why a shard is unassigned or why a shard continues to remain on its current node when you might expect otherwise.",
        "operationId": "cluster-allocation-explain",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_disk_info"
          },
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_yes_decisions"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.allocation_explain"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.allocation_explain#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "cluster"
        ],
        "summary": "Explain the shard allocations",
        "description": "Get explanations for shard allocations in the cluster.\nFor unassigned shards, it provides an explanation for why the shard is unassigned.\nFor assigned shards, it provides an explanation for why the shard is remaining on its current node and has not moved or rebalanced to another node.\nThis API can be very useful when attempting to diagnose why a shard is unassigned or why a shard continues to remain on its current node when you might expect otherwise.",
        "operationId": "cluster-allocation-explain-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_disk_info"
          },
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_yes_decisions"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.allocation_explain"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.allocation_explain#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_component_template/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get component templates",
        "description": "Get information about component templates.",
        "operationId": "cluster-get-component-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.get_component_template#name"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#include_defaults"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#local"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.get_component_template#200"
          }
        },
        "x-state": "Added in 7.8.0"
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update a component template",
        "description": "Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases.\n\nAn index template can be composed of multiple component templates.\nTo use a component template, specify it in an index templateâ€™s `composed_of` list.\nComponent templates are only applied to new data streams and indices as part of a matching index template.\n\nSettings and mappings specified directly in the index template or the create index request override any settings or mappings specified in a component template.\n\nComponent templates are only used during index creation.\nFor data streams, this includes data stream creation and the creation of a streamâ€™s backing indices.\nChanges to component templates do not affect existing indices, including a streamâ€™s backing indices.\n\nYou can use C-style `/* *\\/` block comments in component templates.\nYou can include comments anywhere in the request body except before the opening curly bracket.\n\n**Applying component templates**\n\nYou cannot directly apply a component template to a data stream or index.\nTo be applied, a component template must be included in an index template's `composed_of` list.",
        "operationId": "cluster-put-component-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.put_component_template#name"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#create"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#master_timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.put_component_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.put_component_template#200"
          }
        },
        "x-state": "Added in 7.8.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update a component template",
        "description": "Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases.\n\nAn index template can be composed of multiple component templates.\nTo use a component template, specify it in an index templateâ€™s `composed_of` list.\nComponent templates are only applied to new data streams and indices as part of a matching index template.\n\nSettings and mappings specified directly in the index template or the create index request override any settings or mappings specified in a component template.\n\nComponent templates are only used during index creation.\nFor data streams, this includes data stream creation and the creation of a streamâ€™s backing indices.\nChanges to component templates do not affect existing indices, including a streamâ€™s backing indices.\n\nYou can use C-style `/* *\\/` block comments in component templates.\nYou can include comments anywhere in the request body except before the opening curly bracket.\n\n**Applying component templates**\n\nYou cannot directly apply a component template to a data stream or index.\nTo be applied, a component template must be included in an index template's `composed_of` list.",
        "operationId": "cluster-put-component-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.put_component_template#name"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#create"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#master_timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.put_component_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.put_component_template#200"
          }
        },
        "x-state": "Added in 7.8.0"
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete component templates",
        "description": "Component templates are building blocks for constructing index templates that specify index mappings, settings, and aliases.",
        "operationId": "cluster-delete-component-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list or wildcard expression of component template names used to limit the request.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.8.0"
      },
      "head": {
        "tags": [
          "indices"
        ],
        "summary": "Check component templates",
        "description": "Returns information about whether a particular component template exists.",
        "operationId": "cluster-exists-component-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of component template names used to limit the request.\nWildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If true, the request retrieves information from the local node only.\nDefaults to false, which means information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 7.8.0"
      }
    },
    "/_cluster/voting_config_exclusions": {
      "post": {
        "tags": [
          "cluster"
        ],
        "summary": "Update voting configuration exclusions",
        "description": "Update the cluster voting config exclusions by node IDs or node names.\nBy default, if there are more than three master-eligible nodes in the cluster and you remove fewer than half of the master-eligible nodes in the cluster at once, the voting configuration automatically shrinks.\nIf you want to shrink the voting configuration to contain fewer than three nodes or to remove half or more of the master-eligible nodes in the cluster at once, use this API to remove departing nodes from the voting configuration manually.\nThe API adds an entry for each specified node to the clusterâ€™s voting configuration exclusions list.\nIt then waits until the cluster has reconfigured its voting configuration to exclude the specified nodes.\n\nClusters should have no voting configuration exclusions in normal operation.\nOnce the excluded nodes have stopped, clear the voting configuration exclusions with `DELETE /_cluster/voting_config_exclusions`.\nThis API waits for the nodes to be fully removed from the cluster before it returns.\nIf your cluster has voting configuration exclusions for nodes that you no longer intend to remove, use `DELETE /_cluster/voting_config_exclusions?wait_for_removal=false` to clear the voting configuration exclusions without waiting for the nodes to leave the cluster.\n\nA response to `POST /_cluster/voting_config_exclusions` with an HTTP status code of 200 OK guarantees that the node has been removed from the voting configuration and will not be reinstated until the voting configuration exclusions are cleared by calling `DELETE /_cluster/voting_config_exclusions`.\nIf the call to `POST /_cluster/voting_config_exclusions` fails or returns a response with an HTTP status code other than 200 OK then the node may not have been removed from the voting configuration.\nIn that case, you may safely retry the call.\n\nNOTE: Voting exclusions are required only when you remove at least half of the master-eligible nodes from a cluster in a short time period.\nThey are not required when removing master-ineligible nodes or when removing fewer than half of the master-eligible nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/add-elasticsearch-nodes.html"
        },
        "operationId": "cluster-post-voting-config-exclusions",
        "parameters": [
          {
            "in": "query",
            "name": "node_names",
            "description": "A comma-separated list of the names of the nodes to exclude from the\nvoting configuration. If specified, you may not also specify node_ids.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "node_ids",
            "description": "A comma-separated list of the persistent ids of the nodes to exclude\nfrom the voting configuration. If specified, you may not also specify node_names.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "When adding a voting configuration exclusion, the API waits for the\nspecified nodes to be excluded from the voting configuration before\nreturning. If the timeout expires before the appropriate condition\nis satisfied, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 7.0.0"
      },
      "delete": {
        "tags": [
          "cluster"
        ],
        "summary": "Clear cluster voting config exclusions",
        "description": "Remove master-eligible nodes from the voting configuration exclusion list.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/add-elasticsearch-nodes.html"
        },
        "operationId": "cluster-delete-voting-config-exclusions",
        "parameters": [
          {
            "in": "query",
            "name": "wait_for_removal",
            "description": "Specifies whether to wait for all excluded nodes to be removed from the\ncluster before clearing the voting configuration exclusions list.\nDefaults to true, meaning that all excluded nodes must be removed from\nthe cluster before this API takes any action. If set to false then the\nvoting configuration exclusions list is cleared even if some excluded\nnodes are still in the cluster.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 7.0.0"
      }
    },
    "/_component_template": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get component templates",
        "description": "Get information about component templates.",
        "operationId": "cluster-get-component-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.get_component_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#include_defaults"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#local"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.get_component_template#200"
          }
        },
        "x-state": "Added in 7.8.0"
      }
    },
    "/_cluster/settings": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get cluster-wide settings",
        "description": "By default, it returns only settings that have been explicitly defined.",
        "operationId": "cluster-get-settings",
        "parameters": [
          {
            "in": "query",
            "name": "flat_settings",
            "description": "If `true`, returns settings in flat format.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If `true`, returns default cluster settings from the local node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "persistent": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    },
                    "transient": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    },
                    "defaults": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    }
                  },
                  "required": [
                    "persistent",
                    "transient"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "cluster"
        ],
        "summary": "Update the cluster settings",
        "description": "Configure and update dynamic settings on a running cluster.\nYou can also configure dynamic settings locally on an unstarted or shut down node in `elasticsearch.yml`.\n\nUpdates made with this API can be persistent, which apply across cluster restarts, or transient, which reset after a cluster restart.\nYou can also reset transient or persistent settings by assigning them a null value.\n\nIf you configure the same setting using multiple methods, Elasticsearch applies the settings in following order of precedence: 1) Transient setting; 2) Persistent setting; 3) `elasticsearch.yml` setting; 4) Default setting value.\nFor example, you can apply a transient setting to override a persistent setting or `elasticsearch.yml` setting.\nHowever, a change to an `elasticsearch.yml` setting will not override a defined transient or persistent setting.\n\nTIP: In Elastic Cloud, use the user settings feature to configure all cluster settings. This method automatically rejects unsafe settings that could break your cluster.\nIf you run Elasticsearch on your own hardware, use this API to configure dynamic cluster settings.\nOnly use `elasticsearch.yml` for static cluster settings and node settings.\nThe API doesnâ€™t require a restart and ensures a settingâ€™s value is the same on all nodes.\n\nWARNING: Transient cluster settings are no longer recommended. Use persistent cluster settings instead.\nIf a cluster becomes unstable, transient settings can clear unexpectedly, resulting in a potentially undesired cluster configuration.",
        "operationId": "cluster-put-settings",
        "parameters": [
          {
            "in": "query",
            "name": "flat_settings",
            "description": "Return settings in flat format (default: false)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "persistent": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  },
                  "transient": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "persistent": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    },
                    "transient": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    }
                  },
                  "required": [
                    "acknowledged",
                    "persistent",
                    "transient"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_cluster/health": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the cluster health status",
        "description": "You can also use the API to get the health status of only specified data streams and indices.\nFor data streams, the API retrieves the health status of the streamâ€™s backing indices.\n\nThe cluster health status is: green, yellow or red.\nOn the shard level, a red status indicates that the specific shard is not allocated in the cluster. Yellow means that the primary shard is allocated but replicas are not. Green means that all shards are allocated.\nThe index level status is controlled by the worst shard status.\n\nOne of the main benefits of the API is the ability to wait until the cluster reaches a certain high watermark health level.\nThe cluster status is controlled by the worst index status.",
        "operationId": "cluster-health",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.health#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#level"
          },
          {
            "$ref": "#/components/parameters/cluster.health#local"
          },
          {
            "$ref": "#/components/parameters/cluster.health#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_events"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_nodes"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_initializing_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_relocating_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_status"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.health#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_cluster/health/{index}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the cluster health status",
        "description": "You can also use the API to get the health status of only specified data streams and indices.\nFor data streams, the API retrieves the health status of the streamâ€™s backing indices.\n\nThe cluster health status is: green, yellow or red.\nOn the shard level, a red status indicates that the specific shard is not allocated in the cluster. Yellow means that the primary shard is allocated but replicas are not. Green means that all shards are allocated.\nThe index level status is controlled by the worst shard status.\n\nOne of the main benefits of the API is the ability to wait until the cluster reaches a certain high watermark health level.\nThe cluster status is controlled by the worst index status.",
        "operationId": "cluster-health-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.health#index"
          },
          {
            "$ref": "#/components/parameters/cluster.health#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#level"
          },
          {
            "$ref": "#/components/parameters/cluster.health#local"
          },
          {
            "$ref": "#/components/parameters/cluster.health#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_events"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_nodes"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_initializing_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_relocating_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_status"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.health#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_info/{target}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get cluster info",
        "description": "Returns basic information about the cluster.",
        "operationId": "cluster-info",
        "parameters": [
          {
            "in": "path",
            "name": "target",
            "description": "Limits the information returned to the specific target. Supports a comma-separated list, such as http,ingest.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ClusterInfoTargets"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "http": {
                      "$ref": "#/components/schemas/nodes._types:Http"
                    },
                    "ingest": {
                      "$ref": "#/components/schemas/nodes._types:Ingest"
                    },
                    "thread_pool": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/nodes._types:ThreadCount"
                      }
                    },
                    "script": {
                      "$ref": "#/components/schemas/nodes._types:Scripting"
                    }
                  },
                  "required": [
                    "cluster_name"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.9.0"
      }
    },
    "/_cluster/pending_tasks": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the pending cluster tasks",
        "description": "Get information about cluster-level changes (such as create index, update mapping, allocate or fail shard) that have not yet taken effect.\n\nNOTE: This API returns a list of any pending updates to the cluster state.\nThese are distinct from the tasks reported by the task management API which include periodic tasks and tasks initiated by the user, such as node stats, search queries, or create index requests.\nHowever, if a user-initiated task such as a create index command causes a cluster state update, the activity of this task might be reported by both task api and pending cluster tasks API.",
        "operationId": "cluster-pending-tasks",
        "parameters": [
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tasks": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/cluster.pending_tasks:PendingTask"
                      }
                    }
                  },
                  "required": [
                    "tasks"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_remote/info": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get remote cluster information",
        "description": "Get all of the configured remote cluster information.\nThis API returns connection and endpoint information keyed by the configured remote cluster alias.",
        "operationId": "cluster-remote-info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/cluster.remote_info:ClusterRemoteInfo"
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_cluster/reroute": {
      "post": {
        "tags": [
          "cluster"
        ],
        "summary": "Reroute the cluster",
        "description": "Manually change the allocation of individual shards in the cluster.\nFor example, a shard can be moved from one node to another explicitly, an allocation can be canceled, and an unassigned shard can be explicitly allocated to a specific node.\n\nIt is important to note that after processing any reroute commands Elasticsearch will perform rebalancing as normal (respecting the values of settings such as `cluster.routing.rebalance.enable`) in order to remain in a balanced state.\nFor example, if the requested allocation includes moving a shard from node1 to node2 then this may cause a shard to be moved from node2 back to node1 to even things out.\n\nThe cluster can be set to disable allocations using the `cluster.routing.allocation.enable` setting.\nIf allocations are disabled then the only allocations that will be performed are explicit ones given using the reroute command, and consequent allocations due to rebalancing.\n\nThe cluster will attempt to allocate a shard a maximum of `index.allocation.max_retries` times in a row (defaults to `5`), before giving up and leaving the shard unallocated.\nThis scenario can be caused by structural problems such as having an analyzer which refers to a stopwords file which doesnâ€™t exist on all nodes.\n\nOnce the problem has been corrected, allocation can be manually retried by calling the reroute API with the `?retry_failed` URI query parameter, which will attempt a single retry round for these shards.",
        "operationId": "cluster-reroute",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "description": "If true, then the request simulates the operation.\nIt will calculate the result of applying the commands to the current cluster state and return the resulting cluster state after the commands (and rebalancing) have been applied; it will not actually perform the requested changes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "explain",
            "description": "If true, then the response contains an explanation of why the commands can or cannot run.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "metric",
            "description": "Limits the information returned to the specified metrics.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Metrics"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "retry_failed",
            "description": "If true, then retries allocation of shards that are blocked due to too many subsequent allocation failures.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "commands": {
                    "description": "Defines the commands to perform.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/cluster.reroute:Command"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "explanations": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/cluster.reroute:RerouteExplanation"
                      }
                    },
                    "state": {
                      "description": "There aren't any guarantees on the output/structure of the raw cluster state.\nHere you will find the internal representation of the cluster, which can\ndiffer from the external representation.",
                      "type": "object"
                    }
                  },
                  "required": [
                    "acknowledged"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_cluster/state": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the cluster state",
        "description": "Get comprehensive information about the state of the cluster.\n\nThe cluster state is an internal data structure which keeps track of a variety of information needed by every node, including the identity and attributes of the other nodes in the cluster; cluster-wide settings; index metadata, including the mapping and settings for each index; the location and status of every shard copy in the cluster.\n\nThe elected master node ensures that every node in the cluster has a copy of the same cluster state.\nThis API lets you retrieve a representation of this internal state for debugging or diagnostic purposes.\nYou may need to consult the Elasticsearch source code to determine the precise meaning of the response.\n\nBy default the API will route requests to the elected master node since this node is the authoritative source of cluster states.\nYou can also retrieve the cluster state held on the node handling the API request by adding the `?local=true` query parameter.\n\nElasticsearch may need to expend significant effort to compute a response to this API in larger clusters, and the response may comprise a very large quantity of data.\nIf you use this API repeatedly, your cluster may become unstable.\n\nWARNING: The response is a representation of an internal data structure.\nIts format is not subject to the same compatibility guarantees as other more stable APIs and may change from version to version.\nDo not query this API using external monitoring tools.\nInstead, obtain the information you require using other more stable cluster APIs.",
        "operationId": "cluster-state",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.state#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/cluster.state#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.state#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.state#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cluster.state#local"
          },
          {
            "$ref": "#/components/parameters/cluster.state#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_metadata_version"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.state#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_cluster/state/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the cluster state",
        "description": "Get comprehensive information about the state of the cluster.\n\nThe cluster state is an internal data structure which keeps track of a variety of information needed by every node, including the identity and attributes of the other nodes in the cluster; cluster-wide settings; index metadata, including the mapping and settings for each index; the location and status of every shard copy in the cluster.\n\nThe elected master node ensures that every node in the cluster has a copy of the same cluster state.\nThis API lets you retrieve a representation of this internal state for debugging or diagnostic purposes.\nYou may need to consult the Elasticsearch source code to determine the precise meaning of the response.\n\nBy default the API will route requests to the elected master node since this node is the authoritative source of cluster states.\nYou can also retrieve the cluster state held on the node handling the API request by adding the `?local=true` query parameter.\n\nElasticsearch may need to expend significant effort to compute a response to this API in larger clusters, and the response may comprise a very large quantity of data.\nIf you use this API repeatedly, your cluster may become unstable.\n\nWARNING: The response is a representation of an internal data structure.\nIts format is not subject to the same compatibility guarantees as other more stable APIs and may change from version to version.\nDo not query this API using external monitoring tools.\nInstead, obtain the information you require using other more stable cluster APIs.",
        "operationId": "cluster-state-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.state#metric"
          },
          {
            "$ref": "#/components/parameters/cluster.state#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/cluster.state#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.state#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.state#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cluster.state#local"
          },
          {
            "$ref": "#/components/parameters/cluster.state#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_metadata_version"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.state#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_cluster/state/{metric}/{index}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the cluster state",
        "description": "Get comprehensive information about the state of the cluster.\n\nThe cluster state is an internal data structure which keeps track of a variety of information needed by every node, including the identity and attributes of the other nodes in the cluster; cluster-wide settings; index metadata, including the mapping and settings for each index; the location and status of every shard copy in the cluster.\n\nThe elected master node ensures that every node in the cluster has a copy of the same cluster state.\nThis API lets you retrieve a representation of this internal state for debugging or diagnostic purposes.\nYou may need to consult the Elasticsearch source code to determine the precise meaning of the response.\n\nBy default the API will route requests to the elected master node since this node is the authoritative source of cluster states.\nYou can also retrieve the cluster state held on the node handling the API request by adding the `?local=true` query parameter.\n\nElasticsearch may need to expend significant effort to compute a response to this API in larger clusters, and the response may comprise a very large quantity of data.\nIf you use this API repeatedly, your cluster may become unstable.\n\nWARNING: The response is a representation of an internal data structure.\nIts format is not subject to the same compatibility guarantees as other more stable APIs and may change from version to version.\nDo not query this API using external monitoring tools.\nInstead, obtain the information you require using other more stable cluster APIs.",
        "operationId": "cluster-state-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.state#metric"
          },
          {
            "$ref": "#/components/parameters/cluster.state#index"
          },
          {
            "$ref": "#/components/parameters/cluster.state#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/cluster.state#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.state#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.state#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cluster.state#local"
          },
          {
            "$ref": "#/components/parameters/cluster.state#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_metadata_version"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.state#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_cluster/stats": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get cluster statistics",
        "description": "Get basic index metrics (shard numbers, store size, memory usage) and information about the current nodes that form the cluster (number, roles, os, jvm versions, memory usage, cpu and installed plugins).",
        "operationId": "cluster-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.stats#include_remotes"
          },
          {
            "$ref": "#/components/parameters/cluster.stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.stats#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_cluster/stats/nodes/{node_id}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get cluster statistics",
        "description": "Get basic index metrics (shard numbers, store size, memory usage) and information about the current nodes that form the cluster (number, roles, os, jvm versions, memory usage, cpu and installed plugins).",
        "operationId": "cluster-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/cluster.stats#include_remotes"
          },
          {
            "$ref": "#/components/parameters/cluster.stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.stats#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_connector/{connector_id}/_check_in": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Check in a connector",
        "description": "Update the `last_seen` field in the connector and set it to the current timestamp.",
        "operationId": "connector-check-in",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be checked in",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/{connector_id}": {
      "get": {
        "tags": [
          "connector"
        ],
        "summary": "Get a connector",
        "description": "Get the details about a connector.",
        "operationId": "connector-get",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/connector._types:Connector"
                }
              }
            }
          }
        },
        "x-beta": true
      },
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Create or update a connector",
        "operationId": "connector-put",
        "parameters": [
          {
            "$ref": "#/components/parameters/connector.put#connector_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/connector.put"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/connector.put#200"
          }
        },
        "x-beta": true
      },
      "delete": {
        "tags": [
          "connector"
        ],
        "summary": "Delete a connector",
        "description": "Removes a connector and associated sync jobs.\nThis is a destructive action that is not recoverable.\nNOTE: This action doesnâ€™t delete any API keys, ingest pipelines, or data indices associated with the connector.\nThese need to be removed manually.",
        "operationId": "connector-delete",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be deleted",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "delete_sync_jobs",
            "description": "A flag indicating if associated sync jobs should be also removed. Defaults to false.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_last_sync": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector last sync stats",
        "description": "Update the fields related to the last sync of a connector.\nThis action is used for analytics and monitoring.",
        "operationId": "connector-last-sync",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "last_access_control_sync_error": {
                    "type": "string"
                  },
                  "last_access_control_sync_scheduled_at": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "last_access_control_sync_status": {
                    "$ref": "#/components/schemas/connector._types:SyncStatus"
                  },
                  "last_deleted_document_count": {
                    "type": "number"
                  },
                  "last_incremental_sync_scheduled_at": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "last_indexed_document_count": {
                    "type": "number"
                  },
                  "last_seen": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "last_sync_error": {
                    "type": "string"
                  },
                  "last_sync_scheduled_at": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "last_sync_status": {
                    "$ref": "#/components/schemas/connector._types:SyncStatus"
                  },
                  "last_synced": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "sync_cursor": {
                    "type": "object"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector": {
      "get": {
        "tags": [
          "connector"
        ],
        "summary": "Get all connectors",
        "description": "Get information about all connectors.",
        "operationId": "connector-list",
        "parameters": [
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies a max number of results to get",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "index_name",
            "description": "A comma-separated list of connector index names to fetch connector documents for",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "connector_name",
            "description": "A comma-separated list of connector names to fetch connector documents for",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "service_type",
            "description": "A comma-separated list of connector service types to fetch connector documents for",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "query",
            "description": "A wildcard query string that filters connectors with matching name, description or index name",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/connector._types:Connector"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      },
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Create or update a connector",
        "operationId": "connector-put-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/connector.put"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/connector.put#200"
          }
        },
        "x-beta": true
      },
      "post": {
        "tags": [
          "connector"
        ],
        "summary": "Create a connector",
        "description": "Connectors are Elasticsearch integrations that bring content from third-party data sources, which can be deployed on Elastic Cloud or hosted on your own infrastructure.\nElastic managed connectors (Native connectors) are a managed service on Elastic Cloud.\nSelf-managed connectors (Connector clients) are self-managed on your infrastructure.",
        "operationId": "connector-post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "type": "string"
                  },
                  "index_name": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "is_native": {
                    "type": "boolean"
                  },
                  "language": {
                    "type": "string"
                  },
                  "name": {
                    "type": "string"
                  },
                  "service_type": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "required": [
                    "result",
                    "id"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/_sync_job/{connector_sync_job_id}/_cancel": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Cancel a connector sync job",
        "description": "Cancel a connector sync job, which sets the status to cancelling and updates `cancellation_requested_at` to the current time.\nThe connector service is then responsible for setting the status of connector sync jobs to cancelled.",
        "operationId": "connector-sync-job-cancel",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier of the connector sync job",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/_sync_job/{connector_sync_job_id}/_check_in": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Check in a connector sync job",
        "description": "Check in a connector sync job and set the `last_seen` field to the current time before updating it in the internal index.\n\nTo sync data using self-managed connectors, you need to deploy the Elastic connector service on your own infrastructure.\nThis service runs automatically on Elastic Cloud for Elastic managed connectors.",
        "operationId": "connector-sync-job-check-in",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier of the connector sync job to be checked in.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/_sync_job/{connector_sync_job_id}/_claim": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Claim a connector sync job",
        "description": "This action updates the job status to `in_progress` and sets the `last_seen` and `started_at` timestamps to the current time.\nAdditionally, it can set the `sync_cursor` property for the sync job.\n\nThis API is not intended for direct connector management by users.\nIt supports the implementation of services that utilize the connector protocol to communicate with Elasticsearch.\n\nTo sync data using self-managed connectors, you need to deploy the Elastic connector service on your own infrastructure.\nThis service runs automatically on Elastic Cloud for Elastic managed connectors.",
        "operationId": "connector-sync-job-claim",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier of the connector sync job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "sync_cursor": {
                    "description": "The cursor object from the last incremental sync job.\nThis should reference the `sync_cursor` field in the connector state for which the job runs.",
                    "type": "object"
                  },
                  "worker_hostname": {
                    "description": "The host name of the current system that will run the job.",
                    "type": "string"
                  }
                },
                "required": [
                  "worker_hostname"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/_sync_job/{connector_sync_job_id}": {
      "get": {
        "tags": [
          "connector"
        ],
        "summary": "Get a connector sync job",
        "operationId": "connector-sync-job-get",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier of the connector sync job",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/connector._types:ConnectorSyncJob"
                }
              }
            }
          }
        },
        "x-beta": true
      },
      "delete": {
        "tags": [
          "connector"
        ],
        "summary": "Delete a connector sync job",
        "description": "Remove a connector sync job and its associated data.\nThis is a destructive action that is not recoverable.",
        "operationId": "connector-sync-job-delete",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier of the connector sync job to be deleted",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/_sync_job/{connector_sync_job_id}/_error": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Set a connector sync job error",
        "description": "Set the `error` field for a connector sync job and set its `status` to `error`.\n\nTo sync data using self-managed connectors, you need to deploy the Elastic connector service on your own infrastructure.\nThis service runs automatically on Elastic Cloud for Elastic managed connectors.",
        "operationId": "connector-sync-job-error",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier for the connector sync job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "error": {
                    "description": "The error for the connector sync job error field.",
                    "type": "string"
                  }
                },
                "required": [
                  "error"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/_sync_job": {
      "get": {
        "tags": [
          "connector"
        ],
        "summary": "Get all connector sync jobs",
        "description": "Get information about all stored connector sync jobs listed by their creation date in ascending order.",
        "operationId": "connector-sync-job-list",
        "parameters": [
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies a max number of results to get",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "status",
            "description": "A sync job status to fetch connector sync jobs for",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/connector._types:SyncStatus"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "connector_id",
            "description": "A connector id to fetch connector sync jobs for",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "job_type",
            "description": "A comma-separated list of job types to fetch the sync jobs for",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/connector._types:SyncJobType"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/connector._types:SyncJobType"
                  }
                }
              ]
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/connector._types:ConnectorSyncJob"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      },
      "post": {
        "tags": [
          "connector"
        ],
        "summary": "Create a connector sync job",
        "description": "Create a connector sync job document in the internal index and initialize its counters and timestamps with default values.",
        "operationId": "connector-sync-job-post",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "job_type": {
                    "$ref": "#/components/schemas/connector._types:SyncJobType"
                  },
                  "trigger_method": {
                    "$ref": "#/components/schemas/connector._types:SyncJobTriggerMethod"
                  }
                },
                "required": [
                  "id"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/_sync_job/{connector_sync_job_id}/_stats": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Set the connector sync job stats",
        "description": "Stats include: `deleted_document_count`, `indexed_document_count`, `indexed_document_volume`, and `total_document_count`.\nYou can also update `last_seen`.\nThis API is mainly used by the connector service for updating sync job information.\n\nTo sync data using self-managed connectors, you need to deploy the Elastic connector service on your own infrastructure.\nThis service runs automatically on Elastic Cloud for Elastic managed connectors.",
        "operationId": "connector-sync-job-update-stats",
        "parameters": [
          {
            "in": "path",
            "name": "connector_sync_job_id",
            "description": "The unique identifier of the connector sync job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "deleted_document_count": {
                    "description": "The number of documents the sync job deleted.",
                    "type": "number"
                  },
                  "indexed_document_count": {
                    "description": "The number of documents the sync job indexed.",
                    "type": "number"
                  },
                  "indexed_document_volume": {
                    "description": "The total size of the data (in MiB) the sync job indexed.",
                    "type": "number"
                  },
                  "last_seen": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "total_document_count": {
                    "description": "The total number of documents in the target index after the sync job finished.",
                    "type": "number"
                  }
                },
                "required": [
                  "deleted_document_count",
                  "indexed_document_count",
                  "indexed_document_volume"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/{connector_id}/_filtering/_activate": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Activate the connector draft filter",
        "description": "Activates the valid draft filtering for a connector.",
        "operationId": "connector-update-active-filtering",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/{connector_id}/_api_key_id": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector API key ID",
        "description": "Update the `api_key_id` and `api_key_secret_id` fields of a connector.\nYou can specify the ID of the API key used for authorization and the ID of the connector secret where the API key is stored.\nThe connector secret ID is required only for Elastic managed (native) connectors.\nSelf-managed connectors (connector clients) do not use this field.",
        "operationId": "connector-update-api-key-id",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "api_key_id": {
                    "type": "string"
                  },
                  "api_key_secret_id": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_configuration": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector configuration",
        "description": "Update the configuration field in the connector document.",
        "operationId": "connector-update-configuration",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "configuration": {
                    "$ref": "#/components/schemas/connector._types:ConnectorConfiguration"
                  },
                  "values": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_error": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector error field",
        "description": "Set the error field for the connector.\nIf the error provided in the request body is non-null, the connectorâ€™s status is updated to error.\nOtherwise, if the error is reset to null, the connector status is updated to connected.",
        "operationId": "connector-update-error",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "error": {
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "$ref": "#/components/schemas/_spec_utils:NullValue"
                      }
                    ]
                  }
                },
                "required": [
                  "error"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/{connector_id}/_features": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector features",
        "description": "Update the connector features in the connector document.\nThis API can be used to control the following aspects of a connector:\n\n* document-level security\n* incremental syncs\n* advanced sync rules\n* basic sync rules\n\nNormally, the running connector service automatically manages these features.\nHowever, you can use this API to override the default behavior.\n\nTo sync data using self-managed connectors, you need to deploy the Elastic connector service on your own infrastructure.\nThis service runs automatically on Elastic Cloud for Elastic managed connectors.",
        "operationId": "connector-update-features",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "features": {
                    "$ref": "#/components/schemas/connector._types:ConnectorFeatures"
                  }
                },
                "required": [
                  "features"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/{connector_id}/_filtering": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector filtering",
        "description": "Update the draft filtering configuration of a connector and marks the draft validation state as edited.\nThe filtering draft is activated once validated by the running Elastic connector service.\nThe filtering property is used to configure sync rules (both basic and advanced) for a connector.",
        "operationId": "connector-update-filtering",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "filtering": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/connector._types:FilteringConfig"
                    }
                  },
                  "rules": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/connector._types:FilteringRule"
                    }
                  },
                  "advanced_snippet": {
                    "$ref": "#/components/schemas/connector._types:FilteringAdvancedSnippet"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_filtering/_validation": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector draft filtering validation",
        "description": "Update the draft filtering validation info for a connector.",
        "operationId": "connector-update-filtering-validation",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "validation": {
                    "$ref": "#/components/schemas/connector._types:FilteringRulesValidation"
                  }
                },
                "required": [
                  "validation"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_connector/{connector_id}/_index_name": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector index name",
        "description": "Update the `index_name` field of a connector, specifying the index where the data ingested by the connector is stored.",
        "operationId": "connector-update-index-name",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "index_name": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/_types:IndexName"
                      },
                      {
                        "$ref": "#/components/schemas/_spec_utils:NullValue"
                      }
                    ]
                  }
                },
                "required": [
                  "index_name"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_name": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector name and description",
        "operationId": "connector-update-name",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "type": "string"
                  },
                  "description": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_native": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector is_native flag",
        "operationId": "connector-update-native",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "is_native": {
                    "type": "boolean"
                  }
                },
                "required": [
                  "is_native"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_pipeline": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector pipeline",
        "description": "When you create a new connector, the configuration of an ingest pipeline is populated with default settings.",
        "operationId": "connector-update-pipeline",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "pipeline": {
                    "$ref": "#/components/schemas/connector._types:IngestPipelineParams"
                  }
                },
                "required": [
                  "pipeline"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_scheduling": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector scheduling",
        "operationId": "connector-update-scheduling",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "scheduling": {
                    "$ref": "#/components/schemas/connector._types:SchedulingConfiguration"
                  }
                },
                "required": [
                  "scheduling"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_service_type": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector service type",
        "operationId": "connector-update-service-type",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "service_type": {
                    "type": "string"
                  }
                },
                "required": [
                  "service_type"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_connector/{connector_id}/_status": {
      "put": {
        "tags": [
          "connector"
        ],
        "summary": "Update the connector status",
        "operationId": "connector-update-status",
        "parameters": [
          {
            "in": "path",
            "name": "connector_id",
            "description": "The unique identifier of the connector to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "status": {
                    "$ref": "#/components/schemas/connector._types:ConnectorStatus"
                  }
                },
                "required": [
                  "status"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_count": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Count search results",
        "description": "Get the number of documents matching a query.\n\nThe query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.\nThe query is optional. When no query is provided, the API uses `match_all` to count all the documents.\n\nThe count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.\n\nThe operation is broadcast across all shards.\nFor each shard ID group, a replica is chosen and the search is run against it.\nThis means that replicas increase the scalability of the count.",
        "operationId": "count-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Count search results",
        "description": "Get the number of documents matching a query.\n\nThe query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.\nThe query is optional. When no query is provided, the API uses `match_all` to count all the documents.\n\nThe count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.\n\nThe operation is broadcast across all shards.\nFor each shard ID group, a replica is chosen and the search is run against it.\nThis means that replicas increase the scalability of the count.",
        "operationId": "count",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      }
    },
    "/{index}/_count": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Count search results",
        "description": "Get the number of documents matching a query.\n\nThe query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.\nThe query is optional. When no query is provided, the API uses `match_all` to count all the documents.\n\nThe count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.\n\nThe operation is broadcast across all shards.\nFor each shard ID group, a replica is chosen and the search is run against it.\nThis means that replicas increase the scalability of the count.",
        "operationId": "count-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#index"
          },
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Count search results",
        "description": "Get the number of documents matching a query.\n\nThe query can be provided either by using a simple query string as a parameter, or by defining Query DSL within the request body.\nThe query is optional. When no query is provided, the API uses `match_all` to count all the documents.\n\nThe count API supports multi-target syntax. You can run a single count API search across multiple data streams and indices.\n\nThe operation is broadcast across all shards.\nFor each shard ID group, a replica is chosen and the search is run against it.\nThis means that replicas increase the scalability of the count.",
        "operationId": "count-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#index"
          },
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      }
    },
    "/{index}/_create/{id}": {
      "put": {
        "tags": [
          "document"
        ],
        "summary": "Create a new document in the index",
        "description": "You can index a new JSON document with the `/<target>/_doc/` or `/<target>/_create/<_id>` APIs\nUsing `_create` guarantees that the document is indexed only if it does not already exist.\nIt returns a 409 response when a document with a same ID already exists in the index.\nTo update an existing document, you must use the `/<target>/_doc/` API.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To add a document using the `PUT /<target>/_create/<_id>` or `POST /<target>/_create/<_id>` request formats, you must have the `create_doc`, `create`, `index`, or `write` index privilege.\n* To automatically create a data stream or index with this API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\n**Automatically create data streams and indices**\n\nIf the request's target doesn't exist and matches an index template with a `data_stream` definition, the index operation automatically creates the data stream.\n\nIf the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.\n\nNOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.\n\nIf no mapping exists, the index operation creates a dynamic mapping.\nBy default, new fields and objects are automatically added to the mapping if needed.\n\nAutomatic index creation is controlled by the `action.auto_create_index` setting.\nIf it is `true`, any index can be created automatically.\nYou can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to `false` to turn off automatic index creation entirely.\nSpecify a comma-separated list of patterns you want to allow or prefix each pattern with `+` or `-` to indicate whether it should be allowed or blocked.\nWhen a list is specified, the default behaviour is to disallow.\n\nNOTE: The `action.auto_create_index` setting affects the automatic creation of indices only.\nIt does not affect the creation of data streams.\n\n**Routing**\n\nBy default, shard placementâ€‰â€”â€‰or routingâ€‰â€”â€‰is controlled by using a hash of the document's ID value.\nFor more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the `routing` parameter.\n\nWhen setting up explicit mapping, you can also use the `_routing` field to direct the index operation to extract the routing value from the document itself.\nThis does come at the (very minimal) cost of an additional document parsing pass.\nIf the `_routing` mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n** Distributed**\n\nThe index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.\nAfter the primary shard completes the operation, if needed, the update is distributed to applicable replicas.\n\n**Active shards**\n\nTo improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.\nIf the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.\nBy default, write operations only wait for the primary shards to be active before proceeding (that is to say `wait_for_active_shards` is `1`).\nThis default can be overridden in the index settings dynamically by setting `index.write.wait_for_active_shards`.\nTo alter this behavior per operation, use the `wait_for_active_shards request` parameter.\n\nValid values are all or any positive integer up to the total number of configured copies per shard in the index (which is `number_of_replicas`+1).\nSpecifying a negative value or a number greater than the number of shard copies will throw an error.\n\nFor example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).\nIf you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.\nThis means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.\nIf `wait_for_active_shards` is set on the request to `3` (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.\nThis requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.\nHowever, if you set `wait_for_active_shards` to `all` (or to `4`, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.\nThe operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.\n\nIt is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.\nAfter the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.\nThe `_shards` section of the API response reveals the number of shard copies on which replication succeeded and failed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html"
        },
        "operationId": "create",
        "parameters": [
          {
            "$ref": "#/components/parameters/create#index"
          },
          {
            "$ref": "#/components/parameters/create#id"
          },
          {
            "$ref": "#/components/parameters/create#pipeline"
          },
          {
            "$ref": "#/components/parameters/create#refresh"
          },
          {
            "$ref": "#/components/parameters/create#routing"
          },
          {
            "$ref": "#/components/parameters/create#timeout"
          },
          {
            "$ref": "#/components/parameters/create#version"
          },
          {
            "$ref": "#/components/parameters/create#version_type"
          },
          {
            "$ref": "#/components/parameters/create#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/create"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/create#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Create a new document in the index",
        "description": "You can index a new JSON document with the `/<target>/_doc/` or `/<target>/_create/<_id>` APIs\nUsing `_create` guarantees that the document is indexed only if it does not already exist.\nIt returns a 409 response when a document with a same ID already exists in the index.\nTo update an existing document, you must use the `/<target>/_doc/` API.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To add a document using the `PUT /<target>/_create/<_id>` or `POST /<target>/_create/<_id>` request formats, you must have the `create_doc`, `create`, `index`, or `write` index privilege.\n* To automatically create a data stream or index with this API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\n**Automatically create data streams and indices**\n\nIf the request's target doesn't exist and matches an index template with a `data_stream` definition, the index operation automatically creates the data stream.\n\nIf the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.\n\nNOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.\n\nIf no mapping exists, the index operation creates a dynamic mapping.\nBy default, new fields and objects are automatically added to the mapping if needed.\n\nAutomatic index creation is controlled by the `action.auto_create_index` setting.\nIf it is `true`, any index can be created automatically.\nYou can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to `false` to turn off automatic index creation entirely.\nSpecify a comma-separated list of patterns you want to allow or prefix each pattern with `+` or `-` to indicate whether it should be allowed or blocked.\nWhen a list is specified, the default behaviour is to disallow.\n\nNOTE: The `action.auto_create_index` setting affects the automatic creation of indices only.\nIt does not affect the creation of data streams.\n\n**Routing**\n\nBy default, shard placementâ€‰â€”â€‰or routingâ€‰â€”â€‰is controlled by using a hash of the document's ID value.\nFor more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the `routing` parameter.\n\nWhen setting up explicit mapping, you can also use the `_routing` field to direct the index operation to extract the routing value from the document itself.\nThis does come at the (very minimal) cost of an additional document parsing pass.\nIf the `_routing` mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n** Distributed**\n\nThe index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.\nAfter the primary shard completes the operation, if needed, the update is distributed to applicable replicas.\n\n**Active shards**\n\nTo improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.\nIf the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.\nBy default, write operations only wait for the primary shards to be active before proceeding (that is to say `wait_for_active_shards` is `1`).\nThis default can be overridden in the index settings dynamically by setting `index.write.wait_for_active_shards`.\nTo alter this behavior per operation, use the `wait_for_active_shards request` parameter.\n\nValid values are all or any positive integer up to the total number of configured copies per shard in the index (which is `number_of_replicas`+1).\nSpecifying a negative value or a number greater than the number of shard copies will throw an error.\n\nFor example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).\nIf you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.\nThis means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.\nIf `wait_for_active_shards` is set on the request to `3` (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.\nThis requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.\nHowever, if you set `wait_for_active_shards` to `all` (or to `4`, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.\nThe operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.\n\nIt is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.\nAfter the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.\nThe `_shards` section of the API response reveals the number of shard copies on which replication succeeded and failed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html"
        },
        "operationId": "create-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/create#index"
          },
          {
            "$ref": "#/components/parameters/create#id"
          },
          {
            "$ref": "#/components/parameters/create#pipeline"
          },
          {
            "$ref": "#/components/parameters/create#refresh"
          },
          {
            "$ref": "#/components/parameters/create#routing"
          },
          {
            "$ref": "#/components/parameters/create#timeout"
          },
          {
            "$ref": "#/components/parameters/create#version"
          },
          {
            "$ref": "#/components/parameters/create#version_type"
          },
          {
            "$ref": "#/components/parameters/create#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/create"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/create#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_dangling/{index_uuid}": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Import a dangling index",
        "description": "If Elasticsearch encounters index data that is absent from the current cluster state, those indices are considered to be dangling.\nFor example, this can happen if you delete more than `cluster.indices.tombstones.size` indices while an Elasticsearch node is offline.",
        "operationId": "dangling-indices-import-dangling-index",
        "parameters": [
          {
            "in": "path",
            "name": "index_uuid",
            "description": "The UUID of the index to import. Use the get dangling indices API to locate the UUID.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Uuid"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "accept_data_loss",
            "description": "This parameter must be set to true to import a dangling index.\nBecause Elasticsearch cannot know where the dangling index data came from or determine which shard copies are fresh and which are stale, it cannot guarantee that the imported data represents the latest state of the index when it was last in the cluster.",
            "required": true,
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete a dangling index",
        "description": "If Elasticsearch encounters index data that is absent from the current cluster state, those indices are considered to be dangling.\nFor example, this can happen if you delete more than `cluster.indices.tombstones.size` indices while an Elasticsearch node is offline.",
        "operationId": "dangling-indices-delete-dangling-index",
        "parameters": [
          {
            "in": "path",
            "name": "index_uuid",
            "description": "The UUID of the index to delete. Use the get dangling indices API to find the UUID.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Uuid"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "accept_data_loss",
            "description": "This parameter must be set to true to acknowledge that it will no longer be possible to recove data from the dangling index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_dangling": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get the dangling indices",
        "description": "If Elasticsearch encounters index data that is absent from the current cluster state, those indices are considered to be dangling.\nFor example, this can happen if you delete more than `cluster.indices.tombstones.size` indices while an Elasticsearch node is offline.\n\nUse this API to list dangling indices, which you can then import or delete.",
        "operationId": "dangling-indices-list-dangling-indices",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "dangling_indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/dangling_indices.list_dangling_indices:DanglingIndex"
                      }
                    }
                  },
                  "required": [
                    "dangling_indices"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/{index}/_doc/{id}": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get a document by its ID",
        "description": "Get a document and its source or stored fields from an index.\n\nBy default, this API is realtime and is not affected by the refresh rate of the index (when data will become visible for search).\nIn the case where stored fields are requested with the `stored_fields` parameter and the document has been updated but is not yet refreshed, the API will have to parse and analyze the source to extract the stored fields.\nTo turn off realtime behavior, set the `realtime` parameter to false.\n\n**Source filtering**\n\nBy default, the API returns the contents of the `_source` field unless you have used the `stored_fields` parameter or the `_source` field is turned off.\nYou can turn off `_source` retrieval by using the `_source` parameter:\n\n```\nGET my-index-000001/_doc/0?_source=false\n```\n\nIf you only need one or two fields from the `_source`, use the `_source_includes` or `_source_excludes` parameters to include or filter out particular fields.\nThis can be helpful with large documents where partial retrieval can save on network overhead\nBoth parameters take a comma separated list of fields or wildcard expressions.\nFor example:\n\n```\nGET my-index-000001/_doc/0?_source_includes=*.id&_source_excludes=entities\n```\n\nIf you only want to specify includes, you can use a shorter notation:\n\n```\nGET my-index-000001/_doc/0?_source=*.id\n```\n\n**Routing**\n\nIf routing is used during indexing, the routing value also needs to be specified to retrieve a document.\nFor example:\n\n```\nGET my-index-000001/_doc/2?routing=user1\n```\n\nThis request gets the document with ID 2, but it is routed based on the user.\nThe document is not fetched if the correct routing is not specified.\n\n**Distributed**\n\nThe GET operation is hashed into a specific shard ID.\nIt is then redirected to one of the replicas within that shard ID and returns the result.\nThe replicas are the primary shard and its replicas within that shard ID group.\nThis means that the more replicas you have, the better your GET scaling will be.\n\n**Versioning support**\n\nYou can use the `version` parameter to retrieve the document only if its current version is equal to the specified one.\n\nInternally, Elasticsearch has marked the old document as deleted and added an entirely new document.\nThe old version of the document doesn't disappear immediately, although you won't be able to access it.\nElasticsearch cleans up deleted documents in the background as you continue to index more data.",
        "operationId": "get",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index that contains the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "A unique document identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force_synthetic_source",
            "description": "Indicates whether the request forces synthetic `_source`.\nUse this paramater to test if the mapping supports synthetic `_source` and to get a sense of the worst case performance.\nFetches with this parameter enabled will be slower than enabling synthetic source natively in the index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.\n\nIf it is set to `_local`, the operation will prefer to be run on a local allocated shard when possible.\nIf it is set to a custom value, the value is used to guarantee that the same shards will be used for the same custom value.\nThis can help with \"jumping values\" when hitting different shards in different refresh states.\nA sample value can be something like the web session ID or the user name.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If `true`, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "Indicates whether to return the `_source` field (`true` or `false`) or lists the fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned.\nYou can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stored_fields",
            "description": "A comma-separated list of stored fields to return as part of a hit.\nIf no fields are specified, no stored fields are included in the response.\nIf this field is specified, the `_source` parameter defaults to `false`.\nOnly leaf fields can be retrieved with the `stored_field` option.\nObject fields can't be returned;â€‹if specified, the request fails.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "The version number for concurrency control.\nIt must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "The version type.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_global.get:GetResult"
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "document"
        ],
        "summary": "Create or update a document in an index",
        "description": "Add a JSON document to the specified data stream or index and make it searchable.\nIf the target is an index and the document already exists, the request updates the document and increments its version.\n\nNOTE: You cannot use this API to send update requests for existing documents in a data stream.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To add or overwrite a document using the `PUT /<target>/_doc/<_id>` request format, you must have the `create`, `index`, or `write` index privilege.\n* To add a document using the `POST /<target>/_doc/` request format, you must have the `create_doc`, `create`, `index`, or `write` index privilege.\n* To automatically create a data stream or index with this API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nNOTE: Replica shards might not all be started when an indexing operation returns successfully.\nBy default, only the primary is required. Set `wait_for_active_shards` to change this default behavior.\n\n**Automatically create data streams and indices**\n\nIf the request's target doesn't exist and matches an index template with a `data_stream` definition, the index operation automatically creates the data stream.\n\nIf the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.\n\nNOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.\n\nIf no mapping exists, the index operation creates a dynamic mapping.\nBy default, new fields and objects are automatically added to the mapping if needed.\n\nAutomatic index creation is controlled by the `action.auto_create_index` setting.\nIf it is `true`, any index can be created automatically.\nYou can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to `false` to turn off automatic index creation entirely.\nSpecify a comma-separated list of patterns you want to allow or prefix each pattern with `+` or `-` to indicate whether it should be allowed or blocked.\nWhen a list is specified, the default behaviour is to disallow.\n\nNOTE: The `action.auto_create_index` setting affects the automatic creation of indices only.\nIt does not affect the creation of data streams.\n\n**Optimistic concurrency control**\n\nIndex operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the `if_seq_no` and `if_primary_term` parameters.\nIf a mismatch is detected, the operation will result in a `VersionConflictException` and a status code of `409`.\n\n**Routing**\n\nBy default, shard placementâ€‰â€”â€‰or routingâ€‰â€”â€‰is controlled by using a hash of the document's ID value.\nFor more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the `routing` parameter.\n\nWhen setting up explicit mapping, you can also use the `_routing` field to direct the index operation to extract the routing value from the document itself.\nThis does come at the (very minimal) cost of an additional document parsing pass.\nIf the `_routing` mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n * ** Distributed**\n\nThe index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.\nAfter the primary shard completes the operation, if needed, the update is distributed to applicable replicas.\n\n**Active shards**\n\nTo improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.\nIf the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.\nBy default, write operations only wait for the primary shards to be active before proceeding (that is to say `wait_for_active_shards` is `1`).\nThis default can be overridden in the index settings dynamically by setting `index.write.wait_for_active_shards`.\nTo alter this behavior per operation, use the `wait_for_active_shards request` parameter.\n\nValid values are all or any positive integer up to the total number of configured copies per shard in the index (which is `number_of_replicas`+1).\nSpecifying a negative value or a number greater than the number of shard copies will throw an error.\n\nFor example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).\nIf you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.\nThis means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.\nIf `wait_for_active_shards` is set on the request to `3` (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.\nThis requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.\nHowever, if you set `wait_for_active_shards` to `all` (or to `4`, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.\nThe operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.\n\nIt is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.\nAfter the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.\nThe `_shards` section of the API response reveals the number of shard copies on which replication succeeded and failed.\n\n**No operation (noop) updates**\n\nWhen updating a document by using this API, a new version of the document is always created even if the document hasn't changed.\nIf this isn't acceptable use the `_update` API with `detect_noop` set to `true`.\nThe `detect_noop` option isn't available on this API because it doesnâ€™t fetch the old source and isn't able to compare it against the new source.\n\nThere isn't a definitive rule for when noop updates aren't acceptable.\nIt's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.\n\n**Versioning**\n\nEach indexed document is given a version number.\nBy default, internal versioning is used that starts at 1 and increments with each update, deletes included.\nOptionally, the version number can be set to an external value (for example, if maintained in a database).\nTo enable this functionality, `version_type` should be set to `external`.\nThe value provided must be a numeric, long value greater than or equal to 0, and less than around `9.2e+18`.\n\nNOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.\nIf no version is provided, the operation runs without any version checks.\n\nWhen using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.\nIf true, the document will be indexed and the new version number used.\nIf the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:\n\n```\nPUT my-index-000001/_doc/1?version=2&version_type=external\n{\n  \"user\": {\n    \"id\": \"elkbee\"\n  }\n}\n\nIn this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.\nIf the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).\n\nA nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.\nEven the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html"
        },
        "operationId": "index",
        "parameters": [
          {
            "$ref": "#/components/parameters/index#index"
          },
          {
            "$ref": "#/components/parameters/index#id"
          },
          {
            "$ref": "#/components/parameters/index#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/index#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/index#op_type"
          },
          {
            "$ref": "#/components/parameters/index#pipeline"
          },
          {
            "$ref": "#/components/parameters/index#refresh"
          },
          {
            "$ref": "#/components/parameters/index#routing"
          },
          {
            "$ref": "#/components/parameters/index#timeout"
          },
          {
            "$ref": "#/components/parameters/index#version"
          },
          {
            "$ref": "#/components/parameters/index#version_type"
          },
          {
            "$ref": "#/components/parameters/index#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/index#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/index"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/index#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Create or update a document in an index",
        "description": "Add a JSON document to the specified data stream or index and make it searchable.\nIf the target is an index and the document already exists, the request updates the document and increments its version.\n\nNOTE: You cannot use this API to send update requests for existing documents in a data stream.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To add or overwrite a document using the `PUT /<target>/_doc/<_id>` request format, you must have the `create`, `index`, or `write` index privilege.\n* To add a document using the `POST /<target>/_doc/` request format, you must have the `create_doc`, `create`, `index`, or `write` index privilege.\n* To automatically create a data stream or index with this API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nNOTE: Replica shards might not all be started when an indexing operation returns successfully.\nBy default, only the primary is required. Set `wait_for_active_shards` to change this default behavior.\n\n**Automatically create data streams and indices**\n\nIf the request's target doesn't exist and matches an index template with a `data_stream` definition, the index operation automatically creates the data stream.\n\nIf the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.\n\nNOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.\n\nIf no mapping exists, the index operation creates a dynamic mapping.\nBy default, new fields and objects are automatically added to the mapping if needed.\n\nAutomatic index creation is controlled by the `action.auto_create_index` setting.\nIf it is `true`, any index can be created automatically.\nYou can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to `false` to turn off automatic index creation entirely.\nSpecify a comma-separated list of patterns you want to allow or prefix each pattern with `+` or `-` to indicate whether it should be allowed or blocked.\nWhen a list is specified, the default behaviour is to disallow.\n\nNOTE: The `action.auto_create_index` setting affects the automatic creation of indices only.\nIt does not affect the creation of data streams.\n\n**Optimistic concurrency control**\n\nIndex operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the `if_seq_no` and `if_primary_term` parameters.\nIf a mismatch is detected, the operation will result in a `VersionConflictException` and a status code of `409`.\n\n**Routing**\n\nBy default, shard placementâ€‰â€”â€‰or routingâ€‰â€”â€‰is controlled by using a hash of the document's ID value.\nFor more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the `routing` parameter.\n\nWhen setting up explicit mapping, you can also use the `_routing` field to direct the index operation to extract the routing value from the document itself.\nThis does come at the (very minimal) cost of an additional document parsing pass.\nIf the `_routing` mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n * ** Distributed**\n\nThe index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.\nAfter the primary shard completes the operation, if needed, the update is distributed to applicable replicas.\n\n**Active shards**\n\nTo improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.\nIf the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.\nBy default, write operations only wait for the primary shards to be active before proceeding (that is to say `wait_for_active_shards` is `1`).\nThis default can be overridden in the index settings dynamically by setting `index.write.wait_for_active_shards`.\nTo alter this behavior per operation, use the `wait_for_active_shards request` parameter.\n\nValid values are all or any positive integer up to the total number of configured copies per shard in the index (which is `number_of_replicas`+1).\nSpecifying a negative value or a number greater than the number of shard copies will throw an error.\n\nFor example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).\nIf you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.\nThis means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.\nIf `wait_for_active_shards` is set on the request to `3` (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.\nThis requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.\nHowever, if you set `wait_for_active_shards` to `all` (or to `4`, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.\nThe operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.\n\nIt is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.\nAfter the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.\nThe `_shards` section of the API response reveals the number of shard copies on which replication succeeded and failed.\n\n**No operation (noop) updates**\n\nWhen updating a document by using this API, a new version of the document is always created even if the document hasn't changed.\nIf this isn't acceptable use the `_update` API with `detect_noop` set to `true`.\nThe `detect_noop` option isn't available on this API because it doesnâ€™t fetch the old source and isn't able to compare it against the new source.\n\nThere isn't a definitive rule for when noop updates aren't acceptable.\nIt's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.\n\n**Versioning**\n\nEach indexed document is given a version number.\nBy default, internal versioning is used that starts at 1 and increments with each update, deletes included.\nOptionally, the version number can be set to an external value (for example, if maintained in a database).\nTo enable this functionality, `version_type` should be set to `external`.\nThe value provided must be a numeric, long value greater than or equal to 0, and less than around `9.2e+18`.\n\nNOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.\nIf no version is provided, the operation runs without any version checks.\n\nWhen using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.\nIf true, the document will be indexed and the new version number used.\nIf the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:\n\n```\nPUT my-index-000001/_doc/1?version=2&version_type=external\n{\n  \"user\": {\n    \"id\": \"elkbee\"\n  }\n}\n\nIn this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.\nIf the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).\n\nA nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.\nEven the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html"
        },
        "operationId": "index-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/index#index"
          },
          {
            "$ref": "#/components/parameters/index#id"
          },
          {
            "$ref": "#/components/parameters/index#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/index#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/index#op_type"
          },
          {
            "$ref": "#/components/parameters/index#pipeline"
          },
          {
            "$ref": "#/components/parameters/index#refresh"
          },
          {
            "$ref": "#/components/parameters/index#routing"
          },
          {
            "$ref": "#/components/parameters/index#timeout"
          },
          {
            "$ref": "#/components/parameters/index#version"
          },
          {
            "$ref": "#/components/parameters/index#version_type"
          },
          {
            "$ref": "#/components/parameters/index#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/index#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/index"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/index#200"
          }
        }
      },
      "delete": {
        "tags": [
          "document"
        ],
        "summary": "Delete a document",
        "description": "Remove a JSON document from the specified index.\n\nNOTE: You cannot send deletion requests directly to a data stream.\nTo delete a document in a data stream, you must target the backing index containing the document.\n\n**Optimistic concurrency control**\n\nDelete operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the `if_seq_no` and `if_primary_term` parameters.\nIf a mismatch is detected, the operation will result in a `VersionConflictException` and a status code of `409`.\n\n**Versioning**\n\nEach document indexed is versioned.\nWhen deleting a document, the version can be specified to make sure the relevant document you are trying to delete is actually being deleted and it has not changed in the meantime.\nEvery write operation run on a document, deletes included, causes its version to be incremented.\nThe version number of a deleted document remains available for a short time after deletion to allow for control of concurrent operations.\nThe length of time for which a deleted document's version remains available is determined by the `index.gc_deletes` index setting.\n\n**Routing**\n\nIf routing is used during indexing, the routing value also needs to be specified to delete a document.\n\nIf the `_routing` mapping is set to `required` and no routing value is specified, the delete API throws a `RoutingMissingException` and rejects the request.\n\nFor example:\n\n```\nDELETE /my-index-000001/_doc/1?routing=shard-1\n```\n\nThis request deletes the document with ID 1, but it is routed based on the user.\nThe document is not deleted if the correct routing is not specified.\n\n**Distributed**\n\nThe delete operation gets hashed into a specific shard ID.\nIt then gets redirected into the primary shard within that ID group and replicated (if needed) to shard replicas within that ID group.",
        "operationId": "delete",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the target index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "if_primary_term",
            "description": "Only perform the operation if the document has this primary term.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "if_seq_no",
            "description": "Only perform the operation if the document has this sequence number.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SequenceNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.\nIf `wait_for`, it waits for a refresh to make this operation visible to search.\nIf `false`, it does nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for active shards.\n\nThis parameter is useful for situations where the primary shard assigned to perform the delete operation might not be available when the delete operation runs.\nSome reasons for this might be that the primary shard is currently recovering from a store or undergoing relocation.\nBy default, the delete operation will wait on the primary shard to become available for up to 1 minute before failing and responding with an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "An explicit version number for concurrency control.\nIt must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "The version type.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The minimum number of shard copies that must be active before proceeding with the operation.\nYou can set it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe default value of `1` means it waits for each primary shard to be active.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:WriteResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "document"
        ],
        "summary": "Check a document",
        "description": "Verify that a document exists.\nFor example, check to see if a document with the `_id` 0 exists:\n\n```\nHEAD my-index-000001/_doc/0\n```\n\nIf the document exists, the API returns a status code of `200 - OK`.\nIf the document doesnâ€™t exist, the API returns `404 - Not Found`.\n\n**Versioning support**\n\nYou can use the `version` parameter to check the document only if its current version is equal to the specified one.\n\nInternally, Elasticsearch has marked the old document as deleted and added an entirely new document.\nThe old version of the document doesn't disappear immediately, although you won't be able to access it.\nElasticsearch cleans up deleted documents in the background as you continue to index more data.",
        "operationId": "exists",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of data streams, indices, and aliases.\nIt supports wildcards (`*`).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "A unique document identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.\n\nIf it is set to `_local`, the operation will prefer to be run on a local allocated shard when possible.\nIf it is set to a custom value, the value is used to guarantee that the same shards will be used for the same custom value.\nThis can help with \"jumping values\" when hitting different shards in different refresh states.\nA sample value can be something like the web session ID or the user name.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If `true`, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "Indicates whether to return the `_source` field (`true` or `false`) or lists the fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned.\nYou can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stored_fields",
            "description": "A comma-separated list of stored fields to return as part of a hit.\nIf no fields are specified, no stored fields are included in the response.\nIf this field is specified, the `_source` parameter defaults to `false`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "Explicit version number for concurrency control.\nThe specified version must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "The version type.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/{index}/_delete_by_query": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Delete documents",
        "description": "Deletes documents that match the specified query.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:\n\n* `read`\n* `delete` or `write`\n\nYou can specify the query criteria in the request URI or the request body using the same syntax as the search API.\nWhen you submit a delete by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and deletes matching documents using internal versioning.\nIf a document changes between the time that the snapshot is taken and the delete operation is processed, it results in a version conflict and the delete operation fails.\n\nNOTE: Documents with a version equal to 0 cannot be deleted using delete by query because internal versioning does not support 0 as a valid version number.\n\nWhile processing a delete by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents to delete.\nA bulk delete request is performed for each batch of matching documents.\nIf a search or bulk request is rejected, the requests are retried up to 10 times, with exponential back off.\nIf the maximum retry limit is reached, processing halts and all failed requests are returned in the response.\nAny delete requests that completed successfully still stick, they are not rolled back.\n\nYou can opt to count version conflicts instead of halting and returning by setting `conflicts` to `proceed`.\nNote that if you opt to count version conflicts the operation could attempt to delete more documents from the source than `max_docs` until it has successfully deleted `max_docs documents`, or it has gone through every document in the source query.\n\n**Throttling delete requests**\n\nTo control the rate at which delete by query issues batches of delete operations, you can set `requests_per_second` to any positive decimal number.\nThis pads each batch with a wait time to throttle the rate.\nSet `requests_per_second` to `-1` to disable throttling.\n\nThrottling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.\nThe padding time is the difference between the batch size divided by the `requests_per_second` and the time spent writing.\nBy default the batch size is `1000`, so if `requests_per_second` is set to `500`:\n\n```\ntarget_time = 1000 / 500 per second = 2 seconds\nwait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds\n```\n\nSince the batch is issued as a single `_bulk` request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.\nThis is \"bursty\" instead of \"smooth\".\n\n**Slicing**\n\nDelete by query supports sliced scroll to parallelize the delete process.\nThis can improve efficiency and provide a convenient way to break the request down into smaller parts.\n\nSetting `slices` to `auto` lets Elasticsearch choose the number of slices to use.\nThis setting will use one slice per shard, up to a certain limit.\nIf there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.\nAdding slices to the delete by query operation creates sub-requests which means it has some quirks:\n\n* You can see these requests in the tasks APIs. These sub-requests are \"child\" tasks of the task for the request with slices.\n* Fetching the status of the task for the request with slices only contains the status of completed slices.\n* These sub-requests are individually addressable for things like cancellation and rethrottling.\n* Rethrottling the request with `slices` will rethrottle the unfinished sub-request proportionally.\n* Canceling the request with `slices` will cancel each sub-request.\n* Due to the nature of `slices` each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.\n* Parameters like `requests_per_second` and `max_docs` on a request with `slices` are distributed proportionally to each sub-request. Combine that with the earlier point about distribution being uneven and you should conclude that using `max_docs` with `slices` might not result in exactly `max_docs` documents being deleted.\n* Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.\n\nIf you're slicing manually or otherwise tuning automatic slicing, keep in mind that:\n\n* Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many `slices` hurts performance. Setting `slices` higher than the number of shards generally does not improve efficiency and adds overhead.\n* Delete performance scales linearly across available resources with the number of slices.\n\nWhether query or delete performance dominates the runtime depends on the documents being reindexed and cluster resources.\n\n**Cancel a delete by query operation**\n\nAny delete by query can be canceled using the task cancel API. For example:\n\n```\nPOST _tasks/r1A2WoRbTwKZ516z6NEs5A:36619/_cancel\n```\n\nThe task ID can be found by using the get tasks API.\n\nCancellation should happen quickly but might take a few seconds.\nThe get task status API will continue to list the delete by query task until this task checks that it has been cancelled and terminates itself.",
        "operationId": "delete-by-query",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).\nTo search all data streams or indices, omit this parameter or use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyzer",
            "description": "Analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyze_wildcard",
            "description": "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "conflicts",
            "description": "What to do if delete by query hits version conflicts: `abort` or `proceed`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Conflicts"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "default_operator",
            "description": "The default operator for query string query: `AND` or `OR`.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types.query_dsl:Operator"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "df",
            "description": "The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nIt supports comma-separated values, such as `open,hidden`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lenient",
            "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_docs",
            "description": "The maximum number of documents to process.\nDefaults to all documents.\nWhen set to a value less then or equal to `scroll_size`, a scroll will not be used to retrieve the results for the operation.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nIt is random by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes all shards involved in the delete by query after the request completes.\nThis is different than the delete API's `refresh` parameter, which causes just the shard that received the delete request to be refreshed.\nUnlike the delete API, it does not support `wait_for`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "request_cache",
            "description": "If `true`, the request cache is used for this request.\nDefaults to the index-level setting.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "q",
            "description": "A query in the Lucene query string syntax.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll",
            "description": "The period to retain the search context for scrolling.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll_size",
            "description": "The size of the scroll request that powers the operation.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_timeout",
            "description": "The explicit timeout for each search request.\nIt defaults to no timeout.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_type",
            "description": "The type of the search operation.\nAvailable options include `query_then_fetch` and `dfs_query_then_fetch`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SearchType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "slices",
            "description": "The number of slices this task should be divided into.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Slices"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "sort",
            "description": "A comma-separated list of `<field>:<direction>` pairs.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stats",
            "description": "The specific `tag` of the request for logging and statistical purposes.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "terminate_after",
            "description": "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nUse with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period each deletion request waits for active shards.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "If `true`, returns the document version as part of a hit.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe `timeout` value controls how long each write request waits for unavailable shards to become available.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the operation is complete.\nIf `false`, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task. Elasticsearch creates a record of this task as a document at `.tasks/task/${taskId}`. When you are done with a task, you should delete the task document so Elasticsearch can reclaim the space.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "max_docs": {
                    "description": "The maximum number of documents to delete.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "slice": {
                    "$ref": "#/components/schemas/_types:SlicedScroll"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "batches": {
                      "description": "The number of scroll responses pulled back by the delete by query.",
                      "type": "number"
                    },
                    "deleted": {
                      "description": "The number of documents that were successfully deleted.",
                      "type": "number"
                    },
                    "failures": {
                      "description": "An array of failures if there were any unrecoverable errors during the process.\nIf this array is not empty, the request ended abnormally because of those failures.\nDelete by query is implemented using batches and any failures cause the entire process to end but all failures in the current batch are collected into the array.\nYou can use the `conflicts` option to prevent reindex from ending on version conflicts.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:BulkIndexByScrollFailure"
                      }
                    },
                    "noops": {
                      "description": "This field is always equal to zero for delete by query.\nIt exists only so that delete by query, update by query, and reindex APIs return responses with the same structure.",
                      "type": "number"
                    },
                    "requests_per_second": {
                      "description": "The number of requests per second effectively run during the delete by query.",
                      "type": "number"
                    },
                    "retries": {
                      "$ref": "#/components/schemas/_types:Retries"
                    },
                    "slice_id": {
                      "type": "number"
                    },
                    "task": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    },
                    "throttled": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "throttled_until": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_until_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "timed_out": {
                      "description": "If `true`, some requests run during the delete by query operation timed out.",
                      "type": "boolean"
                    },
                    "took": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "total": {
                      "description": "The number of documents that were successfully processed.",
                      "type": "number"
                    },
                    "version_conflicts": {
                      "description": "The number of version conflicts that the delete by query hit.",
                      "type": "number"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_delete_by_query/{task_id}/_rethrottle": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Throttle a delete by query operation",
        "description": "Change the number of requests per second for a particular delete by query operation.\nRethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.",
        "operationId": "delete-by-query-rethrottle",
        "parameters": [
          {
            "in": "path",
            "name": "task_id",
            "description": "The ID for the task.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TaskId"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.\nTo disable throttling, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/tasks._types:TaskListResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_scripts/{id}": {
      "get": {
        "tags": [
          "script"
        ],
        "summary": "Get a script or search template",
        "description": "Retrieves a stored script or search template.",
        "operationId": "get-script",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The identifier for the stored script or search template.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for the master node.\nIf the master node is not available before the timeout expires, the request fails and returns an error.\nIt can also be set to `-1` to indicate that the request should never timeout.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "found": {
                      "type": "boolean"
                    },
                    "script": {
                      "$ref": "#/components/schemas/_types:StoredScript"
                    }
                  },
                  "required": [
                    "_id",
                    "found"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "script"
        ],
        "summary": "Create or update a script or search template",
        "description": "Creates or updates a stored script or search template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "put-script",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#context_"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      },
      "post": {
        "tags": [
          "script"
        ],
        "summary": "Create or update a script or search template",
        "description": "Creates or updates a stored script or search template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "put-script-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#context_"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      },
      "delete": {
        "tags": [
          "script"
        ],
        "summary": "Delete a script or search template",
        "description": "Deletes a stored script or search template.",
        "operationId": "delete-script",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The identifier for the stored script or search template.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nIt can also be set to `-1` to indicate that the request should never timeout.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nIt can also be set to `-1` to indicate that the request should never timeout.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_enrich/policy/{name}": {
      "get": {
        "tags": [
          "enrich"
        ],
        "summary": "Get an enrich policy",
        "description": "Returns information about an enrich policy.",
        "operationId": "enrich-get-policy",
        "parameters": [
          {
            "$ref": "#/components/parameters/enrich.get_policy#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/enrich.get_policy#200"
          }
        },
        "x-state": "Added in 7.5.0"
      },
      "put": {
        "tags": [
          "enrich"
        ],
        "summary": "Create an enrich policy",
        "description": "Creates an enrich policy.",
        "operationId": "enrich-put-policy",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the enrich policy to create or update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "geo_match": {
                    "$ref": "#/components/schemas/enrich._types:Policy"
                  },
                  "match": {
                    "$ref": "#/components/schemas/enrich._types:Policy"
                  },
                  "range": {
                    "$ref": "#/components/schemas/enrich._types:Policy"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      },
      "delete": {
        "tags": [
          "enrich"
        ],
        "summary": "Delete an enrich policy",
        "description": "Deletes an existing enrich policy and its enrich index.",
        "operationId": "enrich-delete-policy",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Enrich policy to delete.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_enrich/policy/{name}/_execute": {
      "put": {
        "tags": [
          "enrich"
        ],
        "summary": "Run an enrich policy",
        "description": "Create the enrich index for an existing enrich policy.",
        "operationId": "enrich-execute-policy",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Enrich policy to execute.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks other enrich policy execution requests until complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "$ref": "#/components/schemas/enrich.execute_policy:ExecuteEnrichPolicyStatus"
                    },
                    "task": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_enrich/policy": {
      "get": {
        "tags": [
          "enrich"
        ],
        "summary": "Get an enrich policy",
        "description": "Returns information about an enrich policy.",
        "operationId": "enrich-get-policy-1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/enrich.get_policy#200"
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_enrich/_stats": {
      "get": {
        "tags": [
          "enrich"
        ],
        "summary": "Get enrich stats",
        "description": "Returns enrich coordinator statistics and information about enrich policies that are currently executing.",
        "operationId": "enrich-stats",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "coordinator_stats": {
                      "description": "Objects containing information about each coordinating ingest node for configured enrich processors.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/enrich.stats:CoordinatorStats"
                      }
                    },
                    "executing_policies": {
                      "description": "Objects containing information about each enrich policy that is currently executing.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/enrich.stats:ExecutingPolicy"
                      }
                    },
                    "cache_stats": {
                      "description": "Objects containing information about the enrich cache stats on each ingest node.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/enrich.stats:CacheStats"
                      }
                    }
                  },
                  "required": [
                    "coordinator_stats",
                    "executing_policies"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_eql/search/{id}": {
      "get": {
        "tags": [
          "eql"
        ],
        "summary": "Get async EQL search results",
        "description": "Get the current status and available results for an async EQL search or a stored synchronous EQL search.",
        "operationId": "eql-get",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "Period for which the search and its results are stored on the cluster.\nDefaults to the keep_alive value set by the searchâ€™s EQL search API request.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion_timeout",
            "description": "Timeout duration to wait for the request to finish.\nDefaults to no timeout, meaning the request waits for complete search results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/eql._types:EqlSearchResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "delete": {
        "tags": [
          "eql"
        ],
        "summary": "Delete an async EQL search",
        "description": "Delete an async EQL search or a stored synchronous EQL search.\nThe API also deletes results for the search.",
        "operationId": "eql-delete",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the search to delete.\nA search ID is provided in the EQL search API's response for an async search.\nA search ID is also provided if the requestâ€™s `keep_on_completion` parameter is `true`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_eql/search/status/{id}": {
      "get": {
        "tags": [
          "eql"
        ],
        "summary": "Get the async EQL status",
        "description": "Get the current status for an async EQL search or a stored synchronous EQL search without returning results.",
        "operationId": "eql-get-status",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "is_partial": {
                      "description": "If true, the search request is still executing. If false, the search is completed.",
                      "type": "boolean"
                    },
                    "is_running": {
                      "description": "If true, the response does not contain complete search results. This could be because either the search is still running (is_running status is false), or because it is already completed (is_running status is true) and results are partial due to failures or timeouts.",
                      "type": "boolean"
                    },
                    "start_time_in_millis": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "expiration_time_in_millis": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "completion_status": {
                      "description": "For a completed search shows the http status code of the completed search.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "id",
                    "is_partial",
                    "is_running"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/{index}/_eql/search": {
      "get": {
        "tags": [
          "eql"
        ],
        "summary": "Get EQL search results",
        "description": "Returns search results for an Event Query Language (EQL) query.\nEQL assumes each document in a data stream or index corresponds to an event.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/eql.html"
        },
        "operationId": "eql-search",
        "parameters": [
          {
            "$ref": "#/components/parameters/eql.search#index"
          },
          {
            "$ref": "#/components/parameters/eql.search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/eql.search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/eql.search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/eql.search#keep_alive"
          },
          {
            "$ref": "#/components/parameters/eql.search#keep_on_completion"
          },
          {
            "$ref": "#/components/parameters/eql.search#wait_for_completion_timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/eql.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/eql.search#200"
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "post": {
        "tags": [
          "eql"
        ],
        "summary": "Get EQL search results",
        "description": "Returns search results for an Event Query Language (EQL) query.\nEQL assumes each document in a data stream or index corresponds to an event.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/eql.html"
        },
        "operationId": "eql-search-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/eql.search#index"
          },
          {
            "$ref": "#/components/parameters/eql.search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/eql.search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/eql.search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/eql.search#keep_alive"
          },
          {
            "$ref": "#/components/parameters/eql.search#keep_on_completion"
          },
          {
            "$ref": "#/components/parameters/eql.search#wait_for_completion_timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/eql.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/eql.search#200"
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_query/async": {
      "post": {
        "tags": [
          "esql"
        ],
        "summary": "Run an async ES|QL query",
        "description": "Asynchronously run an ES|QL (Elasticsearch query language) query, monitor its progress, and retrieve results when they become available.\n\nThe API accepts the same parameters and request body as the synchronous query API, along with additional async related properties.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html"
        },
        "operationId": "esql-async-query",
        "parameters": [
          {
            "in": "query",
            "name": "delimiter",
            "description": "The character to use between values within a CSV row.\nIt is valid only for the CSV format.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "drop_null_columns",
            "description": "Indicates whether columns that are entirely `null` will be removed from the `columns` and `values` portion of the results.\nIf `true`, the response will include an extra section under the name `all_columns` which has the name of all the columns.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "format",
            "description": "A short version of the Accept header, for example `json` or `yaml`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/esql.query:EsqlFormat"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "The period for which the query and its results are stored in the cluster.\nThe default period is five days.\nWhen this period expires, the query and its results are deleted, even if the query is still ongoing.\nIf the `keep_on_completion` parameter is false, Elasticsearch only stores async queries that do not complete within the period set by the `wait_for_completion_timeout` parameter, regardless of this value.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "keep_on_completion",
            "description": "Indicates whether the query and its results are stored in the cluster.\nIf false, the query and its results are stored in the cluster only if the request does not complete during the period set by the `wait_for_completion_timeout` parameter.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion_timeout",
            "description": "The period to wait for the request to finish.\nBy default, the request waits for 1 second for the query results.\nIf the query completes during this period, results are returned\nOtherwise, a query ID is returned that can later be used to retrieve the results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "columnar": {
                    "description": "By default, ES|QL returns results as rows. For example, FROM returns each individual document as one row. For the JSON, YAML, CBOR and smile formats, ES|QL can return the results in a columnar fashion where one row represents all the values of a certain column in the results.",
                    "type": "boolean"
                  },
                  "filter": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "locale": {
                    "type": "string"
                  },
                  "params": {
                    "description": "To avoid any attempts of hacking or code injection, extract the values in a separate list of parameters. Use question mark placeholders (?) in the query string for each of the parameters.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:FieldValue"
                    }
                  },
                  "profile": {
                    "description": "If provided and `true` the response will include an extra `profile` object\nwith information on how the query was executed. This information is for human debugging\nand its format can change at any time but it can give some insight into the performance\nof each part of the query.",
                    "type": "boolean"
                  },
                  "query": {
                    "description": "The ES|QL query API accepts an ES|QL query string in the query parameter, runs it, and returns the results.",
                    "type": "string"
                  },
                  "tables": {
                    "description": "Tables to use with the LOOKUP operation. The top level key is the table\nname and the next level key is the column name.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/esql._types:TableValuesContainer"
                      }
                    }
                  },
                  "include_ccs_metadata": {
                    "description": "When set to `true` and performing a cross-cluster query, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.",
                    "type": "boolean"
                  }
                },
                "required": [
                  "query"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:EsqlResult"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.13.0"
      }
    },
    "/_query/async/{id}": {
      "get": {
        "tags": [
          "esql"
        ],
        "summary": "Get async ES|QL query results",
        "description": "Get the current status and available results or stored results for an ES|QL asynchronous query.\nIf the Elasticsearch security features are enabled, only the user who first submitted the ES|QL query can retrieve the results using this API.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html"
        },
        "operationId": "esql-async-query-get",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The unique identifier of the query.\nA query ID is provided in the ES|QL async query API response for a query that does not complete in the designated time.\nA query ID is also provided when the request was submitted with the `keep_on_completion` parameter set to `true`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "drop_null_columns",
            "description": "Indicates whether columns that are entirely `null` will be removed from the `columns` and `values` portion of the results.\nIf `true`, the response will include an extra section under the name `all_columns` which has the name of all the columns.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "The period for which the query and its results are stored in the cluster.\nWhen this period expires, the query and its results are deleted, even if the query is still ongoing.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion_timeout",
            "description": "The period to wait for the request to finish.\nBy default, the request waits for complete query results.\nIf the request completes during the period specified in this parameter, complete query results are returned.\nOtherwise, the response returns an `is_running` value of `true` and no results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:EsqlResult"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.13.0"
      },
      "delete": {
        "tags": [
          "esql"
        ],
        "summary": "Delete an async ES|QL query",
        "description": "If the query is still running, it is cancelled.\nOtherwise, the stored results are deleted.\n\nIf the Elasticsearch security features are enabled, only the following users can use this API to delete a query:\n\n* The authenticated user that submitted the original query request\n* Users with the `cancel_task` cluster privilege",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html"
        },
        "operationId": "esql-async-query-delete",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The unique identifier of the query.\nA query ID is provided in the ES|QL async query API response for a query that does not complete in the designated time.\nA query ID is also provided when the request was submitted with the `keep_on_completion` parameter set to `true`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.13.0"
      }
    },
    "/_query": {
      "post": {
        "tags": [
          "esql"
        ],
        "summary": "Run an ES|QL query",
        "description": "Get search results for an ES|QL (Elasticsearch query language) query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/esql.html"
        },
        "operationId": "esql-query",
        "parameters": [
          {
            "in": "query",
            "name": "format",
            "description": "A short version of the Accept header, e.g. json, yaml.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/esql.query:EsqlFormat"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delimiter",
            "description": "The character to use between values within a CSV row. Only valid for the CSV format.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "drop_null_columns",
            "description": "Should columns that are entirely `null` be removed from the `columns` and `values` portion of the results?\nDefaults to `false`. If `true` then the response will include an extra section under the name `all_columns` which has the name of all columns.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "columnar": {
                    "description": "By default, ES|QL returns results as rows. For example, FROM returns each individual document as one row. For the JSON, YAML, CBOR and smile formats, ES|QL can return the results in a columnar fashion where one row represents all the values of a certain column in the results.",
                    "type": "boolean"
                  },
                  "filter": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "locale": {
                    "type": "string"
                  },
                  "params": {
                    "description": "To avoid any attempts of hacking or code injection, extract the values in a separate list of parameters. Use question mark placeholders (?) in the query string for each of the parameters.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:FieldValue"
                    }
                  },
                  "profile": {
                    "description": "If provided and `true` the response will include an extra `profile` object\nwith information on how the query was executed. This information is for human debugging\nand its format can change at any time but it can give some insight into the performance\nof each part of the query.",
                    "type": "boolean"
                  },
                  "query": {
                    "description": "The ES|QL query API accepts an ES|QL query string in the query parameter, runs it, and returns the results.",
                    "type": "string"
                  },
                  "tables": {
                    "description": "Tables to use with the LOOKUP operation. The top level key is the table\nname and the next level key is the column name.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/esql._types:TableValuesContainer"
                      }
                    }
                  },
                  "include_ccs_metadata": {
                    "description": "When set to `true` and performing a cross-cluster query, the response will include an extra `_clusters`\nobject with information about the clusters that participated in the search along with info such as shards\ncount.",
                    "type": "boolean"
                  }
                },
                "required": [
                  "query"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:EsqlResult"
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_source/{id}": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get a document's source",
        "description": "Get the source of a document.\nFor example:\n\n```\nGET my-index-000001/_source/1\n```\n\nYou can use the source filtering parameters to control which parts of the `_source` are returned:\n\n```\nGET my-index-000001/_source/1/?_source_includes=*.id&_source_excludes=entities\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html"
        },
        "operationId": "get-source",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index that contains the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "A unique document identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If `true`, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "Indicates whether to return the `_source` field (`true` or `false`) or lists the fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stored_fields",
            "description": "A comma-separated list of stored fields to return as part of a hit.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "The version number for concurrency control.\nIt must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "The version type.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "document"
        ],
        "summary": "Check for a document source",
        "description": "Check whether a document source exists in an index.\nFor example:\n\n```\nHEAD my-index-000001/_source/1\n```\n\nA document's source is not available if it is disabled in the mapping.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-source-field.html"
        },
        "operationId": "exists-source",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of data streams, indices, and aliases.\nIt supports wildcards (`*`).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nBy default, the operation is randomized between the shard replicas.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If `true`, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, the request refreshes the relevant shards before retrieving the document.\nSetting it to `true` should be done after careful thought and verification that this does not cause a heavy load on the system (and slow down indexing).",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "Indicates whether to return the `_source` field (`true` or `false`) or lists the fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "The version number for concurrency control.\nIt must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "The version type.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/{index}/_explain/{id}": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Explain a document match result",
        "description": "Get information about why a specific document matches, or doesn't match, a query.\nIt computes a score explanation for a query and a specific document.",
        "operationId": "explain",
        "parameters": [
          {
            "$ref": "#/components/parameters/explain#index"
          },
          {
            "$ref": "#/components/parameters/explain#id"
          },
          {
            "$ref": "#/components/parameters/explain#analyzer"
          },
          {
            "$ref": "#/components/parameters/explain#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/explain#default_operator"
          },
          {
            "$ref": "#/components/parameters/explain#df"
          },
          {
            "$ref": "#/components/parameters/explain#lenient"
          },
          {
            "$ref": "#/components/parameters/explain#preference"
          },
          {
            "$ref": "#/components/parameters/explain#routing"
          },
          {
            "$ref": "#/components/parameters/explain#_source"
          },
          {
            "$ref": "#/components/parameters/explain#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/explain#_source_includes"
          },
          {
            "$ref": "#/components/parameters/explain#stored_fields"
          },
          {
            "$ref": "#/components/parameters/explain#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/explain"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/explain#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Explain a document match result",
        "description": "Get information about why a specific document matches, or doesn't match, a query.\nIt computes a score explanation for a query and a specific document.",
        "operationId": "explain-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/explain#index"
          },
          {
            "$ref": "#/components/parameters/explain#id"
          },
          {
            "$ref": "#/components/parameters/explain#analyzer"
          },
          {
            "$ref": "#/components/parameters/explain#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/explain#default_operator"
          },
          {
            "$ref": "#/components/parameters/explain#df"
          },
          {
            "$ref": "#/components/parameters/explain#lenient"
          },
          {
            "$ref": "#/components/parameters/explain#preference"
          },
          {
            "$ref": "#/components/parameters/explain#routing"
          },
          {
            "$ref": "#/components/parameters/explain#_source"
          },
          {
            "$ref": "#/components/parameters/explain#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/explain#_source_includes"
          },
          {
            "$ref": "#/components/parameters/explain#stored_fields"
          },
          {
            "$ref": "#/components/parameters/explain#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/explain"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/explain#200"
          }
        }
      }
    },
    "/_features": {
      "get": {
        "tags": [
          "features"
        ],
        "summary": "Get the features",
        "description": "Get a list of features that can be included in snapshots using the `feature_states` field when creating a snapshot.\nYou can use this API to determine which feature states to include when taking a snapshot.\nBy default, all feature states are included in a snapshot if that snapshot includes the global state, or none if it does not.\n\nA feature state includes one or more system indices necessary for a given feature to function.\nIn order to ensure data integrity, all system indices that comprise a feature state are snapshotted and restored together.\n\nThe features listed by this API are a combination of built-in features and features defined by plugins.\nIn order for a feature state to be listed in this API and recognized as a valid feature state by the create snapshot API, the plugin that defines that feature must be installed on the master node.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-take-snapshot.html"
        },
        "operationId": "features-get-features",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "features": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/features._types:Feature"
                      }
                    }
                  },
                  "required": [
                    "features"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.12.0"
      }
    },
    "/_features/_reset": {
      "post": {
        "tags": [
          "features"
        ],
        "summary": "Reset the features",
        "description": "Clear all of the state information stored in system indices by Elasticsearch features, including the security and machine learning indices.\n\nWARNING: Intended for development and testing use only. Do not reset features on a production cluster.\n\nReturn a cluster to the same state as a new installation by resetting the feature state for all Elasticsearch features.\nThis deletes all state information stored in system indices.\n\nThe response code is HTTP 200 if the state is successfully reset for all features.\nIt is HTTP 500 if the reset operation failed for any feature.\n\nNote that select features might provide a way to reset particular system indices.\nUsing this API resets all features, both those that are built-in and implemented as plugins.\n\nTo list the features that will be affected, use the get features API.\n\nIMPORTANT: The features installed on the node you submit this request to are the features that will be reset. Run on the master node if you have any doubts about which plugins are installed on individual nodes.",
        "operationId": "features-reset-features",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "features": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/features._types:Feature"
                      }
                    }
                  },
                  "required": [
                    "features"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_field_caps": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get the field capabilities",
        "description": "Get information about the capabilities of fields among multiple indices.\n\nFor data streams, the API returns field capabilities among the streamâ€™s backing indices.\nIt returns runtime fields like any other field.\nFor example, a runtime field with a type of keyword is returned the same as any other field that belongs to the `keyword` family.",
        "operationId": "field-caps",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_empty_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Get the field capabilities",
        "description": "Get information about the capabilities of fields among multiple indices.\n\nFor data streams, the API returns field capabilities among the streamâ€™s backing indices.\nIt returns runtime fields like any other field.\nFor example, a runtime field with a type of keyword is returned the same as any other field that belongs to the `keyword` family.",
        "operationId": "field-caps-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_empty_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/{index}/_field_caps": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get the field capabilities",
        "description": "Get information about the capabilities of fields among multiple indices.\n\nFor data streams, the API returns field capabilities among the streamâ€™s backing indices.\nIt returns runtime fields like any other field.\nFor example, a runtime field with a type of keyword is returned the same as any other field that belongs to the `keyword` family.",
        "operationId": "field-caps-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#index"
          },
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_empty_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Get the field capabilities",
        "description": "Get information about the capabilities of fields among multiple indices.\n\nFor data streams, the API returns field capabilities among the streamâ€™s backing indices.\nIt returns runtime fields like any other field.\nFor example, a runtime field with a type of keyword is returned the same as any other field that belongs to the `keyword` family.",
        "operationId": "field-caps-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#index"
          },
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_empty_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/{index}/_fleet/global_checkpoints": {
      "get": {
        "tags": [
          "fleet"
        ],
        "summary": "Returns the current global checkpoints for an index",
        "description": "This API is design for internal use by the fleet server project.",
        "operationId": "fleet-global-checkpoints",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A single index or index alias that resolves to a single index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                {
                  "$ref": "#/components/schemas/_types:IndexAlias"
                }
              ]
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_advance",
            "description": "A boolean value which controls whether to wait (until the timeout) for the global checkpoints\nto advance past the provided `checkpoints`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_index",
            "description": "A boolean value which controls whether to wait (until the timeout) for the target index to exist\nand all primary shards be active. Can only be true when `wait_for_advance` is true.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "checkpoints",
            "description": "A comma separated list of previous global checkpoints. When used in combination with `wait_for_advance`,\nthe API will only return once the global checkpoints advances past the checkpoints. Providing an empty list\nwill cause Elasticsearch to immediately return the current global checkpoints.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/fleet._types:Checkpoint"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a global checkpoints to advance past `checkpoints`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "global_checkpoints": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/fleet._types:Checkpoint"
                      }
                    },
                    "timed_out": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "global_checkpoints",
                    "timed_out"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_fleet/_fleet_msearch": {
      "get": {
        "tags": [
          "fleet"
        ],
        "summary": "Executes several [fleet searches](https://www.elastic.co/guide/en/elasticsearch/reference/current/fleet-search.html) with a single API request",
        "description": "The API follows the same structure as the [multi search](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html) API. However, similar to the fleet search API, it\nsupports the wait_for_checkpoints parameter.",
        "operationId": "fleet-msearch",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        },
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "fleet"
        ],
        "summary": "Executes several [fleet searches](https://www.elastic.co/guide/en/elasticsearch/reference/current/fleet-search.html) with a single API request",
        "description": "The API follows the same structure as the [multi search](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html) API. However, similar to the fleet search API, it\nsupports the wait_for_checkpoints parameter.",
        "operationId": "fleet-msearch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/{index}/_fleet/_fleet_msearch": {
      "get": {
        "tags": [
          "fleet"
        ],
        "summary": "Executes several [fleet searches](https://www.elastic.co/guide/en/elasticsearch/reference/current/fleet-search.html) with a single API request",
        "description": "The API follows the same structure as the [multi search](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html) API. However, similar to the fleet search API, it\nsupports the wait_for_checkpoints parameter.",
        "operationId": "fleet-msearch-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#index"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        },
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "fleet"
        ],
        "summary": "Executes several [fleet searches](https://www.elastic.co/guide/en/elasticsearch/reference/current/fleet-search.html) with a single API request",
        "description": "The API follows the same structure as the [multi search](https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html) API. However, similar to the fleet search API, it\nsupports the wait_for_checkpoints parameter.",
        "operationId": "fleet-msearch-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#index"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/{index}/_fleet/_fleet_search": {
      "get": {
        "tags": [
          "fleet"
        ],
        "summary": "The purpose of the fleet search api is to provide a search api where the search will only be executed\n",
        "description": "after provided checkpoint has been processed and is visible for searches inside of Elasticsearch.",
        "operationId": "fleet-search",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.search#index"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyzer"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/fleet.search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.search#default_operator"
          },
          {
            "$ref": "#/components/parameters/fleet.search#df"
          },
          {
            "$ref": "#/components/parameters/fleet.search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.search#explain"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.search#lenient"
          },
          {
            "$ref": "#/components/parameters/fleet.search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/fleet.search#preference"
          },
          {
            "$ref": "#/components/parameters/fleet.search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#request_cache"
          },
          {
            "$ref": "#/components/parameters/fleet.search#routing"
          },
          {
            "$ref": "#/components/parameters/fleet.search#scroll"
          },
          {
            "$ref": "#/components/parameters/fleet.search#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stats"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/fleet.search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/fleet.search#timeout"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_scores"
          },
          {
            "$ref": "#/components/parameters/fleet.search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.search#version"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/fleet.search#q"
          },
          {
            "$ref": "#/components/parameters/fleet.search#size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#from"
          },
          {
            "$ref": "#/components/parameters/fleet.search#sort"
          },
          {
            "$ref": "#/components/parameters/fleet.search#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.search#200"
          }
        },
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "fleet"
        ],
        "summary": "The purpose of the fleet search api is to provide a search api where the search will only be executed\n",
        "description": "after provided checkpoint has been processed and is visible for searches inside of Elasticsearch.",
        "operationId": "fleet-search-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.search#index"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyzer"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/fleet.search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.search#default_operator"
          },
          {
            "$ref": "#/components/parameters/fleet.search#df"
          },
          {
            "$ref": "#/components/parameters/fleet.search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.search#explain"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.search#lenient"
          },
          {
            "$ref": "#/components/parameters/fleet.search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/fleet.search#preference"
          },
          {
            "$ref": "#/components/parameters/fleet.search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#request_cache"
          },
          {
            "$ref": "#/components/parameters/fleet.search#routing"
          },
          {
            "$ref": "#/components/parameters/fleet.search#scroll"
          },
          {
            "$ref": "#/components/parameters/fleet.search#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stats"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/fleet.search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/fleet.search#timeout"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_scores"
          },
          {
            "$ref": "#/components/parameters/fleet.search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.search#version"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/fleet.search#q"
          },
          {
            "$ref": "#/components/parameters/fleet.search#size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#from"
          },
          {
            "$ref": "#/components/parameters/fleet.search#sort"
          },
          {
            "$ref": "#/components/parameters/fleet.search#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.search#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_script_context": {
      "get": {
        "tags": [
          "script"
        ],
        "summary": "Get script contexts",
        "description": "Get a list of supported script contexts and their methods.",
        "operationId": "get-script-context",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contexts": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.get_script_context:Context"
                      }
                    }
                  },
                  "required": [
                    "contexts"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_script_language": {
      "get": {
        "tags": [
          "script"
        ],
        "summary": "Get script languages",
        "description": "Get a list of available script types, languages, and contexts.",
        "operationId": "get-script-languages",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "language_contexts": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.get_script_languages:LanguageContext"
                      }
                    },
                    "types_allowed": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "language_contexts",
                    "types_allowed"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_graph/explore": {
      "get": {
        "tags": [
          "graph"
        ],
        "summary": "Explore graph analytics",
        "description": "Extract and summarize information about the documents and terms in an Elasticsearch data stream or index.\nThe easiest way to understand the behavior of this API is to use the Graph UI to explore connections.\nAn initial request to the `_explore` API contains a seed query that identifies the documents of interest and specifies the fields that define the vertices and connections you want to include in the graph.\nSubsequent requests enable you to spider out from one more vertices of interest.\nYou can exclude vertices that have already been returned.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/kibana/current/xpack-graph.html"
        },
        "operationId": "graph-explore",
        "parameters": [
          {
            "$ref": "#/components/parameters/graph.explore#index"
          },
          {
            "$ref": "#/components/parameters/graph.explore#routing"
          },
          {
            "$ref": "#/components/parameters/graph.explore#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/graph.explore"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/graph.explore#200"
          }
        }
      },
      "post": {
        "tags": [
          "graph"
        ],
        "summary": "Explore graph analytics",
        "description": "Extract and summarize information about the documents and terms in an Elasticsearch data stream or index.\nThe easiest way to understand the behavior of this API is to use the Graph UI to explore connections.\nAn initial request to the `_explore` API contains a seed query that identifies the documents of interest and specifies the fields that define the vertices and connections you want to include in the graph.\nSubsequent requests enable you to spider out from one more vertices of interest.\nYou can exclude vertices that have already been returned.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/kibana/current/xpack-graph.html"
        },
        "operationId": "graph-explore-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/graph.explore#index"
          },
          {
            "$ref": "#/components/parameters/graph.explore#routing"
          },
          {
            "$ref": "#/components/parameters/graph.explore#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/graph.explore"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/graph.explore#200"
          }
        }
      }
    },
    "/_health_report": {
      "get": {
        "tags": [
          "health_report"
        ],
        "summary": "Get the cluster health",
        "description": "Get a report with the health status of an Elasticsearch cluster.\nThe report contains a list of indicators that compose Elasticsearch functionality.\n\nEach indicator has a health status of: green, unknown, yellow or red.\nThe indicator will provide an explanation and metadata describing the reason for its current health status.\n\nThe clusterâ€™s status is controlled by the worst indicator status.\n\nIn the event that an indicatorâ€™s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.\nEach impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.\n\nSome health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.\nThe root cause and remediation steps are encapsulated in a diagnosis.\nA diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.\n\nNOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.\nWhen setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.",
        "operationId": "health-report",
        "parameters": [
          {
            "$ref": "#/components/parameters/health_report#timeout"
          },
          {
            "$ref": "#/components/parameters/health_report#verbose"
          },
          {
            "$ref": "#/components/parameters/health_report#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/health_report#200"
          }
        },
        "x-state": "Added in 8.7.0"
      }
    },
    "/_health_report/{feature}": {
      "get": {
        "tags": [
          "health_report"
        ],
        "summary": "Get the cluster health",
        "description": "Get a report with the health status of an Elasticsearch cluster.\nThe report contains a list of indicators that compose Elasticsearch functionality.\n\nEach indicator has a health status of: green, unknown, yellow or red.\nThe indicator will provide an explanation and metadata describing the reason for its current health status.\n\nThe clusterâ€™s status is controlled by the worst indicator status.\n\nIn the event that an indicatorâ€™s status is non-green, a list of impacts may be present in the indicator result which detail the functionalities that are negatively affected by the health issue.\nEach impact carries with it a severity level, an area of the system that is affected, and a simple description of the impact on the system.\n\nSome health indicators can determine the root cause of a health problem and prescribe a set of steps that can be performed in order to improve the health of the system.\nThe root cause and remediation steps are encapsulated in a diagnosis.\nA diagnosis contains a cause detailing a root cause analysis, an action containing a brief description of the steps to take to fix the problem, the list of affected resources (if applicable), and a detailed step-by-step troubleshooting guide to fix the diagnosed problem.\n\nNOTE: The health indicators perform root cause analysis of non-green health statuses. This can be computationally expensive when called frequently.\nWhen setting up automated polling of the API for health status, set verbose to false to disable the more expensive analysis logic.",
        "operationId": "health-report-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/health_report#feature"
          },
          {
            "$ref": "#/components/parameters/health_report#timeout"
          },
          {
            "$ref": "#/components/parameters/health_report#verbose"
          },
          {
            "$ref": "#/components/parameters/health_report#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/health_report#200"
          }
        },
        "x-state": "Added in 8.7.0"
      }
    },
    "/_ilm/policy/{policy}": {
      "get": {
        "tags": [
          "ilm"
        ],
        "summary": "Get lifecycle policies",
        "operationId": "ilm-get-lifecycle",
        "parameters": [
          {
            "$ref": "#/components/parameters/ilm.get_lifecycle#policy"
          },
          {
            "$ref": "#/components/parameters/ilm.get_lifecycle#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ilm.get_lifecycle#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ilm.get_lifecycle#200"
          }
        },
        "x-state": "Added in 6.6.0"
      },
      "put": {
        "tags": [
          "ilm"
        ],
        "summary": "Create or update a lifecycle policy",
        "description": "If the specified policy exists, it is replaced and the policy version is incremented.\n\nNOTE: Only the latest version of the policy is stored, you cannot revert to previous versions.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ilm-index-lifecycle.html"
        },
        "operationId": "ilm-put-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "policy",
            "description": "Identifier for the policy.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "policy": {
                    "$ref": "#/components/schemas/ilm._types:Policy"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      },
      "delete": {
        "tags": [
          "ilm"
        ],
        "summary": "Delete a lifecycle policy",
        "description": "You cannot delete policies that are currently in use. If the policy is being used to manage any indices, the request fails and returns an error.",
        "operationId": "ilm-delete-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "policy",
            "description": "Identifier for the policy.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/{index}/_ilm/explain": {
      "get": {
        "tags": [
          "ilm"
        ],
        "summary": "Explain the lifecycle state",
        "description": "Get the current lifecycle status for one or more indices.\nFor data streams, the API retrieves the current lifecycle status for the stream's backing indices.\n\nThe response indicates when the index entered each lifecycle state, provides the definition of the running phase, and information about any failures.",
        "operationId": "ilm-explain-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases to target. Supports wildcards (`*`).\nTo target all data streams and indices, use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "only_errors",
            "description": "Filters the returned indices to only indices that are managed by ILM and are in an error state, either due to an encountering an error while executing the policy, or attempting to use a policy that does not exist.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "only_managed",
            "description": "Filters the returned indices to only indices that are managed by ILM.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "indices": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/ilm.explain_lifecycle:LifecycleExplain"
                      }
                    }
                  },
                  "required": [
                    "indices"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/_ilm/policy": {
      "get": {
        "tags": [
          "ilm"
        ],
        "summary": "Get lifecycle policies",
        "operationId": "ilm-get-lifecycle-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ilm.get_lifecycle#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ilm.get_lifecycle#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ilm.get_lifecycle#200"
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/_ilm/status": {
      "get": {
        "tags": [
          "ilm"
        ],
        "summary": "Get the ILM status",
        "description": "Get the current index lifecycle management status.",
        "operationId": "ilm-get-status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "operation_mode": {
                      "$ref": "#/components/schemas/_types:LifecycleOperationMode"
                    }
                  },
                  "required": [
                    "operation_mode"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/_ilm/migrate_to_data_tiers": {
      "post": {
        "tags": [
          "ilm"
        ],
        "summary": "Migrate to data tiers routing",
        "description": "Switch the indices, ILM policies, and legacy, composable, and component templates from using custom node attributes and attribute-based allocation filters to using data tiers.\nOptionally, delete one legacy index template.\nUsing node roles enables ILM to automatically move the indices between data tiers.\n\nMigrating away from custom node attributes routing can be manually performed.\nThis API provides an automated way of performing three out of the four manual steps listed in the migration guide:\n\n1. Stop setting the custom hot attribute on new indices.\n1. Remove custom allocation settings from existing ILM policies.\n1. Replace custom allocation settings from existing indices with the corresponding tier preference.\n\nILM must be stopped before performing the migration.\nUse the stop ILM and get ILM status APIs to wait until the reported operation mode is `STOPPED`.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/migrate-index-allocation-filters.html"
        },
        "operationId": "ilm-migrate-to-data-tiers",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "description": "If true, simulates the migration from node attributes based allocation filters to data tiers, but does not perform the migration.\nThis provides a way to retrieve the indices and ILM policies that need to be migrated.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "legacy_template_to_delete": {
                    "type": "string"
                  },
                  "node_attribute": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "dry_run": {
                      "type": "boolean"
                    },
                    "removed_legacy_template": {
                      "description": "The name of the legacy index template that was deleted.\nThis information is missing if no legacy index templates were deleted.",
                      "type": "string"
                    },
                    "migrated_ilm_policies": {
                      "description": "The ILM policies that were updated.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "migrated_indices": {
                      "$ref": "#/components/schemas/_types:Indices"
                    },
                    "migrated_legacy_templates": {
                      "description": "The legacy index templates that were updated to not contain custom routing settings for the provided data attribute.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "migrated_composable_templates": {
                      "description": "The composable index templates that were updated to not contain custom routing settings for the provided data attribute.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "migrated_component_templates": {
                      "description": "The component templates that were updated to not contain custom routing settings for the provided data attribute.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "dry_run",
                    "removed_legacy_template",
                    "migrated_ilm_policies",
                    "migrated_indices",
                    "migrated_legacy_templates",
                    "migrated_composable_templates",
                    "migrated_component_templates"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.14.0"
      }
    },
    "/_ilm/move/{index}": {
      "post": {
        "tags": [
          "ilm"
        ],
        "summary": "Move to a lifecycle step",
        "description": "Manually move an index into a specific step in the lifecycle policy and run that step.\n\nWARNING: This operation can result in the loss of data. Manually moving an index into a specific step runs that step even if it has already been performed. This is a potentially destructive action and this should be considered an expert level API.\n\nYou must specify both the current step and the step to be executed in the body of the request.\nThe request will fail if the current step does not match the step currently running for the index\nThis is to prevent the index from being moved from an unexpected step into the next step.\n\nWhen specifying the target (`next_step`) to which the index will be moved, either the name or both the action and name fields are optional.\nIf only the phase is specified, the index will move to the first step of the first action in the target phase.\nIf the phase and action are specified, the index will move to the first step of the specified action in the specified phase.\nOnly actions specified in the ILM policy are considered valid.\nAn index cannot move to a step that is not part of its policy.",
        "operationId": "ilm-move-to-step",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index whose lifecycle step is to change",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "current_step": {
                    "$ref": "#/components/schemas/ilm.move_to_step:StepKey"
                  },
                  "next_step": {
                    "$ref": "#/components/schemas/ilm.move_to_step:StepKey"
                  }
                },
                "required": [
                  "current_step",
                  "next_step"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/{index}/_ilm/remove": {
      "post": {
        "tags": [
          "ilm"
        ],
        "summary": "Remove policies from an index",
        "description": "Remove the assigned lifecycle policies from an index or a data stream's backing indices.\nIt also stops managing the indices.",
        "operationId": "ilm-remove-policy",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index to remove policy on",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "failed_indexes": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:IndexName"
                      }
                    },
                    "has_failures": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "failed_indexes",
                    "has_failures"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/{index}/_ilm/retry": {
      "post": {
        "tags": [
          "ilm"
        ],
        "summary": "Retry a policy",
        "description": "Retry running the lifecycle policy for an index that is in the ERROR step.\nThe API sets the policy back to the step where the error occurred and runs the step.\nUse the explain lifecycle state API to determine whether an index is in the ERROR step.",
        "operationId": "ilm-retry",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the indices (comma-separated) whose failed lifecycle step is to be retry",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/_ilm/start": {
      "post": {
        "tags": [
          "ilm"
        ],
        "summary": "Start the ILM plugin",
        "description": "Start the index lifecycle management plugin if it is currently stopped.\nILM is started automatically when the cluster is formed.\nRestarting ILM is necessary only when it has been stopped using the stop ILM API.",
        "operationId": "ilm-start",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/_ilm/stop": {
      "post": {
        "tags": [
          "ilm"
        ],
        "summary": "Stop the ILM plugin",
        "description": "Halt all lifecycle management operations and stop the index lifecycle management plugin.\nThis is useful when you are performing maintenance on the cluster and need to prevent ILM from performing any actions on your indices.\n\nThe API returns as soon as the stop request has been acknowledged, but the plugin might continue to run until in-progress operations complete and the plugin can be safely stopped.\nUse the get ILM status API to check whether ILM is running.",
        "operationId": "ilm-stop",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.6.0"
      }
    },
    "/{index}/_doc": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Create or update a document in an index",
        "description": "Add a JSON document to the specified data stream or index and make it searchable.\nIf the target is an index and the document already exists, the request updates the document and increments its version.\n\nNOTE: You cannot use this API to send update requests for existing documents in a data stream.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or index alias:\n\n* To add or overwrite a document using the `PUT /<target>/_doc/<_id>` request format, you must have the `create`, `index`, or `write` index privilege.\n* To add a document using the `POST /<target>/_doc/` request format, you must have the `create_doc`, `create`, `index`, or `write` index privilege.\n* To automatically create a data stream or index with this API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege.\n\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nNOTE: Replica shards might not all be started when an indexing operation returns successfully.\nBy default, only the primary is required. Set `wait_for_active_shards` to change this default behavior.\n\n**Automatically create data streams and indices**\n\nIf the request's target doesn't exist and matches an index template with a `data_stream` definition, the index operation automatically creates the data stream.\n\nIf the target doesn't exist and doesn't match a data stream template, the operation automatically creates the index and applies any matching index templates.\n\nNOTE: Elasticsearch includes several built-in index templates. To avoid naming collisions with these templates, refer to index pattern documentation.\n\nIf no mapping exists, the index operation creates a dynamic mapping.\nBy default, new fields and objects are automatically added to the mapping if needed.\n\nAutomatic index creation is controlled by the `action.auto_create_index` setting.\nIf it is `true`, any index can be created automatically.\nYou can modify this setting to explicitly allow or block automatic creation of indices that match specified patterns or set it to `false` to turn off automatic index creation entirely.\nSpecify a comma-separated list of patterns you want to allow or prefix each pattern with `+` or `-` to indicate whether it should be allowed or blocked.\nWhen a list is specified, the default behaviour is to disallow.\n\nNOTE: The `action.auto_create_index` setting affects the automatic creation of indices only.\nIt does not affect the creation of data streams.\n\n**Optimistic concurrency control**\n\nIndex operations can be made conditional and only be performed if the last modification to the document was assigned the sequence number and primary term specified by the `if_seq_no` and `if_primary_term` parameters.\nIf a mismatch is detected, the operation will result in a `VersionConflictException` and a status code of `409`.\n\n**Routing**\n\nBy default, shard placementâ€‰â€”â€‰or routingâ€‰â€”â€‰is controlled by using a hash of the document's ID value.\nFor more explicit control, the value fed into the hash function used by the router can be directly specified on a per-operation basis using the `routing` parameter.\n\nWhen setting up explicit mapping, you can also use the `_routing` field to direct the index operation to extract the routing value from the document itself.\nThis does come at the (very minimal) cost of an additional document parsing pass.\nIf the `_routing` mapping is defined and set to be required, the index operation will fail if no routing value is provided or extracted.\n\nNOTE: Data streams do not support custom routing unless they were created with the `allow_custom_routing` setting enabled in the template.\n\n * ** Distributed**\n\nThe index operation is directed to the primary shard based on its route and performed on the actual node containing this shard.\nAfter the primary shard completes the operation, if needed, the update is distributed to applicable replicas.\n\n**Active shards**\n\nTo improve the resiliency of writes to the system, indexing operations can be configured to wait for a certain number of active shard copies before proceeding with the operation.\nIf the requisite number of active shard copies are not available, then the write operation must wait and retry, until either the requisite shard copies have started or a timeout occurs.\nBy default, write operations only wait for the primary shards to be active before proceeding (that is to say `wait_for_active_shards` is `1`).\nThis default can be overridden in the index settings dynamically by setting `index.write.wait_for_active_shards`.\nTo alter this behavior per operation, use the `wait_for_active_shards request` parameter.\n\nValid values are all or any positive integer up to the total number of configured copies per shard in the index (which is `number_of_replicas`+1).\nSpecifying a negative value or a number greater than the number of shard copies will throw an error.\n\nFor example, suppose you have a cluster of three nodes, A, B, and C and you create an index index with the number of replicas set to 3 (resulting in 4 shard copies, one more copy than there are nodes).\nIf you attempt an indexing operation, by default the operation will only ensure the primary copy of each shard is available before proceeding.\nThis means that even if B and C went down and A hosted the primary shard copies, the indexing operation would still proceed with only one copy of the data.\nIf `wait_for_active_shards` is set on the request to `3` (and all three nodes are up), the indexing operation will require 3 active shard copies before proceeding.\nThis requirement should be met because there are 3 active nodes in the cluster, each one holding a copy of the shard.\nHowever, if you set `wait_for_active_shards` to `all` (or to `4`, which is the same in this situation), the indexing operation will not proceed as you do not have all 4 copies of each shard active in the index.\nThe operation will timeout unless a new node is brought up in the cluster to host the fourth copy of the shard.\n\nIt is important to note that this setting greatly reduces the chances of the write operation not writing to the requisite number of shard copies, but it does not completely eliminate the possibility, because this check occurs before the write operation starts.\nAfter the write operation is underway, it is still possible for replication to fail on any number of shard copies but still succeed on the primary.\nThe `_shards` section of the API response reveals the number of shard copies on which replication succeeded and failed.\n\n**No operation (noop) updates**\n\nWhen updating a document by using this API, a new version of the document is always created even if the document hasn't changed.\nIf this isn't acceptable use the `_update` API with `detect_noop` set to `true`.\nThe `detect_noop` option isn't available on this API because it doesnâ€™t fetch the old source and isn't able to compare it against the new source.\n\nThere isn't a definitive rule for when noop updates aren't acceptable.\nIt's a combination of lots of factors like how frequently your data source sends updates that are actually noops and how many queries per second Elasticsearch runs on the shard receiving the updates.\n\n**Versioning**\n\nEach indexed document is given a version number.\nBy default, internal versioning is used that starts at 1 and increments with each update, deletes included.\nOptionally, the version number can be set to an external value (for example, if maintained in a database).\nTo enable this functionality, `version_type` should be set to `external`.\nThe value provided must be a numeric, long value greater than or equal to 0, and less than around `9.2e+18`.\n\nNOTE: Versioning is completely real time, and is not affected by the near real time aspects of search operations.\nIf no version is provided, the operation runs without any version checks.\n\nWhen using the external version type, the system checks to see if the version number passed to the index request is greater than the version of the currently stored document.\nIf true, the document will be indexed and the new version number used.\nIf the value provided is less than or equal to the stored document's version number, a version conflict will occur and the index operation will fail. For example:\n\n```\nPUT my-index-000001/_doc/1?version=2&version_type=external\n{\n  \"user\": {\n    \"id\": \"elkbee\"\n  }\n}\n\nIn this example, the operation will succeed since the supplied version of 2 is higher than the current document version of 1.\nIf the document was already updated and its version was set to 2 or higher, the indexing command will fail and result in a conflict (409 HTTP status code).\n\nA nice side effect is that there is no need to maintain strict ordering of async indexing operations run as a result of changes to a source database, as long as version numbers from the source database are used.\nEven the simple case of updating the Elasticsearch index using data from a database is simplified if external versioning is used, as only the latest version will be used if the index operations arrive out of order.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams.html"
        },
        "operationId": "index-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/index#index"
          },
          {
            "$ref": "#/components/parameters/index#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/index#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/index#op_type"
          },
          {
            "$ref": "#/components/parameters/index#pipeline"
          },
          {
            "$ref": "#/components/parameters/index#refresh"
          },
          {
            "$ref": "#/components/parameters/index#routing"
          },
          {
            "$ref": "#/components/parameters/index#timeout"
          },
          {
            "$ref": "#/components/parameters/index#version"
          },
          {
            "$ref": "#/components/parameters/index#version_type"
          },
          {
            "$ref": "#/components/parameters/index#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/index#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/index"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/index#200"
          }
        }
      }
    },
    "/{index}/_block/{block}": {
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Add an index block",
        "description": "Limits the operations allowed on an index by blocking specific operation types.",
        "operationId": "indices-add-block",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma separated list of indices to add a block to",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "block",
            "description": "The block to add (one of read, write, read_only or metadata)",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/indices.add_block:IndicesBlockOptions"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.add_block:IndicesBlockStatus"
                      }
                    }
                  },
                  "required": [
                    "acknowledged",
                    "shards_acknowledged",
                    "indices"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_analyze": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get tokens from text analysis",
        "description": "The analyze API performs analysis on a text string and returns the resulting tokens.\n\nGenerating excessive amount of tokens may cause a node to run out of memory.\nThe `index.analyze.max_token_count` setting enables you to limit the number of tokens that can be produced.\nIf more than this limit of tokens gets generated, an error occurs.\nThe `_analyze` endpoint without a specified index will always use `10000` as its limit.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
        },
        "operationId": "indices-analyze",
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Get tokens from text analysis",
        "description": "The analyze API performs analysis on a text string and returns the resulting tokens.\n\nGenerating excessive amount of tokens may cause a node to run out of memory.\nThe `index.analyze.max_token_count` setting enables you to limit the number of tokens that can be produced.\nIf more than this limit of tokens gets generated, an error occurs.\nThe `_analyze` endpoint without a specified index will always use `10000` as its limit.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
        },
        "operationId": "indices-analyze-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      }
    },
    "/{index}/_analyze": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get tokens from text analysis",
        "description": "The analyze API performs analysis on a text string and returns the resulting tokens.\n\nGenerating excessive amount of tokens may cause a node to run out of memory.\nThe `index.analyze.max_token_count` setting enables you to limit the number of tokens that can be produced.\nIf more than this limit of tokens gets generated, an error occurs.\nThe `_analyze` endpoint without a specified index will always use `10000` as its limit.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
        },
        "operationId": "indices-analyze-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.analyze#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Get tokens from text analysis",
        "description": "The analyze API performs analysis on a text string and returns the resulting tokens.\n\nGenerating excessive amount of tokens may cause a node to run out of memory.\nThe `index.analyze.max_token_count` setting enables you to limit the number of tokens that can be produced.\nIf more than this limit of tokens gets generated, an error occurs.\nThe `_analyze` endpoint without a specified index will always use `10000` as its limit.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
        },
        "operationId": "indices-analyze-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.analyze#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      }
    },
    "/_cache/clear": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Clear the cache",
        "description": "Clear the cache of one or more indices.\nFor data streams, the API clears the caches of the stream's backing indices.\n\nBy default, the clear cache API clears all caches.\nTo clear only specific caches, use the `fielddata`, `query`, or `request` parameters.\nTo clear the cache only of specific fields, use the `fields` parameter.",
        "operationId": "indices-clear-cache",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.clear_cache#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#fielddata"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#fields"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#query"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#request"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.clear_cache#200"
          }
        }
      }
    },
    "/{index}/_cache/clear": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Clear the cache",
        "description": "Clear the cache of one or more indices.\nFor data streams, the API clears the caches of the stream's backing indices.\n\nBy default, the clear cache API clears all caches.\nTo clear only specific caches, use the `fielddata`, `query`, or `request` parameters.\nTo clear the cache only of specific fields, use the `fields` parameter.",
        "operationId": "indices-clear-cache-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.clear_cache#index"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#fielddata"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#fields"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#query"
          },
          {
            "$ref": "#/components/parameters/indices.clear_cache#request"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.clear_cache#200"
          }
        }
      }
    },
    "/{index}/_clone/{target}": {
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Clone an index",
        "description": "Clone an existing index into a new index.\nEach original primary shard is cloned into a new primary shard in the new index.\n\nIMPORTANT: Elasticsearch does not apply index templates to the resulting index.\nThe API also does not copy index metadata from the original index.\nIndex metadata includes aliases, index lifecycle management phase definitions, and cross-cluster replication (CCR) follower information.\nFor example, if you clone a CCR follower index, the resulting clone will not be a follower index.\n\nThe clone API copies most index settings from the source index to the resulting index, with the exception of `index.number_of_replicas` and `index.auto_expand_replicas`.\nTo set the number of replicas in the resulting index, configure these settings in the clone request.\n\nCloning works as follows:\n\n* First, it creates a new target index with the same definition as the source index.\n* Then it hard-links segments from the source index into the target index. If the file system does not support hard-linking, all segments are copied into the new index, which is a much more time consuming process.\n* Finally, it recovers the target index as though it were a closed index which had just been re-opened.\n\nIMPORTANT: Indices can only be cloned if they meet the following requirements:\n\n* The index must be marked as read-only and have a cluster health status of green.\n* The target index must not exist.\n* The source index must have the same number of primary shards as the target index.\n* The node handling the clone process must have sufficient free disk space to accommodate a second copy of the existing index.\n\nThe current write index on a data stream cannot be cloned.\nIn order to clone the current write index, the data stream must first be rolled over so that a new write index is created and then the previous write index can be cloned.\n\nNOTE: Mappings cannot be specified in the `_clone` request. The mappings of the source index will be used for the target index.\n\n**Monitor the cloning process**\n\nThe cloning process can be monitored with the cat recovery API or the cluster health API can be used to wait until all primary shards have been allocated by setting the `wait_for_status` parameter to `yellow`.\n\nThe `_clone` API returns as soon as the target index has been added to the cluster state, before any shards have been allocated.\nAt this point, all shards are in the state unassigned.\nIf, for any reason, the target index can't be allocated, its primary shard will remain unassigned until it can be allocated on that node.\n\nOnce the primary shard is allocated, it moves to state initializing, and the clone process begins.\nWhen the clone operation completes, the shard will become active.\nAt that point, Elasticsearch will try to allocate any replicas and may decide to relocate the primary shard to another node.\n\n**Wait for active shards**\n\nBecause the clone operation creates a new index to clone the shards to, the wait for active shards setting on index creation applies to the clone index action as well.",
        "operationId": "indices-clone",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.clone#index"
          },
          {
            "$ref": "#/components/parameters/indices.clone#target"
          },
          {
            "$ref": "#/components/parameters/indices.clone#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.clone#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.clone#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.clone"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.clone#200"
          }
        },
        "x-state": "Added in 7.4.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Clone an index",
        "description": "Clone an existing index into a new index.\nEach original primary shard is cloned into a new primary shard in the new index.\n\nIMPORTANT: Elasticsearch does not apply index templates to the resulting index.\nThe API also does not copy index metadata from the original index.\nIndex metadata includes aliases, index lifecycle management phase definitions, and cross-cluster replication (CCR) follower information.\nFor example, if you clone a CCR follower index, the resulting clone will not be a follower index.\n\nThe clone API copies most index settings from the source index to the resulting index, with the exception of `index.number_of_replicas` and `index.auto_expand_replicas`.\nTo set the number of replicas in the resulting index, configure these settings in the clone request.\n\nCloning works as follows:\n\n* First, it creates a new target index with the same definition as the source index.\n* Then it hard-links segments from the source index into the target index. If the file system does not support hard-linking, all segments are copied into the new index, which is a much more time consuming process.\n* Finally, it recovers the target index as though it were a closed index which had just been re-opened.\n\nIMPORTANT: Indices can only be cloned if they meet the following requirements:\n\n* The index must be marked as read-only and have a cluster health status of green.\n* The target index must not exist.\n* The source index must have the same number of primary shards as the target index.\n* The node handling the clone process must have sufficient free disk space to accommodate a second copy of the existing index.\n\nThe current write index on a data stream cannot be cloned.\nIn order to clone the current write index, the data stream must first be rolled over so that a new write index is created and then the previous write index can be cloned.\n\nNOTE: Mappings cannot be specified in the `_clone` request. The mappings of the source index will be used for the target index.\n\n**Monitor the cloning process**\n\nThe cloning process can be monitored with the cat recovery API or the cluster health API can be used to wait until all primary shards have been allocated by setting the `wait_for_status` parameter to `yellow`.\n\nThe `_clone` API returns as soon as the target index has been added to the cluster state, before any shards have been allocated.\nAt this point, all shards are in the state unassigned.\nIf, for any reason, the target index can't be allocated, its primary shard will remain unassigned until it can be allocated on that node.\n\nOnce the primary shard is allocated, it moves to state initializing, and the clone process begins.\nWhen the clone operation completes, the shard will become active.\nAt that point, Elasticsearch will try to allocate any replicas and may decide to relocate the primary shard to another node.\n\n**Wait for active shards**\n\nBecause the clone operation creates a new index to clone the shards to, the wait for active shards setting on index creation applies to the clone index action as well.",
        "operationId": "indices-clone-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.clone#index"
          },
          {
            "$ref": "#/components/parameters/indices.clone#target"
          },
          {
            "$ref": "#/components/parameters/indices.clone#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.clone#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.clone#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.clone"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.clone#200"
          }
        },
        "x-state": "Added in 7.4.0"
      }
    },
    "/{index}/_close": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Close an index",
        "description": "A closed index is blocked for read or write operations and does not allow all operations that opened indices allow.\nIt is not possible to index documents or to search for documents in a closed index.\nClosed indices do not have to maintain internal data structures for indexing or searching documents, which results in a smaller overhead on the cluster.\n\nWhen opening or closing an index, the master node is responsible for restarting the index shards to reflect the new state of the index.\nThe shards will then go through the normal recovery process.\nThe data of opened and closed indices is automatically replicated by the cluster to ensure that enough shard copies are safely kept around at all times.\n\nYou can open and close multiple indices.\nAn error is thrown if the request explicitly refers to a missing index.\nThis behaviour can be turned off using the `ignore_unavailable=true` parameter.\n\nBy default, you must explicitly name the indices you are opening or closing.\nTo open or close indices with `_all`, `*`, or other wildcard expressions, change the` action.destructive_requires_name` setting to `false`. This setting can also be changed with the cluster update settings API.\n\nClosed indices consume a significant amount of disk-space which can cause problems in managed environments.\nClosing indices can be turned off with the cluster settings API by setting `cluster.indices.close.enable` to `false`.",
        "operationId": "indices-close",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list or wildcard expression of index names used to limit the request.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "indices": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/indices.close:CloseIndexResult"
                      }
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "indices",
                    "shards_acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{index}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index information",
        "description": "Get information about one or more indices. For data streams, the API returns information about the\nstreamâ€™s backing indices.",
        "operationId": "indices-get",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and index aliases used to limit the request.\nWildcard expressions (*) are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard expressions can match. If the request can target data streams, this argument\ndetermines whether wildcard expressions match hidden data streams. Supports comma-separated values,\nsuch as open,hidden.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "flat_settings",
            "description": "If true, returns settings in flat format.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If false, requests that target a missing index return an error.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If true, return all default settings in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "features",
            "description": "Return only information on specified index features",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/indices.get:Features"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:IndexState"
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Create an index",
        "description": "You can use the create index API to add a new index to an Elasticsearch cluster.\nWhen creating an index, you can specify the following:\n\n* Settings for the index.\n* Mappings for fields in the index.\n* Index aliases\n\n**Wait for active shards**\n\nBy default, index creation will only return a response to the client when the primary copies of each shard have been started, or the request times out.\nThe index creation response will indicate what happened.\nFor example, `acknowledged` indicates whether the index was successfully created in the cluster, `while shards_acknowledged` indicates whether the requisite number of shard copies were started for each shard in the index before timing out.\nNote that it is still possible for either `acknowledged` or `shards_acknowledged` to be `false`, but for the index creation to be successful.\nThese values simply indicate whether the operation completed before the timeout.\nIf `acknowledged` is false, the request timed out before the cluster state was updated with the newly created index, but it probably will be created sometime soon.\nIf `shards_acknowledged` is false, then the request timed out before the requisite number of shards were started (by default just the primaries), even if the cluster state was successfully updated to reflect the newly created index (that is to say, `acknowledged` is `true`).\n\nYou can change the default of only waiting for the primary shards to start through the index setting `index.write.wait_for_active_shards`.\nNote that changing this setting will also affect the `wait_for_active_shards` value on all subsequent write operations.",
        "operationId": "indices-create",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the index you wish to create.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aliases": {
                    "description": "Aliases for the index.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/indices._types:Alias"
                    }
                  },
                  "mappings": {
                    "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                  },
                  "settings": {
                    "$ref": "#/components/schemas/indices._types:IndexSettings"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "index": {
                      "$ref": "#/components/schemas/_types:IndexName"
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    },
                    "acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "index",
                    "shards_acknowledged",
                    "acknowledged"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete indices",
        "description": "Deleting an index deletes its documents, shards, and metadata.\nIt does not delete related Kibana components, such as data views, visualizations, or dashboards.\n\nYou cannot delete the current write index of a data stream.\nTo delete the index, you must roll over the data stream so a new write index is created.\nYou can then use the delete index API to delete the previous write index.",
        "operationId": "indices-delete",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of indices to delete.\nYou cannot specify index aliases.\nBy default, this parameter does not support wildcards (`*`) or `_all`.\nTo use wildcards or `_all`, set the `action.destructive_requires_name` cluster setting to `false`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:IndicesResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "indices"
        ],
        "summary": "Check indices",
        "description": "Check if one or more indices, index aliases, or data streams exist.",
        "operationId": "indices-exists",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases. Supports wildcards (`*`).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "flat_settings",
            "description": "If `true`, returns settings in flat format.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If `true`, return all default settings in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request retrieves information from the local node only.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_data_stream/{name}": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get data streams",
        "description": "Retrieves information about one or more data streams.",
        "operationId": "indices-get-data-stream-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_data_stream#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_data_stream#200"
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "put": {
        "tags": [
          "data stream"
        ],
        "summary": "Create a data stream",
        "description": "Creates a data stream.\nYou must have a matching index template with data stream enabled.",
        "operationId": "indices-create-data-stream",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the data stream, which must meet the following criteria:\nLowercase only;\nCannot include `\\`, `/`, `*`, `?`, `\"`, `<`, `>`, `|`, `,`, `#`, `:`, or a space character;\nCannot start with `-`, `_`, `+`, or `.ds-`;\nCannot be `.` or `..`;\nCannot be longer than 255 bytes. Multi-byte characters count towards this limit faster.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "delete": {
        "tags": [
          "data stream"
        ],
        "summary": "Delete data streams",
        "description": "Deletes one or more data streams and their backing indices.",
        "operationId": "indices-delete-data-stream",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of data streams to delete. Wildcard (`*`) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of data stream that wildcard patterns can match. Supports comma-separated values,such as `open,hidden`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_data_stream/_stats": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get data stream stats",
        "description": "Retrieves statistics for one or more data streams.",
        "operationId": "indices-data-streams-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.data_streams_stats#expand_wildcards"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.data_streams_stats#200"
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_data_stream/{name}/_stats": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get data stream stats",
        "description": "Retrieves statistics for one or more data streams.",
        "operationId": "indices-data-streams-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.data_streams_stats#name"
          },
          {
            "$ref": "#/components/parameters/indices.data_streams_stats#expand_wildcards"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.data_streams_stats#200"
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/{index}/_alias/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get aliases",
        "description": "Retrieves information for one or more data stream or index aliases.",
        "operationId": "indices-get-alias-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an alias",
        "description": "Adds a data stream or index to an alias.",
        "operationId": "indices-put-alias",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an alias",
        "description": "Adds a data stream or index to an alias.",
        "operationId": "indices-put-alias-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete an alias",
        "description": "Removes a data stream or index from an alias.",
        "operationId": "indices-delete-alias",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.delete_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.delete_alias#200"
          }
        }
      },
      "head": {
        "tags": [
          "indices"
        ],
        "summary": "Check aliases",
        "description": "Checks if one or more data stream or index aliases exist.",
        "operationId": "indices-exists-alias-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.exists_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.exists_alias#200"
          }
        }
      }
    },
    "/{index}/_aliases/{name}": {
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an alias",
        "description": "Adds a data stream or index to an alias.",
        "operationId": "indices-put-alias-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an alias",
        "description": "Adds a data stream or index to an alias.",
        "operationId": "indices-put-alias-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete an alias",
        "description": "Removes a data stream or index from an alias.",
        "operationId": "indices-delete-alias-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.delete_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.delete_alias#200"
          }
        }
      }
    },
    "/_data_stream/{name}/_lifecycle": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get data stream lifecycles",
        "description": "Retrieves the data stream lifecycle configuration of one or more data streams.",
        "operationId": "indices-get-data-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of data streams to limit the request.\nSupports wildcards (`*`).\nTo target all data streams, omit this parameter or use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If `true`, return all default settings in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data_streams": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.get_data_lifecycle:DataStreamWithLifecycle"
                      }
                    }
                  },
                  "required": [
                    "data_streams"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "put": {
        "tags": [
          "data stream"
        ],
        "summary": "Update data stream lifecycles",
        "description": "Update the data stream lifecycle of the specified data streams.",
        "operationId": "indices-put-data-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of data streams used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `hidden`, `open`, `closed`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "data_retention": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "downsampling": {
                    "$ref": "#/components/schemas/indices._types:DataStreamLifecycleDownsampling"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete data stream lifecycles",
        "description": "Removes the data stream lifecycle from a data stream, rendering it not managed by the data stream lifecycle.",
        "operationId": "indices-delete-data-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "A comma-separated list of data streams of which the data stream lifecycle will be deleted; use `*` to get all data streams",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Whether wildcard expressions should get expanded to open or closed indices (default: open)",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit timestamp for the document",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.11.0"
      }
    },
    "/_index_template/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index templates",
        "description": "Get information about one or more index templates.",
        "operationId": "indices-get-index-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_index_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#include_defaults"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_index_template#200"
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an index template",
        "description": "Index templates define settings, mappings, and aliases that can be applied automatically to new indices.\n\nElasticsearch applies templates to new indices based on an wildcard pattern that matches the index name.\nIndex templates are applied during data stream or index creation.\nFor data streams, these settings and mappings are applied when the stream's backing indices are created.\nSettings and mappings specified in a create index API request override any settings or mappings specified in an index template.\nChanges to index templates do not affect existing indices, including the existing backing indices of a data stream.\n\nYou can use C-style `/* *\\/` block comments in index templates.\nYou can include comments anywhere in the request body, except before the opening curly bracket.\n\n**Multiple matching templates**\n\nIf multiple index templates match the name of a new index or data stream, the template with the highest priority is used.\n\nMultiple templates with overlapping index patterns at the same priority are not allowed and an error will be thrown when attempting to create a template matching an existing index template at identical priorities.\n\n**Composing aliases, mappings, and settings**\n\nWhen multiple component templates are specified in the `composed_of` field for an index template, they are merged in the order specified, meaning that later component templates override earlier component templates.\nAny mappings, settings, or aliases from the parent index template are merged in next.\nFinally, any configuration on the index request itself is merged.\nMapping definitions are merged recursively, which means that later mapping components can introduce new field mappings and update the mapping configuration.\nIf a field mapping is already contained in an earlier component, its definition will be completely overwritten by the later one.\nThis recursive merging strategy applies not only to field mappings, but also root options like `dynamic_templates` and `meta`.\nIf an earlier component contains a `dynamic_templates` block, then by default new `dynamic_templates` entries are appended onto the end.\nIf an entry already exists with the same key, then it is overwritten by the new definition.",
        "operationId": "indices-put-index-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_index_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#cause"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_index_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_index_template#200"
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an index template",
        "description": "Index templates define settings, mappings, and aliases that can be applied automatically to new indices.\n\nElasticsearch applies templates to new indices based on an wildcard pattern that matches the index name.\nIndex templates are applied during data stream or index creation.\nFor data streams, these settings and mappings are applied when the stream's backing indices are created.\nSettings and mappings specified in a create index API request override any settings or mappings specified in an index template.\nChanges to index templates do not affect existing indices, including the existing backing indices of a data stream.\n\nYou can use C-style `/* *\\/` block comments in index templates.\nYou can include comments anywhere in the request body, except before the opening curly bracket.\n\n**Multiple matching templates**\n\nIf multiple index templates match the name of a new index or data stream, the template with the highest priority is used.\n\nMultiple templates with overlapping index patterns at the same priority are not allowed and an error will be thrown when attempting to create a template matching an existing index template at identical priorities.\n\n**Composing aliases, mappings, and settings**\n\nWhen multiple component templates are specified in the `composed_of` field for an index template, they are merged in the order specified, meaning that later component templates override earlier component templates.\nAny mappings, settings, or aliases from the parent index template are merged in next.\nFinally, any configuration on the index request itself is merged.\nMapping definitions are merged recursively, which means that later mapping components can introduce new field mappings and update the mapping configuration.\nIf a field mapping is already contained in an earlier component, its definition will be completely overwritten by the later one.\nThis recursive merging strategy applies not only to field mappings, but also root options like `dynamic_templates` and `meta`.\nIf an earlier component contains a `dynamic_templates` block, then by default new `dynamic_templates` entries are appended onto the end.\nIf an entry already exists with the same key, then it is overwritten by the new definition.",
        "operationId": "indices-put-index-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_index_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#cause"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_index_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_index_template#200"
          }
        },
        "x-state": "Added in 7.9.0"
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete an index template",
        "description": "The provided <index-template> may contain multiple template names separated by a comma. If multiple template\nnames are specified then there is no wildcard support and the provided names should match completely with\nexisting templates.",
        "operationId": "indices-delete-index-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of index template names used to limit the request. Wildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.8.0"
      },
      "head": {
        "tags": [
          "indices"
        ],
        "summary": "Check index templates",
        "description": "Check whether index templates exist.",
        "operationId": "indices-exists-index-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of index template names used to limit the request. Wildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_template/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get legacy index templates",
        "description": "Get information about one or more index templates.\n\nIMPORTANT: This documentation is about legacy index templates, which are deprecated and will be replaced by the composable templates introduced in Elasticsearch 7.8.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html"
        },
        "operationId": "indices-get-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_template#200"
          }
        },
        "deprecated": true
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update a legacy index template",
        "description": "Index templates define settings, mappings, and aliases that can be applied automatically to new indices.\nElasticsearch applies templates to new indices based on an index pattern that matches the index name.\n\nIMPORTANT: This documentation is about legacy index templates, which are deprecated and will be replaced by the composable templates introduced in Elasticsearch 7.8.\n\nComposable templates always take precedence over legacy templates.\nIf no composable template matches a new index, matching legacy templates are applied according to their order.\n\nIndex templates are only applied during index creation.\nChanges to index templates do not affect existing indices.\nSettings and mappings specified in create index API requests override any settings or mappings specified in an index template.\n\nYou can use C-style `/* *\\/` block comments in index templates.\nYou can include comments anywhere in the request body, except before the opening curly bracket.\n\n**Indices matching multiple templates**\n\nMultiple index templates can potentially match an index, in this case, both the settings and mappings are merged into the final configuration of the index.\nThe order of the merging can be controlled using the order parameter, with lower order being applied first, and higher orders overriding them.\nNOTE: Multiple matching templates with the same order value will result in a non-deterministic merging order.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html"
        },
        "operationId": "indices-put-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#order"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#cause"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_template#200"
          }
        },
        "deprecated": true
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update a legacy index template",
        "description": "Index templates define settings, mappings, and aliases that can be applied automatically to new indices.\nElasticsearch applies templates to new indices based on an index pattern that matches the index name.\n\nIMPORTANT: This documentation is about legacy index templates, which are deprecated and will be replaced by the composable templates introduced in Elasticsearch 7.8.\n\nComposable templates always take precedence over legacy templates.\nIf no composable template matches a new index, matching legacy templates are applied according to their order.\n\nIndex templates are only applied during index creation.\nChanges to index templates do not affect existing indices.\nSettings and mappings specified in create index API requests override any settings or mappings specified in an index template.\n\nYou can use C-style `/* *\\/` block comments in index templates.\nYou can include comments anywhere in the request body, except before the opening curly bracket.\n\n**Indices matching multiple templates**\n\nMultiple index templates can potentially match an index, in this case, both the settings and mappings are merged into the final configuration of the index.\nThe order of the merging can be controlled using the order parameter, with lower order being applied first, and higher orders overriding them.\nNOTE: Multiple matching templates with the same order value will result in a non-deterministic merging order.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html"
        },
        "operationId": "indices-put-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#order"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#cause"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_template#200"
          }
        },
        "deprecated": true
      },
      "delete": {
        "tags": [
          "indices"
        ],
        "summary": "Delete a legacy index template",
        "description": "IMPORTANT: This documentation is about legacy index templates, which are deprecated and will be replaced by the composable templates introduced in Elasticsearch 7.8.",
        "operationId": "indices-delete-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the legacy index template to delete.\nWildcard (`*`) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "deprecated": true
      },
      "head": {
        "tags": [
          "indices"
        ],
        "summary": "Check existence of index templates",
        "description": "Get information about whether index templates exist.\nIndex templates define settings, mappings, and aliases that can be applied automatically to new indices.\n\nIMPORTANT: This documentation is about legacy index templates, which are deprecated and will be replaced by the composable templates introduced in Elasticsearch 7.8.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html"
        },
        "operationId": "indices-exists-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "A comma-separated list of index template names used to limit the request.\nWildcard (`*`) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "flat_settings",
            "description": "Indicates whether to use a flat format for the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "Indicates whether to get information from the local node only.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for the master node.\nIf the master node is not available before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/{index}/_disk_usage": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Analyze the index disk usage",
        "description": "Analyze the disk usage of each field of an index or data stream.\nThis API might not support indices created in previous Elasticsearch versions.\nThe result of a small index can be inaccurate as some parts of an index might not be analyzed by the API.\n\nNOTE: The total size of fields of the analyzed shards of the index in the response is usually smaller than the index `store_size` value because some small metadata files are ignored and some parts of data files might not be scanned by the API.\nSince stored fields are stored together in a compressed format, the sizes of stored fields are also estimates and can be inaccurate.\nThe stored size of the `_id` field is likely underestimated while the `_source` field is overestimated.",
        "operationId": "indices-disk-usage",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nItâ€™s recommended to execute this API with a single index (or the latest backing index of a data stream) as the API consumes resources significantly.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "flush",
            "description": "If `true`, the API performs a flush before analysis.\nIf `false`, the response may not include uncommitted data.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `true`, missing or closed indices are not included in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "run_expensive_tasks",
            "description": "Analyzing field disk usage is resource-intensive.\nTo use the API, this parameter must be set to `true`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/{index}/_downsample/{target_index}": {
      "post": {
        "tags": [
          "data stream"
        ],
        "summary": "Downsample an index",
        "description": "Aggregate a time series (TSDS) index and store pre-computed statistical summaries (`min`, `max`, `sum`, `value_count` and `avg`) for each metric field grouped by a configured time interval.\nFor example, a TSDS index that contains metrics sampled every 10 seconds can be downsampled to an hourly index.\nAll documents within an hour interval are summarized and stored as a single document in the downsample index.\n\nNOTE: Only indices in a time series data stream are supported.\nNeither field nor document level security can be defined on the source index.\nThe source index must be read only (`index.blocks.write: true`).",
        "operationId": "indices-downsample",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the time series index to downsample.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "target_index",
            "description": "Name of the index to create.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/indices._types:DownsampleConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_alias/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get aliases",
        "description": "Retrieves information for one or more data stream or index aliases.",
        "operationId": "indices-get-alias-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      },
      "head": {
        "tags": [
          "indices"
        ],
        "summary": "Check aliases",
        "description": "Checks if one or more data stream or index aliases exist.",
        "operationId": "indices-exists-alias",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.exists_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.exists_alias#200"
          }
        }
      }
    },
    "/{index}/_lifecycle/explain": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get the status for a data stream lifecycle",
        "description": "Get information about an index or data stream's current data stream lifecycle status, such as time since index creation, time since rollover, the lifecycle configuration managing the index, or any errors encountered during lifecycle execution.",
        "operationId": "indices-explain-data-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index to explain",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "indicates if the API should return the default values the system uses for the index's lifecycle",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "indices": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/indices.explain_data_lifecycle:DataStreamLifecycleExplain"
                      }
                    }
                  },
                  "required": [
                    "indices"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.11.0"
      }
    },
    "/{index}/_field_usage_stats": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get field usage stats",
        "description": "Get field usage information for each shard and field of an index.\nField usage statistics are automatically captured when queries are running on a cluster.\nA shard-level search request that accesses a given field, even if multiple times during that request, is counted as a single use.\n\nThe response body reports the per-shard usage count of the data structures that back the fields in the index.\nA given request will increment each count by a maximum value of 1, even if the request accesses the same field multiple times.",
        "operationId": "indices-field-usage-stats",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list or wildcard expression of index names used to limit the request.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `true`, missing or closed indices are not included in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "fields",
            "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/indices.field_usage_stats:FieldsUsageBody"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_flush": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Flush data streams or indices",
        "description": "Flushing a data stream or index is the process of making sure that any data that is currently only stored in the transaction log is also permanently stored in the Lucene index.\nWhen restarting, Elasticsearch replays any unflushed operations from the transaction log into the Lucene index to bring it back into the state that it was in before the restart.\nElasticsearch automatically triggers flushes as needed, using heuristics that trade off the size of the unflushed transaction log against the cost of performing each flush.\n\nAfter each operation has been flushed it is permanently stored in the Lucene index.\nThis may mean that there is no need to maintain an additional copy of it in the transaction log.\nThe transaction log is made up of multiple files, called generations, and Elasticsearch will delete any generation files when they are no longer needed, freeing up disk space.\n\nIt is also possible to trigger a flush on one or more indices using the flush API, although it is rare for users to need to call this API directly.\nIf you call the flush API after indexing some documents then a successful response indicates that Elasticsearch has flushed all the documents that were indexed before the flush API was called.",
        "operationId": "indices-flush-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.flush#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.flush#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.flush#force"
          },
          {
            "$ref": "#/components/parameters/indices.flush#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.flush#wait_if_ongoing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.flush#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Flush data streams or indices",
        "description": "Flushing a data stream or index is the process of making sure that any data that is currently only stored in the transaction log is also permanently stored in the Lucene index.\nWhen restarting, Elasticsearch replays any unflushed operations from the transaction log into the Lucene index to bring it back into the state that it was in before the restart.\nElasticsearch automatically triggers flushes as needed, using heuristics that trade off the size of the unflushed transaction log against the cost of performing each flush.\n\nAfter each operation has been flushed it is permanently stored in the Lucene index.\nThis may mean that there is no need to maintain an additional copy of it in the transaction log.\nThe transaction log is made up of multiple files, called generations, and Elasticsearch will delete any generation files when they are no longer needed, freeing up disk space.\n\nIt is also possible to trigger a flush on one or more indices using the flush API, although it is rare for users to need to call this API directly.\nIf you call the flush API after indexing some documents then a successful response indicates that Elasticsearch has flushed all the documents that were indexed before the flush API was called.",
        "operationId": "indices-flush",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.flush#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.flush#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.flush#force"
          },
          {
            "$ref": "#/components/parameters/indices.flush#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.flush#wait_if_ongoing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.flush#200"
          }
        }
      }
    },
    "/{index}/_flush": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Flush data streams or indices",
        "description": "Flushing a data stream or index is the process of making sure that any data that is currently only stored in the transaction log is also permanently stored in the Lucene index.\nWhen restarting, Elasticsearch replays any unflushed operations from the transaction log into the Lucene index to bring it back into the state that it was in before the restart.\nElasticsearch automatically triggers flushes as needed, using heuristics that trade off the size of the unflushed transaction log against the cost of performing each flush.\n\nAfter each operation has been flushed it is permanently stored in the Lucene index.\nThis may mean that there is no need to maintain an additional copy of it in the transaction log.\nThe transaction log is made up of multiple files, called generations, and Elasticsearch will delete any generation files when they are no longer needed, freeing up disk space.\n\nIt is also possible to trigger a flush on one or more indices using the flush API, although it is rare for users to need to call this API directly.\nIf you call the flush API after indexing some documents then a successful response indicates that Elasticsearch has flushed all the documents that were indexed before the flush API was called.",
        "operationId": "indices-flush-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.flush#index"
          },
          {
            "$ref": "#/components/parameters/indices.flush#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.flush#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.flush#force"
          },
          {
            "$ref": "#/components/parameters/indices.flush#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.flush#wait_if_ongoing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.flush#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Flush data streams or indices",
        "description": "Flushing a data stream or index is the process of making sure that any data that is currently only stored in the transaction log is also permanently stored in the Lucene index.\nWhen restarting, Elasticsearch replays any unflushed operations from the transaction log into the Lucene index to bring it back into the state that it was in before the restart.\nElasticsearch automatically triggers flushes as needed, using heuristics that trade off the size of the unflushed transaction log against the cost of performing each flush.\n\nAfter each operation has been flushed it is permanently stored in the Lucene index.\nThis may mean that there is no need to maintain an additional copy of it in the transaction log.\nThe transaction log is made up of multiple files, called generations, and Elasticsearch will delete any generation files when they are no longer needed, freeing up disk space.\n\nIt is also possible to trigger a flush on one or more indices using the flush API, although it is rare for users to need to call this API directly.\nIf you call the flush API after indexing some documents then a successful response indicates that Elasticsearch has flushed all the documents that were indexed before the flush API was called.",
        "operationId": "indices-flush-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.flush#index"
          },
          {
            "$ref": "#/components/parameters/indices.flush#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.flush#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.flush#force"
          },
          {
            "$ref": "#/components/parameters/indices.flush#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.flush#wait_if_ongoing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.flush#200"
          }
        }
      }
    },
    "/_forcemerge": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Force a merge",
        "description": "Perform the force merge operation on the shards of one or more indices.\nFor data streams, the API forces a merge on the shards of the stream's backing indices.\n\nMerging reduces the number of segments in each shard by merging some of them together and also frees up the space used by deleted documents.\nMerging normally happens automatically, but sometimes it is useful to trigger a merge manually.\n\nWARNING: We recommend force merging only a read-only index (meaning the index is no longer receiving writes).\nWhen documents are updated or deleted, the old version is not immediately removed but instead soft-deleted and marked with a \"tombstone\".\nThese soft-deleted documents are automatically cleaned up during regular segment merges.\nBut force merge can cause very large (greater than 5 GB) segments to be produced, which are not eligible for regular merges.\nSo the number of soft-deleted documents can then grow rapidly, resulting in higher disk usage and worse search performance.\nIf you regularly force merge an index receiving writes, this can also make snapshots more expensive, since the new documents can't be backed up incrementally.\n\n**Blocks during a force merge**\n\nCalls to this API block until the merge is complete (unless request contains `wait_for_completion=false`).\nIf the client connection is lost before completion then the force merge process will continue in the background.\nAny new requests to force merge the same indices will also block until the ongoing force merge is complete.\n\n**Running force merge asynchronously**\n\nIf the request contains `wait_for_completion=false`, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to get the status of the task.\nHowever, you can not cancel this task as the force merge task is not cancelable.\nElasticsearch creates a record of this task as a document at `_tasks/<task_id>`.\nWhen you are done with a task, you should delete the task document so Elasticsearch can reclaim the space.\n\n**Force merging multiple indices**\n\nYou can force merge multiple indices with a single request by targeting:\n\n* One or more data streams that contain multiple backing indices\n* Multiple indices\n* One or more aliases\n* All data streams and indices in a cluster\n\nEach targeted shard is force-merged separately using the force_merge threadpool.\nBy default each node only has a single `force_merge` thread which means that the shards on that node are force-merged one at a time.\nIf you expand the `force_merge` threadpool on a node then it will force merge its shards in parallel\n\nForce merge makes the storage for the shard being merged temporarily increase, as it may require free space up to triple its size in case `max_num_segments parameter` is set to `1`, to rewrite all segments into a new one.\n\n**Data streams and time-based indices**\n\nForce-merging is useful for managing a data stream's older backing indices and other time-based indices, particularly after a rollover.\nIn these cases, each index only receives indexing traffic for a certain period of time.\nOnce an index receive no more writes, its shards can be force-merged to a single segment.\nThis can be a good idea because single-segment shards can sometimes use simpler and more efficient data structures to perform searches.\nFor example:\n\n```\nPOST /.ds-my-data-stream-2099.03.07-000001/_forcemerge?max_num_segments=1\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-merge.html"
        },
        "operationId": "indices-forcemerge",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.forcemerge#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#flush"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#max_num_segments"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#only_expunge_deletes"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#wait_for_completion"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.forcemerge#200"
          }
        },
        "x-state": "Added in 2.1.0"
      }
    },
    "/{index}/_forcemerge": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Force a merge",
        "description": "Perform the force merge operation on the shards of one or more indices.\nFor data streams, the API forces a merge on the shards of the stream's backing indices.\n\nMerging reduces the number of segments in each shard by merging some of them together and also frees up the space used by deleted documents.\nMerging normally happens automatically, but sometimes it is useful to trigger a merge manually.\n\nWARNING: We recommend force merging only a read-only index (meaning the index is no longer receiving writes).\nWhen documents are updated or deleted, the old version is not immediately removed but instead soft-deleted and marked with a \"tombstone\".\nThese soft-deleted documents are automatically cleaned up during regular segment merges.\nBut force merge can cause very large (greater than 5 GB) segments to be produced, which are not eligible for regular merges.\nSo the number of soft-deleted documents can then grow rapidly, resulting in higher disk usage and worse search performance.\nIf you regularly force merge an index receiving writes, this can also make snapshots more expensive, since the new documents can't be backed up incrementally.\n\n**Blocks during a force merge**\n\nCalls to this API block until the merge is complete (unless request contains `wait_for_completion=false`).\nIf the client connection is lost before completion then the force merge process will continue in the background.\nAny new requests to force merge the same indices will also block until the ongoing force merge is complete.\n\n**Running force merge asynchronously**\n\nIf the request contains `wait_for_completion=false`, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to get the status of the task.\nHowever, you can not cancel this task as the force merge task is not cancelable.\nElasticsearch creates a record of this task as a document at `_tasks/<task_id>`.\nWhen you are done with a task, you should delete the task document so Elasticsearch can reclaim the space.\n\n**Force merging multiple indices**\n\nYou can force merge multiple indices with a single request by targeting:\n\n* One or more data streams that contain multiple backing indices\n* Multiple indices\n* One or more aliases\n* All data streams and indices in a cluster\n\nEach targeted shard is force-merged separately using the force_merge threadpool.\nBy default each node only has a single `force_merge` thread which means that the shards on that node are force-merged one at a time.\nIf you expand the `force_merge` threadpool on a node then it will force merge its shards in parallel\n\nForce merge makes the storage for the shard being merged temporarily increase, as it may require free space up to triple its size in case `max_num_segments parameter` is set to `1`, to rewrite all segments into a new one.\n\n**Data streams and time-based indices**\n\nForce-merging is useful for managing a data stream's older backing indices and other time-based indices, particularly after a rollover.\nIn these cases, each index only receives indexing traffic for a certain period of time.\nOnce an index receive no more writes, its shards can be force-merged to a single segment.\nThis can be a good idea because single-segment shards can sometimes use simpler and more efficient data structures to perform searches.\nFor example:\n\n```\nPOST /.ds-my-data-stream-2099.03.07-000001/_forcemerge?max_num_segments=1\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules-merge.html"
        },
        "operationId": "indices-forcemerge-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.forcemerge#index"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#flush"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#max_num_segments"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#only_expunge_deletes"
          },
          {
            "$ref": "#/components/parameters/indices.forcemerge#wait_for_completion"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.forcemerge#200"
          }
        },
        "x-state": "Added in 2.1.0"
      }
    },
    "/_alias": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get aliases",
        "description": "Retrieves information for one or more data stream or index aliases.",
        "operationId": "indices-get-alias",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      }
    },
    "/{index}/_alias": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get aliases",
        "description": "Retrieves information for one or more data stream or index aliases.",
        "operationId": "indices-get-alias-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      }
    },
    "/_lifecycle/stats": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get data stream lifecycle stats",
        "description": "Get statistics about the data streams that are managed by a data stream lifecycle.",
        "operationId": "indices-get-data-lifecycle-stats",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data_stream_count": {
                      "description": "The count of data streams currently being managed by the data stream lifecycle.",
                      "type": "number"
                    },
                    "data_streams": {
                      "description": "Information about the data streams that are managed by the data stream lifecycle.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.get_data_lifecycle_stats:DataStreamStats"
                      }
                    },
                    "last_run_duration_in_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "time_between_starts_in_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    }
                  },
                  "required": [
                    "data_stream_count",
                    "data_streams"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.12.0"
      }
    },
    "/_data_stream": {
      "get": {
        "tags": [
          "data stream"
        ],
        "summary": "Get data streams",
        "description": "Retrieves information about one or more data streams.",
        "operationId": "indices-get-data-stream",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_data_stream#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_data_stream#200"
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_mapping/field/{fields}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get mapping definitions",
        "description": "Retrieves mapping definitions for one or more fields.\nFor data streams, the API retrieves field mappings for the streamâ€™s backing indices.\n\nThis API is useful if you don't need a complete mapping or if an index mapping contains a large number of fields.",
        "operationId": "indices-get-field-mapping",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#fields"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_field_mapping#200"
          }
        }
      }
    },
    "/{index}/_mapping/field/{fields}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get mapping definitions",
        "description": "Retrieves mapping definitions for one or more fields.\nFor data streams, the API retrieves field mappings for the streamâ€™s backing indices.\n\nThis API is useful if you don't need a complete mapping or if an index mapping contains a large number of fields.",
        "operationId": "indices-get-field-mapping-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#fields"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_field_mapping#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_field_mapping#200"
          }
        }
      }
    },
    "/_index_template": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index templates",
        "description": "Get information about one or more index templates.",
        "operationId": "indices-get-index-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_index_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#include_defaults"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_index_template#200"
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_mapping": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get mapping definitions",
        "description": "For data streams, the API retrieves mappings for the streamâ€™s backing indices.",
        "operationId": "indices-get-mapping",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_mapping#200"
          }
        }
      }
    },
    "/{index}/_mapping": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get mapping definitions",
        "description": "For data streams, the API retrieves mappings for the streamâ€™s backing indices.",
        "operationId": "indices-get-mapping-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_mapping#200"
          }
        }
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Update field mappings",
        "description": "Add new fields to an existing data stream or index.\nYou can also use this API to change the search settings of existing fields and add new properties to existing object fields.\nFor data streams, these changes are applied to all backing indices by default.\n\n**Add multi-fields to an existing field**\n\nMulti-fields let you index the same field in different ways.\nYou can use this API to update the fields mapping parameter and enable multi-fields for an existing field.\nWARNING: If an index (or data stream) contains documents when you add a multi-field, those documents will not have values for the new multi-field.\nYou can populate the new multi-field with the update by query API.\n\n**Change supported mapping parameters for an existing field**\n\nThe documentation for each mapping parameter indicates whether you can update it for an existing field using this API.\nFor example, you can use the update mapping API to update the `ignore_above` parameter.\n\n**Change the mapping of an existing field**\n\nExcept for supported mapping parameters, you can't change the mapping or field type of an existing field.\nChanging an existing field could invalidate data that's already indexed.\n\nIf you need to change the mapping of a field in a data stream's backing indices, refer to documentation about modifying data streams.\nIf you need to change the mapping of a field in other indices, create a new index with the correct mapping and reindex your data into that index.\n\n**Rename a field**\n\nRenaming a field would invalidate data already indexed under the old field name.\nInstead, add an alias field to create an alternate field name.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html"
        },
        "operationId": "indices-put-mapping",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#write_index_only"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_mapping#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Update field mappings",
        "description": "Add new fields to an existing data stream or index.\nYou can also use this API to change the search settings of existing fields and add new properties to existing object fields.\nFor data streams, these changes are applied to all backing indices by default.\n\n**Add multi-fields to an existing field**\n\nMulti-fields let you index the same field in different ways.\nYou can use this API to update the fields mapping parameter and enable multi-fields for an existing field.\nWARNING: If an index (or data stream) contains documents when you add a multi-field, those documents will not have values for the new multi-field.\nYou can populate the new multi-field with the update by query API.\n\n**Change supported mapping parameters for an existing field**\n\nThe documentation for each mapping parameter indicates whether you can update it for an existing field using this API.\nFor example, you can use the update mapping API to update the `ignore_above` parameter.\n\n**Change the mapping of an existing field**\n\nExcept for supported mapping parameters, you can't change the mapping or field type of an existing field.\nChanging an existing field could invalidate data that's already indexed.\n\nIf you need to change the mapping of a field in a data stream's backing indices, refer to documentation about modifying data streams.\nIf you need to change the mapping of a field in other indices, create a new index with the correct mapping and reindex your data into that index.\n\n**Rename a field**\n\nRenaming a field would invalidate data already indexed under the old field name.\nInstead, add an alias field to create an alternate field name.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-params.html"
        },
        "operationId": "indices-put-mapping-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#write_index_only"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_mapping#200"
          }
        }
      }
    },
    "/_settings": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index settings",
        "description": "Get setting information for one or more indices.\nFor data streams, it returns setting information for the stream's backing indices.",
        "operationId": "indices-get-settings",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Update index settings",
        "description": "Changes dynamic index settings in real time.\nFor data streams, index setting changes are applied to all backing indices by default.\n\nTo revert a setting to the default value, use a null value.\nThe list of per-index settings that can be updated dynamically on live indices can be found in index module documentation.\nTo preserve existing settings from being updated, set the `preserve_existing` parameter to `true`.\n\nNOTE: You can only define new analyzers on closed indices.\nTo add an analyzer, you must close the index, define the analyzer, and reopen the index.\nYou cannot close the write index of a data stream.\nTo update the analyzer for a data stream's write index and future backing indices, update the analyzer in the index template used by the stream.\nThen roll over the data stream to apply the new analyzer to the stream's write index and future backing indices.\nThis affects searches and any new data added to the stream after the rollover.\nHowever, it does not affect the data stream's backing indices or their existing data.\nTo change the analyzer for existing backing indices, you must create a new data stream and reindex your data into it.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html"
        },
        "operationId": "indices-put-settings",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#preserve_existing"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_settings"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_settings#200"
          }
        }
      }
    },
    "/{index}/_settings": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index settings",
        "description": "Get setting information for one or more indices.\nFor data streams, it returns setting information for the stream's backing indices.",
        "operationId": "indices-get-settings-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      },
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Update index settings",
        "description": "Changes dynamic index settings in real time.\nFor data streams, index setting changes are applied to all backing indices by default.\n\nTo revert a setting to the default value, use a null value.\nThe list of per-index settings that can be updated dynamically on live indices can be found in index module documentation.\nTo preserve existing settings from being updated, set the `preserve_existing` parameter to `true`.\n\nNOTE: You can only define new analyzers on closed indices.\nTo add an analyzer, you must close the index, define the analyzer, and reopen the index.\nYou cannot close the write index of a data stream.\nTo update the analyzer for a data stream's write index and future backing indices, update the analyzer in the index template used by the stream.\nThen roll over the data stream to apply the new analyzer to the stream's write index and future backing indices.\nThis affects searches and any new data added to the stream after the rollover.\nHowever, it does not affect the data stream's backing indices or their existing data.\nTo change the analyzer for existing backing indices, you must create a new data stream and reindex your data into it.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-modules.html"
        },
        "operationId": "indices-put-settings-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_settings#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#preserve_existing"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_settings"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_settings#200"
          }
        }
      }
    },
    "/{index}/_settings/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index settings",
        "description": "Get setting information for one or more indices.\nFor data streams, it returns setting information for the stream's backing indices.",
        "operationId": "indices-get-settings-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      }
    },
    "/_settings/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index settings",
        "description": "Get setting information for one or more indices.\nFor data streams, it returns setting information for the stream's backing indices.",
        "operationId": "indices-get-settings-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      }
    },
    "/_template": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get legacy index templates",
        "description": "Get information about one or more index templates.\n\nIMPORTANT: This documentation is about legacy index templates, which are deprecated and will be replaced by the composable templates introduced in Elasticsearch 7.8.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index-templates.html"
        },
        "operationId": "indices-get-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_template#200"
          }
        },
        "deprecated": true
      }
    },
    "/_data_stream/_migrate/{name}": {
      "post": {
        "tags": [
          "data stream"
        ],
        "summary": "Convert an index alias to a data stream",
        "description": "Converts an index alias to a data stream.\nYou must have a matching index template that is data stream enabled.\nThe alias must meet the following criteria:\nThe alias must have a write index;\nAll indices for the alias must have a `@timestamp` field mapping of a `date` or `date_nanos` field type;\nThe alias must not have any filters;\nThe alias must not use custom routing.\nIf successful, the request removes the alias and creates a data stream with the same name.\nThe indices for the alias become hidden backing indices for the stream.\nThe write index for the alias becomes the write index for the stream.",
        "operationId": "indices-migrate-to-data-stream",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the index alias to convert to a data stream.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_data_stream/_modify": {
      "post": {
        "tags": [
          "data stream"
        ],
        "summary": "Update data streams",
        "description": "Performs one or more data stream modification actions in a single atomic operation.",
        "operationId": "indices-modify-data-stream",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "actions": {
                    "description": "Actions to perform.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/indices.modify_data_stream:Action"
                    }
                  }
                },
                "required": [
                  "actions"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.16.0"
      }
    },
    "/{index}/_open": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Open a closed index",
        "description": "For data streams, the API opens any closed backing indices.\n\nA closed index is blocked for read/write operations and does not allow all operations that opened indices allow.\nIt is not possible to index documents or to search for documents in a closed index.\nThis allows closed indices to not have to maintain internal data structures for indexing or searching documents, resulting in a smaller overhead on the cluster.\n\nWhen opening or closing an index, the master is responsible for restarting the index shards to reflect the new state of the index.\nThe shards will then go through the normal recovery process.\nThe data of opened or closed indices is automatically replicated by the cluster to ensure that enough shard copies are safely kept around at all times.\n\nYou can open and close multiple indices.\nAn error is thrown if the request explicitly refers to a missing index.\nThis behavior can be turned off by using the `ignore_unavailable=true` parameter.\n\nBy default, you must explicitly name the indices you are opening or closing.\nTo open or close indices with `_all`, `*`, or other wildcard expressions, change the `action.destructive_requires_name` setting to `false`.\nThis setting can also be changed with the cluster update settings API.\n\nClosed indices consume a significant amount of disk-space which can cause problems in managed environments.\nClosing indices can be turned off with the cluster settings API by setting `cluster.indices.close.enable` to `false`.\n\nBecause opening or closing an index allocates its shards, the `wait_for_active_shards` setting on index creation applies to the `_open` and `_close` index actions as well.",
        "operationId": "indices-open",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nBy default, you must explicitly name the indices you using to limit the request.\nTo limit a request using `_all`, `*`, or other wildcard expressions, change the `action.destructive_requires_name` setting to false.\nYou can update this setting in the `elasticsearch.yml` file or using the cluster update settings API.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "shards_acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_data_stream/_promote/{name}": {
      "post": {
        "tags": [
          "data stream"
        ],
        "summary": "Promote a data stream",
        "description": "Promote a data stream from a replicated data stream managed by cross-cluster replication (CCR) to a regular data stream.\n\nWith CCR auto following, a data stream from a remote cluster can be replicated to the local cluster.\nThese data streams can't be rolled over in the local cluster.\nThese replicated data streams roll over only if the upstream data stream rolls over.\nIn the event that the remote cluster is no longer available, the data stream in the local cluster can be promoted to a regular data stream, which allows these data streams to be rolled over in the local cluster.\n\nNOTE: When promoting a data stream, ensure the local cluster has a data stream enabled index template that matches the data stream.\nIf this is missing, the data stream will not be able to roll over until a matching index template is created.\nThis will affect the lifecycle management of the data stream and interfere with the data stream size and retention.",
        "operationId": "indices-promote-data-stream",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the data stream",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_recovery": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index recovery information",
        "description": "Get information about ongoing and completed shard recoveries for one or more indices.\nFor data streams, the API returns information for the stream's backing indices.\n\nAll recoveries, whether ongoing or complete, are kept in the cluster state and may be reported on at any time.\n\nShard recovery is the process of initializing a shard copy, such as restoring a primary shard from a snapshot or creating a replica shard from a primary shard.\nWhen a shard recovery completes, the recovered shard is available for search and indexing.\n\nRecovery automatically occurs during the following processes:\n\n* When creating an index for the first time.\n* When a node rejoins the cluster and starts up any missing primary shard copies using the data that it holds in its data path.\n* Creation of new replica shard copies from the primary.\n* Relocation of a shard copy to a different node in the same cluster.\n* A snapshot restore operation.\n* A clone, shrink, or split operation.\n\nYou can determine the cause of a shard recovery using the recovery or cat recovery APIs.\n\nThe index recovery API reports information about completed recoveries only for shard copies that currently exist in the cluster.\nIt only reports the last recovery for each shard copy and does not report historical information about earlier recoveries, nor does it report information about the recoveries of shard copies that no longer exist.\nThis means that if a shard copy completes a recovery and then Elasticsearch relocates it onto a different node then the information about the original recovery will not be shown in the recovery API.",
        "operationId": "indices-recovery",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.recovery#active_only"
          },
          {
            "$ref": "#/components/parameters/indices.recovery#detailed"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.recovery#200"
          }
        }
      }
    },
    "/{index}/_recovery": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index recovery information",
        "description": "Get information about ongoing and completed shard recoveries for one or more indices.\nFor data streams, the API returns information for the stream's backing indices.\n\nAll recoveries, whether ongoing or complete, are kept in the cluster state and may be reported on at any time.\n\nShard recovery is the process of initializing a shard copy, such as restoring a primary shard from a snapshot or creating a replica shard from a primary shard.\nWhen a shard recovery completes, the recovered shard is available for search and indexing.\n\nRecovery automatically occurs during the following processes:\n\n* When creating an index for the first time.\n* When a node rejoins the cluster and starts up any missing primary shard copies using the data that it holds in its data path.\n* Creation of new replica shard copies from the primary.\n* Relocation of a shard copy to a different node in the same cluster.\n* A snapshot restore operation.\n* A clone, shrink, or split operation.\n\nYou can determine the cause of a shard recovery using the recovery or cat recovery APIs.\n\nThe index recovery API reports information about completed recoveries only for shard copies that currently exist in the cluster.\nIt only reports the last recovery for each shard copy and does not report historical information about earlier recoveries, nor does it report information about the recoveries of shard copies that no longer exist.\nThis means that if a shard copy completes a recovery and then Elasticsearch relocates it onto a different node then the information about the original recovery will not be shown in the recovery API.",
        "operationId": "indices-recovery-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.recovery#index"
          },
          {
            "$ref": "#/components/parameters/indices.recovery#active_only"
          },
          {
            "$ref": "#/components/parameters/indices.recovery#detailed"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.recovery#200"
          }
        }
      }
    },
    "/_refresh": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Refresh an index",
        "description": "A refresh makes recent operations performed on one or more indices available for search.\nFor data streams, the API runs the refresh operation on the streamâ€™s backing indices.\n\nBy default, Elasticsearch periodically refreshes indices every second, but only on indices that have received one search request or more in the last 30 seconds.\nYou can change this default interval with the `index.refresh_interval` setting.\n\nRefresh requests are synchronous and do not return a response until the refresh operation completes.\n\nRefreshes are resource-intensive.\nTo ensure good cluster performance, it's recommended to wait for Elasticsearch's periodic refresh rather than performing an explicit refresh when possible.\n\nIf your application workflow indexes documents and then runs a search to retrieve the indexed document, it's recommended to use the index API's `refresh=wait_for` query parameter option.\nThis option ensures the indexing operation waits for a periodic refresh before running the search.",
        "operationId": "indices-refresh-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.refresh#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.refresh#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Refresh an index",
        "description": "A refresh makes recent operations performed on one or more indices available for search.\nFor data streams, the API runs the refresh operation on the streamâ€™s backing indices.\n\nBy default, Elasticsearch periodically refreshes indices every second, but only on indices that have received one search request or more in the last 30 seconds.\nYou can change this default interval with the `index.refresh_interval` setting.\n\nRefresh requests are synchronous and do not return a response until the refresh operation completes.\n\nRefreshes are resource-intensive.\nTo ensure good cluster performance, it's recommended to wait for Elasticsearch's periodic refresh rather than performing an explicit refresh when possible.\n\nIf your application workflow indexes documents and then runs a search to retrieve the indexed document, it's recommended to use the index API's `refresh=wait_for` query parameter option.\nThis option ensures the indexing operation waits for a periodic refresh before running the search.",
        "operationId": "indices-refresh",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.refresh#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.refresh#200"
          }
        }
      }
    },
    "/{index}/_refresh": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Refresh an index",
        "description": "A refresh makes recent operations performed on one or more indices available for search.\nFor data streams, the API runs the refresh operation on the streamâ€™s backing indices.\n\nBy default, Elasticsearch periodically refreshes indices every second, but only on indices that have received one search request or more in the last 30 seconds.\nYou can change this default interval with the `index.refresh_interval` setting.\n\nRefresh requests are synchronous and do not return a response until the refresh operation completes.\n\nRefreshes are resource-intensive.\nTo ensure good cluster performance, it's recommended to wait for Elasticsearch's periodic refresh rather than performing an explicit refresh when possible.\n\nIf your application workflow indexes documents and then runs a search to retrieve the indexed document, it's recommended to use the index API's `refresh=wait_for` query parameter option.\nThis option ensures the indexing operation waits for a periodic refresh before running the search.",
        "operationId": "indices-refresh-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.refresh#index"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.refresh#200"
          }
        }
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Refresh an index",
        "description": "A refresh makes recent operations performed on one or more indices available for search.\nFor data streams, the API runs the refresh operation on the streamâ€™s backing indices.\n\nBy default, Elasticsearch periodically refreshes indices every second, but only on indices that have received one search request or more in the last 30 seconds.\nYou can change this default interval with the `index.refresh_interval` setting.\n\nRefresh requests are synchronous and do not return a response until the refresh operation completes.\n\nRefreshes are resource-intensive.\nTo ensure good cluster performance, it's recommended to wait for Elasticsearch's periodic refresh rather than performing an explicit refresh when possible.\n\nIf your application workflow indexes documents and then runs a search to retrieve the indexed document, it's recommended to use the index API's `refresh=wait_for` query parameter option.\nThis option ensures the indexing operation waits for a periodic refresh before running the search.",
        "operationId": "indices-refresh-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.refresh#index"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.refresh#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.refresh#200"
          }
        }
      }
    },
    "/{index}/_reload_search_analyzers": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Reload search analyzers",
        "description": "Reload an index's search analyzers and their resources.\nFor data streams, the API reloads search analyzers and resources for the stream's backing indices.\n\nIMPORTANT: After reloading the search analyzers you should clear the request cache to make sure it doesn't contain responses derived from the previous versions of the analyzer.\n\nYou can use the reload search analyzers API to pick up changes to synonym files used in the `synonym_graph` or `synonym` token filter of a search analyzer.\nTo be eligible, the token filter must have an `updateable` flag of `true` and only be used in search analyzers.\n\nNOTE: This API does not perform a reload for each shard of an index.\nInstead, it performs a reload for each node containing index shards.\nAs a result, the total shard count returned by the API can differ from the number of index shards.\nBecause reloading affects every node with an index shard, it is important to update the synonym file on every data node in the cluster--including nodes that don't contain a shard replica--before using this API.\nThis ensures the synonym file is updated everywhere in the cluster in case shards are relocated in the future.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyzer.html"
        },
        "operationId": "indices-reload-search-analyzers",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#index"
          },
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.reload_search_analyzers#200"
          }
        },
        "x-state": "Added in 7.3.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Reload search analyzers",
        "description": "Reload an index's search analyzers and their resources.\nFor data streams, the API reloads search analyzers and resources for the stream's backing indices.\n\nIMPORTANT: After reloading the search analyzers you should clear the request cache to make sure it doesn't contain responses derived from the previous versions of the analyzer.\n\nYou can use the reload search analyzers API to pick up changes to synonym files used in the `synonym_graph` or `synonym` token filter of a search analyzer.\nTo be eligible, the token filter must have an `updateable` flag of `true` and only be used in search analyzers.\n\nNOTE: This API does not perform a reload for each shard of an index.\nInstead, it performs a reload for each node containing index shards.\nAs a result, the total shard count returned by the API can differ from the number of index shards.\nBecause reloading affects every node with an index shard, it is important to update the synonym file on every data node in the cluster--including nodes that don't contain a shard replica--before using this API.\nThis ensures the synonym file is updated everywhere in the cluster in case shards are relocated in the future.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-analyzer.html"
        },
        "operationId": "indices-reload-search-analyzers-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#index"
          },
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.reload_search_analyzers#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.reload_search_analyzers#200"
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_resolve/cluster/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Resolve the cluster",
        "description": "Resolve the specified index expressions to return information about each cluster, including the local cluster, if included.\nMultiple patterns and remote clusters are supported.\n\nThis endpoint is useful before doing a cross-cluster search in order to determine which remote clusters should be included in a search.\n\nYou use the same index expression with this endpoint as you would for cross-cluster search.\nIndex and cluster exclusions are also supported with this endpoint.\n\nFor each cluster in the index expression, information is returned about:\n\n* Whether the querying (\"local\") cluster is currently connected to each remote cluster in the index expression scope.\n* Whether each remote cluster is configured with `skip_unavailable` as `true` or `false`.\n* Whether there are any indices, aliases, or data streams on that cluster that match the index expression.\n* Whether the search is likely to have errors returned when you do the cross-cluster search (including any authorization errors if you do not have permission to query the index).\n* Cluster version information, including the Elasticsearch server version.\n\nFor example, `GET /_resolve/cluster/my-index-*,cluster*:my-index-*` returns information about the local cluster and all remotely configured clusters that start with the alias `cluster*`.\nEach cluster returns information about whether it has any indices, aliases or data streams that match `my-index-*`.\n\n**Advantages of using this endpoint before a cross-cluster search**\n\nYou may want to exclude a cluster or index from a search when:\n\n* A remote cluster is not currently connected and is configured with `skip_unavailable=false`. Running a cross-cluster search under those conditions will cause the entire search to fail.\n* A cluster has no matching indices, aliases or data streams for the index expression (or your user does not have permissions to search them). For example, suppose your index expression is `logs*,remote1:logs*` and the remote1 cluster has no indices, aliases or data streams that match `logs*`. In that case, that cluster will return no results from that cluster if you include it in a cross-cluster search.\n* The index expression (combined with any query parameters you specify) will likely cause an exception to be thrown when you do the search. In these cases, the \"error\" field in the `_resolve/cluster` response will be present. (This is also where security/permission errors will be shown.)\n* A remote cluster is an older version that does not support the feature you want to use in your search.",
        "operationId": "indices-resolve-cluster",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated name(s) or index pattern(s) of the indices, aliases, and data streams to resolve.\nResources on remote clusters can be specified using the `<cluster>`:`<name>` syntax.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing\nor closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_throttled",
            "description": "If true, concrete, expanded or aliased indices are ignored when frozen. Defaults to false.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If false, the request returns an error if it targets a missing or closed index. Defaults to false.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices.resolve_cluster:ResolveClusterInfo"
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 8.13.0"
      }
    },
    "/_resolve/index/{name}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Resolve indices",
        "description": "Resolve the names and/or index patterns for indices, aliases, and data streams.\nMultiple patterns and remote clusters are supported.",
        "operationId": "indices-resolve-index",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated name(s) or index pattern(s) of the indices, aliases, and data streams to resolve.\nResources on remote clusters can be specified using the `<cluster>`:`<name>` syntax.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.resolve_index:ResolveIndexItem"
                      }
                    },
                    "aliases": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.resolve_index:ResolveIndexAliasItem"
                      }
                    },
                    "data_streams": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.resolve_index:ResolveIndexDataStreamsItem"
                      }
                    }
                  },
                  "required": [
                    "indices",
                    "aliases",
                    "data_streams"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/{alias}/_rollover": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Roll over to a new index",
        "description": "TIP: It is recommended to use the index lifecycle rollover action to automate rollovers.\n\nThe rollover API creates a new index for a data stream or index alias.\nThe API behavior depends on the rollover target.\n\n**Roll over a data stream**\n\nIf you roll over a data stream, the API creates a new write index for the stream.\nThe stream's previous write index becomes a regular backing index.\nA rollover also increments the data stream's generation.\n\n**Roll over an index alias with a write index**\n\nTIP: Prior to Elasticsearch 7.9, you'd typically use an index alias with a write index to manage time series data.\nData streams replace this functionality, require less maintenance, and automatically integrate with data tiers.\n\nIf an index alias points to multiple indices, one of the indices must be a write index.\nThe rollover API creates a new write index for the alias with `is_write_index` set to `true`.\nThe API also `sets is_write_index` to `false` for the previous write index.\n\n**Roll over an index alias with one index**\n\nIf you roll over an index alias that points to only one index, the API creates a new index for the alias and removes the original index from the alias.\n\nNOTE: A rollover creates a new index and is subject to the `wait_for_active_shards` setting.\n\n**Increment index names for an alias**\n\nWhen you roll over an index alias, you can specify a name for the new index.\nIf you don't specify a name and the current index ends with `-` and a number, such as `my-index-000001` or `my-index-3`, the new index name increments that number.\nFor example, if you roll over an alias with a current index of `my-index-000001`, the rollover creates a new index named `my-index-000002`.\nThis number is always six characters and zero-padded, regardless of the previous index's name.\n\nIf you use an index alias for time series data, you can use date math in the index name to track the rollover date.\nFor example, you can create an alias that points to an index named `<my-index-{now/d}-000001>`.\nIf you create the index on May 6, 2099, the index's name is `my-index-2099.05.06-000001`.\nIf you roll over the alias on May 7, 2099, the new index's name is `my-index-2099.05.07-000002`.",
        "operationId": "indices-rollover",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.rollover#alias"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#dry_run"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.rollover"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.rollover#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/{alias}/_rollover/{new_index}": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Roll over to a new index",
        "description": "TIP: It is recommended to use the index lifecycle rollover action to automate rollovers.\n\nThe rollover API creates a new index for a data stream or index alias.\nThe API behavior depends on the rollover target.\n\n**Roll over a data stream**\n\nIf you roll over a data stream, the API creates a new write index for the stream.\nThe stream's previous write index becomes a regular backing index.\nA rollover also increments the data stream's generation.\n\n**Roll over an index alias with a write index**\n\nTIP: Prior to Elasticsearch 7.9, you'd typically use an index alias with a write index to manage time series data.\nData streams replace this functionality, require less maintenance, and automatically integrate with data tiers.\n\nIf an index alias points to multiple indices, one of the indices must be a write index.\nThe rollover API creates a new write index for the alias with `is_write_index` set to `true`.\nThe API also `sets is_write_index` to `false` for the previous write index.\n\n**Roll over an index alias with one index**\n\nIf you roll over an index alias that points to only one index, the API creates a new index for the alias and removes the original index from the alias.\n\nNOTE: A rollover creates a new index and is subject to the `wait_for_active_shards` setting.\n\n**Increment index names for an alias**\n\nWhen you roll over an index alias, you can specify a name for the new index.\nIf you don't specify a name and the current index ends with `-` and a number, such as `my-index-000001` or `my-index-3`, the new index name increments that number.\nFor example, if you roll over an alias with a current index of `my-index-000001`, the rollover creates a new index named `my-index-000002`.\nThis number is always six characters and zero-padded, regardless of the previous index's name.\n\nIf you use an index alias for time series data, you can use date math in the index name to track the rollover date.\nFor example, you can create an alias that points to an index named `<my-index-{now/d}-000001>`.\nIf you create the index on May 6, 2099, the index's name is `my-index-2099.05.06-000001`.\nIf you roll over the alias on May 7, 2099, the new index's name is `my-index-2099.05.07-000002`.",
        "operationId": "indices-rollover-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.rollover#alias"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#new_index"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#dry_run"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.rollover"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.rollover#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_segments": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index segments",
        "description": "Get low-level information about the Lucene segments in index shards.\nFor data streams, the API returns information about the stream's backing indices.",
        "operationId": "indices-segments",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.segments#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.segments#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.segments#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.segments#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.segments#200"
          }
        }
      }
    },
    "/{index}/_segments": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index segments",
        "description": "Get low-level information about the Lucene segments in index shards.\nFor data streams, the API returns information about the stream's backing indices.",
        "operationId": "indices-segments-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.segments#index"
          },
          {
            "$ref": "#/components/parameters/indices.segments#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.segments#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.segments#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.segments#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.segments#200"
          }
        }
      }
    },
    "/_shard_stores": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index shard stores",
        "description": "Get store information about replica shards in one or more indices.\nFor data streams, the API retrieves store information for the stream's backing indices.\n\nThe index shard stores API returns the following information:\n\n* The node on which each replica shard exists.\n* The allocation ID for each replica shard.\n* A unique ID for each replica shard.\n* Any errors encountered while opening the shard index or from an earlier failure.\n\nBy default, the API returns store information only for primary shards that are unassigned or have one or more unassigned replica shards.",
        "operationId": "indices-shard-stores",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.shard_stores#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#status"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.shard_stores#200"
          }
        }
      }
    },
    "/{index}/_shard_stores": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index shard stores",
        "description": "Get store information about replica shards in one or more indices.\nFor data streams, the API retrieves store information for the stream's backing indices.\n\nThe index shard stores API returns the following information:\n\n* The node on which each replica shard exists.\n* The allocation ID for each replica shard.\n* A unique ID for each replica shard.\n* Any errors encountered while opening the shard index or from an earlier failure.\n\nBy default, the API returns store information only for primary shards that are unassigned or have one or more unassigned replica shards.",
        "operationId": "indices-shard-stores-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.shard_stores#index"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.shard_stores#status"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.shard_stores#200"
          }
        }
      }
    },
    "/{index}/_shrink/{target}": {
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Shrink an index",
        "description": "Shrink an index into a new index with fewer primary shards.\n\nBefore you can shrink an index:\n\n* The index must be read-only.\n* A copy of every shard in the index must reside on the same node.\n* The index must have a green health status.\n\nTo make shard allocation easier, we recommend you also remove the index's replica shards.\nYou can later re-add replica shards as part of the shrink operation.\n\nThe requested number of primary shards in the target index must be a factor of the number of shards in the source index.\nFor example an index with 8 primary shards can be shrunk into 4, 2 or 1 primary shards or an index with 15 primary shards can be shrunk into 5, 3 or 1.\nIf the number of shards in the index is a prime number it can only be shrunk into a single primary shard\n Before shrinking, a (primary or replica) copy of every shard in the index must be present on the same node.\n\nThe current write index on a data stream cannot be shrunk. In order to shrink the current write index, the data stream must first be rolled over so that a new write index is created and then the previous write index can be shrunk.\n\nA shrink operation:\n\n* Creates a new target index with the same definition as the source index, but with a smaller number of primary shards.\n* Hard-links segments from the source index into the target index. If the file system does not support hard-linking, then all segments are copied into the new index, which is a much more time consuming process. Also if using multiple data paths, shards on different data paths require a full copy of segment files if they are not on the same disk since hardlinks do not work across disks.\n* Recovers the target index as though it were a closed index which had just been re-opened. Recovers shards to the `.routing.allocation.initial_recovery._id` index setting.\n\nIMPORTANT: Indices can only be shrunk if they satisfy the following requirements:\n\n* The target index must not exist.\n* The source index must have more primary shards than the target index.\n* The number of primary shards in the target index must be a factor of the number of primary shards in the source index. The source index must have more primary shards than the target index.\n* The index must not contain more than 2,147,483,519 documents in total across all shards that will be shrunk into a single shard on the target index as this is the maximum number of docs that can fit into a single shard.\n* The node handling the shrink process must have sufficient free disk space to accommodate a second copy of the existing index.",
        "operationId": "indices-shrink",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.shrink#index"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#target"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.shrink"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.shrink#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Shrink an index",
        "description": "Shrink an index into a new index with fewer primary shards.\n\nBefore you can shrink an index:\n\n* The index must be read-only.\n* A copy of every shard in the index must reside on the same node.\n* The index must have a green health status.\n\nTo make shard allocation easier, we recommend you also remove the index's replica shards.\nYou can later re-add replica shards as part of the shrink operation.\n\nThe requested number of primary shards in the target index must be a factor of the number of shards in the source index.\nFor example an index with 8 primary shards can be shrunk into 4, 2 or 1 primary shards or an index with 15 primary shards can be shrunk into 5, 3 or 1.\nIf the number of shards in the index is a prime number it can only be shrunk into a single primary shard\n Before shrinking, a (primary or replica) copy of every shard in the index must be present on the same node.\n\nThe current write index on a data stream cannot be shrunk. In order to shrink the current write index, the data stream must first be rolled over so that a new write index is created and then the previous write index can be shrunk.\n\nA shrink operation:\n\n* Creates a new target index with the same definition as the source index, but with a smaller number of primary shards.\n* Hard-links segments from the source index into the target index. If the file system does not support hard-linking, then all segments are copied into the new index, which is a much more time consuming process. Also if using multiple data paths, shards on different data paths require a full copy of segment files if they are not on the same disk since hardlinks do not work across disks.\n* Recovers the target index as though it were a closed index which had just been re-opened. Recovers shards to the `.routing.allocation.initial_recovery._id` index setting.\n\nIMPORTANT: Indices can only be shrunk if they satisfy the following requirements:\n\n* The target index must not exist.\n* The source index must have more primary shards than the target index.\n* The number of primary shards in the target index must be a factor of the number of primary shards in the source index. The source index must have more primary shards than the target index.\n* The index must not contain more than 2,147,483,519 documents in total across all shards that will be shrunk into a single shard on the target index as this is the maximum number of docs that can fit into a single shard.\n* The node handling the shrink process must have sufficient free disk space to accommodate a second copy of the existing index.",
        "operationId": "indices-shrink-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.shrink#index"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#target"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.shrink#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.shrink"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.shrink#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_index_template/_simulate_index/{name}": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Simulate an index",
        "description": "Get the index configuration that would be applied to the specified index from an existing index template.",
        "operationId": "indices-simulate-index-template",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the index to simulate",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If true, returns all relevant default configurations for the index template.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "overlapping": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.simulate_template:Overlapping"
                      }
                    },
                    "template": {
                      "$ref": "#/components/schemas/indices.simulate_template:Template"
                    }
                  },
                  "required": [
                    "template"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_index_template/_simulate": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Simulate an index template",
        "description": "Get the index configuration that would be applied by a particular index template.",
        "operationId": "indices-simulate-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.simulate_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#include_defaults"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.simulate_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.simulate_template#200"
          }
        }
      }
    },
    "/_index_template/_simulate/{name}": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Simulate an index template",
        "description": "Get the index configuration that would be applied by a particular index template.",
        "operationId": "indices-simulate-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.simulate_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#include_defaults"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.simulate_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.simulate_template#200"
          }
        }
      }
    },
    "/{index}/_split/{target}": {
      "put": {
        "tags": [
          "indices"
        ],
        "summary": "Split an index",
        "description": "Split an index into a new index with more primary shards.\n* Before you can split an index:\n\n* The index must be read-only.\n* The cluster health status must be green.\n\nYou can do make an index read-only with the following request using the add index block API:\n\n```\nPUT /my_source_index/_block/write\n```\n\nThe current write index on a data stream cannot be split.\nIn order to split the current write index, the data stream must first be rolled over so that a new write index is created and then the previous write index can be split.\n\nThe number of times the index can be split (and the number of shards that each original shard can be split into) is determined by the `index.number_of_routing_shards` setting.\nThe number of routing shards specifies the hashing space that is used internally to distribute documents across shards with consistent hashing.\nFor instance, a 5 shard index with `number_of_routing_shards` set to 30 (5 x 2 x 3) could be split by a factor of 2 or 3.\n\nA split operation:\n\n* Creates a new target index with the same definition as the source index, but with a larger number of primary shards.\n* Hard-links segments from the source index into the target index. If the file system doesn't support hard-linking, all segments are copied into the new index, which is a much more time consuming process.\n* Hashes all documents again, after low level files are created, to delete documents that belong to a different shard.\n* Recovers the target index as though it were a closed index which had just been re-opened.\n\nIMPORTANT: Indices can only be split if they satisfy the following requirements:\n\n* The target index must not exist.\n* The source index must have fewer primary shards than the target index.\n* The number of primary shards in the target index must be a multiple of the number of primary shards in the source index.\n* The node handling the split process must have sufficient free disk space to accommodate a second copy of the existing index.",
        "operationId": "indices-split",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.split#index"
          },
          {
            "$ref": "#/components/parameters/indices.split#target"
          },
          {
            "$ref": "#/components/parameters/indices.split#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.split#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.split#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.split"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.split#200"
          }
        },
        "x-state": "Added in 6.1.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Split an index",
        "description": "Split an index into a new index with more primary shards.\n* Before you can split an index:\n\n* The index must be read-only.\n* The cluster health status must be green.\n\nYou can do make an index read-only with the following request using the add index block API:\n\n```\nPUT /my_source_index/_block/write\n```\n\nThe current write index on a data stream cannot be split.\nIn order to split the current write index, the data stream must first be rolled over so that a new write index is created and then the previous write index can be split.\n\nThe number of times the index can be split (and the number of shards that each original shard can be split into) is determined by the `index.number_of_routing_shards` setting.\nThe number of routing shards specifies the hashing space that is used internally to distribute documents across shards with consistent hashing.\nFor instance, a 5 shard index with `number_of_routing_shards` set to 30 (5 x 2 x 3) could be split by a factor of 2 or 3.\n\nA split operation:\n\n* Creates a new target index with the same definition as the source index, but with a larger number of primary shards.\n* Hard-links segments from the source index into the target index. If the file system doesn't support hard-linking, all segments are copied into the new index, which is a much more time consuming process.\n* Hashes all documents again, after low level files are created, to delete documents that belong to a different shard.\n* Recovers the target index as though it were a closed index which had just been re-opened.\n\nIMPORTANT: Indices can only be split if they satisfy the following requirements:\n\n* The target index must not exist.\n* The source index must have fewer primary shards than the target index.\n* The number of primary shards in the target index must be a multiple of the number of primary shards in the source index.\n* The node handling the split process must have sufficient free disk space to accommodate a second copy of the existing index.",
        "operationId": "indices-split-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.split#index"
          },
          {
            "$ref": "#/components/parameters/indices.split#target"
          },
          {
            "$ref": "#/components/parameters/indices.split#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.split#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.split#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.split"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.split#200"
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_stats": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index statistics",
        "description": "For data streams, the API retrieves statistics for the stream's backing indices.\n\nBy default, the returned statistics are index-level with `primaries` and `total` aggregations.\n`primaries` are the values for only the primary shards.\n`total` are the accumulated values for both primary and replica shards.\n\nTo get shard-level statistics, set the `level` parameter to `shards`.\n\nNOTE: When moving to another node, the shard-level statistics for a shard are cleared.\nAlthough the shard is no longer part of the node, that node retains any node-level statistics to which the shard contributed.",
        "operationId": "indices-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_stats/{metric}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index statistics",
        "description": "For data streams, the API retrieves statistics for the stream's backing indices.\n\nBy default, the returned statistics are index-level with `primaries` and `total` aggregations.\n`primaries` are the values for only the primary shards.\n`total` are the accumulated values for both primary and replica shards.\n\nTo get shard-level statistics, set the `level` parameter to `shards`.\n\nNOTE: When moving to another node, the shard-level statistics for a shard are cleared.\nAlthough the shard is no longer part of the node, that node retains any node-level statistics to which the shard contributed.",
        "operationId": "indices-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#metric"
          },
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/{index}/_stats": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index statistics",
        "description": "For data streams, the API retrieves statistics for the stream's backing indices.\n\nBy default, the returned statistics are index-level with `primaries` and `total` aggregations.\n`primaries` are the values for only the primary shards.\n`total` are the accumulated values for both primary and replica shards.\n\nTo get shard-level statistics, set the `level` parameter to `shards`.\n\nNOTE: When moving to another node, the shard-level statistics for a shard are cleared.\nAlthough the shard is no longer part of the node, that node retains any node-level statistics to which the shard contributed.",
        "operationId": "indices-stats-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#index"
          },
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/{index}/_stats/{metric}": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Get index statistics",
        "description": "For data streams, the API retrieves statistics for the stream's backing indices.\n\nBy default, the returned statistics are index-level with `primaries` and `total` aggregations.\n`primaries` are the values for only the primary shards.\n`total` are the accumulated values for both primary and replica shards.\n\nTo get shard-level statistics, set the `level` parameter to `shards`.\n\nNOTE: When moving to another node, the shard-level statistics for a shard are cleared.\nAlthough the shard is no longer part of the node, that node retains any node-level statistics to which the shard contributed.",
        "operationId": "indices-stats-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#index"
          },
          {
            "$ref": "#/components/parameters/indices.stats#metric"
          },
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/{index}/_unfreeze": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Unfreeze an index",
        "description": "When a frozen index is unfrozen, the index goes through the normal recovery process and becomes writeable again.",
        "operationId": "indices-unfreeze",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Identifier for the index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "shards_acknowledged"
                  ]
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Added in 6.6.0"
      }
    },
    "/_aliases": {
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Create or update an alias",
        "description": "Adds a data stream or index to an alias.",
        "operationId": "indices-update-aliases",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "actions": {
                    "description": "Actions to perform.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/indices.update_aliases:Action"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_validate/query": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Validate a query",
        "description": "Validates a query without running it.",
        "operationId": "indices-validate-query",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        },
        "x-state": "Added in 1.3.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Validate a query",
        "description": "Validates a query without running it.",
        "operationId": "indices-validate-query-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/{index}/_validate/query": {
      "get": {
        "tags": [
          "indices"
        ],
        "summary": "Validate a query",
        "description": "Validates a query without running it.",
        "operationId": "indices-validate-query-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#index"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        },
        "x-state": "Added in 1.3.0"
      },
      "post": {
        "tags": [
          "indices"
        ],
        "summary": "Validate a query",
        "description": "Validates a query without running it.",
        "operationId": "indices-validate-query-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#index"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_inference/{inference_id}": {
      "get": {
        "tags": [
          "inference"
        ],
        "summary": "Get an inference endpoint",
        "operationId": "inference-get-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.get#inference_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.get#200"
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "put": {
        "tags": [
          "inference"
        ],
        "summary": "Create an inference endpoint",
        "description": "When you create an inference endpoint, the associated machine learning model is automatically deployed if it is not already running.\nAfter creating the endpoint, wait for the model deployment to complete before using it.\nTo verify the deployment status, use the get trained model statistics API.\nLook for `\"state\": \"fully_allocated\"` in the response and ensure that the `\"allocation_count\"` matches the `\"target_allocation_count\"`.\nAvoid creating multiple endpoints for the same model unless required, as each endpoint consumes significant resources.\n\nIMPORTANT: The inference APIs enable you to use certain services, such as built-in machine learning models (ELSER, E5), models uploaded through Eland, Cohere, OpenAI, Mistral, Azure OpenAI, Google AI Studio, Google Vertex AI, Anthropic, Watsonx.ai, or Hugging Face.\nFor built-in models and models uploaded through Eland, the inference APIs offer an alternative way to use and manage trained models.\nHowever, if you do not plan to use the inference APIs to use these models or if you want to use non-NLP models, use the machine learning trained model APIs.",
        "operationId": "inference-put",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.put#inference_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.put"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.put#200"
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "post": {
        "tags": [
          "inference"
        ],
        "summary": "Perform inference on the service",
        "operationId": "inference-inference",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.inference#inference_id"
          },
          {
            "$ref": "#/components/parameters/inference.inference#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.inference"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.inference#200"
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "delete": {
        "tags": [
          "inference"
        ],
        "summary": "Delete an inference endpoint",
        "operationId": "inference-delete",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.delete#inference_id"
          },
          {
            "$ref": "#/components/parameters/inference.delete#dry_run"
          },
          {
            "$ref": "#/components/parameters/inference.delete#force"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.delete#200"
          }
        },
        "x-state": "Added in 8.11.0"
      }
    },
    "/_inference/{task_type}/{inference_id}": {
      "get": {
        "tags": [
          "inference"
        ],
        "summary": "Get an inference endpoint",
        "operationId": "inference-get-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.get#task_type"
          },
          {
            "$ref": "#/components/parameters/inference.get#inference_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.get#200"
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "put": {
        "tags": [
          "inference"
        ],
        "summary": "Create an inference endpoint",
        "description": "When you create an inference endpoint, the associated machine learning model is automatically deployed if it is not already running.\nAfter creating the endpoint, wait for the model deployment to complete before using it.\nTo verify the deployment status, use the get trained model statistics API.\nLook for `\"state\": \"fully_allocated\"` in the response and ensure that the `\"allocation_count\"` matches the `\"target_allocation_count\"`.\nAvoid creating multiple endpoints for the same model unless required, as each endpoint consumes significant resources.\n\nIMPORTANT: The inference APIs enable you to use certain services, such as built-in machine learning models (ELSER, E5), models uploaded through Eland, Cohere, OpenAI, Mistral, Azure OpenAI, Google AI Studio, Google Vertex AI, Anthropic, Watsonx.ai, or Hugging Face.\nFor built-in models and models uploaded through Eland, the inference APIs offer an alternative way to use and manage trained models.\nHowever, if you do not plan to use the inference APIs to use these models or if you want to use non-NLP models, use the machine learning trained model APIs.",
        "operationId": "inference-put-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.put#task_type"
          },
          {
            "$ref": "#/components/parameters/inference.put#inference_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.put"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.put#200"
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "post": {
        "tags": [
          "inference"
        ],
        "summary": "Perform inference on the service",
        "operationId": "inference-inference-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.inference#task_type"
          },
          {
            "$ref": "#/components/parameters/inference.inference#inference_id"
          },
          {
            "$ref": "#/components/parameters/inference.inference#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.inference"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.inference#200"
          }
        },
        "x-state": "Added in 8.11.0"
      },
      "delete": {
        "tags": [
          "inference"
        ],
        "summary": "Delete an inference endpoint",
        "operationId": "inference-delete-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.delete#task_type"
          },
          {
            "$ref": "#/components/parameters/inference.delete#inference_id"
          },
          {
            "$ref": "#/components/parameters/inference.delete#dry_run"
          },
          {
            "$ref": "#/components/parameters/inference.delete#force"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.delete#200"
          }
        },
        "x-state": "Added in 8.11.0"
      }
    },
    "/_inference": {
      "get": {
        "tags": [
          "inference"
        ],
        "summary": "Get an inference endpoint",
        "operationId": "inference-get",
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.get#200"
          }
        },
        "x-state": "Added in 8.11.0"
      }
    },
    "/_inference/{inference_id}/_stream": {
      "post": {
        "tags": [
          "inference"
        ],
        "summary": "Perform streaming inference",
        "description": "Get real-time responses for completion tasks by delivering answers incrementally, reducing response times during computation.\nThis API works only with the completion task type.\n\nIMPORTANT: The inference APIs enable you to use certain services, such as built-in machine learning models (ELSER, E5), models uploaded through Eland, Cohere, OpenAI, Azure, Google AI Studio, Google Vertex AI, Anthropic, Watsonx.ai, or Hugging Face. For built-in models and models uploaded through Eland, the inference APIs offer an alternative way to use and manage trained models. However, if you do not plan to use the inference APIs to use these models or if you want to use non-NLP models, use the machine learning trained model APIs.\n\nThis API requires the `monitor_inference` cluster privilege (the built-in `inference_admin` and `inference_user` roles grant this privilege). You must use a client that supports streaming.",
        "operationId": "inference-stream-inference",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.stream_inference#inference_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.stream_inference"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.stream_inference#200"
          }
        },
        "x-state": "Added in 8.16.0"
      }
    },
    "/_inference/{task_type}/{inference_id}/_stream": {
      "post": {
        "tags": [
          "inference"
        ],
        "summary": "Perform streaming inference",
        "description": "Get real-time responses for completion tasks by delivering answers incrementally, reducing response times during computation.\nThis API works only with the completion task type.\n\nIMPORTANT: The inference APIs enable you to use certain services, such as built-in machine learning models (ELSER, E5), models uploaded through Eland, Cohere, OpenAI, Azure, Google AI Studio, Google Vertex AI, Anthropic, Watsonx.ai, or Hugging Face. For built-in models and models uploaded through Eland, the inference APIs offer an alternative way to use and manage trained models. However, if you do not plan to use the inference APIs to use these models or if you want to use non-NLP models, use the machine learning trained model APIs.\n\nThis API requires the `monitor_inference` cluster privilege (the built-in `inference_admin` and `inference_user` roles grant this privilege). You must use a client that supports streaming.",
        "operationId": "inference-stream-inference-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.stream_inference#task_type"
          },
          {
            "$ref": "#/components/parameters/inference.stream_inference#inference_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.stream_inference"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.stream_inference#200"
          }
        },
        "x-state": "Added in 8.16.0"
      }
    },
    "/_inference/{inference_id}/_update": {
      "post": {
        "tags": [
          "inference"
        ],
        "summary": "Update an inference endpoint",
        "description": "Modify `task_settings`, secrets (within `service_settings`), or `num_allocations` for an inference endpoint, depending on the specific endpoint service and `task_type`.\n\nIMPORTANT: The inference APIs enable you to use certain services, such as built-in machine learning models (ELSER, E5), models uploaded through Eland, Cohere, OpenAI, Azure, Google AI Studio, Google Vertex AI, Anthropic, Watsonx.ai, or Hugging Face.\nFor built-in models and models uploaded through Eland, the inference APIs offer an alternative way to use and manage trained models.\nHowever, if you do not plan to use the inference APIs to use these models or if you want to use non-NLP models, use the machine learning trained model APIs.",
        "operationId": "inference-update",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.update#inference_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.update"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.update#200"
          }
        },
        "x-state": "Added in 8.17.0"
      }
    },
    "/_inference/{task_type}/{inference_id}/_update": {
      "post": {
        "tags": [
          "inference"
        ],
        "summary": "Update an inference endpoint",
        "description": "Modify `task_settings`, secrets (within `service_settings`), or `num_allocations` for an inference endpoint, depending on the specific endpoint service and `task_type`.\n\nIMPORTANT: The inference APIs enable you to use certain services, such as built-in machine learning models (ELSER, E5), models uploaded through Eland, Cohere, OpenAI, Azure, Google AI Studio, Google Vertex AI, Anthropic, Watsonx.ai, or Hugging Face.\nFor built-in models and models uploaded through Eland, the inference APIs offer an alternative way to use and manage trained models.\nHowever, if you do not plan to use the inference APIs to use these models or if you want to use non-NLP models, use the machine learning trained model APIs.",
        "operationId": "inference-update-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/inference.update#task_type"
          },
          {
            "$ref": "#/components/parameters/inference.update#inference_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/inference.update"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/inference.update#200"
          }
        },
        "x-state": "Added in 8.17.0"
      }
    },
    "/": {
      "get": {
        "tags": [
          "info"
        ],
        "summary": "Get cluster info",
        "description": "Get basic build, version, and cluster information.",
        "operationId": "info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "cluster_uuid": {
                      "$ref": "#/components/schemas/_types:Uuid"
                    },
                    "name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "tagline": {
                      "type": "string"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:ElasticsearchVersionInfo"
                    }
                  },
                  "required": [
                    "cluster_name",
                    "cluster_uuid",
                    "name",
                    "tagline",
                    "version"
                  ]
                }
              }
            }
          }
        }
      },
      "head": {
        "tags": [
          "cluster"
        ],
        "summary": "Ping the cluster",
        "description": "Get information about whether the cluster is running.",
        "operationId": "ping",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_ingest/geoip/database/{id}": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get GeoIP database configurations",
        "description": "Get information about one or more IP geolocation database configurations.",
        "operationId": "ingest-get-geoip-database-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_geoip_database#id"
          },
          {
            "$ref": "#/components/parameters/ingest.get_geoip_database#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_geoip_database#200"
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "put": {
        "tags": [
          "ingest"
        ],
        "summary": "Create or update a GeoIP database configuration",
        "description": "Refer to the create or update IP geolocation database configuration API.",
        "operationId": "ingest-put-geoip-database",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "ID of the database configuration to create or update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "name": {
                    "$ref": "#/components/schemas/_types:Name"
                  },
                  "maxmind": {
                    "$ref": "#/components/schemas/ingest._types:Maxmind"
                  }
                },
                "required": [
                  "name",
                  "maxmind"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "delete": {
        "tags": [
          "ingest"
        ],
        "summary": "Delete GeoIP database configurations",
        "description": "Delete one or more IP geolocation database configurations.",
        "operationId": "ingest-delete-geoip-database",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A comma-separated list of geoip database configurations to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_ingest/ip_location/database/{id}": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get IP geolocation database configurations",
        "operationId": "ingest-get-ip-location-database-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_ip_location_database#id"
          },
          {
            "$ref": "#/components/parameters/ingest.get_ip_location_database#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_ip_location_database#200"
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "put": {
        "tags": [
          "ingest"
        ],
        "summary": "Create or update an IP geolocation database configuration",
        "operationId": "ingest-put-ip-location-database",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The database configuration identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nA value of `-1` indicates that the request should never time out.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response from all relevant nodes in the cluster after updating the cluster metadata.\nIf no response is received before the timeout expires, the cluster metadata update still applies but the response indicates that it was not completely acknowledged.\nA value of `-1` indicates that the request should never time out.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ingest._types:DatabaseConfiguration"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "delete": {
        "tags": [
          "ingest"
        ],
        "summary": "Delete IP geolocation database configurations",
        "operationId": "ingest-delete-ip-location-database",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A comma-separated list of IP location database configurations.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nA value of `-1` indicates that the request should never time out.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nA value of `-1` indicates that the request should never time out.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_ingest/pipeline/{id}": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get pipelines",
        "description": "Get information about one or more ingest pipelines.\nThis API returns a local reference of the pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html"
        },
        "operationId": "ingest-get-pipeline-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#id"
          },
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#summary"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_pipeline#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "put": {
        "tags": [
          "ingest"
        ],
        "summary": "Create or update a pipeline",
        "description": "Changes made using this API take effect immediately.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html"
        },
        "operationId": "ingest-put-pipeline",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "ID of the ingest pipeline to create or update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "if_version",
            "description": "Required version for optimistic concurrency control for pipeline updates",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "description": {
                    "description": "Description of the ingest pipeline.",
                    "type": "string"
                  },
                  "on_failure": {
                    "description": "Processors to run immediately after a processor failure. Each processor supports a processor-level `on_failure` value. If a processor without an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter as a fallback. The processors in this parameter run sequentially in the order specified. Elasticsearch will not attempt to run the pipeline's remaining processors.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
                    }
                  },
                  "processors": {
                    "description": "Processors used to perform transformations on documents before indexing. Processors run sequentially in the order specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
                    }
                  },
                  "version": {
                    "$ref": "#/components/schemas/_types:VersionNumber"
                  },
                  "deprecated": {
                    "description": "Marks this ingest pipeline as deprecated.\nWhen a deprecated ingest pipeline is referenced as the default or final pipeline when creating or updating a non-deprecated index template, Elasticsearch will emit a deprecation warning.",
                    "type": "boolean"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "delete": {
        "tags": [
          "ingest"
        ],
        "summary": "Delete pipelines",
        "description": "Delete one or more ingest pipelines.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html"
        },
        "operationId": "ingest-delete-pipeline",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Pipeline ID or wildcard expression of pipeline IDs used to limit the request.\nTo delete all ingest pipelines in a cluster, use a value of `*`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_ingest/geoip/stats": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get GeoIP statistics",
        "description": "Get download statistics for GeoIP2 databases that are used with the GeoIP processor.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/geoip-processor.html"
        },
        "operationId": "ingest-geo-ip-stats",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stats": {
                      "$ref": "#/components/schemas/ingest.geo_ip_stats:GeoIpDownloadStatistics"
                    },
                    "nodes": {
                      "description": "Downloaded GeoIP2 databases for each node.",
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/ingest.geo_ip_stats:GeoIpNodeDatabases"
                      }
                    }
                  },
                  "required": [
                    "stats",
                    "nodes"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_ingest/geoip/database": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get GeoIP database configurations",
        "description": "Get information about one or more IP geolocation database configurations.",
        "operationId": "ingest-get-geoip-database",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_geoip_database#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_geoip_database#200"
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_ingest/ip_location/database": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get IP geolocation database configurations",
        "operationId": "ingest-get-ip-location-database",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_ip_location_database#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_ip_location_database#200"
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_ingest/pipeline": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Get pipelines",
        "description": "Get information about one or more ingest pipelines.\nThis API returns a local reference of the pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html"
        },
        "operationId": "ingest-get-pipeline",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#summary"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_pipeline#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_ingest/processor/grok": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Run a grok processor",
        "description": "Extract structured fields out of a single text field within a document.\nYou must choose which field to extract matched fields from, as well as the grok pattern you expect will match.\nA grok pattern is like a regular expression that supports aliased expressions that can be reused.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/grok-processor.html"
        },
        "operationId": "ingest-processor-grok",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "patterns": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "patterns"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_ingest/pipeline/_simulate": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate a pipeline",
        "description": "Run an ingest pipeline against a set of provided documents.\nYou can either specify an existing pipeline to use with the provided documents or supply a pipeline definition in the body of the request.",
        "operationId": "ingest-simulate",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate a pipeline",
        "description": "Run an ingest pipeline against a set of provided documents.\nYou can either specify an existing pipeline to use with the provided documents or supply a pipeline definition in the body of the request.",
        "operationId": "ingest-simulate-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_ingest/pipeline/{id}/_simulate": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate a pipeline",
        "description": "Run an ingest pipeline against a set of provided documents.\nYou can either specify an existing pipeline to use with the provided documents or supply a pipeline definition in the body of the request.",
        "operationId": "ingest-simulate-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#id"
          },
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate a pipeline",
        "description": "Run an ingest pipeline against a set of provided documents.\nYou can either specify an existing pipeline to use with the provided documents or supply a pipeline definition in the body of the request.",
        "operationId": "ingest-simulate-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#id"
          },
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/{index}/_knn_search": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a knn search",
        "description": "NOTE: The kNN search API has been replaced by the `knn` option in the search API.\n\nPerform a k-nearest neighbor (kNN) search on a dense_vector field and return the matching documents.\nGiven a query vector, the API finds the k closest vectors and returns those documents as search hits.\n\nElasticsearch uses the HNSW algorithm to support efficient kNN search.\nLike most kNN algorithms, HNSW is an approximate method that sacrifices result accuracy for improved search speed.\nThis means the results returned are not always the true k closest neighbors.\n\nThe kNN search API supports restricting the search using a filter.\nThe search will return the top k documents that also match the filter query.\n\nA kNN search response has the exact same structure as a search API response.\nHowever, certain sections have a meaning specific to kNN search:\n\n* The document `_score` is determined by the similarity between the query and document vector.\n* The `hits.total` object contains the total number of nearest neighbor candidates considered, which is `num_candidates * num_shards`. The `hits.total.relation` will always be `eq`, indicating an exact value.",
        "operationId": "knn-search",
        "parameters": [
          {
            "$ref": "#/components/parameters/knn_search#index"
          },
          {
            "$ref": "#/components/parameters/knn_search#routing"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/knn_search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/knn_search#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a knn search",
        "description": "NOTE: The kNN search API has been replaced by the `knn` option in the search API.\n\nPerform a k-nearest neighbor (kNN) search on a dense_vector field and return the matching documents.\nGiven a query vector, the API finds the k closest vectors and returns those documents as search hits.\n\nElasticsearch uses the HNSW algorithm to support efficient kNN search.\nLike most kNN algorithms, HNSW is an approximate method that sacrifices result accuracy for improved search speed.\nThis means the results returned are not always the true k closest neighbors.\n\nThe kNN search API supports restricting the search using a filter.\nThe search will return the top k documents that also match the filter query.\n\nA kNN search response has the exact same structure as a search API response.\nHowever, certain sections have a meaning specific to kNN search:\n\n* The document `_score` is determined by the similarity between the query and document vector.\n* The `hits.total` object contains the total number of nearest neighbor candidates considered, which is `num_candidates * num_shards`. The `hits.total.relation` will always be `eq`, indicating an exact value.",
        "operationId": "knn-search-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/knn_search#index"
          },
          {
            "$ref": "#/components/parameters/knn_search#routing"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/knn_search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/knn_search#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_license": {
      "get": {
        "tags": [
          "license"
        ],
        "summary": "Get license information",
        "description": "Get information about your Elastic license including its type, its status, when it was issued, and when it expires.\n\nNOTE: If the master node is generating a new cluster state, the get license API may return a `404 Not Found` response.\nIf you receive an unexpected 404 response after cluster startup, wait a short period and retry the request.",
        "operationId": "license-get",
        "parameters": [
          {
            "in": "query",
            "name": "accept_enterprise",
            "description": "If `true`, this parameter returns enterprise for Enterprise license types. If `false`, this parameter returns platinum for both platinum and enterprise license types. This behavior is maintained for backwards compatibility.\nThis parameter is deprecated and will always be set to true in 8.x.",
            "deprecated": true,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "Specifies whether to retrieve local information. The default value is `false`, which means the information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "license": {
                      "$ref": "#/components/schemas/license.get:LicenseInformation"
                    }
                  },
                  "required": [
                    "license"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "license"
        ],
        "summary": "Update the license",
        "description": "You can update your license at runtime without shutting down your nodes.\nLicense updates take effect immediately.\nIf the license you are installing does not support all of the features that were available with your previous license, however, you are notified in the response.\nYou must then re-submit the API request with the acknowledge parameter set to true.\n\nNOTE: If Elasticsearch security features are enabled and you are installing a gold or higher license, you must enable TLS on the transport networking layer before you install the license.\nIf the operator privileges feature is enabled, only operator users can use this API.",
        "operationId": "license-post",
        "parameters": [
          {
            "$ref": "#/components/parameters/license.post#acknowledge"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/license.post"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/license.post#200"
          }
        }
      },
      "post": {
        "tags": [
          "license"
        ],
        "summary": "Update the license",
        "description": "You can update your license at runtime without shutting down your nodes.\nLicense updates take effect immediately.\nIf the license you are installing does not support all of the features that were available with your previous license, however, you are notified in the response.\nYou must then re-submit the API request with the acknowledge parameter set to true.\n\nNOTE: If Elasticsearch security features are enabled and you are installing a gold or higher license, you must enable TLS on the transport networking layer before you install the license.\nIf the operator privileges feature is enabled, only operator users can use this API.",
        "operationId": "license-post-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/license.post#acknowledge"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/license.post"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/license.post#200"
          }
        }
      },
      "delete": {
        "tags": [
          "license"
        ],
        "summary": "Delete the license",
        "description": "When the license expires, your subscription level reverts to Basic.\n\nIf the operator privileges feature is enabled, only operator users can use this API.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/kibana/current/managing-licenses.html"
        },
        "operationId": "license-delete",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_license/basic_status": {
      "get": {
        "tags": [
          "license"
        ],
        "summary": "Get the basic license status",
        "operationId": "license-get-basic-status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "eligible_to_start_basic": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "eligible_to_start_basic"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_license/trial_status": {
      "get": {
        "tags": [
          "license"
        ],
        "summary": "Get the trial status",
        "operationId": "license-get-trial-status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "eligible_to_start_trial": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "eligible_to_start_trial"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_license/start_basic": {
      "post": {
        "tags": [
          "license"
        ],
        "summary": "Start a basic license",
        "description": "Start an indefinite basic license, which gives access to all the basic features.\n\nNOTE: In order to start a basic license, you must not currently have a basic license.\n\nIf the basic license does not support all of the features that are available with your current license, however, you are notified in the response.\nYou must then re-submit the API request with the `acknowledge` parameter set to `true`.\n\nTo check the status of your basic license, use the get basic license API.",
        "operationId": "license-post-start-basic",
        "parameters": [
          {
            "in": "query",
            "name": "acknowledge",
            "description": "whether the user has acknowledged acknowledge messages (default: false)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "basic_was_started": {
                      "type": "boolean"
                    },
                    "error_message": {
                      "type": "string"
                    },
                    "type": {
                      "$ref": "#/components/schemas/license._types:LicenseType"
                    },
                    "acknowledge": {
                      "type": "object",
                      "additionalProperties": {
                        "oneOf": [
                          {
                            "type": "string"
                          },
                          {
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          }
                        ]
                      }
                    }
                  },
                  "required": [
                    "acknowledged",
                    "basic_was_started"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_license/start_trial": {
      "post": {
        "tags": [
          "license"
        ],
        "summary": "Start a trial",
        "description": "Start a 30-day trial, which gives access to all subscription features.\n\nNOTE: You are allowed to start a trial only if your cluster has not already activated a trial for the current major product version.\nFor example, if you have already activated a trial for v8.0, you cannot start a new trial until v9.0. You can, however, request an extended trial at https://www.elastic.co/trialextension.\n\nTo check the status of your trial, use the get trial status API.",
        "operationId": "license-post-start-trial",
        "parameters": [
          {
            "in": "query",
            "name": "acknowledge",
            "description": "whether the user has acknowledged acknowledge messages (default: false)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "type_query_string",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "error_message": {
                      "type": "string"
                    },
                    "trial_was_started": {
                      "type": "boolean"
                    },
                    "type": {
                      "$ref": "#/components/schemas/license._types:LicenseType"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "trial_was_started"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_logstash/pipeline/{id}": {
      "get": {
        "tags": [
          "logstash"
        ],
        "summary": "Get Logstash pipelines",
        "description": "Get pipelines that are used for Logstash Central Management.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/logstash/current/logstash-centralized-pipeline-management.html"
        },
        "operationId": "logstash-get-pipeline-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/logstash.get_pipeline#id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/logstash.get_pipeline#200"
          }
        },
        "x-state": "Added in 7.12.0"
      },
      "put": {
        "tags": [
          "logstash"
        ],
        "summary": "Create or update a Logstash pipeline",
        "description": "Create a pipeline that is used for Logstash Central Management.\nIf the specified pipeline exists, it is replaced.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/logstash/current/logstash-centralized-pipeline-management.html"
        },
        "operationId": "logstash-put-pipeline",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "An identifier for the pipeline.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/logstash._types:Pipeline"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 7.12.0"
      },
      "delete": {
        "tags": [
          "logstash"
        ],
        "summary": "Delete a Logstash pipeline",
        "description": "Delete a pipeline that is used for Logstash Central Management.\nIf the request succeeds, you receive an empty response with an appropriate status code.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/logstash/current/logstash-centralized-pipeline-management.html"
        },
        "operationId": "logstash-delete-pipeline",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "An identifier for the pipeline.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 7.12.0"
      }
    },
    "/_logstash/pipeline": {
      "get": {
        "tags": [
          "logstash"
        ],
        "summary": "Get Logstash pipelines",
        "description": "Get pipelines that are used for Logstash Central Management.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/logstash/current/logstash-centralized-pipeline-management.html"
        },
        "operationId": "logstash-get-pipeline",
        "responses": {
          "200": {
            "$ref": "#/components/responses/logstash.get_pipeline#200"
          }
        },
        "x-state": "Added in 7.12.0"
      }
    },
    "/_mget": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple documents",
        "description": "Get multiple JSON documents by ID from one or more indices.\nIf you specify an index in the request URI, you only need to specify the document IDs in the request body.\nTo ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.\n\n**Filter source fields**\n\nBy default, the `_source` field is returned for every document (if stored).\nUse the `_source` and `_source_include` or `source_exclude` attributes to filter what fields are returned for a particular document.\nYou can include the `_source`, `_source_includes`, and `_source_excludes` query parameters in the request URI to specify the defaults to use when there are no per-document instructions.\n\n**Get stored fields**\n\nUse the `stored_fields` attribute to specify the set of stored fields you want to retrieve.\nAny requested fields that are not stored are ignored.\nYou can include the `stored_fields` query parameter in the request URI to specify the defaults to use when there are no per-document instructions.",
        "operationId": "mget",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#force_synthetic_source"
          },
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        },
        "x-state": "Added in 1.3.0"
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple documents",
        "description": "Get multiple JSON documents by ID from one or more indices.\nIf you specify an index in the request URI, you only need to specify the document IDs in the request body.\nTo ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.\n\n**Filter source fields**\n\nBy default, the `_source` field is returned for every document (if stored).\nUse the `_source` and `_source_include` or `source_exclude` attributes to filter what fields are returned for a particular document.\nYou can include the `_source`, `_source_includes`, and `_source_excludes` query parameters in the request URI to specify the defaults to use when there are no per-document instructions.\n\n**Get stored fields**\n\nUse the `stored_fields` attribute to specify the set of stored fields you want to retrieve.\nAny requested fields that are not stored are ignored.\nYou can include the `stored_fields` query parameter in the request URI to specify the defaults to use when there are no per-document instructions.",
        "operationId": "mget-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#force_synthetic_source"
          },
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/{index}/_mget": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple documents",
        "description": "Get multiple JSON documents by ID from one or more indices.\nIf you specify an index in the request URI, you only need to specify the document IDs in the request body.\nTo ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.\n\n**Filter source fields**\n\nBy default, the `_source` field is returned for every document (if stored).\nUse the `_source` and `_source_include` or `source_exclude` attributes to filter what fields are returned for a particular document.\nYou can include the `_source`, `_source_includes`, and `_source_excludes` query parameters in the request URI to specify the defaults to use when there are no per-document instructions.\n\n**Get stored fields**\n\nUse the `stored_fields` attribute to specify the set of stored fields you want to retrieve.\nAny requested fields that are not stored are ignored.\nYou can include the `stored_fields` query parameter in the request URI to specify the defaults to use when there are no per-document instructions.",
        "operationId": "mget-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#index"
          },
          {
            "$ref": "#/components/parameters/mget#force_synthetic_source"
          },
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        },
        "x-state": "Added in 1.3.0"
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple documents",
        "description": "Get multiple JSON documents by ID from one or more indices.\nIf you specify an index in the request URI, you only need to specify the document IDs in the request body.\nTo ensure fast responses, this multi get (mget) API responds with partial results if one or more shards fail.\n\n**Filter source fields**\n\nBy default, the `_source` field is returned for every document (if stored).\nUse the `_source` and `_source_include` or `source_exclude` attributes to filter what fields are returned for a particular document.\nYou can include the `_source`, `_source_includes`, and `_source_excludes` query parameters in the request URI to specify the defaults to use when there are no per-document instructions.\n\n**Get stored fields**\n\nUse the `stored_fields` attribute to specify the set of stored fields you want to retrieve.\nAny requested fields that are not stored are ignored.\nYou can include the `stored_fields` query parameter in the request URI to specify the defaults to use when there are no per-document instructions.",
        "operationId": "mget-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#index"
          },
          {
            "$ref": "#/components/parameters/mget#force_synthetic_source"
          },
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_migration/deprecations": {
      "get": {
        "tags": [
          "migration"
        ],
        "summary": "Get deprecation information",
        "description": "Get information about different cluster, node, and index level settings that use deprecated features that will be removed or changed in the next major version.\n\nTIP: This APIs is designed for indirect use by the Upgrade Assistant.\nYou are strongly recommended to use the Upgrade Assistant.",
        "operationId": "migration-deprecations",
        "responses": {
          "200": {
            "$ref": "#/components/responses/migration.deprecations#200"
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/{index}/_migration/deprecations": {
      "get": {
        "tags": [
          "migration"
        ],
        "summary": "Get deprecation information",
        "description": "Get information about different cluster, node, and index level settings that use deprecated features that will be removed or changed in the next major version.\n\nTIP: This APIs is designed for indirect use by the Upgrade Assistant.\nYou are strongly recommended to use the Upgrade Assistant.",
        "operationId": "migration-deprecations-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/migration.deprecations#index"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/migration.deprecations#200"
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_migration/system_features": {
      "get": {
        "tags": [
          "migration"
        ],
        "summary": "Get feature migration information",
        "description": "Version upgrades sometimes require changes to how features store configuration information and data in system indices.\nCheck which features need to be migrated and the status of any migrations that are in progress.\n\nTIP: This API is designed for indirect use by the Upgrade Assistant.\nYou are strongly recommended to use the Upgrade Assistant.",
        "operationId": "migration-get-feature-upgrade-status",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "features": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/migration.get_feature_upgrade_status:MigrationFeature"
                      }
                    },
                    "migration_status": {
                      "$ref": "#/components/schemas/migration.get_feature_upgrade_status:MigrationStatus"
                    }
                  },
                  "required": [
                    "features",
                    "migration_status"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.16.0"
      },
      "post": {
        "tags": [
          "migration"
        ],
        "summary": "Start the feature migration",
        "description": "Version upgrades sometimes require changes to how features store configuration information and data in system indices.\nThis API starts the automatic migration process.\n\nSome functionality might be temporarily unavailable during the migration process.\n\nTIP: The API is designed for indirect use by the Upgrade Assistant. We strongly recommend you use the Upgrade Assistant.",
        "operationId": "migration-post-feature-upgrade",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "accepted": {
                      "type": "boolean"
                    },
                    "features": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/migration.post_feature_upgrade:MigrationFeature"
                      }
                    }
                  },
                  "required": [
                    "accepted",
                    "features"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.16.0"
      }
    },
    "/_ml/trained_models/{model_id}/deployment/cache/_clear": {
      "post": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Clear trained model deployment cache",
        "description": "Cache will be cleared on all nodes where the trained model is assigned.\nA trained model deployment may have an inference cache enabled.\nAs requests are handled by each allocated node, their responses may be cached on that individual node.\nCalling this API clears the caches without restarting the deployment.",
        "operationId": "ml-clear-trained-model-deployment-cache",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cleared": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "cleared"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.5.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_close": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Close anomaly detection jobs",
        "description": "A job can be opened and closed multiple times throughout its lifecycle. A closed job cannot receive data or perform analysis operations, but you can still explore and navigate results.\nWhen you close a job, it runs housekeeping tasks such as pruning the model history, flushing buffers, calculating final results and persisting the model snapshots. Depending upon the size of the job, it could take several minutes to close and the equivalent time to re-open. After it is closed, the job has a minimal overhead on the cluster except for maintaining its meta data. Therefore it is a best practice to close jobs that are no longer required to process data.\nIf you close an anomaly detection job whose datafeed is running, the request first tries to stop the datafeed. This behavior is equivalent to calling stop datafeed API with the same timeout and force parameters as the close job request.\nWhen a datafeed that has a specified end date stops, it automatically closes its associated job.",
        "operationId": "ml-close-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job. It can be a job identifier, a group name, or a wildcard expression. You can close multiple anomaly detection jobs in a single API request by using a group name, a comma-separated list of jobs, or a wildcard expression. You can close all jobs by using `_all` or by specifying `*` as the job identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request: contains wildcard expressions and there are no jobs that match; contains the  `_all` string or no identifiers and there are no matches; or contains wildcard expressions and there are only partial matches. By default, it returns an empty jobs array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Use to close a failed job, or to forcefully close a job which has not responded to its initial close request; the request returns without performing the associated actions such as flushing buffers and persisting the model snapshots.\nIf you want the job to be in a consistent state after the close job API returns, do not set to `true`. This parameter should be used only in situations where the job has already failed or where you are not interested in results the job might have recently produced or might produce in the future.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait until a job has closed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_no_match": {
                    "description": "Refer to the description for the `allow_no_match` query parameter.",
                    "type": "boolean"
                  },
                  "force": {
                    "description": "Refer to the descriptiion for the `force` query parameter.",
                    "type": "boolean"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "closed": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "closed"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/calendars/{calendar_id}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get calendar configuration info",
        "operationId": "ml-get-calendars-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#calendar_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "put": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Create a calendar",
        "operationId": "ml-put-calendar",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "job_ids": {
                    "description": "An array of anomaly detection job identifiers.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "description": {
                    "description": "A description of the calendar.",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "calendar_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "description": {
                      "description": "A description of the calendar.",
                      "type": "string"
                    },
                    "job_ids": {
                      "$ref": "#/components/schemas/_types:Ids"
                    }
                  },
                  "required": [
                    "calendar_id",
                    "job_ids"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get calendar configuration info",
        "operationId": "ml-get-calendars-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#calendar_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete a calendar",
        "description": "Removes all scheduled events from a calendar, then deletes it.",
        "operationId": "ml-delete-calendar",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_ml/calendars/{calendar_id}/events/{event_id}": {
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete events from a calendar",
        "operationId": "ml-delete-calendar-event",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "event_id",
            "description": "Identifier for the scheduled event.\nYou can obtain this identifier by using the get calendar events API.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_ml/calendars/{calendar_id}/jobs/{job_id}": {
      "put": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Add anomaly detection job to calendar",
        "operationId": "ml-put-calendar-job",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "job_id",
            "description": "An identifier for the anomaly detection jobs. It can be a job identifier, a group name, or a comma-separated list of jobs or groups.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "calendar_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "description": {
                      "description": "A description of the calendar.",
                      "type": "string"
                    },
                    "job_ids": {
                      "$ref": "#/components/schemas/_types:Ids"
                    }
                  },
                  "required": [
                    "calendar_id",
                    "job_ids"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete anomaly jobs from a calendar",
        "operationId": "ml-delete-calendar-job",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "job_id",
            "description": "An identifier for the anomaly detection jobs. It can be a job identifier, a group name, or a\ncomma-separated list of jobs or groups.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "calendar_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "description": {
                      "description": "A description of the calendar.",
                      "type": "string"
                    },
                    "job_ids": {
                      "$ref": "#/components/schemas/_types:Ids"
                    }
                  },
                  "required": [
                    "calendar_id",
                    "job_ids"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_ml/data_frame/analytics/{id}": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Get data frame analytics job configuration info",
        "description": "You can get information for multiple data frame analytics jobs in a single\nAPI request by using a comma-separated list of data frame analytics jobs or a\nwildcard expression.",
        "operationId": "ml-get-data-frame-analytics",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#id"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.3.0"
      },
      "put": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Create a data frame analytics job",
        "description": "This API creates a data frame analytics job that performs an analysis on the\nsource indices and stores the outcome in a destination index.\nBy default, the query used in the source configuration is `{\"match_all\": {}}`.\n\nIf the destination index does not exist, it is created automatically when you start the job.\n\nIf you supply only a subset of the regression or classification parameters, hyperparameter optimization occurs. It determines a value for each of the undefined parameters.",
        "operationId": "ml-put-data-frame-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_lazy_start": {
                    "description": "Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node. If\nset to `false` and a machine learning node with capacity to run the job\ncannot be immediately found, the API returns an error. If set to `true`,\nthe API does not return an error; the job waits in the `starting` state\nuntil sufficient machine learning node capacity is available. This\nbehavior is also affected by the cluster-wide\n`xpack.ml.max_lazy_ml_nodes` setting.",
                    "type": "boolean"
                  },
                  "analysis": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                  },
                  "analyzed_fields": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                  },
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "dest": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                  },
                  "max_num_threads": {
                    "description": "The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.",
                    "type": "number"
                  },
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "model_memory_limit": {
                    "description": "The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try\nto create data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.",
                    "type": "string"
                  },
                  "source": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                  },
                  "headers": {
                    "$ref": "#/components/schemas/_types:HttpHeaders"
                  },
                  "version": {
                    "$ref": "#/components/schemas/_types:VersionString"
                  }
                },
                "required": [
                  "analysis",
                  "dest",
                  "source"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsAuthorization"
                    },
                    "allow_lazy_start": {
                      "type": "boolean"
                    },
                    "analysis": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                    },
                    "analyzed_fields": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                    },
                    "create_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "description": {
                      "type": "string"
                    },
                    "dest": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "max_num_threads": {
                      "type": "number"
                    },
                    "_meta": {
                      "$ref": "#/components/schemas/_types:Metadata"
                    },
                    "model_memory_limit": {
                      "type": "string"
                    },
                    "source": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    }
                  },
                  "required": [
                    "allow_lazy_start",
                    "analysis",
                    "create_time",
                    "dest",
                    "id",
                    "max_num_threads",
                    "model_memory_limit",
                    "source",
                    "version"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      },
      "delete": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Delete a data frame analytics job",
        "operationId": "ml-delete-data-frame-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If `true`, it deletes a job that is not stopped; this method is quicker than stopping and deleting the job.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The time to wait for the job to be deleted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/datafeeds/{datafeed_id}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get datafeeds configuration info",
        "description": "You can get information for multiple datafeeds in a single API request by\nusing a comma-separated list of datafeeds or a wildcard expression. You can\nget information for all datafeeds by using `_all`, by specifying `*` as the\n`<feed_id>`, or by omitting the `<feed_id>`.\nThis API returns a maximum of 10,000 datafeeds.",
        "operationId": "ml-get-datafeeds",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeeds#200"
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "put": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Create a datafeed",
        "description": "Datafeeds retrieve data from Elasticsearch for analysis by an anomaly detection job.\nYou can associate only one datafeed with each anomaly detection job.\nThe datafeed contains a query that runs at a defined interval (`frequency`).\nIf you are concerned about delayed data, you can add a delay (`query_delay') at each interval.\nBy default, the datafeed uses the following query: `{\"match_all\": {\"boost\": 1}}`.\n\nWhen Elasticsearch security features are enabled, your datafeed remembers which roles the user who created it had\nat the time of creation and runs the query using those same roles. If you provide secondary authorization headers,\nthose credentials are used instead.\nYou must use Kibana, this API, or the create anomaly detection jobs API to create a datafeed. Do not add a datafeed\ndirectly to the `.ml-config` index. Do not give users `write` privileges on the `.ml-config` index.",
        "operationId": "ml-put-datafeed",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed.\nThis identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.\nIt must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If true, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the `_all`\nstring or when no indices are specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument determines\nwhether wildcard expressions match hidden data streams. Supports comma-separated values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_throttled",
            "description": "If true, concrete, expanded, or aliased indices are ignored when frozen.",
            "deprecated": true,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If true, unavailable indices (missing or closed) are ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aggregations": {
                    "description": "If set, the datafeed performs aggregation searches.\nSupport for aggregations is limited and should be used only with low cardinality data.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                    }
                  },
                  "chunking_config": {
                    "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                  },
                  "delayed_data_check_config": {
                    "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "indices": {
                    "$ref": "#/components/schemas/_types:Indices"
                  },
                  "indices_options": {
                    "$ref": "#/components/schemas/_types:IndicesOptions"
                  },
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "max_empty_searches": {
                    "description": "If a real-time datafeed has never seen any data (including during any initial training period), it automatically\nstops and closes the associated job after this many real-time searches return no documents. In other words,\nit stops after `frequency` times `max_empty_searches` of real-time operation. If not set, a datafeed with no\nend time that sees no data remains started until it is explicitly stopped. By default, it is not set.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "query_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "runtime_mappings": {
                    "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                  },
                  "script_fields": {
                    "description": "Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.\nThe detector configuration objects in a job can contain functions that use these script fields.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types:ScriptField"
                    }
                  },
                  "scroll_size": {
                    "description": "The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.\nThe maximum value is the value of `index.max_result_window`, which is 10,000 by default.",
                    "type": "number"
                  },
                  "headers": {
                    "$ref": "#/components/schemas/_types:HttpHeaders"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "aggregations": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                      }
                    },
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DatafeedAuthorization"
                    },
                    "chunking_config": {
                      "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                    },
                    "delayed_data_check_config": {
                      "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                    },
                    "datafeed_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "frequency": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "indices_options": {
                      "$ref": "#/components/schemas/_types:IndicesOptions"
                    },
                    "max_empty_searches": {
                      "type": "number"
                    },
                    "query": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    },
                    "query_delay": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "runtime_mappings": {
                      "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                    },
                    "script_fields": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types:ScriptField"
                      }
                    },
                    "scroll_size": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "chunking_config",
                    "datafeed_id",
                    "indices",
                    "job_id",
                    "query",
                    "query_delay",
                    "scroll_size"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete a datafeed",
        "operationId": "ml-delete-datafeed",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed. This\nidentifier can contain lowercase alphanumeric characters (a-z and 0-9),\nhyphens, and underscores. It must start and end with alphanumeric\ncharacters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Use to forcefully delete a started datafeed; this method is quicker than\nstopping and deleting the datafeed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/_delete_expired_data/{job_id}": {
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete expired ML data",
        "description": "Deletes all job results, model snapshots and forecast data that have exceeded\ntheir retention days period. Machine learning state documents that are not\nassociated with any job are also deleted.\nYou can limit the request to a single or set of anomaly detection jobs by\nusing a job identifier, a group name, a comma-separated list of jobs, or a\nwildcard expression. You can delete expired data for all anomaly detection\njobs by using _all, by specifying * as the <job_id>, or by omitting the\n<job_id>.",
        "operationId": "ml-delete-expired-data",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#requests_per_second"
          },
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.delete_expired_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_expired_data#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/_delete_expired_data": {
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete expired ML data",
        "description": "Deletes all job results, model snapshots and forecast data that have exceeded\ntheir retention days period. Machine learning state documents that are not\nassociated with any job are also deleted.\nYou can limit the request to a single or set of anomaly detection jobs by\nusing a job identifier, a group name, a comma-separated list of jobs, or a\nwildcard expression. You can delete expired data for all anomaly detection\njobs by using _all, by specifying * as the <job_id>, or by omitting the\n<job_id>.",
        "operationId": "ml-delete-expired-data-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#requests_per_second"
          },
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.delete_expired_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_expired_data#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/filters/{filter_id}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get filters",
        "description": "You can get a single filter or all filters.",
        "operationId": "ml-get-filters-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_filters#filter_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_filters#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_filters#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_filters#200"
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "put": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Create a filter",
        "description": "A filter contains a list of strings. It can be used by one or more anomaly detection jobs.\nSpecifically, filters are referenced in the `custom_rules` property of detector configuration objects.",
        "operationId": "ml-put-filter",
        "parameters": [
          {
            "in": "path",
            "name": "filter_id",
            "description": "A string that uniquely identifies a filter.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A description of the filter.",
                    "type": "string"
                  },
                  "items": {
                    "description": "The items of the filter. A wildcard `*` can be used at the beginning or the end of an item.\nUp to 10000 items are allowed in each filter.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "description": {
                      "type": "string"
                    },
                    "filter_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "description",
                    "filter_id",
                    "items"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete a filter",
        "description": "If an anomaly detection job references the filter, you cannot delete the\nfilter. You must update or delete the job before you can delete the filter.",
        "operationId": "ml-delete-filter",
        "parameters": [
          {
            "in": "path",
            "name": "filter_id",
            "description": "A string that uniquely identifies a filter.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_forecast": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Predict future behavior of a time series",
        "description": "Forecasts are not supported for jobs that perform population analysis; an\nerror occurs if you try to create a forecast for a job that has an\n`over_field_name` in its configuration. Forcasts predict future behavior\nbased on historical data.",
        "operationId": "ml-forecast",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job. The job must be open when you\ncreate a forecast; otherwise, an error occurs.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "duration",
            "description": "A period of time that indicates how far into the future to forecast. For\nexample, `30d` corresponds to 30 days. The forecast starts at the last\nrecord that was processed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expires_in",
            "description": "The period of time that forecast results are retained. After a forecast\nexpires, the results are deleted. If set to a value of 0, the forecast is\nnever automatically deleted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_model_memory",
            "description": "The maximum memory the forecast can use. If the forecast needs to use\nmore than the provided amount, it will spool to disk. Default is 20mb,\nmaximum is 500mb and minimum is 1mb. If set to 40% or more of the jobâ€™s\nconfigured memory limit, it is automatically reduced to below that\namount.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "duration": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "expires_in": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "max_model_memory": {
                    "description": "Refer to the description for the `max_model_memory` query parameter.",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "forecast_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "forecast_id"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.1.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete forecasts from a job",
        "description": "By default, forecasts are retained for 14 days. You can specify a\ndifferent retention period with the `expires_in` parameter in the forecast\njobs API. The delete forecast API enables you to delete one or more\nforecasts before they expire.",
        "operationId": "ml-delete-forecast",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_forecast#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#allow_no_forecasts"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_forecast#200"
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_forecast/{forecast_id}": {
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete forecasts from a job",
        "description": "By default, forecasts are retained for 14 days. You can specify a\ndifferent retention period with the `expires_in` parameter in the forecast\njobs API. The delete forecast API enables you to delete one or more\nforecasts before they expire.",
        "operationId": "ml-delete-forecast-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_forecast#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#forecast_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#allow_no_forecasts"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_forecast#200"
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection jobs configuration info",
        "description": "You can get information for multiple anomaly detection jobs in a single API\nrequest by using a group name, a comma-separated list of jobs, or a wildcard\nexpression. You can get information for all anomaly detection jobs by using\n`_all`, by specifying `*` as the `<job_id>`, or by omitting the `<job_id>`.",
        "operationId": "ml-get-jobs",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_jobs#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_jobs#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_jobs#200"
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "put": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Create an anomaly detection job",
        "description": "If you include a `datafeed_config`, you must have read index privileges on the source index.\nIf you include a `datafeed_config` but do not provide a query, the datafeed uses `{\"match_all\": {\"boost\": 1}}`.",
        "operationId": "ml-put-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "The identifier for the anomaly detection job. This identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `true`, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the\n`_all` string or when no indices are specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument determines\nwhether wildcard expressions match hidden data streams. Supports comma-separated values. Valid values are:\n\n* `all`: Match any data stream or index, including hidden ones.\n* `closed`: Match closed, non-hidden indices. Also matches any non-hidden data stream. Data streams cannot be closed.\n* `hidden`: Match hidden data streams and hidden indices. Must be combined with `open`, `closed`, or both.\n* `none`: Wildcard patterns are not accepted.\n* `open`: Match open, non-hidden indices. Also matches any non-hidden data stream.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_throttled",
            "description": "If `true`, concrete, expanded or aliased indices are ignored when frozen.",
            "deprecated": true,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `true`, unavailable indices (missing or closed) are ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_lazy_open": {
                    "description": "Advanced configuration option. Specifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node. By default, if a machine learning node with capacity to run the job cannot immediately be found, the open anomaly detection jobs API returns an error. However, this is also subject to the cluster-wide `xpack.ml.max_lazy_ml_nodes` setting. If this option is set to true, the open anomaly detection jobs API does not return an error and the job waits in the opening state until sufficient machine learning node capacity is available.",
                    "type": "boolean"
                  },
                  "analysis_config": {
                    "$ref": "#/components/schemas/ml._types:AnalysisConfig"
                  },
                  "analysis_limits": {
                    "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                  },
                  "background_persist_interval": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "custom_settings": {
                    "$ref": "#/components/schemas/ml._types:CustomSettings"
                  },
                  "daily_model_snapshot_retention_after_days": {
                    "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job. It specifies a period of time (in days) after which only the first snapshot per day is retained. This period is relative to the timestamp of the most recent snapshot for this job. Valid values range from 0 to `model_snapshot_retention_days`.",
                    "type": "number"
                  },
                  "data_description": {
                    "$ref": "#/components/schemas/ml._types:DataDescription"
                  },
                  "datafeed_config": {
                    "$ref": "#/components/schemas/ml._types:DatafeedConfig"
                  },
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "groups": {
                    "description": "A list of job groups. A job can belong to no groups or many.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "model_plot_config": {
                    "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                  },
                  "model_snapshot_retention_days": {
                    "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job. It specifies the maximum period of time (in days) that snapshots are retained. This period is relative to the timestamp of the most recent snapshot for this job. By default, snapshots ten days older than the newest snapshot are deleted.",
                    "type": "number"
                  },
                  "renormalization_window_days": {
                    "description": "Advanced configuration option. The period over which adjustments to the score are applied, as new data is seen. The default value is the longer of 30 days or 100 bucket spans.",
                    "type": "number"
                  },
                  "results_index_name": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "results_retention_days": {
                    "description": "Advanced configuration option. The period of time (in days) that results are retained. Age is calculated relative to the timestamp of the latest bucket result. If this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch. The default value is null, which means all results are retained. Annotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results. Annotations added by users are retained forever.",
                    "type": "number"
                  }
                },
                "required": [
                  "analysis_config",
                  "data_description"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allow_lazy_open": {
                      "type": "boolean"
                    },
                    "analysis_config": {
                      "$ref": "#/components/schemas/ml._types:AnalysisConfigRead"
                    },
                    "analysis_limits": {
                      "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                    },
                    "background_persist_interval": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "create_time": {
                      "$ref": "#/components/schemas/_types:DateTime"
                    },
                    "custom_settings": {
                      "$ref": "#/components/schemas/ml._types:CustomSettings"
                    },
                    "daily_model_snapshot_retention_after_days": {
                      "type": "number"
                    },
                    "data_description": {
                      "$ref": "#/components/schemas/ml._types:DataDescription"
                    },
                    "datafeed_config": {
                      "$ref": "#/components/schemas/ml._types:Datafeed"
                    },
                    "description": {
                      "type": "string"
                    },
                    "groups": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "job_type": {
                      "type": "string"
                    },
                    "job_version": {
                      "type": "string"
                    },
                    "model_plot_config": {
                      "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                    },
                    "model_snapshot_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "model_snapshot_retention_days": {
                      "type": "number"
                    },
                    "renormalization_window_days": {
                      "type": "number"
                    },
                    "results_index_name": {
                      "type": "string"
                    },
                    "results_retention_days": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "allow_lazy_open",
                    "analysis_config",
                    "analysis_limits",
                    "create_time",
                    "daily_model_snapshot_retention_after_days",
                    "data_description",
                    "job_id",
                    "job_type",
                    "job_version",
                    "model_snapshot_retention_days",
                    "results_index_name"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete an anomaly detection job",
        "description": "All job configuration, model state and results are deleted.\nIt is not currently possible to delete multiple jobs using wildcards or a\ncomma separated list. If you delete a job that has a datafeed, the request\nfirst tries to delete the datafeed. This behavior is equivalent to calling\nthe delete datafeed API with the same timeout and force parameters as the\ndelete job request.",
        "operationId": "ml-delete-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Use to forcefully delete an opened job; this method is quicker than\nclosing and deleting the job.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delete_user_annotations",
            "description": "Specifies whether annotations that have been added by the\nuser should be deleted along with any auto-generated annotations when the job is\nreset.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "Specifies whether the request should return immediately or wait until the\njob deletion completes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get model snapshots info",
        "operationId": "ml-get-model-snapshots",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#snapshot_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get model snapshots info",
        "operationId": "ml-get-model-snapshots-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#snapshot_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "delete": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Delete a model snapshot",
        "description": "You cannot delete the active model snapshot. To delete that snapshot, first\nrevert to a different one. To identify the active model snapshot, refer to\nthe `model_snapshot_id` in the results from the get jobs API.",
        "operationId": "ml-delete-model-snapshot",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "Identifier for the model snapshot.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/trained_models/{model_id}": {
      "get": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Get trained model configuration info",
        "operationId": "ml-get-trained-models",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#decompress_definition"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#exclude_generated"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#include"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#include_model_definition"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#tags"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models#200"
          }
        },
        "x-state": "Added in 7.10.0"
      },
      "put": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Create a trained model",
        "description": "Enable you to supply a trained model that is not created by data frame analytics.",
        "operationId": "ml-put-trained-model",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "defer_definition_decompression",
            "description": "If set to `true` and a `compressed_definition` is provided,\nthe request defers definition decompression and skips relevant\nvalidations.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "Whether to wait for all child operations (e.g. model download)\nto complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "compressed_definition": {
                    "description": "The compressed (GZipped and Base64 encoded) inference definition of the\nmodel. If compressed_definition is specified, then definition cannot be\nspecified.",
                    "type": "string"
                  },
                  "definition": {
                    "$ref": "#/components/schemas/ml.put_trained_model:Definition"
                  },
                  "description": {
                    "description": "A human-readable description of the inference trained model.",
                    "type": "string"
                  },
                  "inference_config": {
                    "$ref": "#/components/schemas/ml._types:InferenceConfigCreateContainer"
                  },
                  "input": {
                    "$ref": "#/components/schemas/ml.put_trained_model:Input"
                  },
                  "metadata": {
                    "description": "An object map that contains metadata about the model.",
                    "type": "object"
                  },
                  "model_type": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelType"
                  },
                  "model_size_bytes": {
                    "description": "The estimated memory usage in bytes to keep the trained model in memory.\nThis property is supported only if defer_definition_decompression is true\nor the model definition is not supplied.",
                    "type": "number"
                  },
                  "platform_architecture": {
                    "description": "The platform architecture (if applicable) of the trained mode. If the model\nonly works on one platform, because it is heavily optimized for a particular\nprocessor architecture and OS combination, then this field specifies which.\nThe format of the string must match the platform identifiers used by Elasticsearch,\nso one of, `linux-x86_64`, `linux-aarch64`, `darwin-x86_64`, `darwin-aarch64`,\nor `windows-x86_64`. For portable models (those that work independent of processor\narchitecture or OS features), leave this field unset.",
                    "type": "string"
                  },
                  "tags": {
                    "description": "An array of tags to organize the model.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "prefix_strings": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelPrefixStrings"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ml._types:TrainedModelConfig"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      },
      "delete": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Delete an unreferenced trained model",
        "description": "The request deletes a trained inference model that is not referenced by an ingest pipeline.",
        "operationId": "ml-delete-trained-model",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Forcefully deletes a trained model that is referenced by ingest pipelines or has a started deployment.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_ml/trained_models/{model_id}/model_aliases/{model_alias}": {
      "put": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Create or update a trained model alias",
        "description": "A trained model alias is a logical name used to reference a single trained\nmodel.\nYou can use aliases instead of trained model identifiers to make it easier to\nreference your models. For example, you can use aliases in inference\naggregations and processors.\nAn alias must be unique and refer to only a single trained model. However,\nyou can have multiple aliases for each trained model.\nIf you use this API to update an alias such that it references a different\ntrained model ID and the model uses a different type of data frame analytics,\nan error occurs. For example, this situation occurs if you have a trained\nmodel for regression analysis and a trained model for classification\nanalysis; you cannot reassign an alias from one type of trained model to\nanother.\nIf you use this API to update an alias and there are very few input fields in\ncommon between the old and new trained models for the model alias, the API\nreturns a warning.",
        "operationId": "ml-put-trained-model-alias",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The identifier for the trained model that the alias refers to.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "model_alias",
            "description": "The alias to create or update. This value cannot end in numbers.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "reassign",
            "description": "Specifies whether the alias gets reassigned to the specified trained\nmodel if it is already assigned to a different model. If the alias is\nalready assigned and this parameter is false, the API returns an error.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      },
      "delete": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Delete a trained model alias",
        "description": "This API deletes an existing model alias that refers to a trained model. If\nthe model alias is missing or refers to a model other than the one identified\nby the `model_id`, this API returns an error.",
        "operationId": "ml-delete-trained-model-alias",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The trained model ID to which the model alias refers.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "model_alias",
            "description": "The model alias to delete.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_ml/anomaly_detectors/_estimate_model_memory": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Estimate job model memory usage",
        "description": "Makes an estimation of the memory usage for an anomaly detection job model.\nIt is based on analysis configuration details for the job and cardinality\nestimates for the fields it references.",
        "operationId": "ml-estimate-model-memory",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "analysis_config": {
                    "$ref": "#/components/schemas/ml._types:AnalysisConfig"
                  },
                  "max_bucket_cardinality": {
                    "description": "Estimates of the highest cardinality in a single bucket that is observed\nfor influencer fields over the time period that the job analyzes data.\nTo produce a good answer, values must be provided for all influencer\nfields. Providing values for fields that are not listed as `influencers`\nhas no effect on the estimation.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  },
                  "overall_cardinality": {
                    "description": "Estimates of the cardinality that is observed for fields over the whole\ntime period that the job analyzes data. To produce a good answer, values\nmust be provided for fields referenced in the `by_field_name`,\n`over_field_name` and `partition_field_name` of any detectors. Providing\nvalues for other fields has no effect on the estimation. It can be\nomitted from the request if no detectors have a `by_field_name`,\n`over_field_name` or `partition_field_name`.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "model_memory_estimate": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "model_memory_estimate"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.7.0"
      }
    },
    "/_ml/data_frame/_evaluate": {
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Evaluate data frame analytics",
        "description": "The API packages together commonly used evaluation metrics for various types\nof machine learning features. This has been designed for use on indexes\ncreated by data frame analytics. Evaluation requires both a ground truth\nfield and an analytics result field to be present.",
        "operationId": "ml-evaluate-data-frame",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "evaluation": {
                    "$ref": "#/components/schemas/ml._types:DataframeEvaluationContainer"
                  },
                  "index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  }
                },
                "required": [
                  "evaluation",
                  "index"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "classification": {
                      "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummary"
                    },
                    "outlier_detection": {
                      "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeOutlierDetectionSummary"
                    },
                    "regression": {
                      "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeRegressionSummary"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/data_frame/analytics/_explain": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Explain data frame analytics config",
        "description": "This API provides explanations for a data frame analytics config that either\nexists already or one that has not been created yet. The following\nexplanations are provided:\n* which fields are included or not in the analysis and why,\n* how much memory is estimated to be required. The estimate can be used when deciding the appropriate value for model_memory_limit setting later on.\nIf you have object fields or fields that are excluded via source filtering, they are not included in the explanation.",
        "operationId": "ml-explain-data-frame-analytics",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.3.0"
      },
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Explain data frame analytics config",
        "description": "This API provides explanations for a data frame analytics config that either\nexists already or one that has not been created yet. The following\nexplanations are provided:\n* which fields are included or not in the analysis and why,\n* how much memory is estimated to be required. The estimate can be used when deciding the appropriate value for model_memory_limit setting later on.\nIf you have object fields or fields that are excluded via source filtering, they are not included in the explanation.",
        "operationId": "ml-explain-data-frame-analytics-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/data_frame/analytics/{id}/_explain": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Explain data frame analytics config",
        "description": "This API provides explanations for a data frame analytics config that either\nexists already or one that has not been created yet. The following\nexplanations are provided:\n* which fields are included or not in the analysis and why,\n* how much memory is estimated to be required. The estimate can be used when deciding the appropriate value for model_memory_limit setting later on.\nIf you have object fields or fields that are excluded via source filtering, they are not included in the explanation.",
        "operationId": "ml-explain-data-frame-analytics-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.explain_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.3.0"
      },
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Explain data frame analytics config",
        "description": "This API provides explanations for a data frame analytics config that either\nexists already or one that has not been created yet. The following\nexplanations are provided:\n* which fields are included or not in the analysis and why,\n* how much memory is estimated to be required. The estimate can be used when deciding the appropriate value for model_memory_limit setting later on.\nIf you have object fields or fields that are excluded via source filtering, they are not included in the explanation.",
        "operationId": "ml-explain-data-frame-analytics-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.explain_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_flush": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Force buffered data to be processed",
        "description": "The flush jobs API is only applicable when sending data for analysis using\nthe post data API. Depending on the content of the buffer, then it might\nadditionally calculate new results. Both flush and close operations are\nsimilar, however the flush is more efficient if you are expecting to send\nmore data for analysis. When flushing, the job remains open and is available\nto continue analyzing data. A close operation additionally prunes and\npersists the model state to disk and the job must be opened again before\nanalyzing further data.",
        "operationId": "ml-flush-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "advance_time",
            "description": "Specifies to advance to a particular time value. Results are generated\nand the model is updated for data from the specified time interval.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "calc_interim",
            "description": "If true, calculates the interim results for the most recent bucket or all\nbuckets within the latency period.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "end",
            "description": "When used in conjunction with `calc_interim` and `start`, specifies the\nrange of buckets on which to calculate interim results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "skip_time",
            "description": "Specifies to skip to a particular time value. Results are not generated\nand the model is not updated for data from the specified time interval.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "start",
            "description": "When used in conjunction with `calc_interim`, specifies the range of\nbuckets on which to calculate interim results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "advance_time": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "calc_interim": {
                    "description": "Refer to the description for the `calc_interim` query parameter.",
                    "type": "boolean"
                  },
                  "end": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "skip_time": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "start": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "flushed": {
                      "type": "boolean"
                    },
                    "last_finalized_bucket_end": {
                      "description": "Provides the timestamp (in milliseconds since the epoch) of the end of\nthe last bucket that was processed.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "flushed"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/buckets/{timestamp}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for buckets",
        "description": "The API presents a chronological view of the records, grouped by bucket.",
        "operationId": "ml-get-buckets",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#timestamp"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for buckets",
        "description": "The API presents a chronological view of the records, grouped by bucket.",
        "operationId": "ml-get-buckets-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#timestamp"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/buckets": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for buckets",
        "description": "The API presents a chronological view of the records, grouped by bucket.",
        "operationId": "ml-get-buckets-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for buckets",
        "description": "The API presents a chronological view of the records, grouped by bucket.",
        "operationId": "ml-get-buckets-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/calendars/{calendar_id}/events": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get info about events in calendars",
        "operationId": "ml-get-calendar-events",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar. You can get information for multiple calendars by using a comma-separated list of ids or a wildcard expression. You can get information for all calendars by using `_all` or `*` or by omitting the calendar identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "end",
            "description": "Specifies to get events with timestamps earlier than this time.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Skips the specified number of events.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "job_id",
            "description": "Specifies to get events for a specific anomaly detection job identifier or job group. It must be used with a calendar identifier of `_all` or `*`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies the maximum number of events to obtain.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "start",
            "description": "Specifies to get events with timestamps after this time.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ml._types:CalendarEvent"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "events"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Add scheduled events to the calendar",
        "operationId": "ml-post-calendar-events",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "events": {
                    "description": "A list of one of more scheduled events. The eventâ€™s start and end times can be specified as integer milliseconds since the epoch or as a string in ISO 8601 format.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ml._types:CalendarEvent"
                    }
                  }
                },
                "required": [
                  "events"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "events": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ml._types:CalendarEvent"
                      }
                    }
                  },
                  "required": [
                    "events"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_ml/calendars": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get calendar configuration info",
        "operationId": "ml-get-calendars",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get calendar configuration info",
        "operationId": "ml-get-calendars-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/categories/{category_id}": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for categories",
        "operationId": "ml-get-categories",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#category_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for categories",
        "operationId": "ml-get-categories-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#category_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/categories": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for categories",
        "operationId": "ml-get-categories-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for categories",
        "operationId": "ml-get-categories-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/data_frame/analytics": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Get data frame analytics job configuration info",
        "description": "You can get information for multiple data frame analytics jobs in a single\nAPI request by using a comma-separated list of data frame analytics jobs or a\nwildcard expression.",
        "operationId": "ml-get-data-frame-analytics-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/data_frame/analytics/_stats": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Get data frame analytics job stats",
        "operationId": "ml-get-data-frame-analytics-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics_stats#200"
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/data_frame/analytics/{id}/_stats": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Get data frame analytics job stats",
        "operationId": "ml-get-data-frame-analytics-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#id"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics_stats#200"
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_stats": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get datafeeds stats",
        "description": "You can get statistics for multiple datafeeds in a single API request by\nusing a comma-separated list of datafeeds or a wildcard expression. You can\nget statistics for all datafeeds by using `_all`, by specifying `*` as the\n`<feed_id>`, or by omitting the `<feed_id>`. If the datafeed is stopped, the\nonly information you receive is the `datafeed_id` and the `state`.\nThis API returns a maximum of 10,000 datafeeds.",
        "operationId": "ml-get-datafeed-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeed_stats#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeed_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeed_stats#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/datafeeds/_stats": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get datafeeds stats",
        "description": "You can get statistics for multiple datafeeds in a single API request by\nusing a comma-separated list of datafeeds or a wildcard expression. You can\nget statistics for all datafeeds by using `_all`, by specifying `*` as the\n`<feed_id>`, or by omitting the `<feed_id>`. If the datafeed is stopped, the\nonly information you receive is the `datafeed_id` and the `state`.\nThis API returns a maximum of 10,000 datafeeds.",
        "operationId": "ml-get-datafeed-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeed_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeed_stats#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/datafeeds": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get datafeeds configuration info",
        "description": "You can get information for multiple datafeeds in a single API request by\nusing a comma-separated list of datafeeds or a wildcard expression. You can\nget information for all datafeeds by using `_all`, by specifying `*` as the\n`<feed_id>`, or by omitting the `<feed_id>`.\nThis API returns a maximum of 10,000 datafeeds.",
        "operationId": "ml-get-datafeeds-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeeds#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/filters": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get filters",
        "description": "You can get a single filter or all filters.",
        "operationId": "ml-get-filters",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_filters#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_filters#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_filters#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/influencers": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for influencers",
        "description": "Influencers are the entities that have contributed to, or are to blame for,\nthe anomalies. Influencer results are available only if an\n`influencer_field_name` is specified in the job configuration.",
        "operationId": "ml-get-influencers",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_influencers#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#influencer_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_influencers"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_influencers#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job results for influencers",
        "description": "Influencers are the entities that have contributed to, or are to blame for,\nthe anomalies. Influencer results are available only if an\n`influencer_field_name` is specified in the job configuration.",
        "operationId": "ml-get-influencers-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_influencers#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#influencer_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_influencers"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_influencers#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/_stats": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job stats",
        "operationId": "ml-get-job-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_job_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_job_stats#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_stats": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job stats",
        "operationId": "ml-get-job-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_job_stats#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_job_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_job_stats#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/anomaly_detectors": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection jobs configuration info",
        "description": "You can get information for multiple anomaly detection jobs in a single API\nrequest by using a group name, a comma-separated list of jobs, or a wildcard\nexpression. You can get information for all anomaly detection jobs by using\n`_all`, by specifying `*` as the `<job_id>`, or by omitting the `<job_id>`.",
        "operationId": "ml-get-jobs-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_jobs#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_jobs#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/memory/_stats": {
      "get": {
        "tags": [
          "ml"
        ],
        "summary": "Get machine learning memory usage info",
        "description": "Get information about how machine learning jobs and trained models are using memory,\non each node, both within the JVM heap, and natively, outside of the JVM.",
        "operationId": "ml-get-memory-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#human"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_memory_stats#200"
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_ml/memory/{node_id}/_stats": {
      "get": {
        "tags": [
          "ml"
        ],
        "summary": "Get machine learning memory usage info",
        "description": "Get information about how machine learning jobs and trained models are using memory,\non each node, both within the JVM heap, and natively, outside of the JVM.",
        "operationId": "ml-get-memory-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#node_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#human"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_memory_stats#200"
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_upgrade/_stats": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly detection job model snapshot upgrade usage info",
        "operationId": "ml-get-model-snapshot-upgrade-stats",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "A numerical character string that uniquely identifies the model snapshot. You can get information for multiple\nsnapshots by using a comma-separated list or a wildcard expression. You can get all snapshots by using `_all`,\nby specifying `*` as the snapshot ID, or by omitting the snapshot ID.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n -  Contains wildcard expressions and there are no jobs that match.\n -  Contains the _all string or no identifiers and there are no matches.\n -  Contains wildcard expressions and there are only partial matches.\n\nThe default value is true, which returns an empty jobs array when there are no matches and the subset of results\nwhen there are partial matches. If this parameter is false, the request returns a 404 status code when there are\nno matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "model_snapshot_upgrades": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ml._types:ModelSnapshotUpgrade"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "model_snapshot_upgrades"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.16.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get model snapshots info",
        "operationId": "ml-get-model-snapshots-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get model snapshots info",
        "operationId": "ml-get-model-snapshots-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/overall_buckets": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get overall bucket results",
        "description": "Retrievs overall bucket results that summarize the bucket results of\nmultiple anomaly detection jobs.\n\nThe `overall_score` is calculated by combining the scores of all the\nbuckets within the overall bucket span. First, the maximum\n`anomaly_score` per anomaly detection job in the overall bucket is\ncalculated. Then the `top_n` of those scores are averaged to result in\nthe `overall_score`. This means that you can fine-tune the\n`overall_score` so that it is more or less sensitive to the number of\njobs that detect an anomaly at the same time. For example, if you set\n`top_n` to `1`, the `overall_score` is the maximum bucket score in the\noverall bucket. Alternatively, if you set `top_n` to the number of jobs,\nthe `overall_score` is high only when all jobs detect anomalies in that\noverall bucket. If you set the `bucket_span` parameter (to a value\ngreater than its default), the `overall_score` is the maximum\n`overall_score` of the overall buckets that have a span equal to the\njobs' largest bucket span.",
        "operationId": "ml-get-overall-buckets",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#bucket_span"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#overall_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#start"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#top_n"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_overall_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_overall_buckets#200"
          }
        },
        "x-state": "Added in 6.1.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get overall bucket results",
        "description": "Retrievs overall bucket results that summarize the bucket results of\nmultiple anomaly detection jobs.\n\nThe `overall_score` is calculated by combining the scores of all the\nbuckets within the overall bucket span. First, the maximum\n`anomaly_score` per anomaly detection job in the overall bucket is\ncalculated. Then the `top_n` of those scores are averaged to result in\nthe `overall_score`. This means that you can fine-tune the\n`overall_score` so that it is more or less sensitive to the number of\njobs that detect an anomaly at the same time. For example, if you set\n`top_n` to `1`, the `overall_score` is the maximum bucket score in the\noverall bucket. Alternatively, if you set `top_n` to the number of jobs,\nthe `overall_score` is high only when all jobs detect anomalies in that\noverall bucket. If you set the `bucket_span` parameter (to a value\ngreater than its default), the `overall_score` is the maximum\n`overall_score` of the overall buckets that have a span equal to the\njobs' largest bucket span.",
        "operationId": "ml-get-overall-buckets-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#bucket_span"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#overall_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#start"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#top_n"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_overall_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_overall_buckets#200"
          }
        },
        "x-state": "Added in 6.1.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/records": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly records for an anomaly detection job",
        "description": "Records contain the detailed analytical results. They describe the anomalous\nactivity that has been identified in the input data based on the detector\nconfiguration.\nThere can be many anomaly records depending on the characteristics and size\nof the input data. In practice, there are often too many to be able to\nmanually process them. The machine learning features therefore perform a\nsophisticated aggregation of the anomaly records into buckets.\nThe number of record results depends on the number of anomalies found in each\nbucket, which relates to the number of time series being modeled and the\nnumber of detectors.",
        "operationId": "ml-get-records",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_records#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#record_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_records"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_records#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Get anomaly records for an anomaly detection job",
        "description": "Records contain the detailed analytical results. They describe the anomalous\nactivity that has been identified in the input data based on the detector\nconfiguration.\nThere can be many anomaly records depending on the characteristics and size\nof the input data. In practice, there are often too many to be able to\nmanually process them. The machine learning features therefore perform a\nsophisticated aggregation of the anomaly records into buckets.\nThe number of record results depends on the number of anomalies found in each\nbucket, which relates to the number of time series being modeled and the\nnumber of detectors.",
        "operationId": "ml-get-records-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_records#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#record_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_records"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_records#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/trained_models": {
      "get": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Get trained model configuration info",
        "operationId": "ml-get-trained-models-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#decompress_definition"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#exclude_generated"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#include"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#include_model_definition"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#tags"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models#200"
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_ml/trained_models/{model_id}/_stats": {
      "get": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Get trained models usage info",
        "description": "You can get usage information for multiple trained\nmodels in a single API request by using a comma-separated list of model IDs or a wildcard expression.",
        "operationId": "ml-get-trained-models-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models_stats#200"
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_ml/trained_models/_stats": {
      "get": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Get trained models usage info",
        "description": "You can get usage information for multiple trained\nmodels in a single API request by using a comma-separated list of model IDs or a wildcard expression.",
        "operationId": "ml-get-trained-models-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models_stats#200"
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_ml/trained_models/{model_id}/_infer": {
      "post": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Evaluate a trained model",
        "operationId": "ml-infer-trained-model",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.infer_trained_model"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.infer_trained_model#200"
          }
        },
        "x-state": "Added in 8.3.0"
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_infer": {
      "post": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Evaluate a trained model",
        "operationId": "ml-infer-trained-model-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.infer_trained_model"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.infer_trained_model#200"
          }
        },
        "x-state": "Added in 8.3.0"
      }
    },
    "/_ml/info": {
      "get": {
        "tags": [
          "ml"
        ],
        "summary": "Get machine learning information",
        "description": "Get defaults and limits used by machine learning.\nThis endpoint is designed to be used by a user interface that needs to fully\nunderstand machine learning configurations where some options are not\nspecified, meaning that the defaults should be used. This endpoint may be\nused to find out what those defaults are. It also provides information about\nthe maximum size of machine learning jobs that could run in the current\ncluster configuration.",
        "operationId": "ml-info",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "defaults": {
                      "$ref": "#/components/schemas/ml.info:Defaults"
                    },
                    "limits": {
                      "$ref": "#/components/schemas/ml.info:Limits"
                    },
                    "upgrade_mode": {
                      "type": "boolean"
                    },
                    "native_code": {
                      "$ref": "#/components/schemas/ml.info:NativeCode"
                    }
                  },
                  "required": [
                    "defaults",
                    "limits",
                    "upgrade_mode",
                    "native_code"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_open": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Open anomaly detection jobs",
        "description": "An anomaly detection job must be opened to be ready to receive and analyze\ndata. It can be opened and closed multiple times throughout its lifecycle.\nWhen you open a new job, it starts with an empty model.\nWhen you open an existing job, the most recent model state is automatically\nloaded. The job is ready to resume its analysis from where it left off, once\nnew data is received.",
        "operationId": "ml-open-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait until a job has opened.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "opened": {
                      "type": "boolean"
                    },
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeId"
                    }
                  },
                  "required": [
                    "opened",
                    "node"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_data": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Send data to an anomaly detection job for analysis",
        "description": "IMPORTANT: For each job, data can be accepted from only a single connection at a time.\nIt is not currently possible to post data to multiple jobs using wildcards or a comma-separated list.",
        "operationId": "ml-post-data",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job. The job must have a state of open to receive and process the data.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "reset_end",
            "description": "Specifies the end of the bucket resetting range.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "reset_start",
            "description": "Specifies the start of the bucket resetting range.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "object"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "processed_record_count": {
                      "type": "number"
                    },
                    "processed_field_count": {
                      "type": "number"
                    },
                    "input_bytes": {
                      "type": "number"
                    },
                    "input_field_count": {
                      "type": "number"
                    },
                    "invalid_date_count": {
                      "type": "number"
                    },
                    "missing_field_count": {
                      "type": "number"
                    },
                    "out_of_order_timestamp_count": {
                      "type": "number"
                    },
                    "empty_bucket_count": {
                      "type": "number"
                    },
                    "sparse_bucket_count": {
                      "type": "number"
                    },
                    "bucket_count": {
                      "type": "number"
                    },
                    "earliest_record_timestamp": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "latest_record_timestamp": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "last_data_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "latest_empty_bucket_timestamp": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "latest_sparse_bucket_timestamp": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "input_record_count": {
                      "type": "number"
                    },
                    "log_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    }
                  },
                  "required": [
                    "job_id",
                    "processed_record_count",
                    "processed_field_count",
                    "input_bytes",
                    "input_field_count",
                    "invalid_date_count",
                    "missing_field_count",
                    "out_of_order_timestamp_count",
                    "empty_bucket_count",
                    "sparse_bucket_count",
                    "bucket_count",
                    "input_record_count"
                  ]
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/data_frame/analytics/_preview": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Preview features used by data frame analytics",
        "description": "Previews the extracted features used by a data frame analytics config.",
        "operationId": "ml-preview-data-frame-analytics",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.13.0"
      },
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Preview features used by data frame analytics",
        "description": "Previews the extracted features used by a data frame analytics config.",
        "operationId": "ml-preview-data-frame-analytics-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_ml/data_frame/analytics/{id}/_preview": {
      "get": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Preview features used by data frame analytics",
        "description": "Previews the extracted features used by a data frame analytics config.",
        "operationId": "ml-preview-data-frame-analytics-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.13.0"
      },
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Preview features used by data frame analytics",
        "description": "Previews the extracted features used by a data frame analytics config.",
        "operationId": "ml-preview-data-frame-analytics-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_preview": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Preview a datafeed",
        "description": "This API returns the first \"page\" of search results from a datafeed.\nYou can preview an existing datafeed or provide configuration details for a datafeed\nand anomaly detection job in the API. The preview shows the structure of the data\nthat will be passed to the anomaly detection engine.\nIMPORTANT: When Elasticsearch security features are enabled, the preview uses the credentials of the user that\ncalled the API. However, when the datafeed starts it uses the roles of the last user that created or updated the\ndatafeed. To get a preview that accurately reflects the behavior of the datafeed, use the appropriate credentials.\nYou can also use secondary authorization headers to supply the credentials.",
        "operationId": "ml-preview-datafeed",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Preview a datafeed",
        "description": "This API returns the first \"page\" of search results from a datafeed.\nYou can preview an existing datafeed or provide configuration details for a datafeed\nand anomaly detection job in the API. The preview shows the structure of the data\nthat will be passed to the anomaly detection engine.\nIMPORTANT: When Elasticsearch security features are enabled, the preview uses the credentials of the user that\ncalled the API. However, when the datafeed starts it uses the roles of the last user that created or updated the\ndatafeed. To get a preview that accurately reflects the behavior of the datafeed, use the appropriate credentials.\nYou can also use secondary authorization headers to supply the credentials.",
        "operationId": "ml-preview-datafeed-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/datafeeds/_preview": {
      "get": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Preview a datafeed",
        "description": "This API returns the first \"page\" of search results from a datafeed.\nYou can preview an existing datafeed or provide configuration details for a datafeed\nand anomaly detection job in the API. The preview shows the structure of the data\nthat will be passed to the anomaly detection engine.\nIMPORTANT: When Elasticsearch security features are enabled, the preview uses the credentials of the user that\ncalled the API. However, when the datafeed starts it uses the roles of the last user that created or updated the\ndatafeed. To get a preview that accurately reflects the behavior of the datafeed, use the appropriate credentials.\nYou can also use secondary authorization headers to supply the credentials.",
        "operationId": "ml-preview-datafeed-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        },
        "x-state": "Added in 5.4.0"
      },
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Preview a datafeed",
        "description": "This API returns the first \"page\" of search results from a datafeed.\nYou can preview an existing datafeed or provide configuration details for a datafeed\nand anomaly detection job in the API. The preview shows the structure of the data\nthat will be passed to the anomaly detection engine.\nIMPORTANT: When Elasticsearch security features are enabled, the preview uses the credentials of the user that\ncalled the API. However, when the datafeed starts it uses the roles of the last user that created or updated the\ndatafeed. To get a preview that accurately reflects the behavior of the datafeed, use the appropriate credentials.\nYou can also use secondary authorization headers to supply the credentials.",
        "operationId": "ml-preview-datafeed-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/trained_models/{model_id}/definition/{part}": {
      "put": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Create part of a trained model definition",
        "operationId": "ml-put-trained-model-definition-part",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "part",
            "description": "The definition part number. When the definition is loaded for inference the definition parts are streamed in the\norder of their part number. The first part must be `0` and the final part must be `total_parts - 1`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "definition": {
                    "description": "The definition part for the model. Must be a base64 encoded string.",
                    "type": "string"
                  },
                  "total_definition_length": {
                    "description": "The total uncompressed definition length in bytes. Not base64 encoded.",
                    "type": "number"
                  },
                  "total_parts": {
                    "description": "The total number of parts that will be uploaded. Must be greater than 0.",
                    "type": "number"
                  }
                },
                "required": [
                  "definition",
                  "total_definition_length",
                  "total_parts"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.0.0"
      }
    },
    "/_ml/trained_models/{model_id}/vocabulary": {
      "put": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Create a trained model vocabulary",
        "description": "This API is supported only for natural language processing (NLP) models.\nThe vocabulary is stored in the index as described in `inference_config.*.vocabulary` of the trained model definition.",
        "operationId": "ml-put-trained-model-vocabulary",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "vocabulary": {
                    "description": "The model vocabulary, which must not be empty.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "merges": {
                    "description": "The optional model merges if required by the tokenizer.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "scores": {
                    "description": "The optional vocabulary value scores if required by the tokenizer.",
                    "type": "array",
                    "items": {
                      "type": "number"
                    }
                  }
                },
                "required": [
                  "vocabulary"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.0.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_reset": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Reset an anomaly detection job",
        "description": "All model state and results are deleted. The job is ready to start over as if\nit had just been created.\nIt is not currently possible to reset multiple jobs using wildcards or a\ncomma separated list.",
        "operationId": "ml-reset-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "The ID of the job to reset.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "Should this request wait until the operation has completed before\nreturning.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delete_user_annotations",
            "description": "Specifies whether annotations that have been added by the\nuser should be deleted along with any auto-generated annotations when the job is\nreset.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.14.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_revert": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Revert to a snapshot",
        "description": "The machine learning features react quickly to anomalous input, learning new\nbehaviors in data. Highly anomalous input increases the variance in the\nmodels whilst the system learns whether this is a new step-change in behavior\nor a one-off event. In the case where this anomalous input is known to be a\none-off, then it might be appropriate to reset the model state to a time\nbefore this event. For example, you might consider reverting to a saved\nsnapshot after Black Friday or a critical system failure.",
        "operationId": "ml-revert-model-snapshot",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "You can specify `empty` as the <snapshot_id>. Reverting to the empty\nsnapshot means the anomaly detection job starts learning a new model from\nscratch when it is started.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "delete_intervening_results",
            "description": "If true, deletes the results in the time period between the latest\nresults and the time of the reverted snapshot. It also resets the model\nto accept records for this time period. If you choose not to delete\nintervening results when reverting a snapshot, the job will not accept\ninput data that is older than the current time. If you want to resend\ndata, then delete the intervening results.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "delete_intervening_results": {
                    "description": "Refer to the description for the `delete_intervening_results` query parameter.",
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "model": {
                      "$ref": "#/components/schemas/ml._types:ModelSnapshot"
                    }
                  },
                  "required": [
                    "model"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/set_upgrade_mode": {
      "post": {
        "tags": [
          "ml"
        ],
        "summary": "Set upgrade_mode for ML indices",
        "description": "Sets a cluster wide upgrade_mode setting that prepares machine learning\nindices for an upgrade.\nWhen upgrading your cluster, in some circumstances you must restart your\nnodes and reindex your machine learning indices. In those circumstances,\nthere must be no machine learning jobs running. You can close the machine\nlearning jobs, do the upgrade, then open all the jobs again. Alternatively,\nyou can use this API to temporarily halt tasks associated with the jobs and\ndatafeeds and prevent new jobs from opening. You can also use this API\nduring upgrades that do not require you to reindex your machine learning\nindices, though stopping jobs is not a requirement in that case.\nYou can see the current value for the upgrade_mode setting by using the get\nmachine learning info API.",
        "operationId": "ml-set-upgrade-mode",
        "parameters": [
          {
            "in": "query",
            "name": "enabled",
            "description": "When `true`, it enables `upgrade_mode` which temporarily halts all job\nand datafeed tasks and prohibits new job and datafeed tasks from\nstarting.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The time to wait for the request to be completed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.7.0"
      }
    },
    "/_ml/data_frame/analytics/{id}/_start": {
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Start a data frame analytics job",
        "description": "A data frame analytics job can be started and stopped multiple times\nthroughout its lifecycle.\nIf the destination index does not exist, it is created automatically the\nfirst time you start the data frame analytics job. The\n`index.number_of_shards` and `index.number_of_replicas` settings for the\ndestination index are copied from the source index. If there are multiple\nsource indices, the destination index copies the highest setting values. The\nmappings for the destination index are also copied from the source indices.\nIf there are any mapping conflicts, the job fails to start.\nIf the destination index exists, it is used as is. You can therefore set up\nthe destination index in advance with custom settings and mappings.",
        "operationId": "ml-start-data-frame-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the amount of time to wait until the data frame analytics job\nstarts.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeId"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "node"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_start": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Start datafeeds",
        "description": "A datafeed must be started in order to retrieve data from Elasticsearch. A datafeed can be started and stopped\nmultiple times throughout its lifecycle.\n\nBefore you can start a datafeed, the anomaly detection job must be open. Otherwise, an error occurs.\n\nIf you restart a stopped datafeed, it continues processing input data from the next millisecond after it was stopped.\nIf new data was indexed for that exact millisecond between stopping and starting, it will be ignored.\n\nWhen Elasticsearch security features are enabled, your datafeed remembers which roles the last user to create or\nupdate it had at the time of creation or update and runs the query using those same roles. If you provided secondary\nauthorization headers when you created or updated the datafeed, those credentials are used instead.",
        "operationId": "ml-start-datafeed",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed. This identifier can contain lowercase\nalphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric\ncharacters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "end",
            "description": "The time that the datafeed should end, which can be specified by using one of the following formats:\n\n* ISO 8601 format with milliseconds, for example `2017-01-22T06:00:00.000Z`\n* ISO 8601 format without milliseconds, for example `2017-01-22T06:00:00+00:00`\n* Milliseconds since the epoch, for example `1485061200000`\n\nDate-time arguments using either of the ISO 8601 formats must have a time zone designator, where `Z` is accepted\nas an abbreviation for UTC time. When a URL is expected (for example, in browsers), the `+` used in time zone\ndesignators must be encoded as `%2B`.\nThe end time value is exclusive. If you do not specify an end time, the datafeed\nruns continuously.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "start",
            "description": "The time that the datafeed should begin, which can be specified by using the same formats as the `end` parameter.\nThis value is inclusive.\nIf you do not specify a start time and the datafeed is associated with a new anomaly detection job, the analysis\nstarts from the earliest time for which data is available.\nIf you restart a stopped datafeed and specify a start value that is earlier than the timestamp of the latest\nprocessed record, the datafeed continues from 1 millisecond after the timestamp of the latest processed record.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Specifies the amount of time to wait until a datafeed starts.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "end": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "start": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeIds"
                    },
                    "started": {
                      "description": "For a successful response, this value is always `true`. On failure, an exception is returned instead.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "node",
                    "started"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_start": {
      "post": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Start a trained model deployment",
        "description": "It allocates the model to every machine learning node.",
        "operationId": "ml-start-trained-model-deployment",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model. Currently, only PyTorch models are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "cache_size",
            "description": "The inference cache size (in memory outside the JVM heap) per node for the model.\nThe default value is the same size as the `model_size_bytes`. To disable the cache,\n`0b` can be provided.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ByteSize"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "deployment_id",
            "description": "A unique identifier for the deployment of the model.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "number_of_allocations",
            "description": "The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "priority",
            "description": "The deployment priority.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/ml._types:TrainingPriority"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "queue_capacity",
            "description": "Specifies the number of inference requests that are allowed in the queue. After the number of requests exceeds\nthis value, new requests are rejected with a 429 error.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "threads_per_allocation",
            "description": "Sets the number of threads used by each model allocation during inference. This generally increases\nthe inference speed. The inference process is a compute-bound process; any number\ngreater than the number of available hardware threads on the machine does not increase the\ninference speed. If this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Specifies the amount of time to wait for the model to deploy.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for",
            "description": "Specifies the allocation status to wait for before returning.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/ml._types:DeploymentAllocationState"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "assignment": {
                      "$ref": "#/components/schemas/ml._types:TrainedModelAssignment"
                    }
                  },
                  "required": [
                    "assignment"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.0.0"
      }
    },
    "/_ml/data_frame/analytics/{id}/_stop": {
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Stop data frame analytics jobs",
        "description": "A data frame analytics job can be started and stopped multiple times\nthroughout its lifecycle.",
        "operationId": "ml-stop-data-frame-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is true, which returns an empty data_frame_analytics\narray when there are no matches and the subset of results when there are\npartial matches. If this parameter is false, the request returns a 404\nstatus code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If true, the data frame analytics job is stopped forcefully.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the amount of time to wait until the data frame analytics job\nstops. Defaults to 20 seconds.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_stop": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Stop datafeeds",
        "description": "A datafeed that is stopped ceases to retrieve data from Elasticsearch. A datafeed can be started and stopped\nmultiple times throughout its lifecycle.",
        "operationId": "ml-stop-datafeed",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "Identifier for the datafeed. You can stop multiple datafeeds in a single API request by using a comma-separated\nlist of datafeeds or a wildcard expression. You can close all datafeeds by using `_all` or by specifying `*` as\nthe identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If `true`, the datafeed is stopped forcefully.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Specifies the amount of time to wait until a datafeed stops.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_no_match": {
                    "description": "Refer to the description for the `allow_no_match` query parameter.",
                    "type": "boolean"
                  },
                  "force": {
                    "description": "Refer to the description for the `force` query parameter.",
                    "type": "boolean"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_stop": {
      "post": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Stop a trained model deployment",
        "operationId": "ml-stop-trained-model-deployment",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request: contains wildcard expressions and there are no deployments that match;\ncontains the  `_all` string or no identifiers and there are no matches; or contains wildcard expressions and\nthere are only partial matches. By default, it returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Forcefully stops the deployment, even if it is used by ingest pipelines. You can't use these pipelines until you\nrestart the model deployment.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.0.0"
      }
    },
    "/_ml/data_frame/analytics/{id}/_update": {
      "post": {
        "tags": [
          "ml data frame"
        ],
        "summary": "Update a data frame analytics job",
        "operationId": "ml-update-data-frame-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "model_memory_limit": {
                    "description": "The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try\nto create data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.",
                    "type": "string"
                  },
                  "max_num_threads": {
                    "description": "The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.",
                    "type": "number"
                  },
                  "allow_lazy_start": {
                    "description": "Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node.",
                    "type": "boolean"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsAuthorization"
                    },
                    "allow_lazy_start": {
                      "type": "boolean"
                    },
                    "analysis": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                    },
                    "analyzed_fields": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                    },
                    "create_time": {
                      "type": "number"
                    },
                    "description": {
                      "type": "string"
                    },
                    "dest": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "max_num_threads": {
                      "type": "number"
                    },
                    "model_memory_limit": {
                      "type": "string"
                    },
                    "source": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    }
                  },
                  "required": [
                    "allow_lazy_start",
                    "analysis",
                    "create_time",
                    "dest",
                    "id",
                    "max_num_threads",
                    "model_memory_limit",
                    "source",
                    "version"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_update": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Update a datafeed",
        "description": "You must stop and start the datafeed for the changes to be applied.\nWhen Elasticsearch security features are enabled, your datafeed remembers which roles the user who updated it had at\nthe time of the update and runs the query using those same roles. If you provide secondary authorization headers,\nthose credentials are used instead.",
        "operationId": "ml-update-datafeed",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed.\nThis identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.\nIt must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `true`, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the\n`_all` string or when no indices are specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument determines\nwhether wildcard expressions match hidden data streams. Supports comma-separated values. Valid values are:\n\n* `all`: Match any data stream or index, including hidden ones.\n* `closed`: Match closed, non-hidden indices. Also matches any non-hidden data stream. Data streams cannot be closed.\n* `hidden`: Match hidden data streams and hidden indices. Must be combined with `open`, `closed`, or both.\n* `none`: Wildcard patterns are not accepted.\n* `open`: Match open, non-hidden indices. Also matches any non-hidden data stream.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_throttled",
            "description": "If `true`, concrete, expanded or aliased indices are ignored when frozen.",
            "deprecated": true,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `true`, unavailable indices (missing or closed) are ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aggregations": {
                    "description": "If set, the datafeed performs aggregation searches. Support for aggregations is limited and should be used only\nwith low cardinality data.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                    }
                  },
                  "chunking_config": {
                    "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                  },
                  "delayed_data_check_config": {
                    "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "indices": {
                    "description": "An array of index names. Wildcards are supported. If any of the indices are in remote clusters, the machine\nlearning nodes must have the `remote_cluster_client` role.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "indices_options": {
                    "$ref": "#/components/schemas/_types:IndicesOptions"
                  },
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "max_empty_searches": {
                    "description": "If a real-time datafeed has never seen any data (including during any initial training period), it automatically\nstops and closes the associated job after this many real-time searches return no documents. In other words,\nit stops after `frequency` times `max_empty_searches` of real-time operation. If not set, a datafeed with no\nend time that sees no data remains started until it is explicitly stopped. By default, it is not set.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "query_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "runtime_mappings": {
                    "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                  },
                  "script_fields": {
                    "description": "Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.\nThe detector configuration objects in a job can contain functions that use these script fields.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types:ScriptField"
                    }
                  },
                  "scroll_size": {
                    "description": "The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.\nThe maximum value is the value of `index.max_result_window`.",
                    "type": "number"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DatafeedAuthorization"
                    },
                    "aggregations": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                      }
                    },
                    "chunking_config": {
                      "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                    },
                    "delayed_data_check_config": {
                      "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                    },
                    "datafeed_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "frequency": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "indices_options": {
                      "$ref": "#/components/schemas/_types:IndicesOptions"
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "max_empty_searches": {
                      "type": "number"
                    },
                    "query": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    },
                    "query_delay": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "runtime_mappings": {
                      "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                    },
                    "script_fields": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types:ScriptField"
                      }
                    },
                    "scroll_size": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "chunking_config",
                    "datafeed_id",
                    "indices",
                    "job_id",
                    "query",
                    "query_delay",
                    "scroll_size"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_ml/filters/{filter_id}/_update": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Update a filter",
        "description": "Updates the description of a filter, adds items, or removes items from the list.",
        "operationId": "ml-update-filter",
        "parameters": [
          {
            "in": "path",
            "name": "filter_id",
            "description": "A string that uniquely identifies a filter.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "add_items": {
                    "description": "The items to add to the filter.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "description": {
                    "description": "A description for the filter.",
                    "type": "string"
                  },
                  "remove_items": {
                    "description": "The items to remove from the filter.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "description": {
                      "type": "string"
                    },
                    "filter_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "description",
                    "filter_id",
                    "items"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_update": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Update an anomaly detection job",
        "description": "Updates certain properties of an anomaly detection job.",
        "operationId": "ml-update-job",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_lazy_open": {
                    "description": "Advanced configuration option. Specifies whether this job can open when\nthere is insufficient machine learning node capacity for it to be\nimmediately assigned to a node. If `false` and a machine learning node\nwith capacity to run the job cannot immediately be found, the open\nanomaly detection jobs API returns an error. However, this is also\nsubject to the cluster-wide `xpack.ml.max_lazy_ml_nodes` setting. If this\noption is set to `true`, the open anomaly detection jobs API does not\nreturn an error and the job waits in the opening state until sufficient\nmachine learning node capacity is available.",
                    "type": "boolean"
                  },
                  "analysis_limits": {
                    "$ref": "#/components/schemas/ml._types:AnalysisMemoryLimit"
                  },
                  "background_persist_interval": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "custom_settings": {
                    "description": "Advanced configuration option. Contains custom meta data about the job.\nFor example, it can contain custom URL information as shown in Adding\ncustom URLs to machine learning results.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  },
                  "categorization_filters": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "model_plot_config": {
                    "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                  },
                  "model_prune_window": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "daily_model_snapshot_retention_after_days": {
                    "description": "Advanced configuration option, which affects the automatic removal of old\nmodel snapshots for this job. It specifies a period of time (in days)\nafter which only the first snapshot per day is retained. This period is\nrelative to the timestamp of the most recent snapshot for this job. Valid\nvalues range from 0 to `model_snapshot_retention_days`. For jobs created\nbefore version 7.8.0, the default value matches\n`model_snapshot_retention_days`.",
                    "type": "number"
                  },
                  "model_snapshot_retention_days": {
                    "description": "Advanced configuration option, which affects the automatic removal of old\nmodel snapshots for this job. It specifies the maximum period of time (in\ndays) that snapshots are retained. This period is relative to the\ntimestamp of the most recent snapshot for this job.",
                    "type": "number"
                  },
                  "renormalization_window_days": {
                    "description": "Advanced configuration option. The period over which adjustments to the\nscore are applied, as new data is seen.",
                    "type": "number"
                  },
                  "results_retention_days": {
                    "description": "Advanced configuration option. The period of time (in days) that results\nare retained. Age is calculated relative to the timestamp of the latest\nbucket result. If this property has a non-null value, once per day at\n00:30 (server time), results that are the specified number of days older\nthan the latest bucket result are deleted from Elasticsearch. The default\nvalue is null, which means all results are retained.",
                    "type": "number"
                  },
                  "groups": {
                    "description": "A list of job groups. A job can belong to no groups or many.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "detectors": {
                    "description": "An array of detector update objects.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ml._types:DetectorUpdate"
                    }
                  },
                  "per_partition_categorization": {
                    "$ref": "#/components/schemas/ml._types:PerPartitionCategorization"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allow_lazy_open": {
                      "type": "boolean"
                    },
                    "analysis_config": {
                      "$ref": "#/components/schemas/ml._types:AnalysisConfigRead"
                    },
                    "analysis_limits": {
                      "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                    },
                    "background_persist_interval": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "create_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "finished_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "custom_settings": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "daily_model_snapshot_retention_after_days": {
                      "type": "number"
                    },
                    "data_description": {
                      "$ref": "#/components/schemas/ml._types:DataDescription"
                    },
                    "datafeed_config": {
                      "$ref": "#/components/schemas/ml._types:Datafeed"
                    },
                    "description": {
                      "type": "string"
                    },
                    "groups": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "job_type": {
                      "type": "string"
                    },
                    "job_version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    },
                    "model_plot_config": {
                      "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                    },
                    "model_snapshot_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "model_snapshot_retention_days": {
                      "type": "number"
                    },
                    "renormalization_window_days": {
                      "type": "number"
                    },
                    "results_index_name": {
                      "$ref": "#/components/schemas/_types:IndexName"
                    },
                    "results_retention_days": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "allow_lazy_open",
                    "analysis_config",
                    "analysis_limits",
                    "create_time",
                    "daily_model_snapshot_retention_after_days",
                    "data_description",
                    "job_id",
                    "job_type",
                    "job_version",
                    "model_snapshot_retention_days",
                    "results_index_name"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_update": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Update a snapshot",
        "description": "Updates certain properties of a snapshot.",
        "operationId": "ml-update-model-snapshot",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "Identifier for the model snapshot.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A description of the model snapshot.",
                    "type": "string"
                  },
                  "retain": {
                    "description": "If `true`, this snapshot will not be deleted during automatic cleanup of\nsnapshots older than `model_snapshot_retention_days`. However, this\nsnapshot will be deleted when the job is deleted.",
                    "type": "boolean"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "model": {
                      "$ref": "#/components/schemas/ml._types:ModelSnapshot"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "model"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_update": {
      "post": {
        "tags": [
          "ml trained model"
        ],
        "summary": "Update a trained model deployment",
        "operationId": "ml-update-trained-model-deployment",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model. Currently, only PyTorch models are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "number_of_allocations",
            "description": "The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "number_of_allocations": {
                    "description": "The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.",
                    "type": "number"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "assignment": {
                      "$ref": "#/components/schemas/ml._types:TrainedModelAssignment"
                    }
                  },
                  "required": [
                    "assignment"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true,
        "x-state": "Added in 8.6.0"
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_upgrade": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Upgrade a snapshot",
        "description": "Upgrades an anomaly detection model snapshot to the latest major version.\nOver time, older snapshot formats are deprecated and removed. Anomaly\ndetection jobs support only snapshots that are from the current or previous\nmajor version.\nThis API provides a means to upgrade a snapshot to the current major version.\nThis aids in preparing the cluster for an upgrade to the next major version.\nOnly one snapshot per anomaly detection job can be upgraded at a time and the\nupgraded snapshot cannot be the current snapshot of the anomaly detection\njob.",
        "operationId": "ml-upgrade-job-snapshot",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "A numerical character string that uniquely identifies the model snapshot.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "When true, the API wonâ€™t respond until the upgrade is complete.\nOtherwise, it responds as soon as the upgrade task is assigned to a node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait for the request to complete.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeId"
                    },
                    "completed": {
                      "description": "When true, this means the task is complete. When false, it is still running.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "node",
                    "completed"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_ml/anomaly_detectors/_validate": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Validate an anomaly detection job",
        "operationId": "ml-validate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "analysis_config": {
                    "$ref": "#/components/schemas/ml._types:AnalysisConfig"
                  },
                  "analysis_limits": {
                    "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                  },
                  "data_description": {
                    "$ref": "#/components/schemas/ml._types:DataDescription"
                  },
                  "description": {
                    "type": "string"
                  },
                  "model_plot": {
                    "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                  },
                  "model_snapshot_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "model_snapshot_retention_days": {
                    "type": "number"
                  },
                  "results_index_name": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_ml/anomaly_detectors/_validate/detector": {
      "post": {
        "tags": [
          "ml anomaly"
        ],
        "summary": "Validate an anomaly detection job",
        "operationId": "ml-validate-detector",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ml._types:Detector"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 5.4.0"
      }
    },
    "/_monitoring/bulk": {
      "put": {
        "tags": [
          "monitoring"
        ],
        "summary": "Send monitoring data",
        "description": "This API is used by the monitoring features to send monitoring data.",
        "operationId": "monitoring-bulk-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_id"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_api_version"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#interval"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/monitoring.bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/monitoring.bulk#200"
          }
        },
        "x-state": "Added in 6.3.0"
      },
      "post": {
        "tags": [
          "monitoring"
        ],
        "summary": "Send monitoring data",
        "description": "This API is used by the monitoring features to send monitoring data.",
        "operationId": "monitoring-bulk",
        "parameters": [
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_id"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_api_version"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#interval"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/monitoring.bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/monitoring.bulk#200"
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_monitoring/{type}/bulk": {
      "put": {
        "tags": [
          "monitoring"
        ],
        "summary": "Send monitoring data",
        "description": "This API is used by the monitoring features to send monitoring data.",
        "operationId": "monitoring-bulk-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/monitoring.bulk#type"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_id"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_api_version"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#interval"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/monitoring.bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/monitoring.bulk#200"
          }
        },
        "x-state": "Added in 6.3.0"
      },
      "post": {
        "tags": [
          "monitoring"
        ],
        "summary": "Send monitoring data",
        "description": "This API is used by the monitoring features to send monitoring data.",
        "operationId": "monitoring-bulk-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/monitoring.bulk#type"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_id"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#system_api_version"
          },
          {
            "$ref": "#/components/parameters/monitoring.bulk#interval"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/monitoring.bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/monitoring.bulk#200"
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_msearch": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple searches",
        "description": "The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.\nThe structure is as follows:\n\n```\nheader\\n\nbody\\n\nheader\\n\nbody\\n\n```\n\nThis structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.\n\nIMPORTANT: The final line of data must end with a newline character `\\n`.\nEach newline character may be preceded by a carriage return `\\r`.\nWhen sending requests to this endpoint the `Content-Type` header should be set to `application/x-ndjson`.",
        "operationId": "msearch",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        },
        "x-state": "Added in 1.3.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple searches",
        "description": "The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.\nThe structure is as follows:\n\n```\nheader\\n\nbody\\n\nheader\\n\nbody\\n\n```\n\nThis structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.\n\nIMPORTANT: The final line of data must end with a newline character `\\n`.\nEach newline character may be preceded by a carriage return `\\r`.\nWhen sending requests to this endpoint the `Content-Type` header should be set to `application/x-ndjson`.",
        "operationId": "msearch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/{index}/_msearch": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple searches",
        "description": "The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.\nThe structure is as follows:\n\n```\nheader\\n\nbody\\n\nheader\\n\nbody\\n\n```\n\nThis structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.\n\nIMPORTANT: The final line of data must end with a newline character `\\n`.\nEach newline character may be preceded by a carriage return `\\r`.\nWhen sending requests to this endpoint the `Content-Type` header should be set to `application/x-ndjson`.",
        "operationId": "msearch-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#index"
          },
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        },
        "x-state": "Added in 1.3.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple searches",
        "description": "The format of the request is similar to the bulk API format and makes use of the newline delimited JSON (NDJSON) format.\nThe structure is as follows:\n\n```\nheader\\n\nbody\\n\nheader\\n\nbody\\n\n```\n\nThis structure is specifically optimized to reduce parsing if a specific search ends up redirected to another node.\n\nIMPORTANT: The final line of data must end with a newline character `\\n`.\nEach newline character may be preceded by a carriage return `\\r`.\nWhen sending requests to this endpoint the `Content-Type` header should be set to `application/x-ndjson`.",
        "operationId": "msearch-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#index"
          },
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_msearch/template": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple templated searches",
        "description": "Run multiple templated searches with a single request.\nIf you are providing a text file or text input to `curl`, use the `--data-binary` flag instead of `-d` to preserve newlines.\nFor example:\n\n```\n$ cat requests\n{ \"index\": \"my-index\" }\n{ \"id\": \"my-search-template\", \"params\": { \"query_string\": \"hello world\", \"from\": 0, \"size\": 10 }}\n{ \"index\": \"my-other-index\" }\n{ \"id\": \"my-other-search-template\", \"params\": { \"query_type\": \"match_all\" }}\n\n$ curl -H \"Content-Type: application/x-ndjson\" -XGET localhost:9200/_msearch/template --data-binary \"@requests\"; echo\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "msearch-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple templated searches",
        "description": "Run multiple templated searches with a single request.\nIf you are providing a text file or text input to `curl`, use the `--data-binary` flag instead of `-d` to preserve newlines.\nFor example:\n\n```\n$ cat requests\n{ \"index\": \"my-index\" }\n{ \"id\": \"my-search-template\", \"params\": { \"query_string\": \"hello world\", \"from\": 0, \"size\": 10 }}\n{ \"index\": \"my-other-index\" }\n{ \"id\": \"my-other-search-template\", \"params\": { \"query_type\": \"match_all\" }}\n\n$ curl -H \"Content-Type: application/x-ndjson\" -XGET localhost:9200/_msearch/template --data-binary \"@requests\"; echo\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "msearch-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/{index}/_msearch/template": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple templated searches",
        "description": "Run multiple templated searches with a single request.\nIf you are providing a text file or text input to `curl`, use the `--data-binary` flag instead of `-d` to preserve newlines.\nFor example:\n\n```\n$ cat requests\n{ \"index\": \"my-index\" }\n{ \"id\": \"my-search-template\", \"params\": { \"query_string\": \"hello world\", \"from\": 0, \"size\": 10 }}\n{ \"index\": \"my-other-index\" }\n{ \"id\": \"my-other-search-template\", \"params\": { \"query_type\": \"match_all\" }}\n\n$ curl -H \"Content-Type: application/x-ndjson\" -XGET localhost:9200/_msearch/template --data-binary \"@requests\"; echo\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "msearch-template-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#index"
          },
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        },
        "x-state": "Added in 5.0.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run multiple templated searches",
        "description": "Run multiple templated searches with a single request.\nIf you are providing a text file or text input to `curl`, use the `--data-binary` flag instead of `-d` to preserve newlines.\nFor example:\n\n```\n$ cat requests\n{ \"index\": \"my-index\" }\n{ \"id\": \"my-search-template\", \"params\": { \"query_string\": \"hello world\", \"from\": 0, \"size\": 10 }}\n{ \"index\": \"my-other-index\" }\n{ \"id\": \"my-other-search-template\", \"params\": { \"query_type\": \"match_all\" }}\n\n$ curl -H \"Content-Type: application/x-ndjson\" -XGET localhost:9200/_msearch/template --data-binary \"@requests\"; echo\n```",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "msearch-template-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#index"
          },
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        },
        "x-state": "Added in 5.0.0"
      }
    },
    "/_mtermvectors": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple term vectors",
        "description": "Get multiple term vectors with a single request.\nYou can specify existing documents by index and ID or provide artificial documents in the body of the request.\nYou can specify the index in the request body or request URI.\nThe response contains a `docs` array with all the fetched termvectors.\nEach element has the structure provided by the termvectors API.\n\n**Artificial documents**\n\nYou can also use `mtermvectors` to generate term vectors for artificial documents provided in the body of the request.\nThe mapping used is determined by the specified `_index`.",
        "operationId": "mtermvectors",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple term vectors",
        "description": "Get multiple term vectors with a single request.\nYou can specify existing documents by index and ID or provide artificial documents in the body of the request.\nYou can specify the index in the request body or request URI.\nThe response contains a `docs` array with all the fetched termvectors.\nEach element has the structure provided by the termvectors API.\n\n**Artificial documents**\n\nYou can also use `mtermvectors` to generate term vectors for artificial documents provided in the body of the request.\nThe mapping used is determined by the specified `_index`.",
        "operationId": "mtermvectors-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      }
    },
    "/{index}/_mtermvectors": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple term vectors",
        "description": "Get multiple term vectors with a single request.\nYou can specify existing documents by index and ID or provide artificial documents in the body of the request.\nYou can specify the index in the request body or request URI.\nThe response contains a `docs` array with all the fetched termvectors.\nEach element has the structure provided by the termvectors API.\n\n**Artificial documents**\n\nYou can also use `mtermvectors` to generate term vectors for artificial documents provided in the body of the request.\nThe mapping used is determined by the specified `_index`.",
        "operationId": "mtermvectors-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#index"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Get multiple term vectors",
        "description": "Get multiple term vectors with a single request.\nYou can specify existing documents by index and ID or provide artificial documents in the body of the request.\nYou can specify the index in the request body or request URI.\nThe response contains a `docs` array with all the fetched termvectors.\nEach element has the structure provided by the termvectors API.\n\n**Artificial documents**\n\nYou can also use `mtermvectors` to generate term vectors for artificial documents provided in the body of the request.\nThe mapping used is determined by the specified `_index`.",
        "operationId": "mtermvectors-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#index"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/_repositories_metering/{max_archive_version}": {
      "delete": {
        "tags": [
          "cluster"
        ],
        "summary": "Clear the archived repositories metering",
        "description": "Clear the archived repositories metering information in the cluster.",
        "operationId": "nodes-clear-repositories-metering-archive",
        "parameters": [
          {
            "in": "path",
            "name": "node_id",
            "description": "Comma-separated list of node IDs or names used to limit returned information.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:NodeIds"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "max_archive_version",
            "description": "Specifies the maximum `archive_version` to be cleared from the archive.",
            "required": true,
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/nodes.clear_repositories_metering_archive:ResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_nodes/{node_id}/_repositories_metering": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get cluster repositories metering",
        "description": "Get repositories metering information for a cluster.\nThis API exposes monotonically non-decreasing counters and it is expected that clients would durably store the information needed to compute aggregations over a period of time.\nAdditionally, the information exposed by this API is volatile, meaning that it will not be present after node restarts.",
        "operationId": "nodes-get-repositories-metering-info",
        "parameters": [
          {
            "in": "path",
            "name": "node_id",
            "description": "Comma-separated list of node IDs or names used to limit returned information.\nAll the nodes selective options are explained [here](https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster.html#cluster-nodes).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:NodeIds"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/nodes.get_repositories_metering_info:ResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_nodes/hot_threads": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the hot threads for nodes",
        "description": "Get a breakdown of the hot threads on each selected node in the cluster.\nThe output is plain text with a breakdown of the top hot threads for each node.",
        "operationId": "nodes-hot-threads",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.hot_threads#ignore_idle_threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#interval"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#snapshots"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#type"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#sort"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.hot_threads#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/hot_threads": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get the hot threads for nodes",
        "description": "Get a breakdown of the hot threads on each selected node in the cluster.\nThe output is plain text with a breakdown of the top hot threads for each node.",
        "operationId": "nodes-hot-threads-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.hot_threads#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#ignore_idle_threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#interval"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#snapshots"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#type"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#sort"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.hot_threads#200"
          }
        }
      }
    },
    "/_nodes": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node information",
        "description": "By default, the API returns all attributes and core settings for cluster nodes.",
        "operationId": "nodes-info",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_nodes/{node_id}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node information",
        "description": "By default, the API returns all attributes and core settings for cluster nodes.",
        "operationId": "nodes-info-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_nodes/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node information",
        "description": "By default, the API returns all attributes and core settings for cluster nodes.",
        "operationId": "nodes-info-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_nodes/{node_id}/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node information",
        "description": "By default, the API returns all attributes and core settings for cluster nodes.",
        "operationId": "nodes-info-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.info#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        },
        "x-state": "Added in 1.3.0"
      }
    },
    "/_nodes/reload_secure_settings": {
      "post": {
        "tags": [
          "cluster"
        ],
        "summary": "Reload the keystore on nodes in the cluster",
        "description": "Secure settings are stored in an on-disk keystore. Certain of these settings are reloadable.\nThat is, you can change them on disk and reload them without restarting any nodes in the cluster.\nWhen you have updated reloadable secure settings in your keystore, you can use this API to reload those settings on each node.\n\nWhen the Elasticsearch keystore is password protected and not simply obfuscated, you must provide the password for the keystore when you reload the secure settings.\nReloading the settings for the whole cluster assumes that the keystores for all nodes are protected with the same password; this method is allowed only when inter-node communications are encrypted.\nAlternatively, you can reload the secure settings on each node by locally accessing the API and passing the node-specific Elasticsearch keystore password.",
        "operationId": "nodes-reload-secure-settings",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.reload_secure_settings#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/nodes.reload_secure_settings"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.reload_secure_settings#200"
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_nodes/{node_id}/reload_secure_settings": {
      "post": {
        "tags": [
          "cluster"
        ],
        "summary": "Reload the keystore on nodes in the cluster",
        "description": "Secure settings are stored in an on-disk keystore. Certain of these settings are reloadable.\nThat is, you can change them on disk and reload them without restarting any nodes in the cluster.\nWhen you have updated reloadable secure settings in your keystore, you can use this API to reload those settings on each node.\n\nWhen the Elasticsearch keystore is password protected and not simply obfuscated, you must provide the password for the keystore when you reload the secure settings.\nReloading the settings for the whole cluster assumes that the keystores for all nodes are protected with the same password; this method is allowed only when inter-node communications are encrypted.\nAlternatively, you can reload the secure settings on each node by locally accessing the API and passing the node-specific Elasticsearch keystore password.",
        "operationId": "nodes-reload-secure-settings-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.reload_secure_settings#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.reload_secure_settings#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/nodes.reload_secure_settings"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.reload_secure_settings#200"
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_nodes/stats": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node statistics",
        "description": "Get statistics for nodes in a cluster.\nBy default, all stats are returned. You can limit the returned information by using metrics.",
        "operationId": "nodes-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/stats": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node statistics",
        "description": "Get statistics for nodes in a cluster.\nBy default, all stats are returned. You can limit the returned information by using metrics.",
        "operationId": "nodes-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/stats/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node statistics",
        "description": "Get statistics for nodes in a cluster.\nBy default, all stats are returned. You can limit the returned information by using metrics.",
        "operationId": "nodes-stats-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/stats/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node statistics",
        "description": "Get statistics for nodes in a cluster.\nBy default, all stats are returned. You can limit the returned information by using metrics.",
        "operationId": "nodes-stats-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/stats/{metric}/{index_metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node statistics",
        "description": "Get statistics for nodes in a cluster.\nBy default, all stats are returned. You can limit the returned information by using metrics.",
        "operationId": "nodes-stats-4",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#index_metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/stats/{metric}/{index_metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get node statistics",
        "description": "Get statistics for nodes in a cluster.\nBy default, all stats are returned. You can limit the returned information by using metrics.",
        "operationId": "nodes-stats-5",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#index_metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/usage": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get feature usage information",
        "operationId": "nodes-usage",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        },
        "x-state": "Added in 6.0.0"
      }
    },
    "/_nodes/{node_id}/usage": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get feature usage information",
        "operationId": "nodes-usage-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        },
        "x-state": "Added in 6.0.0"
      }
    },
    "/_nodes/usage/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get feature usage information",
        "operationId": "nodes-usage-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        },
        "x-state": "Added in 6.0.0"
      }
    },
    "/_nodes/{node_id}/usage/{metric}": {
      "get": {
        "tags": [
          "cluster"
        ],
        "summary": "Get feature usage information",
        "operationId": "nodes-usage-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        },
        "x-state": "Added in 6.0.0"
      }
    },
    "/{index}/_pit": {
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Open a point in time",
        "description": "A search request by default runs against the most recent visible data of the target indices,\nwhich is called point in time. Elasticsearch pit (point in time) is a lightweight view into the\nstate of the data as it existed when initiated. In some cases, itâ€™s preferred to perform multiple\nsearch requests using the same point in time. For example, if refreshes happen between\n`search_after` requests, then the results of those requests might not be consistent as changes happening\nbetween searches are only visible to the more recent point in time.\n\nA point in time must be opened explicitly before being used in search requests.\n\nA subsequent search request with the `pit` parameter must not specify `index`, `routing`, or `preference` values as these parameters are copied from the point in time.\n\nJust like regular searches, you can use `from` and `size` to page through point in time search results, up to the first 10,000 hits.\nIf you want to retrieve more hits, use PIT with `search_after`.\n\nIMPORTANT: The open point in time request and each subsequent search request can return different identifiers; always use the most recently received ID for the next search request.\n\nWhen a PIT that contains shard failures is used in a search request, the missing are always reported in the search response as a `NoShardAvailableActionException` exception.\nTo get rid of these exceptions, a new PIT needs to be created so that shards missing from the previous PIT can be handled, assuming they become available in the meantime.\n\n**Keeping point in time alive**\n\nThe `keep_alive` parameter, which is passed to a open point in time request and search request, extends the time to live of the corresponding point in time.\nThe value does not need to be long enough to process all dataâ€‰â€”â€‰it just needs to be long enough for the next request.\n\nNormally, the background merge process optimizes the index by merging together smaller segments to create new, bigger segments.\nOnce the smaller segments are no longer needed they are deleted.\nHowever, open point-in-times prevent the old segments from being deleted since they are still in use.\n\nTIP: Keeping older segments alive means that more disk space and file handles are needed.\nEnsure that you have configured your nodes to have ample free file handles.\n\nAdditionally, if a segment contains deleted or updated documents then the point in time must keep track of whether each document in the segment was live at the time of the initial search request.\nEnsure that your nodes have sufficient heap space if you have many open point-in-times on an index that is subject to ongoing deletes or updates.\nNote that a point-in-time doesn't prevent its associated indices from being deleted.\nYou can check how many point-in-times (that is, search contexts) are open with the nodes stats API.",
        "operationId": "open-point-in-time",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of index names to open point in time; use `_all` or empty string to perform the operation on all indices",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "Extend the length of time that the point in time persists.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nBy default, it is random.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value that is used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nIt supports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "allow_partial_search_results",
            "description": "Indicates whether the point in time tolerates unavailable shards or shard failures when initially creating the PIT.\nIf `false`, creating a point in time request when a shard is missing or unavailable will throw an exception.\nIf `true`, the point in time will contain all the shards that are available at the time of the request.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "index_filter": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_shards": {
                      "$ref": "#/components/schemas/_types:ShardStatistics"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "required": [
                    "_shards",
                    "id"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_scripts/{id}/{context}": {
      "put": {
        "tags": [
          "script"
        ],
        "summary": "Create or update a script or search template",
        "description": "Creates or updates a stored script or search template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "put-script-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#context"
          },
          {
            "$ref": "#/components/parameters/put_script#context_"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      },
      "post": {
        "tags": [
          "script"
        ],
        "summary": "Create or update a script or search template",
        "description": "Creates or updates a stored script or search template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "put-script-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#context"
          },
          {
            "$ref": "#/components/parameters/put_script#context_"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      }
    },
    "/_query_rules/{ruleset_id}/_rule/{rule_id}": {
      "get": {
        "tags": [
          "query_rules"
        ],
        "summary": "Get a query rule",
        "description": "Get details about a query rule within a query ruleset.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-using-query-rules.html"
        },
        "operationId": "query-rules-get-rule",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset containing the rule to retrieve",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The unique identifier of the query rule within the specified ruleset to retrieve",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query_rules._types:QueryRule"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "put": {
        "tags": [
          "query_rules"
        ],
        "summary": "Create or update a query rule",
        "description": "Create or update a query rule within a query ruleset.\n\nIMPORTANT: Due to limitations within pinned queries, you can only pin documents using ids or docs, but cannot use both in single rule.\nIt is advised to use one or the other in query rulesets, to avoid errors.\nAdditionally, pinned queries have a maximum limit of 100 pinned hits.\nIf multiple matching rules pin more than 100 documents, only the first 100 documents are pinned in the order they are specified in the ruleset.",
        "operationId": "query-rules-put-rule",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset containing the rule to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The unique identifier of the query rule within the specified ruleset to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "type": {
                    "$ref": "#/components/schemas/query_rules._types:QueryRuleType"
                  },
                  "criteria": {
                    "description": "The criteria that must be met for the rule to be applied.\nIf multiple criteria are specified for a rule, all criteria must be met for the rule to be applied.",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/query_rules._types:QueryRuleCriteria"
                      },
                      {
                        "type": "array",
                        "items": {
                          "$ref": "#/components/schemas/query_rules._types:QueryRuleCriteria"
                        }
                      }
                    ]
                  },
                  "actions": {
                    "$ref": "#/components/schemas/query_rules._types:QueryRuleActions"
                  },
                  "priority": {
                    "type": "number"
                  }
                },
                "required": [
                  "type",
                  "criteria",
                  "actions"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "delete": {
        "tags": [
          "query_rules"
        ],
        "summary": "Delete a query rule",
        "description": "Delete a query rule within a query ruleset.\nThis is a destructive action that is only recoverable by re-adding the same rule with the create or update query rule API.",
        "operationId": "query-rules-delete-rule",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset containing the rule to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The unique identifier of the query rule within the specified ruleset to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_query_rules/{ruleset_id}": {
      "get": {
        "tags": [
          "query_rules"
        ],
        "summary": "Get a query ruleset",
        "description": "Get details about a query ruleset.",
        "operationId": "query-rules-get-ruleset",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query_rules._types:QueryRuleset"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      },
      "put": {
        "tags": [
          "query_rules"
        ],
        "summary": "Create or update a query ruleset",
        "description": "There is a limit of 100 rules per ruleset.\nThis limit can be increased by using the `xpack.applications.rules.max_rules_per_ruleset` cluster setting.\n\nIMPORTANT: Due to limitations within pinned queries, you can only select documents using `ids` or `docs`, but cannot use both in single rule.\nIt is advised to use one or the other in query rulesets, to avoid errors.\nAdditionally, pinned queries have a maximum limit of 100 pinned hits.\nIf multiple matching rules pin more than 100 documents, only the first 100 documents are pinned in the order they are specified in the ruleset.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-using-query-rules.html"
        },
        "operationId": "query-rules-put-ruleset",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "rules": {
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/query_rules._types:QueryRule"
                      },
                      {
                        "type": "array",
                        "items": {
                          "$ref": "#/components/schemas/query_rules._types:QueryRule"
                        }
                      }
                    ]
                  }
                },
                "required": [
                  "rules"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      },
      "delete": {
        "tags": [
          "query_rules"
        ],
        "summary": "Delete a query ruleset",
        "description": "Remove a query ruleset and its associated data.\nThis is a destructive action that is not recoverable.",
        "operationId": "query-rules-delete-ruleset",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      }
    },
    "/_query_rules": {
      "get": {
        "tags": [
          "query_rules"
        ],
        "summary": "Get all query rulesets",
        "description": "Get summarized information about the query rulesets.",
        "operationId": "query-rules-list-rulesets",
        "parameters": [
          {
            "in": "query",
            "name": "from",
            "description": "The offset from the first result to fetch.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "The maximum number of results to retrieve.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/query_rules.list_rulesets:QueryRulesetListItem"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      }
    },
    "/_query_rules/{ruleset_id}/_test": {
      "post": {
        "tags": [
          "query_rules"
        ],
        "summary": "Test a query ruleset",
        "description": "Evaluate match criteria against a query ruleset to identify the rules that would match that criteria.",
        "operationId": "query-rules-test",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset to be created or updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "match_criteria": {
                    "description": "The match criteria to apply to rules in the given query ruleset.\nMatch criteria should match the keys defined in the `criteria.metadata` field of the rule.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                },
                "required": [
                  "match_criteria"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "total_matched_rules": {
                      "type": "number"
                    },
                    "matched_rules": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/query_rules.test:QueryRulesetMatchedRule"
                      }
                    }
                  },
                  "required": [
                    "total_matched_rules",
                    "matched_rules"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      }
    },
    "/_rank_eval": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Evaluate ranked search results",
        "description": "Evaluate the quality of ranked search results over a set of typical search queries.",
        "operationId": "rank-eval",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Evaluate ranked search results",
        "description": "Evaluate the quality of ranked search results over a set of typical search queries.",
        "operationId": "rank-eval-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/{index}/_rank_eval": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Evaluate ranked search results",
        "description": "Evaluate the quality of ranked search results over a set of typical search queries.",
        "operationId": "rank-eval-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#index"
          },
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        },
        "x-state": "Added in 6.2.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Evaluate ranked search results",
        "description": "Evaluate the quality of ranked search results over a set of typical search queries.",
        "operationId": "rank-eval-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#index"
          },
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_reindex": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Reindex documents",
        "description": "Copy documents from a source to a destination.\nYou can copy all documents to the destination index or reindex a subset of the documents.\nThe source can be any existing index, alias, or data stream.\nThe destination must differ from the source.\nFor example, you cannot reindex a data stream into itself.\n\nIMPORTANT: Reindex requires `_source` to be enabled for all documents in the source.\nThe destination should be configured as wanted before calling the reindex API.\nReindex does not copy the settings from the source or its associated template.\nMappings, shard counts, and replicas, for example, must be configured ahead of time.\n\nIf the Elasticsearch security features are enabled, you must have the following security privileges:\n\n* The `read` index privilege for the source data stream, index, or alias.\n* The `write` index privilege for the destination data stream, index, or index alias.\n* To automatically create a data stream or index with a reindex API request, you must have the `auto_configure`, `create_index`, or `manage` index privilege for the destination data stream, index, or alias.\n* If reindexing from a remote cluster, the `source.remote.user` must have the `monitor` cluster privilege and the `read` index privilege for the source data stream, index, or alias.\n\nIf reindexing from a remote cluster, you must explicitly allow the remote host in the `reindex.remote.whitelist` setting.\nAutomatic data stream creation requires a matching index template with data stream enabled.\n\nThe `dest` element can be configured like the index API to control optimistic concurrency control.\nOmitting `version_type` or setting it to `internal` causes Elasticsearch to blindly dump documents into the destination, overwriting any that happen to have the same ID.\n\nSetting `version_type` to `external` causes Elasticsearch to preserve the `version` from the source, create any documents that are missing, and update any documents that have an older version in the destination than they do in the source.\n\nSetting `op_type` to `create` causes the reindex API to create only missing documents in the destination.\nAll existing documents will cause a version conflict.\n\nIMPORTANT: Because data streams are append-only, any reindex request to a destination data stream must have an `op_type` of `create`.\nA reindex can only add new documents to a destination data stream.\nIt cannot update existing documents in a destination data stream.\n\nBy default, version conflicts abort the reindex process.\nTo continue reindexing if there are conflicts, set the `conflicts` request body property to `proceed`.\nIn this case, the response includes a count of the version conflicts that were encountered.\nNote that the handling of other error types is unaffected by the `conflicts` property.\nAdditionally, if you opt to count version conflicts, the operation could attempt to reindex more documents from the source than `max_docs` until it has successfully indexed `max_docs` documents into the target or it has gone through every document in the source query.\n\nNOTE: The reindex API makes no effort to handle ID collisions.\nThe last document written will \"win\" but the order isn't usually predictable so it is not a good idea to rely on this behavior.\nInstead, make sure that IDs are unique by using a script.\n\n**Running reindex asynchronously**\n\nIf the request contains `wait_for_completion=false`, Elasticsearch performs some preflight checks, launches the request, and returns a task you can use to cancel or get the status of the task.\nElasticsearch creates a record of this task as a document at `_tasks/<task_id>`.\n\n**Reindex from multiple sources**\n\nIf you have many sources to reindex it is generally better to reindex them one at a time rather than using a glob pattern to pick up multiple sources.\nThat way you can resume the process if there are any errors by removing the partially completed source and starting over.\nIt also makes parallelizing the process fairly simple: split the list of sources to reindex and run each list in parallel.\n\nFor example, you can use a bash script like this:\n\n```\nfor index in i1 i2 i3 i4 i5; do\n  curl -HContent-Type:application/json -XPOST localhost:9200/_reindex?pretty -d'{\n    \"source\": {\n      \"index\": \"'$index'\"\n    },\n    \"dest\": {\n      \"index\": \"'$index'-reindexed\"\n    }\n  }'\ndone\n```\n\n** Throttling**\n\nSet `requests_per_second` to any positive decimal number (`1.4`, `6`, `1000`, for example) to throttle the rate at which reindex issues batches of index operations.\nRequests are throttled by padding each batch with a wait time.\nTo turn off throttling, set `requests_per_second` to `-1`.\n\nThe throttling is done by waiting between batches so that the scroll that reindex uses internally can be given a timeout that takes into account the padding.\nThe padding time is the difference between the batch size divided by the `requests_per_second` and the time spent writing.\nBy default the batch size is `1000`, so if `requests_per_second` is set to `500`:\n\n```\ntarget_time = 1000 / 500 per second = 2 seconds\nwait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds\n```\n\nSince the batch is issued as a single bulk request, large batch sizes cause Elasticsearch to create many requests and then wait for a while before starting the next set.\nThis is \"bursty\" instead of \"smooth\".\n\n**Slicing**\n\nReindex supports sliced scroll to parallelize the reindexing process.\nThis parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.\n\nNOTE: Reindexing from remote clusters does not support manual or automatic slicing.\n\nYou can slice a reindex request manually by providing a slice ID and total number of slices to each request.\nYou can also let reindex automatically parallelize by using sliced scroll to slice on `_id`.\nThe `slices` parameter specifies the number of slices to use.\n\nAdding `slices` to the reindex request just automates the manual process, creating sub-requests which means it has some quirks:\n\n* You can see these requests in the tasks API. These sub-requests are \"child\" tasks of the task for the request with slices.\n* Fetching the status of the task for the request with `slices` only contains the status of completed slices.\n* These sub-requests are individually addressable for things like cancellation and rethrottling.\n* Rethrottling the request with `slices` will rethrottle the unfinished sub-request proportionally.\n* Canceling the request with `slices` will cancel each sub-request.\n* Due to the nature of `slices`, each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.\n* Parameters like `requests_per_second` and `max_docs` on a request with `slices` are distributed proportionally to each sub-request. Combine that with the previous point about distribution being uneven and you should conclude that using `max_docs` with `slices` might not result in exactly `max_docs` documents being reindexed.\n* Each sub-request gets a slightly different snapshot of the source, though these are all taken at approximately the same time.\n\nIf slicing automatically, setting `slices` to `auto` will choose a reasonable number for most indices.\nIf slicing manually or otherwise tuning automatic slicing, use the following guidelines.\n\nQuery performance is most efficient when the number of slices is equal to the number of shards in the index.\nIf that number is large (for example, `500`), choose a lower number as too many slices will hurt performance.\nSetting slices higher than the number of shards generally does not improve efficiency and adds overhead.\n\nIndexing performance scales linearly across available resources with the number of slices.\n\nWhether query or indexing performance dominates the runtime depends on the documents being reindexed and cluster resources.\n\n**Modify documents during reindexing**\n\nLike `_update_by_query`, reindex operations support a script that modifies the document.\nUnlike `_update_by_query`, the script is allowed to modify the document's metadata.\n\nJust as in `_update_by_query`, you can set `ctx.op` to change the operation that is run on the destination.\nFor example, set `ctx.op` to `noop` if your script decides that the document doesnâ€™t have to be indexed in the destination. This \"no operation\" will be reported in the `noop` counter in the response body.\nSet `ctx.op` to `delete` if your script decides that the document must be deleted from the destination.\nThe deletion will be reported in the `deleted` counter in the response body.\nSetting `ctx.op` to anything else will return an error, as will setting any other field in `ctx`.\n\nThink of the possibilities! Just be careful; you are able to change:\n\n* `_id`\n* `_index`\n* `_version`\n* `_routing`\n\nSetting `_version` to `null` or clearing it from the `ctx` map is just like not sending the version in an indexing request.\nIt will cause the document to be overwritten in the destination regardless of the version on the target or the version type you use in the reindex API.\n\n**Reindex from remote**\n\nReindex supports reindexing from a remote Elasticsearch cluster.\nThe `host` parameter must contain a scheme, host, port, and optional path.\nThe `username` and `password` parameters are optional and when they are present the reindex operation will connect to the remote Elasticsearch node using basic authentication.\nBe sure to use HTTPS when using basic authentication or the password will be sent in plain text.\nThere are a range of settings available to configure the behavior of the HTTPS connection.\n\nWhen using Elastic Cloud, it is also possible to authenticate against the remote cluster through the use of a valid API key.\nRemote hosts must be explicitly allowed with the `reindex.remote.whitelist` setting.\nIt can be set to a comma delimited list of allowed remote host and port combinations.\nScheme is ignored; only the host and port are used.\nFor example:\n\n```\nreindex.remote.whitelist: [otherhost:9200, another:9200, 127.0.10.*:9200, localhost:*\"]\n```\n\nThe list of allowed hosts must be configured on any nodes that will coordinate the reindex.\nThis feature should work with remote clusters of any version of Elasticsearch.\nThis should enable you to upgrade from any version of Elasticsearch to the current version by reindexing from a cluster of the old version.\n\nWARNING: Elasticsearch does not support forward compatibility across major versions.\nFor example, you cannot reindex from a 7.x cluster into a 6.x cluster.\n\nTo enable queries sent to older versions of Elasticsearch, the `query` parameter is sent directly to the remote host without validation or modification.\n\nNOTE: Reindexing from remote clusters does not support manual or automatic slicing.\n\nReindexing from a remote server uses an on-heap buffer that defaults to a maximum size of 100mb.\nIf the remote index includes very large documents you'll need to use a smaller batch size.\nIt is also possible to set the socket read timeout on the remote connection with the `socket_timeout` field and the connection timeout with the `connect_timeout` field.\nBoth default to 30 seconds.\n\n**Configuring SSL parameters**\n\nReindex from remote supports configurable SSL settings.\nThese must be specified in the `elasticsearch.yml` file, with the exception of the secure settings, which you add in the Elasticsearch keystore.\nIt is not possible to configure SSL in the body of the reindex request.",
        "operationId": "reindex",
        "parameters": [
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, the request refreshes affected shards to make this operation visible to search.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.\nBy default, there is no throttle.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll",
            "description": "The period of time that a consistent view of the index should be maintained for scrolled search.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "slices",
            "description": "The number of slices this task should be divided into.\nIt defaults to one slice, which means the task isn't sliced into subtasks.\n\nReindex supports sliced scroll to parallelize the reindexing process.\nThis parallelization can improve efficiency and provide a convenient way to break the request down into smaller parts.\n\nNOTE: Reindexing from remote clusters does not support manual or automatic slicing.\n\nIf set to `auto`, Elasticsearch chooses the number of slices to use.\nThis setting will use one slice per shard, up to a certain limit.\nIf there are multiple sources, it will choose the number of slices based on the index or backing index with the smallest number of shards.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Slices"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period each indexing waits for automatic index creation, dynamic mapping updates, and waiting for active shards.\nBy default, Elasticsearch waits for at least one minute before failing.\nThe actual wait time could be longer, particularly when multiple waits occur.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe default value is one, which means it waits for each primary shard to be active.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the operation is complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "require_alias",
            "description": "If `true`, the destination must be an index alias.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "conflicts": {
                    "$ref": "#/components/schemas/_types:Conflicts"
                  },
                  "dest": {
                    "$ref": "#/components/schemas/_global.reindex:Destination"
                  },
                  "max_docs": {
                    "description": "The maximum number of documents to reindex.\nBy default, all documents are reindexed.\nIf it is a value less then or equal to `scroll_size`, a scroll will not be used to retrieve the results for the operation.\n\nIf `conflicts` is set to `proceed`, the reindex operation could attempt to reindex more documents from the source than `max_docs` until it has successfully indexed `max_docs` documents into the target or it has gone through every document in the source query.",
                    "type": "number"
                  },
                  "script": {
                    "$ref": "#/components/schemas/_types:Script"
                  },
                  "size": {
                    "type": "number"
                  },
                  "source": {
                    "$ref": "#/components/schemas/_global.reindex:Source"
                  }
                },
                "required": [
                  "dest",
                  "source"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "batches": {
                      "description": "The number of scroll responses that were pulled back by the reindex.",
                      "type": "number"
                    },
                    "created": {
                      "description": "The number of documents that were successfully created.",
                      "type": "number"
                    },
                    "deleted": {
                      "description": "The number of documents that were successfully deleted.",
                      "type": "number"
                    },
                    "failures": {
                      "description": "If there were any unrecoverable errors during the process, it is an array of those failures.\nIf this array is not empty, the request ended because of those failures.\nReindex is implemented using batches and any failure causes the entire process to end but all failures in the current batch are collected into the array.\nYou can use the `conflicts` option to prevent the reindex from ending on version conflicts.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:BulkIndexByScrollFailure"
                      }
                    },
                    "noops": {
                      "description": "The number of documents that were ignored because the script used for the reindex returned a `noop` value for `ctx.op`.",
                      "type": "number"
                    },
                    "retries": {
                      "$ref": "#/components/schemas/_types:Retries"
                    },
                    "requests_per_second": {
                      "description": "The number of requests per second effectively run during the reindex.",
                      "type": "number"
                    },
                    "slice_id": {
                      "type": "number"
                    },
                    "task": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    },
                    "throttled_millis": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "throttled_until_millis": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "timed_out": {
                      "description": "If any of the requests that ran during the reindex timed out, it is `true`.",
                      "type": "boolean"
                    },
                    "took": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "total": {
                      "description": "The number of documents that were successfully processed.",
                      "type": "number"
                    },
                    "updated": {
                      "description": "The number of documents that were successfully updated.\nThat is to say, a document with the same ID already existed before the reindex updated it.",
                      "type": "number"
                    },
                    "version_conflicts": {
                      "description": "The number of version conflicts that occurred.",
                      "type": "number"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 2.3.0"
      }
    },
    "/_reindex/{task_id}/_rethrottle": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Throttle a reindex operation",
        "description": "Change the number of requests per second for a particular reindex operation.\nFor example:\n\n```\nPOST _reindex/r1A2WoRbTwKZ516z6NEs5A:36619/_rethrottle?requests_per_second=-1\n```\n\nRethrottling that speeds up the query takes effect immediately.\nRethrottling that slows down the query will take effect after completing the current batch.\nThis behavior prevents scroll timeouts.",
        "operationId": "reindex-rethrottle",
        "parameters": [
          {
            "in": "path",
            "name": "task_id",
            "description": "The task identifier, which can be found by using the tasks API.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.\nIt can be either `-1` to turn off throttling or any decimal number like `1.7` or `12` to throttle to that level.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_global.reindex_rethrottle:ReindexNode"
                      }
                    }
                  },
                  "required": [
                    "nodes"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 2.4.0"
      }
    },
    "/_render/template": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Render a search template",
        "description": "Render a search template as a search request body.",
        "operationId": "render-search-template",
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Render a search template",
        "description": "Render a search template as a search request body.",
        "operationId": "render-search-template-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      }
    },
    "/_render/template/{id}": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Render a search template",
        "description": "Render a search template as a search request body.",
        "operationId": "render-search-template-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/render_search_template#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Render a search template",
        "description": "Render a search template as a search request body.",
        "operationId": "render-search-template-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/render_search_template#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      }
    },
    "/_rollup/job/{id}": {
      "get": {
        "tags": [
          "rollup"
        ],
        "summary": "Get rollup job information",
        "description": "Get the configuration, stats, and status of rollup jobs.\n\nNOTE: This API returns only active (both `STARTED` and `STOPPED`) jobs.\nIf a job was created, ran for a while, then was deleted, the API does not return any details about it.\nFor details about a historical rollup job, the rollup capabilities API may be more useful.",
        "operationId": "rollup-get-jobs",
        "parameters": [
          {
            "$ref": "#/components/parameters/rollup.get_jobs#id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/rollup.get_jobs#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      },
      "put": {
        "tags": [
          "rollup"
        ],
        "summary": "Create a rollup job",
        "description": "WARNING: From 8.15.0, calling this API in a cluster with no rollup usage will fail with a message about the deprecation and planned removal of rollup features. A cluster needs to contain either a rollup job or a rollup index in order for this API to be allowed to run.\n\nThe rollup job configuration contains all the details about how the job should run, when it indexes documents, and what future queries will be able to run against the rollup index.\n\nThere are three main sections to the job configuration: the logistical details about the job (for example, the cron schedule), the fields that are used for grouping, and what metrics to collect for each group.\n\nJobs are created in a `STOPPED` state. You can start them with the start rollup jobs API.",
        "operationId": "rollup-put-job",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the rollup job. This can be any alphanumeric string and uniquely identifies the\ndata that is associated with the rollup job. The ID is persistent; it is stored with the rolled\nup data. If you create a job, let it run for a while, then delete the job, the data that the job\nrolled up is still be associated with this job ID. You cannot create a new job with the same ID\nsince that could lead to problems with mismatched job configurations.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cron": {
                    "description": "A cron string which defines the intervals when the rollup job should be executed. When the interval\ntriggers, the indexer attempts to rollup the data in the index pattern. The cron pattern is unrelated\nto the time interval of the data being rolled up. For example, you may wish to create hourly rollups\nof your document but to only run the indexer on a daily basis at midnight, as defined by the cron. The\ncron pattern is defined just like a Watcher cron schedule.",
                    "type": "string"
                  },
                  "groups": {
                    "$ref": "#/components/schemas/rollup._types:Groupings"
                  },
                  "index_pattern": {
                    "description": "The index or index pattern to roll up. Supports wildcard-style patterns (`logstash-*`). The job attempts to\nrollup the entire index or index-pattern.",
                    "type": "string"
                  },
                  "metrics": {
                    "description": "Defines the metrics to collect for each grouping tuple. By default, only the doc_counts are collected for each\ngroup. To make rollup useful, you will often add metrics like averages, mins, maxes, etc. Metrics are defined\non a per-field basis and for each field you configure which metric should be collected.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/rollup._types:FieldMetric"
                    }
                  },
                  "page_size": {
                    "description": "The number of bucket results that are processed on each iteration of the rollup indexer. A larger value tends\nto execute faster, but requires more memory during processing. This value has no effect on how the data is\nrolled up; it is merely used for tweaking the speed or memory cost of the indexer.",
                    "type": "number"
                  },
                  "rollup_index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "headers": {
                    "$ref": "#/components/schemas/_types:HttpHeaders"
                  }
                },
                "required": [
                  "cron",
                  "groups",
                  "index_pattern",
                  "page_size",
                  "rollup_index"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      },
      "delete": {
        "tags": [
          "rollup"
        ],
        "summary": "Delete a rollup job",
        "description": "A job must be stopped before it can be deleted.\nIf you attempt to delete a started job, an error occurs.\nSimilarly, if you attempt to delete a nonexistent job, an exception occurs.\n\nIMPORTANT: When you delete a job, you remove only the process that is actively monitoring and rolling up data.\nThe API does not delete any previously rolled up data.\nThis is by design; a user may wish to roll up a static data set.\nBecause the data set is static, after it has been fully rolled up there is no need to keep the indexing rollup job around (as there will be no new data).\nThus the job can be deleted, leaving behind the rolled up data for analysis.\nIf you wish to also remove the rollup data and the rollup index contains the data for only a single job, you can delete the whole rollup index.\nIf the rollup index stores data from several jobs, you must issue a delete-by-query that targets the rollup job's identifier in the rollup index. For example:\n\n```\nPOST my_rollup_index/_delete_by_query\n{\n  \"query\": {\n    \"term\": {\n      \"_rollup.id\": \"the_rollup_job_id\"\n    }\n  }\n}\n```",
        "operationId": "rollup-delete-job",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "task_failures": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:TaskFailure"
                      }
                    }
                  },
                  "required": [
                    "acknowledged"
                  ]
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_rollup/job": {
      "get": {
        "tags": [
          "rollup"
        ],
        "summary": "Get rollup job information",
        "description": "Get the configuration, stats, and status of rollup jobs.\n\nNOTE: This API returns only active (both `STARTED` and `STOPPED`) jobs.\nIf a job was created, ran for a while, then was deleted, the API does not return any details about it.\nFor details about a historical rollup job, the rollup capabilities API may be more useful.",
        "operationId": "rollup-get-jobs-1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/rollup.get_jobs#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_rollup/data/{id}": {
      "get": {
        "tags": [
          "rollup"
        ],
        "summary": "Get the rollup job capabilities",
        "description": "Get the capabilities of any rollup jobs that have been configured for a specific index or index pattern.\n\nThis API is useful because a rollup job is often configured to rollup only a subset of fields from the source index.\nFurthermore, only certain aggregations can be configured for various fields, leading to a limited subset of functionality depending on that configuration.\nThis API enables you to inspect an index and determine:\n\n1. Does this index have associated rollup data somewhere in the cluster?\n2. If yes to the first question, what fields were rolled up, what aggregations can be performed, and where does the data live?",
        "operationId": "rollup-get-rollup-caps",
        "parameters": [
          {
            "$ref": "#/components/parameters/rollup.get_rollup_caps#id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/rollup.get_rollup_caps#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_rollup/data": {
      "get": {
        "tags": [
          "rollup"
        ],
        "summary": "Get the rollup job capabilities",
        "description": "Get the capabilities of any rollup jobs that have been configured for a specific index or index pattern.\n\nThis API is useful because a rollup job is often configured to rollup only a subset of fields from the source index.\nFurthermore, only certain aggregations can be configured for various fields, leading to a limited subset of functionality depending on that configuration.\nThis API enables you to inspect an index and determine:\n\n1. Does this index have associated rollup data somewhere in the cluster?\n2. If yes to the first question, what fields were rolled up, what aggregations can be performed, and where does the data live?",
        "operationId": "rollup-get-rollup-caps-1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/rollup.get_rollup_caps#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/{index}/_rollup/data": {
      "get": {
        "tags": [
          "rollup"
        ],
        "summary": "Get the rollup index capabilities",
        "description": "Get the rollup capabilities of all jobs inside of a rollup index.\nA single rollup index may store the data for multiple rollup jobs and may have a variety of capabilities depending on those jobs. This API enables you to determine:\n\n* What jobs are stored in an index (or indices specified via a pattern)?\n* What target indices were rolled up, what fields were used in those rollups, and what aggregations can be performed on each job?",
        "operationId": "rollup-get-rollup-index-caps",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Data stream or index to check for rollup capabilities.\nWildcard (`*`) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/rollup.get_rollup_index_caps:IndexCapabilities"
                  }
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/{index}/_rollup_search": {
      "get": {
        "tags": [
          "rollup"
        ],
        "summary": "Search rolled-up data",
        "description": "The rollup search endpoint is needed because, internally, rolled-up documents utilize a different document structure than the original data.\nIt rewrites standard Query DSL into a format that matches the rollup documents then takes the response and rewrites it back to what a client would expect given the original query.\n\nThe request body supports a subset of features from the regular search API.\nThe following functionality is not available:\n\n`size`: Because rollups work on pre-aggregated data, no search hits can be returned and so size must be set to zero or omitted entirely.\n`highlighter`, `suggestors`, `post_filter`, `profile`, `explain`: These are similarly disallowed.\n\n**Searching both historical rollup and non-rollup data**\n\nThe rollup search API has the capability to search across both \"live\" non-rollup data and the aggregated rollup data.\nThis is done by simply adding the live indices to the URI. For example:\n\n```\nGET sensor-1,sensor_rollup/_rollup_search\n{\n  \"size\": 0,\n  \"aggregations\": {\n     \"max_temperature\": {\n      \"max\": {\n        \"field\": \"temperature\"\n      }\n    }\n  }\n}\n```\n\nThe rollup search endpoint does two things when the search runs:\n\n* The original request is sent to the non-rollup index unaltered.\n* A rewritten version of the original request is sent to the rollup index.\n\nWhen the two responses are received, the endpoint rewrites the rollup response and merges the two together.\nDuring the merging process, if there is any overlap in buckets between the two responses, the buckets from the non-rollup index are used.",
        "operationId": "rollup-rollup-search",
        "parameters": [
          {
            "$ref": "#/components/parameters/rollup.rollup_search#index"
          },
          {
            "$ref": "#/components/parameters/rollup.rollup_search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/rollup.rollup_search#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rollup.rollup_search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rollup.rollup_search#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "rollup"
        ],
        "summary": "Search rolled-up data",
        "description": "The rollup search endpoint is needed because, internally, rolled-up documents utilize a different document structure than the original data.\nIt rewrites standard Query DSL into a format that matches the rollup documents then takes the response and rewrites it back to what a client would expect given the original query.\n\nThe request body supports a subset of features from the regular search API.\nThe following functionality is not available:\n\n`size`: Because rollups work on pre-aggregated data, no search hits can be returned and so size must be set to zero or omitted entirely.\n`highlighter`, `suggestors`, `post_filter`, `profile`, `explain`: These are similarly disallowed.\n\n**Searching both historical rollup and non-rollup data**\n\nThe rollup search API has the capability to search across both \"live\" non-rollup data and the aggregated rollup data.\nThis is done by simply adding the live indices to the URI. For example:\n\n```\nGET sensor-1,sensor_rollup/_rollup_search\n{\n  \"size\": 0,\n  \"aggregations\": {\n     \"max_temperature\": {\n      \"max\": {\n        \"field\": \"temperature\"\n      }\n    }\n  }\n}\n```\n\nThe rollup search endpoint does two things when the search runs:\n\n* The original request is sent to the non-rollup index unaltered.\n* A rewritten version of the original request is sent to the rollup index.\n\nWhen the two responses are received, the endpoint rewrites the rollup response and merges the two together.\nDuring the merging process, if there is any overlap in buckets between the two responses, the buckets from the non-rollup index are used.",
        "operationId": "rollup-rollup-search-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/rollup.rollup_search#index"
          },
          {
            "$ref": "#/components/parameters/rollup.rollup_search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/rollup.rollup_search#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rollup.rollup_search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rollup.rollup_search#200"
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_rollup/job/{id}/_start": {
      "post": {
        "tags": [
          "rollup"
        ],
        "summary": "Start rollup jobs",
        "description": "If you try to start a job that does not exist, an exception occurs.\nIf you try to start a job that is already started, nothing happens.",
        "operationId": "rollup-start-job",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the rollup job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "started": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "started"
                  ]
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_rollup/job/{id}/_stop": {
      "post": {
        "tags": [
          "rollup"
        ],
        "summary": "Stop rollup jobs",
        "description": "If you try to stop a job that does not exist, an exception occurs.\nIf you try to stop a job that is already stopped, nothing happens.\n\nSince only a stopped job can be deleted, it can be useful to block the API until the indexer has fully stopped.\nThis is accomplished with the `wait_for_completion` query parameter, and optionally a timeout. For example:\n\n```\nPOST _rollup/job/sensor/_stop?wait_for_completion=true&timeout=10s\n```\nThe parameter blocks the API call from returning until either the job has moved to STOPPED or the specified time has elapsed.\nIf the specified time elapses without the job moving to STOPPED, a timeout exception occurs.",
        "operationId": "rollup-stop-job",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the rollup job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "If `wait_for_completion` is `true`, the API blocks for (at maximum) the specified duration while waiting for the job to stop.\nIf more than `timeout` time has passed, the API throws a timeout exception.\nNOTE: Even if a timeout occurs, the stop request is still processing and eventually moves the job to STOPPED.\nThe timeout simply means the API call itself timed out while waiting for the status change.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If set to `true`, causes the API to block until the indexer state completely stops.\nIf set to `false`, the API returns immediately and the indexer is stopped asynchronously in the background.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        },
        "deprecated": true,
        "x-state": "Technical preview"
      }
    },
    "/_scripts/painless/_execute": {
      "get": {
        "tags": [
          "script"
        ],
        "summary": "Run a script",
        "description": "Runs a script and returns a result.",
        "operationId": "scripts-painless-execute",
        "requestBody": {
          "$ref": "#/components/requestBodies/scripts_painless_execute"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scripts_painless_execute#200"
          }
        },
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "script"
        ],
        "summary": "Run a script",
        "description": "Runs a script and returns a result.",
        "operationId": "scripts-painless-execute-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/scripts_painless_execute"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scripts_painless_execute#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_search": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a search",
        "description": "Get search hits that match the query defined in the request.\nYou can provide search queries using the `q` query string parameter or the request body.\nIf both are specified, only the query parameter is used.\n\nIf the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.\nTo search a point in time (PIT) for an alias, you must have the `read` index privilege for the alias's data streams or indices.\n\n**Search slicing**\n\nWhen paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the `slice` and `pit` properties.\nBy default the splitting is done first on the shards, then locally on each shard.\nThe local splitting partitions the shard into contiguous ranges based on Lucene document IDs.\n\nFor instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.\n\nIMPORTANT: The same point-in-time ID should be used for all slices.\nIf different PIT IDs are used, slices can overlap and miss documents.\nThis situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-cert.html#remote-clusters-privileges-ccs"
        },
        "operationId": "search",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          },
          {
            "$ref": "#/components/parameters/search#force_synthetic_source"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a search",
        "description": "Get search hits that match the query defined in the request.\nYou can provide search queries using the `q` query string parameter or the request body.\nIf both are specified, only the query parameter is used.\n\nIf the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.\nTo search a point in time (PIT) for an alias, you must have the `read` index privilege for the alias's data streams or indices.\n\n**Search slicing**\n\nWhen paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the `slice` and `pit` properties.\nBy default the splitting is done first on the shards, then locally on each shard.\nThe local splitting partitions the shard into contiguous ranges based on Lucene document IDs.\n\nFor instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.\n\nIMPORTANT: The same point-in-time ID should be used for all slices.\nIf different PIT IDs are used, slices can overlap and miss documents.\nThis situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-cert.html#remote-clusters-privileges-ccs"
        },
        "operationId": "search-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          },
          {
            "$ref": "#/components/parameters/search#force_synthetic_source"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      }
    },
    "/{index}/_search": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a search",
        "description": "Get search hits that match the query defined in the request.\nYou can provide search queries using the `q` query string parameter or the request body.\nIf both are specified, only the query parameter is used.\n\nIf the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.\nTo search a point in time (PIT) for an alias, you must have the `read` index privilege for the alias's data streams or indices.\n\n**Search slicing**\n\nWhen paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the `slice` and `pit` properties.\nBy default the splitting is done first on the shards, then locally on each shard.\nThe local splitting partitions the shard into contiguous ranges based on Lucene document IDs.\n\nFor instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.\n\nIMPORTANT: The same point-in-time ID should be used for all slices.\nIf different PIT IDs are used, slices can overlap and miss documents.\nThis situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-cert.html#remote-clusters-privileges-ccs"
        },
        "operationId": "search-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#index"
          },
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          },
          {
            "$ref": "#/components/parameters/search#force_synthetic_source"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a search",
        "description": "Get search hits that match the query defined in the request.\nYou can provide search queries using the `q` query string parameter or the request body.\nIf both are specified, only the query parameter is used.\n\nIf the Elasticsearch security features are enabled, you must have the read index privilege for the target data stream, index, or alias. For cross-cluster search, refer to the documentation about configuring CCS privileges.\nTo search a point in time (PIT) for an alias, you must have the `read` index privilege for the alias's data streams or indices.\n\n**Search slicing**\n\nWhen paging through a large number of documents, it can be helpful to split the search into multiple slices to consume them independently with the `slice` and `pit` properties.\nBy default the splitting is done first on the shards, then locally on each shard.\nThe local splitting partitions the shard into contiguous ranges based on Lucene document IDs.\n\nFor instance if the number of shards is equal to 2 and you request 4 slices, the slices 0 and 2 are assigned to the first shard and the slices 1 and 3 are assigned to the second shard.\n\nIMPORTANT: The same point-in-time ID should be used for all slices.\nIf different PIT IDs are used, slices can overlap and miss documents.\nThis situation can occur because the splitting criterion is based on Lucene document IDs, which are not stable across changes to the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-cert.html#remote-clusters-privileges-ccs"
        },
        "operationId": "search-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#index"
          },
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#include_named_queries_score"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          },
          {
            "$ref": "#/components/parameters/search#force_synthetic_source"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      }
    },
    "/_application/search_application/{name}": {
      "get": {
        "tags": [
          "search_application"
        ],
        "summary": "Get search application details",
        "operationId": "search-application-get",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/search_application._types:SearchApplication"
                }
              }
            }
          }
        },
        "x-beta": true
      },
      "put": {
        "tags": [
          "search_application"
        ],
        "summary": "Create or update a search application",
        "operationId": "search-application-put",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "create",
            "description": "If `true`, this request cannot replace or update existing Search Applications.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/search_application._types:SearchApplication"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      },
      "delete": {
        "tags": [
          "search_application"
        ],
        "summary": "Delete a search application",
        "description": "Remove a search application and its associated alias. Indices attached to the search application are not removed.",
        "operationId": "search-application-delete",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_application/analytics/{name}": {
      "get": {
        "tags": [
          "analytics"
        ],
        "summary": "Get behavioral analytics collections",
        "operationId": "search-application-get-behavioral-analytics-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_application.get_behavioral_analytics#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.get_behavioral_analytics#200"
          }
        },
        "x-state": "Technical preview"
      },
      "put": {
        "tags": [
          "analytics"
        ],
        "summary": "Create a behavioral analytics collection",
        "operationId": "search-application-put-behavioral-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the analytics collection to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/search_application.put_behavioral_analytics:AnalyticsAcknowledgeResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      },
      "delete": {
        "tags": [
          "analytics"
        ],
        "summary": "Delete a behavioral analytics collection",
        "description": "The associated data stream is also deleted.",
        "operationId": "search-application-delete-behavioral-analytics",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the analytics collection to be deleted",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_application/analytics": {
      "get": {
        "tags": [
          "analytics"
        ],
        "summary": "Get behavioral analytics collections",
        "operationId": "search-application-get-behavioral-analytics",
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.get_behavioral_analytics#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_application/search_application": {
      "get": {
        "tags": [
          "search_application"
        ],
        "summary": "Get search applications",
        "description": "Get information about search applications.",
        "operationId": "search-application-list",
        "parameters": [
          {
            "in": "query",
            "name": "q",
            "description": "Query in the Lucene query string syntax.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies a max number of results to get.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/search_application.list:SearchApplicationListItem"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        },
        "x-beta": true
      }
    },
    "/_application/analytics/{collection_name}/event/{event_type}": {
      "post": {
        "tags": [
          "analytics"
        ],
        "summary": "Create a behavioral analytics collection event",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/behavioral-analytics-event-reference.html"
        },
        "operationId": "search-application-post-behavioral-analytics-event",
        "parameters": [
          {
            "in": "path",
            "name": "collection_name",
            "description": "The name of the behavioral analytics collection.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "event_type",
            "description": "The analytics event type.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/search_application._types:EventType"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "debug",
            "description": "Whether the response type has to include more details",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "accepted": {
                      "type": "boolean"
                    },
                    "event": {
                      "type": "object"
                    }
                  },
                  "required": [
                    "accepted"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_application/search_application/{name}/_render_query": {
      "post": {
        "tags": [
          "search_application"
        ],
        "summary": "Render a search application query",
        "description": "Generate an Elasticsearch query using the specified query parameters and the search template associated with the search application or a default template if none is specified.\nIf a parameter used in the search template is not specified in `params`, the parameter's default value will be used.\nThe API returns the specific Elasticsearch query that would be generated and run by calling the search application search API.\n\nYou must have `read` privileges on the backing alias of the search application.",
        "operationId": "search-application-render-query",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application to render teh query for.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "params": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_application/search_application/{name}/_search": {
      "get": {
        "tags": [
          "search_application"
        ],
        "summary": "Run a search application search",
        "description": "Generate and run an Elasticsearch query that uses the specified query parameteter and the search template associated with the search application or default template.\nUnspecified template parameters are assigned their default values if applicable.",
        "operationId": "search-application-search",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_application.search#name"
          },
          {
            "$ref": "#/components/parameters/search_application.search#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_application.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.search#200"
          }
        },
        "x-beta": true
      },
      "post": {
        "tags": [
          "search_application"
        ],
        "summary": "Run a search application search",
        "description": "Generate and run an Elasticsearch query that uses the specified query parameteter and the search template associated with the search application or default template.\nUnspecified template parameters are assigned their default values if applicable.",
        "operationId": "search-application-search-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_application.search#name"
          },
          {
            "$ref": "#/components/parameters/search_application.search#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_application.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.search#200"
          }
        },
        "x-beta": true
      }
    },
    "/{index}/_mvt/{field}/{zoom}/{x}/{y}": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Search a vector tile",
        "description": "Search a vector tile for geospatial values.\nBefore using this API, you should be familiar with the Mapbox vector tile specification.\nThe API returns results as a binary mapbox vector tile.\n\nInternally, Elasticsearch translates a vector tile search API request into a search containing:\n\n* A `geo_bounding_box` query on the `<field>`. The query uses the `<zoom>/<x>/<y>` tile as a bounding box.\n* A `geotile_grid` or `geohex_grid` aggregation on the `<field>`. The `grid_agg` parameter determines the aggregation type. The aggregation uses the `<zoom>/<x>/<y>` tile as a bounding box.\n* Optionally, a `geo_bounds` aggregation on the `<field>`. The search only includes this aggregation if the `exact_bounds` parameter is `true`.\n* If the optional parameter `with_labels` is `true`, the internal search will include a dynamic runtime field that calls the `getLabelPosition` function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.\n\nFor example, Elasticsearch may translate a vector tile search API request with a `grid_agg` argument of `geotile` and an `exact_bounds` argument of `true` into the following search\n\n```\nGET my-index/_search\n{\n  \"size\": 10000,\n  \"query\": {\n    \"geo_bounding_box\": {\n      \"my-geo-field\": {\n        \"top_left\": {\n          \"lat\": -40.979898069620134,\n          \"lon\": -45\n        },\n        \"bottom_right\": {\n          \"lat\": -66.51326044311186,\n          \"lon\": 0\n        }\n      }\n    }\n  },\n  \"aggregations\": {\n    \"grid\": {\n      \"geotile_grid\": {\n        \"field\": \"my-geo-field\",\n        \"precision\": 11,\n        \"size\": 65536,\n        \"bounds\": {\n          \"top_left\": {\n            \"lat\": -40.979898069620134,\n            \"lon\": -45\n          },\n          \"bottom_right\": {\n            \"lat\": -66.51326044311186,\n            \"lon\": 0\n          }\n        }\n      }\n    },\n    \"bounds\": {\n      \"geo_bounds\": {\n        \"field\": \"my-geo-field\",\n        \"wrap_longitude\": false\n      }\n    }\n  }\n}\n```\n\nThe API returns results as a binary Mapbox vector tile.\nMapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:\n\n* A `hits` layer containing a feature for each `<field>` value matching the `geo_bounding_box` query.\n* An `aggs` layer containing a feature for each cell of the `geotile_grid` or `geohex_grid`. The layer only contains features for cells with matching data.\n* A meta layer containing:\n  * A feature containing a bounding box. By default, this is the bounding box of the tile.\n  * Value ranges for any sub-aggregations on the `geotile_grid` or `geohex_grid`.\n  * Metadata for the search.\n\nThe API only returns features that can display at its zoom level.\nFor example, if a polygon feature has no area at its zoom level, the API omits it.\nThe API returns errors as UTF-8 encoded JSON.\n\nIMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.\nIf you specify both parameters, the query parameter takes precedence.\n\n**Grid precision for geotile**\n\nFor a `grid_agg` of `geotile`, you can use cells in the `aggs` layer as tiles for lower zoom levels.\n`grid_precision` represents the additional zoom levels available through these cells. The final precision is computed by as follows: `<zoom> + grid_precision`.\nFor example, if `<zoom>` is 7 and `grid_precision` is 8, then the `geotile_grid` aggregation will use a precision of 15.\nThe maximum final precision is 29.\nThe `grid_precision` also determines the number of cells for the grid as follows: `(2^grid_precision) x (2^grid_precision)`.\nFor example, a value of 8 divides the tile into a grid of 256 x 256 cells.\nThe `aggs` layer only contains features for cells with matching data.\n\n**Grid precision for geohex**\n\nFor a `grid_agg` of `geohex`, Elasticsearch uses `<zoom>` and `grid_precision` to calculate a final precision as follows: `<zoom> + grid_precision`.\n\nThis precision determines the H3 resolution of the hexagonal cells produced by the `geohex` aggregation.\nThe following table maps the H3 resolution for each precision.\nFor example, if `<zoom>` is 3 and `grid_precision` is 3, the precision is 6.\nAt a precision of 6, hexagonal cells have an H3 resolution of 2.\nIf `<zoom>` is 3 and `grid_precision` is 4, the precision is 7.\nAt a precision of 7, hexagonal cells have an H3 resolution of 3.\n\n| Precision | Unique tile bins | H3 resolution | Unique hex bins |\tRatio |\n| --------- | ---------------- | ------------- | ----------------| ----- |\n| 1  | 4                  | 0  | 122             | 30.5           |\n| 2  | 16                 | 0  | 122             | 7.625          |\n| 3  | 64                 | 1  | 842             | 13.15625       |\n| 4  | 256                | 1  | 842             | 3.2890625      |\n| 5  | 1024               | 2  | 5882            | 5.744140625    |\n| 6  | 4096               | 2  | 5882            | 1.436035156    |\n| 7  | 16384              | 3  | 41162           | 2.512329102    |\n| 8  | 65536              | 3  | 41162           | 0.6280822754   |\n| 9  | 262144             | 4  | 288122          | 1.099098206    |\n| 10 | 1048576            | 4  | 288122          | 0.2747745514   |\n| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |\n| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |\n| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |\n| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |\n| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |\n| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |\n| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |\n| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |\n| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |\n| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |\n| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |\n| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |\n| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |\n| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |\n| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |\n| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |\n| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |\n| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |\n| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |\n\nHexagonal cells don't align perfectly on a vector tile.\nSome cells may intersect more than one vector tile.\nTo compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.\nElasticsearch uses the H3 resolution that is closest to the corresponding geotile density.",
        "externalDocs": {
          "url": "https://github.com/mapbox/vector-tile-spec/blob/master/README.md"
        },
        "operationId": "search-mvt-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_mvt#index"
          },
          {
            "$ref": "#/components/parameters/search_mvt#field"
          },
          {
            "$ref": "#/components/parameters/search_mvt#zoom"
          },
          {
            "$ref": "#/components/parameters/search_mvt#x"
          },
          {
            "$ref": "#/components/parameters/search_mvt#y"
          },
          {
            "$ref": "#/components/parameters/search_mvt#exact_bounds"
          },
          {
            "$ref": "#/components/parameters/search_mvt#extent"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_agg"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_precision"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_type"
          },
          {
            "$ref": "#/components/parameters/search_mvt#size"
          },
          {
            "$ref": "#/components/parameters/search_mvt#with_labels"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_mvt"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_mvt#200"
          }
        },
        "x-state": "Added in 7.15.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Search a vector tile",
        "description": "Search a vector tile for geospatial values.\nBefore using this API, you should be familiar with the Mapbox vector tile specification.\nThe API returns results as a binary mapbox vector tile.\n\nInternally, Elasticsearch translates a vector tile search API request into a search containing:\n\n* A `geo_bounding_box` query on the `<field>`. The query uses the `<zoom>/<x>/<y>` tile as a bounding box.\n* A `geotile_grid` or `geohex_grid` aggregation on the `<field>`. The `grid_agg` parameter determines the aggregation type. The aggregation uses the `<zoom>/<x>/<y>` tile as a bounding box.\n* Optionally, a `geo_bounds` aggregation on the `<field>`. The search only includes this aggregation if the `exact_bounds` parameter is `true`.\n* If the optional parameter `with_labels` is `true`, the internal search will include a dynamic runtime field that calls the `getLabelPosition` function of the geometry doc value. This enables the generation of new point features containing suggested geometry labels, so that, for example, multi-polygons will have only one label.\n\nFor example, Elasticsearch may translate a vector tile search API request with a `grid_agg` argument of `geotile` and an `exact_bounds` argument of `true` into the following search\n\n```\nGET my-index/_search\n{\n  \"size\": 10000,\n  \"query\": {\n    \"geo_bounding_box\": {\n      \"my-geo-field\": {\n        \"top_left\": {\n          \"lat\": -40.979898069620134,\n          \"lon\": -45\n        },\n        \"bottom_right\": {\n          \"lat\": -66.51326044311186,\n          \"lon\": 0\n        }\n      }\n    }\n  },\n  \"aggregations\": {\n    \"grid\": {\n      \"geotile_grid\": {\n        \"field\": \"my-geo-field\",\n        \"precision\": 11,\n        \"size\": 65536,\n        \"bounds\": {\n          \"top_left\": {\n            \"lat\": -40.979898069620134,\n            \"lon\": -45\n          },\n          \"bottom_right\": {\n            \"lat\": -66.51326044311186,\n            \"lon\": 0\n          }\n        }\n      }\n    },\n    \"bounds\": {\n      \"geo_bounds\": {\n        \"field\": \"my-geo-field\",\n        \"wrap_longitude\": false\n      }\n    }\n  }\n}\n```\n\nThe API returns results as a binary Mapbox vector tile.\nMapbox vector tiles are encoded as Google Protobufs (PBF). By default, the tile contains three layers:\n\n* A `hits` layer containing a feature for each `<field>` value matching the `geo_bounding_box` query.\n* An `aggs` layer containing a feature for each cell of the `geotile_grid` or `geohex_grid`. The layer only contains features for cells with matching data.\n* A meta layer containing:\n  * A feature containing a bounding box. By default, this is the bounding box of the tile.\n  * Value ranges for any sub-aggregations on the `geotile_grid` or `geohex_grid`.\n  * Metadata for the search.\n\nThe API only returns features that can display at its zoom level.\nFor example, if a polygon feature has no area at its zoom level, the API omits it.\nThe API returns errors as UTF-8 encoded JSON.\n\nIMPORTANT: You can specify several options for this API as either a query parameter or request body parameter.\nIf you specify both parameters, the query parameter takes precedence.\n\n**Grid precision for geotile**\n\nFor a `grid_agg` of `geotile`, you can use cells in the `aggs` layer as tiles for lower zoom levels.\n`grid_precision` represents the additional zoom levels available through these cells. The final precision is computed by as follows: `<zoom> + grid_precision`.\nFor example, if `<zoom>` is 7 and `grid_precision` is 8, then the `geotile_grid` aggregation will use a precision of 15.\nThe maximum final precision is 29.\nThe `grid_precision` also determines the number of cells for the grid as follows: `(2^grid_precision) x (2^grid_precision)`.\nFor example, a value of 8 divides the tile into a grid of 256 x 256 cells.\nThe `aggs` layer only contains features for cells with matching data.\n\n**Grid precision for geohex**\n\nFor a `grid_agg` of `geohex`, Elasticsearch uses `<zoom>` and `grid_precision` to calculate a final precision as follows: `<zoom> + grid_precision`.\n\nThis precision determines the H3 resolution of the hexagonal cells produced by the `geohex` aggregation.\nThe following table maps the H3 resolution for each precision.\nFor example, if `<zoom>` is 3 and `grid_precision` is 3, the precision is 6.\nAt a precision of 6, hexagonal cells have an H3 resolution of 2.\nIf `<zoom>` is 3 and `grid_precision` is 4, the precision is 7.\nAt a precision of 7, hexagonal cells have an H3 resolution of 3.\n\n| Precision | Unique tile bins | H3 resolution | Unique hex bins |\tRatio |\n| --------- | ---------------- | ------------- | ----------------| ----- |\n| 1  | 4                  | 0  | 122             | 30.5           |\n| 2  | 16                 | 0  | 122             | 7.625          |\n| 3  | 64                 | 1  | 842             | 13.15625       |\n| 4  | 256                | 1  | 842             | 3.2890625      |\n| 5  | 1024               | 2  | 5882            | 5.744140625    |\n| 6  | 4096               | 2  | 5882            | 1.436035156    |\n| 7  | 16384              | 3  | 41162           | 2.512329102    |\n| 8  | 65536              | 3  | 41162           | 0.6280822754   |\n| 9  | 262144             | 4  | 288122          | 1.099098206    |\n| 10 | 1048576            | 4  | 288122          | 0.2747745514   |\n| 11 | 4194304            | 5  | 2016842         | 0.4808526039   |\n| 12 | 16777216           | 6  | 14117882        | 0.8414913416   |\n| 13 | 67108864           | 6  | 14117882        | 0.2103728354   |\n| 14 | 268435456          | 7  | 98825162        | 0.3681524172   |\n| 15 | 1073741824         | 8  | 691776122       | 0.644266719    |\n| 16 | 4294967296         | 8  | 691776122       | 0.1610666797   |\n| 17 | 17179869184        | 9  | 4842432842      | 0.2818666889   |\n| 18 | 68719476736        | 10 | 33897029882     | 0.4932667053   |\n| 19 | 274877906944       | 11 | 237279209162    | 0.8632167343   |\n| 20 | 1099511627776      | 11 | 237279209162    | 0.2158041836   |\n| 21 | 4398046511104      | 12 | 1660954464122   | 0.3776573213   |\n| 22 | 17592186044416     | 13 | 11626681248842  | 0.6609003122   |\n| 23 | 70368744177664     | 13 | 11626681248842  | 0.165225078    |\n| 24 | 281474976710656    | 14 | 81386768741882  | 0.2891438866   |\n| 25 | 1125899906842620   | 15 | 569707381193162 | 0.5060018015   |\n| 26 | 4503599627370500   | 15 | 569707381193162 | 0.1265004504   |\n| 27 | 18014398509482000  | 15 | 569707381193162 | 0.03162511259  |\n| 28 | 72057594037927900  | 15 | 569707381193162 | 0.007906278149 |\n| 29 | 288230376151712000 | 15 | 569707381193162 | 0.001976569537 |\n\nHexagonal cells don't align perfectly on a vector tile.\nSome cells may intersect more than one vector tile.\nTo compute the H3 resolution for each precision, Elasticsearch compares the average density of hexagonal bins at each resolution with the average density of tile bins at each zoom level.\nElasticsearch uses the H3 resolution that is closest to the corresponding geotile density.",
        "externalDocs": {
          "url": "https://github.com/mapbox/vector-tile-spec/blob/master/README.md"
        },
        "operationId": "search-mvt",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_mvt#index"
          },
          {
            "$ref": "#/components/parameters/search_mvt#field"
          },
          {
            "$ref": "#/components/parameters/search_mvt#zoom"
          },
          {
            "$ref": "#/components/parameters/search_mvt#x"
          },
          {
            "$ref": "#/components/parameters/search_mvt#y"
          },
          {
            "$ref": "#/components/parameters/search_mvt#exact_bounds"
          },
          {
            "$ref": "#/components/parameters/search_mvt#extent"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_agg"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_precision"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_type"
          },
          {
            "$ref": "#/components/parameters/search_mvt#size"
          },
          {
            "$ref": "#/components/parameters/search_mvt#with_labels"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_mvt"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_mvt#200"
          }
        },
        "x-state": "Added in 7.15.0"
      }
    },
    "/_search_shards": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get the search shards",
        "description": "Get the indices and shards that a search request would be run against.\nThis information can be useful for working out issues or planning optimizations with routing and shard preferences.\nWhen filtered aliases are used, the filter is returned as part of the `indices` section.\n\nIf the Elasticsearch security features are enabled, you must have the `view_index_metadata` or `manage` index privilege for the target data stream, index, or alias.",
        "operationId": "search-shards",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_shards#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_shards#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_shards#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_shards#local"
          },
          {
            "$ref": "#/components/parameters/search_shards#preference"
          },
          {
            "$ref": "#/components/parameters/search_shards#routing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_shards#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Get the search shards",
        "description": "Get the indices and shards that a search request would be run against.\nThis information can be useful for working out issues or planning optimizations with routing and shard preferences.\nWhen filtered aliases are used, the filter is returned as part of the `indices` section.\n\nIf the Elasticsearch security features are enabled, you must have the `view_index_metadata` or `manage` index privilege for the target data stream, index, or alias.",
        "operationId": "search-shards-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_shards#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_shards#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_shards#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_shards#local"
          },
          {
            "$ref": "#/components/parameters/search_shards#preference"
          },
          {
            "$ref": "#/components/parameters/search_shards#routing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_shards#200"
          }
        }
      }
    },
    "/{index}/_search_shards": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get the search shards",
        "description": "Get the indices and shards that a search request would be run against.\nThis information can be useful for working out issues or planning optimizations with routing and shard preferences.\nWhen filtered aliases are used, the filter is returned as part of the `indices` section.\n\nIf the Elasticsearch security features are enabled, you must have the `view_index_metadata` or `manage` index privilege for the target data stream, index, or alias.",
        "operationId": "search-shards-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_shards#index"
          },
          {
            "$ref": "#/components/parameters/search_shards#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_shards#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_shards#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_shards#local"
          },
          {
            "$ref": "#/components/parameters/search_shards#preference"
          },
          {
            "$ref": "#/components/parameters/search_shards#routing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_shards#200"
          }
        }
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Get the search shards",
        "description": "Get the indices and shards that a search request would be run against.\nThis information can be useful for working out issues or planning optimizations with routing and shard preferences.\nWhen filtered aliases are used, the filter is returned as part of the `indices` section.\n\nIf the Elasticsearch security features are enabled, you must have the `view_index_metadata` or `manage` index privilege for the target data stream, index, or alias.",
        "operationId": "search-shards-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_shards#index"
          },
          {
            "$ref": "#/components/parameters/search_shards#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_shards#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_shards#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_shards#local"
          },
          {
            "$ref": "#/components/parameters/search_shards#preference"
          },
          {
            "$ref": "#/components/parameters/search_shards#routing"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_shards#200"
          }
        }
      }
    },
    "/_search/template": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a search with a search template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search-template",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        },
        "x-state": "Added in 2.0.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a search with a search template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search-template-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        },
        "x-state": "Added in 2.0.0"
      }
    },
    "/{index}/_search/template": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Run a search with a search template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search-template-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#index"
          },
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        },
        "x-state": "Added in 2.0.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Run a search with a search template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search-template-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#index"
          },
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        },
        "x-state": "Added in 2.0.0"
      }
    },
    "/_searchable_snapshots/cache/stats": {
      "get": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Get cache statistics",
        "description": "Get statistics about the shared cache for partially mounted indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots.html"
        },
        "operationId": "searchable-snapshots-cache-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/searchable_snapshots.cache_stats#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/searchable_snapshots.cache_stats#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_searchable_snapshots/{node_id}/cache/stats": {
      "get": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Get cache statistics",
        "description": "Get statistics about the shared cache for partially mounted indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots.html"
        },
        "operationId": "searchable-snapshots-cache-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/searchable_snapshots.cache_stats#node_id"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.cache_stats#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/searchable_snapshots.cache_stats#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_searchable_snapshots/cache/clear": {
      "post": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Clear the cache",
        "description": "Clear indices and data streams from the shared cache for partially mounted indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots.html"
        },
        "operationId": "searchable-snapshots-clear-cache",
        "parameters": [
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#pretty"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#human"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/searchable_snapshots.clear_cache#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/{index}/_searchable_snapshots/cache/clear": {
      "post": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Clear the cache",
        "description": "Clear indices and data streams from the shared cache for partially mounted indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/searchable-snapshots.html"
        },
        "operationId": "searchable-snapshots-clear-cache-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#index"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#pretty"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.clear_cache#human"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/searchable_snapshots.clear_cache#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_snapshot/{repository}/{snapshot}/_mount": {
      "post": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Mount a snapshot",
        "description": "Mount a snapshot as a searchable snapshot index.\nDo not use this API for snapshots managed by index lifecycle management (ILM).\nManually mounting ILM-managed snapshots can interfere with ILM processes.",
        "operationId": "searchable-snapshots-mount",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "The name of the repository containing the snapshot of the index to mount.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot",
            "description": "The name of the snapshot of the index to mount.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for the master node.\nIf the master node is not available before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If true, the request blocks until the operation is complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "storage",
            "description": "The mount option for the searchable snapshot index.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "renamed_index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "index_settings": {
                    "description": "The settings that should be added to the index when it is mounted.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  },
                  "ignore_index_settings": {
                    "description": "The names of settings that should be removed from the index when it is mounted.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "index"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "snapshot": {
                      "$ref": "#/components/schemas/searchable_snapshots.mount:MountedSnapshot"
                    }
                  },
                  "required": [
                    "snapshot"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_searchable_snapshots/stats": {
      "get": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Get searchable snapshot statistics",
        "operationId": "searchable-snapshots-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/searchable_snapshots.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/searchable_snapshots.stats#200"
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/{index}/_searchable_snapshots/stats": {
      "get": {
        "tags": [
          "searchable_snapshots"
        ],
        "summary": "Get searchable snapshot statistics",
        "operationId": "searchable-snapshots-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/searchable_snapshots.stats#index"
          },
          {
            "$ref": "#/components/parameters/searchable_snapshots.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/searchable_snapshots.stats#200"
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_security/profile/_activate": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Activate a user profile",
        "description": "Create or update a user profile on behalf of another user.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nThe calling application must have either an `access_token` or a combination of `username` and `password` for the user that the profile document is intended for.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nThis API creates or updates a profile document for end users with information that is extracted from the user's authentication object including `username`, `full_name,` `roles`, and the authentication realm.\nFor example, in the JWT `access_token` case, the profile user's `username` is extracted from the JWT token claim pointed to by the `claims.principal` setting of the JWT realm that authenticated the token.\n\nWhen updating a profile document, the API enables the document if it was disabled.\nAny updates do not change existing content for either the `labels` or `data` fields.",
        "operationId": "security-activate-user-profile",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_token": {
                    "description": "The user's Elasticsearch access token or JWT.\nBoth `access` and `id` JWT token types are supported and they depend on the underlying JWT realm configuration.\nIf you specify the `access_token` grant type, this parameter is required.\nIt is not valid with other grant types.",
                    "type": "string"
                  },
                  "grant_type": {
                    "$ref": "#/components/schemas/security._types:GrantType"
                  },
                  "password": {
                    "description": "The user's password.\nIf you specify the `password` grant type, this parameter is required.\nIt is not valid with other grant types.",
                    "type": "string"
                  },
                  "username": {
                    "description": "The username that identifies the user.\nIf you specify the `password` grant type, this parameter is required.\nIt is not valid with other grant types.",
                    "type": "string"
                  }
                },
                "required": [
                  "grant_type"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/security._types:UserProfileWithMetadata"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_security/_authenticate": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Authenticate a user",
        "description": "Authenticates a user and returns information about the authenticated user.\nInclude the user information in a [basic auth header](https://en.wikipedia.org/wiki/Basic_access_authentication).\nA successful call returns a JSON structure that shows user information such as their username, the roles that are assigned to the user, any assigned metadata, and information about the realms that authenticated and authorized the user.\nIf the user cannot be authenticated, this API returns a 401 status code.",
        "operationId": "security-authenticate",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_key": {
                      "$ref": "#/components/schemas/security.authenticate:AuthenticateApiKey"
                    },
                    "authentication_realm": {
                      "$ref": "#/components/schemas/security._types:RealmInfo"
                    },
                    "email": {
                      "oneOf": [
                        {
                          "type": "string"
                        },
                        {
                          "nullable": true,
                          "type": "string"
                        }
                      ]
                    },
                    "full_name": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/_types:Name"
                        },
                        {
                          "nullable": true,
                          "type": "string"
                        }
                      ]
                    },
                    "lookup_realm": {
                      "$ref": "#/components/schemas/security._types:RealmInfo"
                    },
                    "metadata": {
                      "$ref": "#/components/schemas/_types:Metadata"
                    },
                    "roles": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "username": {
                      "$ref": "#/components/schemas/_types:Username"
                    },
                    "enabled": {
                      "type": "boolean"
                    },
                    "authentication_type": {
                      "type": "string"
                    },
                    "token": {
                      "$ref": "#/components/schemas/security.authenticate:Token"
                    }
                  },
                  "required": [
                    "authentication_realm",
                    "lookup_realm",
                    "metadata",
                    "roles",
                    "username",
                    "enabled",
                    "authentication_type"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_security/role": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get roles",
        "description": "Get roles in the native realm.\nThe role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe get roles API cannot retrieve roles that are defined in roles files.",
        "operationId": "security-get-role-1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Bulk create or update roles",
        "description": "The role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe bulk create or update roles API cannot update roles that are defined in roles files.",
        "operationId": "security-bulk-put-role",
        "parameters": [
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "roles": {
                    "description": "A dictionary of role name to RoleDescriptor objects to add or update",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/security._types:RoleDescriptor"
                    }
                  }
                },
                "required": [
                  "roles"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "created": {
                      "description": "Array of created roles",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "updated": {
                      "description": "Array of updated roles",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "noop": {
                      "description": "Array of role names without any changes",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "errors": {
                      "$ref": "#/components/schemas/security._types:BulkError"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Bulk delete roles",
        "description": "The role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe bulk delete roles API cannot delete roles that are defined in roles files.",
        "operationId": "security-bulk-delete-role",
        "parameters": [
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "names": {
                    "description": "An array of role names to delete",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "names"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "deleted": {
                      "description": "Array of deleted roles",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "not_found": {
                      "description": "Array of roles that could not be found",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "errors": {
                      "$ref": "#/components/schemas/security._types:BulkError"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_security/api_key/_bulk_update": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Bulk update API keys",
        "description": "Update the attributes for multiple API keys.\n\nIMPORTANT: It is not possible to use an API key as the authentication credential for this API. To update API keys, the owner user's credentials are required.\n\nThis API is similar to the update API key API but enables you to apply the same update to multiple API keys in one API call. This operation can greatly improve performance over making individual updates.\n\nIt is not possible to update expired or invalidated API keys.\n\nThis API supports updates to API key access scope, metadata and expiration.\nThe access scope of each API key is derived from the `role_descriptors` you specify in the request and a snapshot of the owner user's permissions at the time of the request.\nThe snapshot of the owner's permissions is updated automatically on every call.\n\nIMPORTANT: If you don't specify `role_descriptors` in the request, a call to this API might still change an API key's access scope. This change can occur if the owner user's permissions have changed since the API key was created or last modified.\n\nA successful request returns a JSON structure that contains the IDs of all updated API keys, the IDs of API keys that already had the requested changes and did not require an update, and error details for any failed update.",
        "operationId": "security-bulk-update-api-keys",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "expiration": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "ids": {
                    "description": "The API key identifiers.",
                    "oneOf": [
                      {
                        "type": "string"
                      },
                      {
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    ]
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "role_descriptors": {
                    "description": "The role descriptors to assign to the API keys.\nAn API key's effective permissions are an intersection of its assigned privileges and the point-in-time snapshot of permissions of the owner user.\nYou can assign new privileges by specifying them in this parameter.\nTo remove assigned privileges, supply the `role_descriptors` parameter as an empty object `{}`.\nIf an API key has no assigned privileges, it inherits the owner user's full permissions.\nThe snapshot of the owner's permissions is always updated, whether you supply the `role_descriptors` parameter.\nThe structure of a role descriptor is the same as the request for the create API keys API.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/security._types:RoleDescriptor"
                    }
                  }
                },
                "required": [
                  "ids"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "errors": {
                      "$ref": "#/components/schemas/security._types:BulkError"
                    },
                    "noops": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "updated": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "noops",
                    "updated"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.5.0"
      }
    },
    "/_security/user/{username}/_password": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Change passwords",
        "description": "Change the passwords of users in the native realm and built-in users.",
        "operationId": "security-change-password",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.change_password#username"
          },
          {
            "$ref": "#/components/parameters/security.change_password#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.change_password"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.change_password#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Change passwords",
        "description": "Change the passwords of users in the native realm and built-in users.",
        "operationId": "security-change-password-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.change_password#username"
          },
          {
            "$ref": "#/components/parameters/security.change_password#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.change_password"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.change_password#200"
          }
        }
      }
    },
    "/_security/user/_password": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Change passwords",
        "description": "Change the passwords of users in the native realm and built-in users.",
        "operationId": "security-change-password-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.change_password#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.change_password"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.change_password#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Change passwords",
        "description": "Change the passwords of users in the native realm and built-in users.",
        "operationId": "security-change-password-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.change_password#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.change_password"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.change_password#200"
          }
        }
      }
    },
    "/_security/api_key/{ids}/_clear_cache": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Clear the API key cache",
        "description": "Evict a subset of all entries from the API key cache.\nThe cache is also automatically cleared on state changes of the security index.",
        "operationId": "security-clear-api-key-cache",
        "parameters": [
          {
            "in": "path",
            "name": "ids",
            "description": "Comma-separated list of API key IDs to evict from the API key cache.\nTo evict all API keys, use `*`.\nDoes not support other wildcard patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_security/privilege/{application}/_clear_cache": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Clear the privileges cache",
        "description": "Evict privileges from the native application privilege cache.\nThe cache is also automatically cleared for applications that have their privileges updated.",
        "operationId": "security-clear-cached-privileges",
        "parameters": [
          {
            "in": "path",
            "name": "application",
            "description": "A comma-separated list of applications.\nTo clear all applications, use an asterism (`*`).\nIt does not support other wildcard patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_security/realm/{realms}/_clear_cache": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Clear the user cache",
        "description": "Evict users from the user cache.\nYou can completely clear the cache or evict specific users.\n\nUser credentials are cached in memory on each node to avoid connecting to a remote authentication service or hitting the disk for every incoming request.\nThere are realm settings that you can use to configure the user cache.\nFor more information, refer to the documentation about controlling the user cache.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/controlling-user-cache.html"
        },
        "operationId": "security-clear-cached-realms",
        "parameters": [
          {
            "in": "path",
            "name": "realms",
            "description": "A comma-separated list of realms.\nTo clear all realms, use an asterisk (`*`).\nIt does not support other wildcard patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "usernames",
            "description": "A comma-separated list of the users to clear from the cache.\nIf you do not specify this parameter, the API evicts all users from the user cache.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/role/{name}/_clear_cache": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Clear the roles cache",
        "description": "Evict roles from the native role cache.",
        "operationId": "security-clear-cached-roles",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "A comma-separated list of roles to evict from the role cache.\nTo evict all roles, use an asterisk (`*`).\nIt does not support other wildcard patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}/credential/token/{name}/_clear_cache": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Clear service account token caches",
        "description": "Evict a subset of all entries from the service account token caches.\nTwo separate caches exist for service account tokens: one cache for tokens backed by the `service_tokens` file, and another for tokens backed by the `.security` index.\nThis API clears matching entries from both caches.\n\nThe cache for service account tokens backed by the `.security` index is cleared automatically on state changes of the security index.\nThe cache for tokens backed by the `service_tokens` file is cleared automatically on file changes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-clear-cached-service-tokens",
        "parameters": [
          {
            "in": "path",
            "name": "namespace",
            "description": "The namespace, which is a top-level grouping of service accounts.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Namespace"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "service",
            "description": "The name of the service, which must be unique within its namespace.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Service"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "name",
            "description": "A comma-separated list of token names to evict from the service account token caches.\nUse a wildcard (`*`) to evict all tokens that belong to a service account.\nIt does not support other wildcard patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/api_key": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get API key information",
        "description": "Retrieves information for one or more API keys.\nNOTE: If you have only the `manage_own_api_key` privilege, this API returns only the API keys that you own.\nIf you have `read_security`, `manage_api_key` or greater privileges (including `manage_security`), this API returns all API keys regardless of ownership.",
        "operationId": "security-get-api-key",
        "parameters": [
          {
            "in": "query",
            "name": "id",
            "description": "An API key id.\nThis parameter cannot be used with any of `name`, `realm_name` or `username`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "name",
            "description": "An API key name.\nThis parameter cannot be used with any of `id`, `realm_name` or `username`.\nIt supports prefix search with wildcard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "owner",
            "description": "A boolean flag that can be used to query API keys owned by the currently authenticated user.\nThe `realm_name` or `username` parameters cannot be specified when this parameter is set to `true` as they are assumed to be the currently authenticated ones.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realm_name",
            "description": "The name of an authentication realm.\nThis parameter cannot be used with either `id` or `name` or when `owner` flag is set to `true`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "username",
            "description": "The username of a user.\nThis parameter cannot be used with either `id` or `name` or when `owner` flag is set to `true`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Username"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "with_limited_by",
            "description": "Return the snapshot of the owner user's role descriptors\nassociated with the API key. An API key's actual\npermission is the intersection of its assigned role\ndescriptors and the owner user's role descriptors.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "active_only",
            "description": "A boolean flag that can be used to query API keys that are currently active. An API key is considered active if it is neither invalidated, nor expired at query time. You can specify this together with other parameters such as `owner` or `name`. If `active_only` is false, the response will include both active and inactive (expired or invalidated) keys.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "with_profile_uid",
            "description": "Determines whether to also retrieve the profile uid, for the API key owner principal, if it exists.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_keys": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:ApiKey"
                      }
                    }
                  },
                  "required": [
                    "api_keys"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.7.0"
      },
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Create an API key",
        "description": "Create an API key for access without requiring basic authentication.\n\nIMPORTANT: If the credential that is used to authenticate this request is an API key, the derived API key cannot have any privileges.\nIf you specify privileges, the API returns an error.\n\nA successful request returns a JSON structure that contains the API key, its unique id, and its name.\nIf applicable, it also returns expiration information for the API key in milliseconds.\n\nNOTE: By default, API keys never expire. You can specify expiration information when you create the API keys.\n\nThe API keys are created by the Elasticsearch API key service, which is automatically enabled.\nTo configure or turn off the API key service, refer to API key service setting documentation.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#api-key-service-settings"
        },
        "operationId": "security-create-api-key",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_api_key#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.create_api_key"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_api_key#200"
          }
        },
        "x-state": "Added in 6.7.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create an API key",
        "description": "Create an API key for access without requiring basic authentication.\n\nIMPORTANT: If the credential that is used to authenticate this request is an API key, the derived API key cannot have any privileges.\nIf you specify privileges, the API returns an error.\n\nA successful request returns a JSON structure that contains the API key, its unique id, and its name.\nIf applicable, it also returns expiration information for the API key in milliseconds.\n\nNOTE: By default, API keys never expire. You can specify expiration information when you create the API keys.\n\nThe API keys are created by the Elasticsearch API key service, which is automatically enabled.\nTo configure or turn off the API key service, refer to API key service setting documentation.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#api-key-service-settings"
        },
        "operationId": "security-create-api-key-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_api_key#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.create_api_key"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_api_key#200"
          }
        },
        "x-state": "Added in 6.7.0"
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Invalidate API keys",
        "description": "This API invalidates API keys created by the create API key or grant API key APIs.\nInvalidated API keys fail authentication, but they can still be viewed using the get API key information and query API key information APIs, for at least the configured retention period, until they are automatically deleted.\n\nTo use this API, you must have at least the `manage_security`, `manage_api_key`, or `manage_own_api_key` cluster privileges.\nThe `manage_security` privilege allows deleting any API key, including both REST and cross cluster API keys.\nThe `manage_api_key` privilege allows deleting any REST API key, but not cross cluster API keys.\nThe `manage_own_api_key` only allows deleting REST API keys that are owned by the user.\nIn addition, with the `manage_own_api_key` privilege, an invalidation request must be issued in one of the three formats:\n\n- Set the parameter `owner=true`.\n- Or, set both `username` and `realm_name` to match the user's identity.\n- Or, if the request is issued by an API key, that is to say an API key invalidates itself, specify its ID in the `ids` field.",
        "operationId": "security-invalidate-api-key",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "ids": {
                    "description": "A list of API key ids.\nThis parameter cannot be used with any of `name`, `realm_name`, or `username`.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "name": {
                    "$ref": "#/components/schemas/_types:Name"
                  },
                  "owner": {
                    "description": "Query API keys owned by the currently authenticated user.\nThe `realm_name` or `username` parameters cannot be specified when this parameter is set to `true` as they are assumed to be the currently authenticated ones.\n\nNOTE: At least one of `ids`, `name`, `username`, and `realm_name` must be specified if `owner` is `false`.",
                    "type": "boolean"
                  },
                  "realm_name": {
                    "description": "The name of an authentication realm.\nThis parameter cannot be used with either `ids` or `name`, or when `owner` flag is set to `true`.",
                    "type": "string"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error_count": {
                      "description": "The number of errors that were encountered when invalidating the API keys.",
                      "type": "number"
                    },
                    "error_details": {
                      "description": "Details about the errors.\nThis field is not present in the response when `error_count` is `0`.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:ErrorCause"
                      }
                    },
                    "invalidated_api_keys": {
                      "description": "The IDs of the API keys that were invalidated as part of this request.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "previously_invalidated_api_keys": {
                      "description": "The IDs of the API keys that were already invalidated.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "error_count",
                    "invalidated_api_keys",
                    "previously_invalidated_api_keys"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.7.0"
      }
    },
    "/_security/cross_cluster/api_key": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create a cross-cluster API key",
        "description": "Create an API key of the `cross_cluster` type for the API key based remote cluster access.\nA `cross_cluster` API key cannot be used to authenticate through the REST interface.\n\nIMPORTANT: To authenticate this request you must use a credential that is not an API key. Even if you use an API key that has the required privilege, the API returns an error.\n\nCross-cluster API keys are created by the Elasticsearch API key service, which is automatically enabled.\n\nNOTE: Unlike REST API keys, a cross-cluster API key does not capture permissions of the authenticated user. The API keyâ€™s effective permission is exactly as specified with the `access` property.\n\nA successful request returns a JSON structure that contains the API key, its unique ID, and its name. If applicable, it also returns expiration information for the API key in milliseconds.\n\nBy default, API keys never expire. You can specify expiration information when you create the API keys.\n\nCross-cluster API keys can only be updated with the update cross-cluster API key API.\nAttempting to update them with the update REST API key API or the bulk update REST API keys API will result in an error.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-api-key.html"
        },
        "operationId": "security-create-cross-cluster-api-key",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access": {
                    "$ref": "#/components/schemas/security._types:Access"
                  },
                  "expiration": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "name": {
                    "$ref": "#/components/schemas/_types:Name"
                  }
                },
                "required": [
                  "access",
                  "name"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_key": {
                      "description": "Generated API key.",
                      "type": "string"
                    },
                    "expiration": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "encoded": {
                      "description": "API key credentials which is the base64-encoding of\nthe UTF-8 representation of `id` and `api_key` joined\nby a colon (`:`).",
                      "type": "string"
                    }
                  },
                  "required": [
                    "api_key",
                    "id",
                    "name",
                    "encoded"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}/credential/token/{name}": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Create a service account token",
        "description": "Create a service accounts token for access without requiring basic authentication.\n\nNOTE: Service account tokens never expire.\nYou must actively delete them if they are no longer needed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-create-service-token",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_service_token#namespace"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#service"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#name"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_service_token#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create a service account token",
        "description": "Create a service accounts token for access without requiring basic authentication.\n\nNOTE: Service account tokens never expire.\nYou must actively delete them if they are no longer needed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-create-service-token-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_service_token#namespace"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#service"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#name"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_service_token#200"
          }
        }
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Delete service account tokens",
        "description": "Delete service account tokens for a service in a specified namespace.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-delete-service-token",
        "parameters": [
          {
            "in": "path",
            "name": "namespace",
            "description": "The namespace, which is a top-level grouping of service accounts.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Namespace"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "service",
            "description": "The service name.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Service"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "name",
            "description": "The name of the service account token.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` (the default) then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "description": "If the service account token is successfully deleted, the request returns `{\"found\": true}`.\nOtherwise, the response will have status code 404 and `found` is set to `false`.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_security/service/{namespace}/{service}/credential/token": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create a service account token",
        "description": "Create a service accounts token for access without requiring basic authentication.\n\nNOTE: Service account tokens never expire.\nYou must actively delete them if they are no longer needed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-create-service-token-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_service_token#namespace"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#service"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_service_token#200"
          }
        }
      }
    },
    "/_security/delegate_pki": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Delegate PKI authentication",
        "description": "This API implements the exchange of an X509Certificate chain for an Elasticsearch access token.\nThe certificate chain is validated, according to RFC 5280, by sequentially considering the trust configuration of every installed PKI realm that has `delegation.enabled` set to `true`.\nA successfully trusted client certificate is also subject to the validation of the subject distinguished name according to thw `username_pattern` of the respective realm.\n\nThis API is called by smart and trusted proxies, such as Kibana, which terminate the user's TLS session but still want to authenticate the user by using a PKI realmâ€”-â€‹as if the user connected directly to Elasticsearch.\n\nIMPORTANT: The association between the subject public key in the target certificate and the corresponding private key is not validated.\nThis is part of the TLS authentication process and it is delegated to the proxy that calls this API.\nThe proxy is trusted to have performed the TLS authentication and this API translates that authentication into an Elasticsearch access token.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/pki-realm.html"
        },
        "operationId": "security-delegate-pki",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "x509_certificate_chain": {
                    "description": "The X509Certificate chain, which is represented as an ordered string array.\nEach string in the array is a base64-encoded (Section 4 of RFC4648 - not base64url-encoded) of the certificate's DER encoding.\n\nThe first element is the target certificate that contains the subject distinguished name that is requesting access.\nThis may be followed by additional certificates; each subsequent certificate is used to certify the previous one.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "x509_certificate_chain"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "access_token": {
                      "description": "An access token associated with the subject distinguished name of the client's certificate.",
                      "type": "string"
                    },
                    "expires_in": {
                      "description": "The amount of time (in seconds) before the token expires.",
                      "type": "number"
                    },
                    "type": {
                      "description": "The type of token.",
                      "type": "string"
                    },
                    "authentication": {
                      "$ref": "#/components/schemas/security.delegate_pki:Authentication"
                    }
                  },
                  "required": [
                    "access_token",
                    "expires_in",
                    "type"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.4.0"
      }
    },
    "/_security/privilege/{application}/{name}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get application privileges",
        "description": "To use this API, you must have one of the following privileges:\n\n* The `read_security` cluster privilege (or a greater privilege such as `manage_security` or `all`).\n* The \"Manage Application Privileges\" global privilege for the application being referenced in the request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-get-privileges-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_privileges#application"
          },
          {
            "$ref": "#/components/parameters/security.get_privileges#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Delete application privileges",
        "description": "To use this API, you must have one of the following privileges:\n\n* The `manage_security` cluster privilege (or a greater privilege such as `all`).\n* The \"Manage Application Privileges\" global privilege for the application being referenced in the request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-delete-privileges",
        "parameters": [
          {
            "in": "path",
            "name": "application",
            "description": "The name of the application.\nApplication privileges are always associated with exactly one application.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "name",
            "description": "The name of the privilege.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/security.delete_privileges:FoundStatus"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_security/role/{name}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get roles",
        "description": "Get roles in the native realm.\nThe role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe get roles API cannot retrieve roles that are defined in roles files.",
        "operationId": "security-get-role",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_role#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role#200"
          }
        }
      },
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Create or update roles",
        "description": "The role management APIs are generally the preferred way to manage roles in the native realm, rather than using file-based role management.\nThe create or update roles API cannot update roles that are defined in roles files.\nFile-based role management is not available in Elastic Serverless.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/defining-roles.html"
        },
        "operationId": "security-put-role",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create or update roles",
        "description": "The role management APIs are generally the preferred way to manage roles in the native realm, rather than using file-based role management.\nThe create or update roles API cannot update roles that are defined in roles files.\nFile-based role management is not available in Elastic Serverless.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/defining-roles.html"
        },
        "operationId": "security-put-role-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role#200"
          }
        }
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Delete roles",
        "description": "Delete roles in the native realm.\nThe role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe delete roles API cannot remove roles that are defined in roles files.",
        "operationId": "security-delete-role",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the role.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "description": "If the role is successfully deleted, `found` is `true`.\nOtherwise, `found` is `false`.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/role_mapping/{name}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get role mappings",
        "description": "Role mappings define which roles are assigned to each user.\nThe role mapping APIs are generally the preferred way to manage role mappings rather than using role mapping files.\nThe get role mappings API cannot retrieve role mappings that are defined in role mapping files.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-roles.html"
        },
        "operationId": "security-get-role-mapping",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_role_mapping#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role_mapping#200"
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Create or update role mappings",
        "description": "Role mappings define which roles are assigned to each user.\nEach mapping has rules that identify users and a list of roles that are granted to those users.\nThe role mapping APIs are generally the preferred way to manage role mappings rather than using role mapping files. The create or update role mappings API cannot update role mappings that are defined in role mapping files.\n\nNOTE: This API does not create roles. Rather, it maps users to existing roles.\nRoles can be created by using the create or update roles API or roles files.\n\n**Role templates**\n\nThe most common use for role mappings is to create a mapping from a known value on the user to a fixed role name.\nFor example, all users in the `cn=admin,dc=example,dc=com` LDAP group should be given the superuser role in Elasticsearch.\nThe `roles` field is used for this purpose.\n\nFor more complex needs, it is possible to use Mustache templates to dynamically determine the names of the roles that should be granted to the user.\nThe `role_templates` field is used for this purpose.\n\nNOTE: To use role templates successfully, the relevant scripting feature must be enabled.\nOtherwise, all attempts to create a role mapping with role templates fail.\n\nAll of the user fields that are available in the role mapping rules are also available in the role templates.\nThus it is possible to assign a user to a role that reflects their username, their groups, or the name of the realm to which they authenticated.\n\nBy default a template is evaluated to produce a single string that is the name of the role which should be assigned to the user.\nIf the format of the template is set to \"json\" then the template is expected to produce a JSON string or an array of JSON strings for the role names.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-roles.html"
        },
        "operationId": "security-put-role-mapping",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role_mapping#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role_mapping#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role_mapping#200"
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create or update role mappings",
        "description": "Role mappings define which roles are assigned to each user.\nEach mapping has rules that identify users and a list of roles that are granted to those users.\nThe role mapping APIs are generally the preferred way to manage role mappings rather than using role mapping files. The create or update role mappings API cannot update role mappings that are defined in role mapping files.\n\nNOTE: This API does not create roles. Rather, it maps users to existing roles.\nRoles can be created by using the create or update roles API or roles files.\n\n**Role templates**\n\nThe most common use for role mappings is to create a mapping from a known value on the user to a fixed role name.\nFor example, all users in the `cn=admin,dc=example,dc=com` LDAP group should be given the superuser role in Elasticsearch.\nThe `roles` field is used for this purpose.\n\nFor more complex needs, it is possible to use Mustache templates to dynamically determine the names of the roles that should be granted to the user.\nThe `role_templates` field is used for this purpose.\n\nNOTE: To use role templates successfully, the relevant scripting feature must be enabled.\nOtherwise, all attempts to create a role mapping with role templates fail.\n\nAll of the user fields that are available in the role mapping rules are also available in the role templates.\nThus it is possible to assign a user to a role that reflects their username, their groups, or the name of the realm to which they authenticated.\n\nBy default a template is evaluated to produce a single string that is the name of the role which should be assigned to the user.\nIf the format of the template is set to \"json\" then the template is expected to produce a JSON string or an array of JSON strings for the role names.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-roles.html"
        },
        "operationId": "security-put-role-mapping-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role_mapping#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role_mapping#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role_mapping#200"
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Delete role mappings",
        "description": "Role mappings define which roles are assigned to each user.\nThe role mapping APIs are generally the preferred way to manage role mappings rather than using role mapping files.\nThe delete role mappings API cannot remove role mappings that are defined in role mapping files.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-roles.html"
        },
        "operationId": "security-delete-role-mapping",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The distinct name that identifies the role mapping.\nThe name is used solely as an identifier to facilitate interaction via the API; it does not affect the behavior of the mapping in any way.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "description": "If the mapping is successfully deleted, `found` is `true`.\nOtherwise, `found` is `false`.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_security/user/{username}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get users",
        "description": "Get information about users in the native realm and built-in users.",
        "operationId": "security-get-user",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_user#username"
          },
          {
            "$ref": "#/components/parameters/security.get_user#with_profile_uid"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_user#200"
          }
        }
      },
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Create or update users",
        "description": "Add and update users in the native realm.\nA password is required for adding a new user but is optional when updating an existing user.\nTo change a user's password without updating any other fields, use the change password API.",
        "operationId": "security-put-user",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_user#username"
          },
          {
            "$ref": "#/components/parameters/security.put_user#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_user"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_user#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create or update users",
        "description": "Add and update users in the native realm.\nA password is required for adding a new user but is optional when updating an existing user.\nTo change a user's password without updating any other fields, use the change password API.",
        "operationId": "security-put-user-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_user#username"
          },
          {
            "$ref": "#/components/parameters/security.put_user#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_user"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_user#200"
          }
        }
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Delete users",
        "description": "Delete users from the native realm.",
        "operationId": "security-delete-user",
        "parameters": [
          {
            "in": "path",
            "name": "username",
            "description": "An identifier for the user.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Username"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "description": "If the user is successfully deleted, the request returns `{\"found\": true}`.\nOtherwise, `found` is set to `false`.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/user/{username}/_disable": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Disable users",
        "description": "Disable users in the native realm.\nBy default, when you create users, they are enabled.\nYou can use this API to revoke a user's access to Elasticsearch.",
        "operationId": "security-disable-user",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.disable_user#username"
          },
          {
            "$ref": "#/components/parameters/security.disable_user#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.disable_user#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Disable users",
        "description": "Disable users in the native realm.\nBy default, when you create users, they are enabled.\nYou can use this API to revoke a user's access to Elasticsearch.",
        "operationId": "security-disable-user-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.disable_user#username"
          },
          {
            "$ref": "#/components/parameters/security.disable_user#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.disable_user#200"
          }
        }
      }
    },
    "/_security/profile/{uid}/_disable": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Disable a user profile",
        "description": "Disable user profiles so that they are not visible in user profile searches.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nWhen you activate a user profile, its automatically enabled and visible in user profile searches. You can use the disable user profile API to disable a user profile so itâ€™s not visible in these searches.\nTo re-enable a disabled user profile, use the enable user profile API .",
        "operationId": "security-disable-user-profile",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.disable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.disable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.disable_user_profile#200"
          }
        },
        "x-state": "Added in 8.2.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Disable a user profile",
        "description": "Disable user profiles so that they are not visible in user profile searches.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nWhen you activate a user profile, its automatically enabled and visible in user profile searches. You can use the disable user profile API to disable a user profile so itâ€™s not visible in these searches.\nTo re-enable a disabled user profile, use the enable user profile API .",
        "operationId": "security-disable-user-profile-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.disable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.disable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.disable_user_profile#200"
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_security/user/{username}/_enable": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Enable users",
        "description": "Enable users in the native realm.\nBy default, when you create users, they are enabled.",
        "operationId": "security-enable-user",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.enable_user#username"
          },
          {
            "$ref": "#/components/parameters/security.enable_user#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.enable_user#200"
          }
        }
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Enable users",
        "description": "Enable users in the native realm.\nBy default, when you create users, they are enabled.",
        "operationId": "security-enable-user-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.enable_user#username"
          },
          {
            "$ref": "#/components/parameters/security.enable_user#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.enable_user#200"
          }
        }
      }
    },
    "/_security/profile/{uid}/_enable": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Enable a user profile",
        "description": "Enable user profiles to make them visible in user profile searches.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nWhen you activate a user profile, it's automatically enabled and visible in user profile searches.\nIf you later disable the user profile, you can use the enable user profile API to make the profile visible in these searches again.",
        "operationId": "security-enable-user-profile",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.enable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.enable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.enable_user_profile#200"
          }
        },
        "x-state": "Added in 8.2.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Enable a user profile",
        "description": "Enable user profiles to make them visible in user profile searches.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nWhen you activate a user profile, it's automatically enabled and visible in user profile searches.\nIf you later disable the user profile, you can use the enable user profile API to make the profile visible in these searches again.",
        "operationId": "security-enable-user-profile-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.enable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.enable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.enable_user_profile#200"
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_security/enroll/kibana": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Enroll Kibana",
        "description": "Enable a Kibana instance to configure itself for communication with a secured Elasticsearch cluster.\n\nNOTE: This API is currently intended for internal use only by Kibana.\nKibana uses this API internally to configure itself for communications with an Elasticsearch cluster that already has security features enabled.",
        "operationId": "security-enroll-kibana",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "token": {
                      "$ref": "#/components/schemas/security.enroll_kibana:Token"
                    },
                    "http_ca": {
                      "description": "The CA certificate used to sign the node certificates that Elasticsearch uses for TLS on the HTTP layer.\nThe certificate is returned as a Base64 encoded string of the ASN.1 DER encoding of the certificate.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "token",
                    "http_ca"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.0.0"
      }
    },
    "/_security/enroll/node": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Enroll a node",
        "description": "Enroll a new node to allow it to join an existing cluster with security features enabled.\n\nThe response contains all the necessary information for the joining node to bootstrap discovery and security related settings so that it can successfully join the cluster.\nThe response contains key and certificate material that allows the caller to generate valid signed certificates for the HTTP layer of all nodes in the cluster.",
        "operationId": "security-enroll-node",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "http_ca_key": {
                      "description": "The CA private key that can be used by the new node in order to sign its certificate for the HTTP layer, as a Base64 encoded string of the ASN.1 DER encoding of the key.",
                      "type": "string"
                    },
                    "http_ca_cert": {
                      "description": "The CA certificate that can be used by the new node in order to sign its certificate for the HTTP layer, as a Base64 encoded string of the ASN.1 DER encoding of the certificate.",
                      "type": "string"
                    },
                    "transport_ca_cert": {
                      "description": "The CA certificate that is used to sign the TLS certificate for the transport layer, as a Base64 encoded string of the ASN.1 DER encoding of the certificate.",
                      "type": "string"
                    },
                    "transport_key": {
                      "description": "The private key that the node can use for TLS for its transport layer, as a Base64 encoded string of the ASN.1 DER encoding of the key.",
                      "type": "string"
                    },
                    "transport_cert": {
                      "description": "The certificate that the node can use for TLS for its transport layer, as a Base64 encoded string of the ASN.1 DER encoding of the certificate.",
                      "type": "string"
                    },
                    "nodes_addresses": {
                      "description": "A list of transport addresses in the form of `host:port` for the nodes that are already members of the cluster.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "http_ca_key",
                    "http_ca_cert",
                    "transport_ca_cert",
                    "transport_key",
                    "transport_cert",
                    "nodes_addresses"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.0.0"
      }
    },
    "/_security/privilege/_builtin": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get builtin privileges",
        "description": "Get the list of cluster privileges and index privileges that are available in this version of Elasticsearch.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-get-builtin-privileges",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cluster": {
                      "description": "The list of cluster privileges that are understood by this version of Elasticsearch.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:ClusterPrivilege"
                      }
                    },
                    "index": {
                      "$ref": "#/components/schemas/_types:Indices"
                    },
                    "remote_cluster": {
                      "description": "The list of remote_cluster privileges that are understood by this version of Elasticsearch.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:RemoteClusterPrivilege"
                      }
                    }
                  },
                  "required": [
                    "cluster",
                    "index",
                    "remote_cluster"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.3.0"
      }
    },
    "/_security/privilege": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get application privileges",
        "description": "To use this API, you must have one of the following privileges:\n\n* The `read_security` cluster privilege (or a greater privilege such as `manage_security` or `all`).\n* The \"Manage Application Privileges\" global privilege for the application being referenced in the request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-get-privileges",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      },
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Create or update application privileges",
        "description": "To use this API, you must have one of the following privileges:\n\n* The `manage_security` cluster privilege (or a greater privilege such as `all`).\n* The \"Manage Application Privileges\" global privilege for the application being referenced in the request.\n\nApplication names are formed from a prefix, with an optional suffix that conform to the following rules:\n\n* The prefix must begin with a lowercase ASCII letter.\n* The prefix must contain only ASCII letters or digits.\n* The prefix must be at least 3 characters long.\n* If the suffix exists, it must begin with either a dash `-` or `_`.\n* The suffix cannot contain any of the following characters: `\\`, `/`, `*`, `?`, `\"`, `<`, `>`, `|`, `,`, `*`.\n* No part of the name can contain whitespace.\n\nPrivilege names must begin with a lowercase ASCII letter and must contain only ASCII letters and digits along with the characters `_`, `-`, and `.`.\n\nAction names can contain any number of printable ASCII characters and must contain at least one of the following characters: `/`, `*`, `:`.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-put-privileges",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_privileges#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Create or update application privileges",
        "description": "To use this API, you must have one of the following privileges:\n\n* The `manage_security` cluster privilege (or a greater privilege such as `all`).\n* The \"Manage Application Privileges\" global privilege for the application being referenced in the request.\n\nApplication names are formed from a prefix, with an optional suffix that conform to the following rules:\n\n* The prefix must begin with a lowercase ASCII letter.\n* The prefix must contain only ASCII letters or digits.\n* The prefix must be at least 3 characters long.\n* If the suffix exists, it must begin with either a dash `-` or `_`.\n* The suffix cannot contain any of the following characters: `\\`, `/`, `*`, `?`, `\"`, `<`, `>`, `|`, `,`, `*`.\n* No part of the name can contain whitespace.\n\nPrivilege names must begin with a lowercase ASCII letter and must contain only ASCII letters and digits along with the characters `_`, `-`, and `.`.\n\nAction names can contain any number of printable ASCII characters and must contain at least one of the following characters: `/`, `*`, `:`.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-put-privileges-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_privileges#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_security/privilege/{application}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get application privileges",
        "description": "To use this API, you must have one of the following privileges:\n\n* The `read_security` cluster privilege (or a greater privilege such as `manage_security` or `all`).\n* The \"Manage Application Privileges\" global privilege for the application being referenced in the request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-get-privileges-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_privileges#application"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_security/role_mapping": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get role mappings",
        "description": "Role mappings define which roles are assigned to each user.\nThe role mapping APIs are generally the preferred way to manage role mappings rather than using role mapping files.\nThe get role mappings API cannot retrieve role mappings that are defined in role mapping files.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-roles.html"
        },
        "operationId": "security-get-role-mapping-1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role_mapping#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_security/service/{namespace}/{service}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get service accounts",
        "description": "Get a list of service accounts that match the provided path parameters.\n\nNOTE: Currently, only the `elastic/fleet-server` service account is available.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-get-service-accounts",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_service_accounts#namespace"
          },
          {
            "$ref": "#/components/parameters/security.get_service_accounts#service"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_service_accounts#200"
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_security/service/{namespace}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get service accounts",
        "description": "Get a list of service accounts that match the provided path parameters.\n\nNOTE: Currently, only the `elastic/fleet-server` service account is available.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-get-service-accounts-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_service_accounts#namespace"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_service_accounts#200"
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_security/service": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get service accounts",
        "description": "Get a list of service accounts that match the provided path parameters.\n\nNOTE: Currently, only the `elastic/fleet-server` service account is available.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-get-service-accounts-2",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_service_accounts#200"
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_security/service/{namespace}/{service}/credential": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get service account credentials",
        "description": "To use this API, you must have at least the `read_security` cluster privilege (or a greater privilege such as `manage_service_account` or `manage_security`).\n\nThe response includes service account tokens that were created with the create service account tokens API as well as file-backed tokens from all nodes of the cluster.\n\nNOTE: For tokens backed by the `service_tokens` file, the API collects them from all nodes of the cluster.\nTokens with the same name from different nodes are assumed to be the same token and are only counted once towards the total number of service tokens.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/service-accounts.html"
        },
        "operationId": "security-get-service-credentials",
        "parameters": [
          {
            "in": "path",
            "name": "namespace",
            "description": "The name of the namespace.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Namespace"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "service",
            "description": "The service name.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "service_account": {
                      "type": "string"
                    },
                    "count": {
                      "type": "number"
                    },
                    "tokens": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types:Metadata"
                      }
                    },
                    "nodes_credentials": {
                      "$ref": "#/components/schemas/security.get_service_credentials:NodesCredentials"
                    }
                  },
                  "required": [
                    "service_account",
                    "count",
                    "tokens",
                    "nodes_credentials"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_security/settings": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get security index settings",
        "description": "Get the user-configurable settings for the security internal index (`.security` and associated indices).\nOnly a subset of the index settings â€” those that are user-configurableâ€”will be shown.\nThis includes:\n\n* `index.auto_expand_replicas`\n* `index.number_of_replicas`",
        "operationId": "security-get-settings",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "security": {
                      "$ref": "#/components/schemas/security._types:SecuritySettings"
                    },
                    "security-profile": {
                      "$ref": "#/components/schemas/security._types:SecuritySettings"
                    },
                    "security-tokens": {
                      "$ref": "#/components/schemas/security._types:SecuritySettings"
                    }
                  },
                  "required": [
                    "security",
                    "security-profile",
                    "security-tokens"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Update security index settings",
        "description": "Update the user-configurable settings for the security internal index (`.security` and associated indices). Only a subset of settings are allowed to be modified. This includes `index.auto_expand_replicas` and `index.number_of_replicas`.\n\nNOTE: If `index.auto_expand_replicas` is set, `index.number_of_replicas` will be ignored during updates.\n\nIf a specific index is not in use on the system and settings are provided for it, the request will be rejected.\nThis API does not yet support configuring the settings for indices before they are in use.",
        "operationId": "security-update-settings",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "security": {
                    "$ref": "#/components/schemas/security._types:SecuritySettings"
                  },
                  "security-profile": {
                    "$ref": "#/components/schemas/security._types:SecuritySettings"
                  },
                  "security-tokens": {
                    "$ref": "#/components/schemas/security._types:SecuritySettings"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/oauth2/token": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Get a token",
        "description": "Create a bearer token for access without requiring basic authentication.\nThe tokens are created by the Elasticsearch Token Service, which is automatically enabled when you configure TLS on the HTTP interface.\nAlternatively, you can explicitly enable the `xpack.security.authc.token.enabled` setting.\nWhen you are running in production mode, a bootstrap check prevents you from enabling the token service unless you also enable TLS on the HTTP interface.\n\nThe get token API takes the same parameters as a typical OAuth 2.0 token API except for the use of a JSON request body.\n\nA successful get token API call returns a JSON structure that contains the access token, the amount of time (seconds) that the token expires in, the type, and the scope if available.\n\nThe tokens returned by the get token API have a finite period of time for which they are valid and after that time period, they can no longer be used.\nThat time period is defined by the `xpack.security.authc.token.timeout` setting.\nIf you want to invalidate a token immediately, you can do so by using the invalidate token API.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-basic-setup-https.html#encrypt-http-communication"
        },
        "operationId": "security-get-token",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "grant_type": {
                    "$ref": "#/components/schemas/security.get_token:AccessTokenGrantType"
                  },
                  "scope": {
                    "description": "The scope of the token.\nCurrently tokens are only issued for a scope of FULL regardless of the value sent with the request.",
                    "type": "string"
                  },
                  "password": {
                    "$ref": "#/components/schemas/_types:Password"
                  },
                  "kerberos_ticket": {
                    "description": "The base64 encoded kerberos ticket.\nIf you specify the `_kerberos` grant type, this parameter is required.\nThis parameter is not valid with any other supported grant type.",
                    "type": "string"
                  },
                  "refresh_token": {
                    "description": "The string that was returned when you created the token, which enables you to extend its life.\nIf you specify the `refresh_token` grant type, this parameter is required.\nThis parameter is not valid with any other supported grant type.",
                    "type": "string"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "access_token": {
                      "type": "string"
                    },
                    "expires_in": {
                      "type": "number"
                    },
                    "scope": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    },
                    "refresh_token": {
                      "type": "string"
                    },
                    "kerberos_authentication_response_token": {
                      "type": "string"
                    },
                    "authentication": {
                      "$ref": "#/components/schemas/security.get_token:AuthenticatedUser"
                    }
                  },
                  "required": [
                    "access_token",
                    "expires_in",
                    "type",
                    "authentication"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      },
      "delete": {
        "tags": [
          "security"
        ],
        "summary": "Invalidate a token",
        "description": "The access tokens returned by the get token API have a finite period of time for which they are valid.\nAfter that time period, they can no longer be used.\nThe time period is defined by the `xpack.security.authc.token.timeout` setting.\n\nThe refresh tokens returned by the get token API are only valid for 24 hours.\nThey can also be used exactly once.\nIf you want to invalidate one or more access or refresh tokens immediately, use this invalidate token API.\n\nNOTE: While all parameters are optional, at least one of them is required.\nMore specifically, either one of `token` or `refresh_token` parameters is required.\nIf none of these two are specified, then `realm_name` and/or `username` need to be specified.",
        "operationId": "security-invalidate-token",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "description": "An access token.\nThis parameter cannot be used if any of `refresh_token`, `realm_name`, or `username` are used.",
                    "type": "string"
                  },
                  "refresh_token": {
                    "description": "A refresh token.\nThis parameter cannot be used if any of `refresh_token`, `realm_name`, or `username` are used.",
                    "type": "string"
                  },
                  "realm_name": {
                    "$ref": "#/components/schemas/_types:Name"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error_count": {
                      "description": "The number of errors that were encountered when invalidating the tokens.",
                      "type": "number"
                    },
                    "error_details": {
                      "description": "Details about the errors.\nThis field is not present in the response when `error_count` is `0`.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:ErrorCause"
                      }
                    },
                    "invalidated_tokens": {
                      "description": "The number of the tokens that were invalidated as part of this request.",
                      "type": "number"
                    },
                    "previously_invalidated_tokens": {
                      "description": "The number of tokens that were already invalidated.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "error_count",
                    "invalidated_tokens",
                    "previously_invalidated_tokens"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_security/user": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get users",
        "description": "Get information about users in the native realm and built-in users.",
        "operationId": "security-get-user-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_user#with_profile_uid"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_user#200"
          }
        }
      }
    },
    "/_security/user/_privileges": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get user privileges",
        "description": "Get the security privileges for the logged in user.\nAll users can use this API, but only to determine their own privileges.\nTo check the privileges of other users, you must use the run as feature.\nTo check whether a user has a specific list of privileges, use the has privileges API.",
        "operationId": "security-get-user-privileges",
        "parameters": [
          {
            "in": "query",
            "name": "application",
            "description": "The name of the application. Application privileges are always associated with exactly one application. If you do not specify this parameter, the API returns information about all privileges for all applications.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "priviledge",
            "description": "The name of the privilege. If you do not specify this parameter, the API returns information about all privileges for the requested application.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "username",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:Name"
                },
                {
                  "nullable": true,
                  "type": "string"
                }
              ]
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "applications": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
                      }
                    },
                    "cluster": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "remote_cluster": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:RemoteClusterPrivileges"
                      }
                    },
                    "global": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:GlobalPrivilege"
                      }
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:UserIndicesPrivileges"
                      }
                    },
                    "remote_indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:RemoteUserIndicesPrivileges"
                      }
                    },
                    "run_as": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "applications",
                    "cluster",
                    "global",
                    "indices",
                    "run_as"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_security/profile/{uid}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get a user profile",
        "description": "Get a user's profile using the unique profile ID.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.",
        "operationId": "security-get-user-profile",
        "parameters": [
          {
            "in": "path",
            "name": "uid",
            "description": "A unique identifier for the user profile.",
            "required": true,
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/security._types:UserProfileId"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfileId"
                  }
                }
              ]
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "data",
            "description": "A comma-separated list of filters for the `data` field of the profile document.\nTo return all content use `data=*`.\nTo return a subset of content use `data=<key>` to retrieve content nested under the specified `<key>`.\nBy default returns no `data` content.",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "profiles": {
                      "description": "A successful call returns the JSON representation of the user profile and its internal versioning numbers.\nThe API returns an empty object if no profile document is found for the provided `uid`.\nThe content of the data field is not returned by default to avoid deserializing a potential large payload.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:UserProfileWithMetadata"
                      }
                    },
                    "errors": {
                      "$ref": "#/components/schemas/security.get_user_profile:GetUserProfileErrors"
                    }
                  },
                  "required": [
                    "profiles"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_security/api_key/grant": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Grant an API key",
        "description": "Create an API key on behalf of another user.\nThis API is similar to the create API keys API, however it creates the API key for a user that is different than the user that runs the API.\nThe caller must have authentication credentials for the user on whose behalf the API key will be created.\nIt is not possible to use this API to create an API key without that user's credentials.\nThe supported user authentication credential types are:\n\n* username and password\n* Elasticsearch access tokens\n* JWTs\n\nThe user, for whom the authentication credentials is provided, can optionally \"run as\" (impersonate) another user.\nIn this case, the API key will be created on behalf of the impersonated user.\n\nThis API is intended be used by applications that need to create and manage API keys for end users, but cannot guarantee that those users have permission to create API keys on their own behalf.\nThe API keys are created by the Elasticsearch API key service, which is automatically enabled.\n\nA successful grant API key API call returns a JSON structure that contains the API key, its unique id, and its name.\nIf applicable, it also returns expiration information for the API key in milliseconds.\n\nBy default, API keys never expire. You can specify expiration information when you create the API keys.",
        "operationId": "security-grant-api-key",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "api_key": {
                    "$ref": "#/components/schemas/security.grant_api_key:GrantApiKey"
                  },
                  "grant_type": {
                    "$ref": "#/components/schemas/security.grant_api_key:ApiKeyGrantType"
                  },
                  "access_token": {
                    "description": "The user's access token.\nIf you specify the `access_token` grant type, this parameter is required.\nIt is not valid with other grant types.",
                    "type": "string"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  },
                  "password": {
                    "$ref": "#/components/schemas/_types:Password"
                  },
                  "run_as": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                },
                "required": [
                  "api_key",
                  "grant_type"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_key": {
                      "type": "string"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "expiration": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "encoded": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "api_key",
                    "id",
                    "name",
                    "encoded"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.9.0"
      }
    },
    "/_security/user/_has_privileges": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Check user privileges",
        "description": "Determine whether the specified user has a specified list of privileges.\nAll users can use this API, but only to determine their own privileges.\nTo check the privileges of other users, you must use the run as feature.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-has-privileges",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Check user privileges",
        "description": "Determine whether the specified user has a specified list of privileges.\nAll users can use this API, but only to determine their own privileges.\nTo check the privileges of other users, you must use the run as feature.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-has-privileges-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_security/user/{user}/_has_privileges": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Check user privileges",
        "description": "Determine whether the specified user has a specified list of privileges.\nAll users can use this API, but only to determine their own privileges.\nTo check the privileges of other users, you must use the run as feature.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-has-privileges-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.has_privileges#user"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Check user privileges",
        "description": "Determine whether the specified user has a specified list of privileges.\nAll users can use this API, but only to determine their own privileges.\nTo check the privileges of other users, you must use the run as feature.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-privileges.html"
        },
        "operationId": "security-has-privileges-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.has_privileges#user"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        },
        "x-state": "Added in 6.4.0"
      }
    },
    "/_security/profile/_has_privileges": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Check user profile privileges",
        "description": "Determine whether the users associated with the specified user profile IDs have all the requested privileges.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions. Individual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/user-profile.html"
        },
        "operationId": "security-has-privileges-user-profile",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges_user_profile"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges_user_profile#200"
          }
        },
        "x-state": "Added in 8.3.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Check user profile privileges",
        "description": "Determine whether the users associated with the specified user profile IDs have all the requested privileges.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions. Individual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/user-profile.html"
        },
        "operationId": "security-has-privileges-user-profile-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges_user_profile"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges_user_profile#200"
          }
        },
        "x-state": "Added in 8.3.0"
      }
    },
    "/_security/oidc/authenticate": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Authenticate OpenID Connect",
        "description": "Exchange an OpenID Connect authentication response message for an Elasticsearch internal access token and refresh token that can be subsequently used for authentication.\n\nElasticsearch exposes all the necessary OpenID Connect related functionality with the OpenID Connect APIs.\nThese APIs are used internally by Kibana in order to provide OpenID Connect based authentication, but can also be used by other, custom web applications or other clients.",
        "operationId": "security-oidc-authenticate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "nonce": {
                    "description": "Associate a client session with an ID token and mitigate replay attacks.\nThis value needs to be the same as the one that was provided to the `/_security/oidc/prepare` API or the one that was generated by Elasticsearch and included in the response to that call.",
                    "type": "string"
                  },
                  "realm": {
                    "description": "The name of the OpenID Connect realm.\nThis property is useful in cases where multiple realms are defined.",
                    "type": "string"
                  },
                  "redirect_uri": {
                    "description": "The URL to which the OpenID Connect Provider redirected the User Agent in response to an authentication request after a successful authentication.\nThis URL must be provided as-is (URL encoded), taken from the body of the response or as the value of a location header in the response from the OpenID Connect Provider.",
                    "type": "string"
                  },
                  "state": {
                    "description": "Maintain state between the authentication request and the response.\nThis value needs to be the same as the one that was provided to the `/_security/oidc/prepare` API or the one that was generated by Elasticsearch and included in the response to that call.",
                    "type": "string"
                  }
                },
                "required": [
                  "nonce",
                  "redirect_uri",
                  "state"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "access_token": {
                      "description": "The Elasticsearch access token.",
                      "type": "string"
                    },
                    "expires_in": {
                      "description": "The duration (in seconds) of the tokens.",
                      "type": "number"
                    },
                    "refresh_token": {
                      "description": "The Elasticsearch refresh token.",
                      "type": "string"
                    },
                    "type": {
                      "description": "The type of token.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "access_token",
                    "expires_in",
                    "refresh_token",
                    "type"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/oidc/logout": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Logout of OpenID Connect",
        "description": "Invalidate an access token and a refresh token that were generated as a response to the `/_security/oidc/authenticate` API.\n\nIf the OpenID Connect authentication realm in Elasticsearch is accordingly configured, the response to this call will contain a URI pointing to the end session endpoint of the OpenID Connect Provider in order to perform single logout.\n\nElasticsearch exposes all the necessary OpenID Connect related functionality with the OpenID Connect APIs.\nThese APIs are used internally by Kibana in order to provide OpenID Connect based authentication, but can also be used by other, custom web applications or other clients.",
        "operationId": "security-oidc-logout",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_token": {
                    "description": "The access token to be invalidated.",
                    "type": "string"
                  },
                  "refresh_token": {
                    "description": "The refresh token to be invalidated.",
                    "type": "string"
                  }
                },
                "required": [
                  "access_token"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "redirect": {
                      "description": "A URI that points to the end session endpoint of the OpenID Connect Provider with all the parameters of the logout request as HTTP GET parameters.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "redirect"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/oidc/prepare": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Prepare OpenID connect authentication",
        "description": "Create an oAuth 2.0 authentication request as a URL string based on the configuration of the OpenID Connect authentication realm in Elasticsearch.\n\nThe response of this API is a URL pointing to the Authorization Endpoint of the configured OpenID Connect Provider, which can be used to redirect the browser of the user in order to continue the authentication process.\n\nElasticsearch exposes all the necessary OpenID Connect related functionality with the OpenID Connect APIs.\nThese APIs are used internally by Kibana in order to provide OpenID Connect based authentication, but can also be used by other, custom web applications or other clients.",
        "operationId": "security-oidc-prepare-authentication",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "iss": {
                    "description": "In the case of a third party initiated single sign on, this is the issuer identifier for the OP that the RP is to send the authentication request to.\nIt cannot be specified when *realm* is specified.\nOne of *realm* or *iss* is required.",
                    "type": "string"
                  },
                  "login_hint": {
                    "description": "In the case of a third party initiated single sign on, it is a string value that is included in the authentication request as the *login_hint* parameter.\nThis parameter is not valid when *realm* is specified.",
                    "type": "string"
                  },
                  "nonce": {
                    "description": "The value used to associate a client session with an ID token and to mitigate replay attacks.\nIf the caller of the API does not provide a value, Elasticsearch will generate one with sufficient entropy and return it in the response.",
                    "type": "string"
                  },
                  "realm": {
                    "description": "The name of the OpenID Connect realm in Elasticsearch the configuration of which should be used in order to generate the authentication request.\nIt cannot be specified when *iss* is specified.\nOne of *realm* or *iss* is required.",
                    "type": "string"
                  },
                  "state": {
                    "description": "The value used to maintain state between the authentication request and the response, typically used as a Cross-Site Request Forgery mitigation.\nIf the caller of the API does not provide a value, Elasticsearch will generate one with sufficient entropy and return it in the response.",
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nonce": {
                      "type": "string"
                    },
                    "realm": {
                      "type": "string"
                    },
                    "redirect": {
                      "description": "A URI that points to the authorization endpoint of the OpenID Connect Provider with all the parameters of the authentication request as HTTP GET parameters.",
                      "type": "string"
                    },
                    "state": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "nonce",
                    "realm",
                    "redirect",
                    "state"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/_query/api_key": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Find API keys with a query",
        "description": "Get a paginated list of API keys and their information.\nYou can optionally filter the results with a query.\n\nTo use this API, you must have at least the `manage_own_api_key` or the `read_security` cluster privileges.\nIf you have only the `manage_own_api_key` privilege, this API returns only the API keys that you own.\nIf you have the `read_security`, `manage_api_key`, or greater privileges (including `manage_security`), this API returns all API keys regardless of ownership.",
        "operationId": "security-query-api-keys",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.query_api_keys#with_limited_by"
          },
          {
            "$ref": "#/components/parameters/security.query_api_keys#with_profile_uid"
          },
          {
            "$ref": "#/components/parameters/security.query_api_keys#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_api_keys"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_api_keys#200"
          }
        },
        "x-state": "Added in 7.15.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Find API keys with a query",
        "description": "Get a paginated list of API keys and their information.\nYou can optionally filter the results with a query.\n\nTo use this API, you must have at least the `manage_own_api_key` or the `read_security` cluster privileges.\nIf you have only the `manage_own_api_key` privilege, this API returns only the API keys that you own.\nIf you have the `read_security`, `manage_api_key`, or greater privileges (including `manage_security`), this API returns all API keys regardless of ownership.",
        "operationId": "security-query-api-keys-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.query_api_keys#with_limited_by"
          },
          {
            "$ref": "#/components/parameters/security.query_api_keys#with_profile_uid"
          },
          {
            "$ref": "#/components/parameters/security.query_api_keys#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_api_keys"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_api_keys#200"
          }
        },
        "x-state": "Added in 7.15.0"
      }
    },
    "/_security/_query/role": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Find roles with a query",
        "description": "Get roles in a paginated manner.\nThe role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe query roles API does not retrieve roles that are defined in roles files, nor built-in ones.\nYou can optionally filter the results with a query.\nAlso, the results can be paginated and sorted.",
        "operationId": "security-query-role",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_role"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_role#200"
          }
        },
        "x-state": "Added in 8.15.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Find roles with a query",
        "description": "Get roles in a paginated manner.\nThe role management APIs are generally the preferred way to manage roles, rather than using file-based role management.\nThe query roles API does not retrieve roles that are defined in roles files, nor built-in ones.\nYou can optionally filter the results with a query.\nAlso, the results can be paginated and sorted.",
        "operationId": "security-query-role-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_role"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_role#200"
          }
        },
        "x-state": "Added in 8.15.0"
      }
    },
    "/_security/_query/user": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Find users with a query",
        "description": "Get information for users in a paginated manner.\nYou can optionally filter the results with a query.\n\nNOTE: As opposed to the get user API, built-in users are excluded from the result.\nThis API is only for native users.",
        "operationId": "security-query-user",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.query_user#with_profile_uid"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_user"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_user#200"
          }
        },
        "x-state": "Added in 8.14.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Find users with a query",
        "description": "Get information for users in a paginated manner.\nYou can optionally filter the results with a query.\n\nNOTE: As opposed to the get user API, built-in users are excluded from the result.\nThis API is only for native users.",
        "operationId": "security-query-user-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.query_user#with_profile_uid"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_user"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_user#200"
          }
        },
        "x-state": "Added in 8.14.0"
      }
    },
    "/_security/saml/authenticate": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Authenticate SAML",
        "description": "Submit a SAML response message to Elasticsearch for consumption.\n\nNOTE: This API is intended for use by custom web applications other than Kibana.\nIf you are using Kibana, refer to the documentation for configuring SAML single-sign-on on the Elastic Stack.\n\nThe SAML message that is submitted can be:\n\n* A response to a SAML authentication request that was previously created using the SAML prepare authentication API.\n* An unsolicited SAML message in the case of an IdP-initiated single sign-on (SSO) flow.\n\nIn either case, the SAML message needs to be a base64 encoded XML document with a root element of `<Response>`.\n\nAfter successful validation, Elasticsearch responds with an Elasticsearch internal access token and refresh token that can be subsequently used for authentication.\nThis API endpoint essentially exchanges SAML responses that indicate successful authentication in the IdP for Elasticsearch access and refresh tokens, which can be used for authentication against Elasticsearch.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/saml-guide-stack.html"
        },
        "operationId": "security-saml-authenticate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "content": {
                    "description": "The SAML response as it was sent by the user's browser, usually a Base64 encoded XML document.",
                    "type": "string"
                  },
                  "ids": {
                    "$ref": "#/components/schemas/_types:Ids"
                  },
                  "realm": {
                    "description": "The name of the realm that should authenticate the SAML response. Useful in cases where many SAML realms are defined.",
                    "type": "string"
                  }
                },
                "required": [
                  "content",
                  "ids"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "access_token": {
                      "description": "The access token that was generated by Elasticsearch.",
                      "type": "string"
                    },
                    "username": {
                      "description": "The authenticated user's name.",
                      "type": "string"
                    },
                    "expires_in": {
                      "description": "The amount of time (in seconds) left until the token expires.",
                      "type": "number"
                    },
                    "refresh_token": {
                      "description": "The refresh token that was generated by Elasticsearch.",
                      "type": "string"
                    },
                    "realm": {
                      "description": "The name of the realm where the user was authenticated.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "access_token",
                    "username",
                    "expires_in",
                    "refresh_token",
                    "realm"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_security/saml/complete_logout": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Logout of SAML completely",
        "description": "Verifies the logout response sent from the SAML IdP.\n\nNOTE: This API is intended for use by custom web applications other than Kibana.\nIf you are using Kibana, refer to the documentation for configuring SAML single-sign-on on the Elastic Stack.\n\nThe SAML IdP may send a logout response back to the SP after handling the SP-initiated SAML Single Logout.\nThis API verifies the response by ensuring the content is relevant and validating its signature.\nAn empty response is returned if the verification process is successful.\nThe response can be sent by the IdP with either the HTTP-Redirect or the HTTP-Post binding.\nThe caller of this API must prepare the request accordingly so that this API can handle either of them.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/saml-guide-stack.html"
        },
        "operationId": "security-saml-complete-logout",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "realm": {
                    "description": "The name of the SAML realm in Elasticsearch for which the configuration is used to verify the logout response.",
                    "type": "string"
                  },
                  "ids": {
                    "$ref": "#/components/schemas/_types:Ids"
                  },
                  "query_string": {
                    "description": "If the SAML IdP sends the logout response with the HTTP-Redirect binding, this field must be set to the query string of the redirect URI.",
                    "type": "string"
                  },
                  "content": {
                    "description": "If the SAML IdP sends the logout response with the HTTP-Post binding, this field must be set to the value of the SAMLResponse form parameter from the logout response.",
                    "type": "string"
                  }
                },
                "required": [
                  "realm",
                  "ids"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        },
        "x-state": "Added in 7.14.0"
      }
    },
    "/_security/saml/invalidate": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Invalidate SAML",
        "description": "Submit a SAML LogoutRequest message to Elasticsearch for consumption.\n\nNOTE: This API is intended for use by custom web applications other than Kibana.\nIf you are using Kibana, refer to the documentation for configuring SAML single-sign-on on the Elastic Stack.\n\nThe logout request comes from the SAML IdP during an IdP initiated Single Logout.\nThe custom web application can use this API to have Elasticsearch process the `LogoutRequest`.\nAfter successful validation of the request, Elasticsearch invalidates the access token and refresh token that corresponds to that specific SAML principal and provides a URL that contains a SAML LogoutResponse message.\nThus the user can be redirected back to their IdP.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/saml-guide-stack.html"
        },
        "operationId": "security-saml-invalidate",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "acs": {
                    "description": "The Assertion Consumer Service URL that matches the one of the SAML realm in Elasticsearch that should be used. You must specify either this parameter or the `realm` parameter.",
                    "type": "string"
                  },
                  "query_string": {
                    "description": "The query part of the URL that the user was redirected to by the SAML IdP to initiate the Single Logout.\nThis query should include a single parameter named `SAMLRequest` that contains a SAML logout request that is deflated and Base64 encoded.\nIf the SAML IdP has signed the logout request, the URL should include two extra parameters named `SigAlg` and `Signature` that contain the algorithm used for the signature and the signature value itself.\nIn order for Elasticsearch to be able to verify the IdP's signature, the value of the `query_string` field must be an exact match to the string provided by the browser.\nThe client application must not attempt to parse or process the string in any way.",
                    "type": "string"
                  },
                  "realm": {
                    "description": "The name of the SAML realm in Elasticsearch the configuration. You must specify either this parameter or the `acs` parameter.",
                    "type": "string"
                  }
                },
                "required": [
                  "query_string"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "invalidated": {
                      "description": "The number of tokens that were invalidated as part of this logout.",
                      "type": "number"
                    },
                    "realm": {
                      "description": "The realm name of the SAML realm in Elasticsearch that authenticated the user.",
                      "type": "string"
                    },
                    "redirect": {
                      "description": "A SAML logout response as a parameter so that the user can be redirected back to the SAML IdP.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "invalidated",
                    "realm",
                    "redirect"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_security/saml/logout": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Logout of SAML",
        "description": "Submits a request to invalidate an access token and refresh token.\n\nNOTE: This API is intended for use by custom web applications other than Kibana.\nIf you are using Kibana, refer to the documentation for configuring SAML single-sign-on on the Elastic Stack.\n\nThis API invalidates the tokens that were generated for a user by the SAML authenticate API.\nIf the SAML realm in Elasticsearch is configured accordingly and the SAML IdP supports this, the Elasticsearch response contains a URL to redirect the user to the IdP that contains a SAML logout request (starting an SP-initiated SAML Single Logout).",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/saml-guide-stack.html"
        },
        "operationId": "security-saml-logout",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "description": "The access token that was returned as a response to calling the SAML authenticate API.\nAlternatively, the most recent token that was received after refreshing the original one by using a `refresh_token`.",
                    "type": "string"
                  },
                  "refresh_token": {
                    "description": "The refresh token that was returned as a response to calling the SAML authenticate API.\nAlternatively, the most recent refresh token that was received after refreshing the original access token.",
                    "type": "string"
                  }
                },
                "required": [
                  "token"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "redirect": {
                      "description": "A URL that contains a SAML logout request as a parameter.\nYou can use this URL to be redirected back to the SAML IdP and to initiate Single Logout.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "redirect"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_security/saml/prepare": {
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Prepare SAML authentication",
        "description": "Create a SAML authentication request (`<AuthnRequest>`) as a URL string based on the configuration of the respective SAML realm in Elasticsearch.\n\nNOTE: This API is intended for use by custom web applications other than Kibana.\nIf you are using Kibana, refer to the documentation for configuring SAML single-sign-on on the Elastic Stack.\n\nThis API returns a URL pointing to the SAML Identity Provider.\nYou can use the URL to redirect the browser of the user in order to continue the authentication process.\nThe URL includes a single parameter named `SAMLRequest`, which contains a SAML Authentication request that is deflated and Base64 encoded.\nIf the configuration dictates that SAML authentication requests should be signed, the URL has two extra parameters named `SigAlg` and `Signature`.\nThese parameters contain the algorithm used for the signature and the signature value itself.\nIt also returns a random string that uniquely identifies this SAML Authentication request.\nThe caller of this API needs to store this identifier as it needs to be used in a following step of the authentication process.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/saml-guide-stack.html"
        },
        "operationId": "security-saml-prepare-authentication",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "acs": {
                    "description": "The Assertion Consumer Service URL that matches the one of the SAML realms in Elasticsearch.\nThe realm is used to generate the authentication request. You must specify either this parameter or the `realm` parameter.",
                    "type": "string"
                  },
                  "realm": {
                    "description": "The name of the SAML realm in Elasticsearch for which the configuration is used to generate the authentication request.\nYou must specify either this parameter or the `acs` parameter.",
                    "type": "string"
                  },
                  "relay_state": {
                    "description": "A string that will be included in the redirect URL that this API returns as the `RelayState` query parameter.\nIf the Authentication Request is signed, this value is used as part of the signature computation.",
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "realm": {
                      "description": "The name of the Elasticsearch realm that was used to construct the authentication request.",
                      "type": "string"
                    },
                    "redirect": {
                      "description": "The URL to redirect the user to.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "id",
                    "realm",
                    "redirect"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_security/saml/metadata/{realm_name}": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Create SAML service provider metadata",
        "description": "Generate SAML metadata for a SAML 2.0 Service Provider.\n\nThe SAML 2.0 specification provides a mechanism for Service Providers to describe their capabilities and configuration using a metadata file.\nThis API generates Service Provider metadata based on the configuration of a SAML realm in Elasticsearch.",
        "operationId": "security-saml-service-provider-metadata",
        "parameters": [
          {
            "in": "path",
            "name": "realm_name",
            "description": "The name of the SAML realm in Elasticsearch.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "metadata": {
                      "description": "An XML string that contains a SAML Service Provider's metadata for the realm.",
                      "type": "string"
                    }
                  },
                  "required": [
                    "metadata"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.11.0"
      }
    },
    "/_security/profile/_suggest": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Suggest a user profile",
        "description": "Get suggestions for user profiles that match specified search criteria.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.",
        "operationId": "security-suggest-user-profiles",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.suggest_user_profiles#data"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.suggest_user_profiles"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.suggest_user_profiles#200"
          }
        },
        "x-state": "Added in 8.2.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Suggest a user profile",
        "description": "Get suggestions for user profiles that match specified search criteria.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.",
        "operationId": "security-suggest-user-profiles-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.suggest_user_profiles#data"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.suggest_user_profiles"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.suggest_user_profiles#200"
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_security/api_key/{id}": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Update an API key",
        "description": "Update attributes of an existing API key.\nThis API supports updates to an API key's access scope, expiration, and metadata.\n\nTo use this API, you must have at least the `manage_own_api_key` cluster privilege.\nUsers can only update API keys that they created or that were granted to them.\nTo update another userâ€™s API key, use the `run_as` feature to submit a request on behalf of another user.\n\nIMPORTANT: It's not possible to use an API key as the authentication credential for this API. The owner userâ€™s credentials are required.\n\nUse this API to update API keys created by the create API key or grant API Key APIs.\nIf you need to apply the same update to many API keys, you can use the bulk update API keys API to reduce overhead.\nIt's not possible to update expired API keys or API keys that have been invalidated by the invalidate API key API.\n\nThe access scope of an API key is derived from the `role_descriptors` you specify in the request and a snapshot of the owner user's permissions at the time of the request.\nThe snapshot of the owner's permissions is updated automatically on every call.\n\nIMPORTANT: If you don't specify `role_descriptors` in the request, a call to this API might still change the API key's access scope.\nThis change can occur if the owner user's permissions have changed since the API key was created or last modified.",
        "operationId": "security-update-api-key",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the API key to update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "role_descriptors": {
                    "description": "The role descriptors to assign to this API key.\nThe API key's effective permissions are an intersection of its assigned privileges and the point in time snapshot of permissions of the owner user.\nYou can assign new privileges by specifying them in this parameter.\nTo remove assigned privileges, you can supply an empty `role_descriptors` parameter, that is to say, an empty object `{}`.\nIf an API key has no assigned privileges, it inherits the owner user's full permissions.\nThe snapshot of the owner's permissions is always updated, whether you supply the `role_descriptors` parameter or not.\nThe structure of a role descriptor is the same as the request for the create API keys API.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/security._types:RoleDescriptor"
                    }
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "expiration": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "updated": {
                      "description": "If `true`, the API key was updated.\nIf `false`, the API key didn't change because no change was detected.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "updated"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.4.0"
      }
    },
    "/_security/cross_cluster/api_key/{id}": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Update a cross-cluster API key",
        "description": "Update the attributes of an existing cross-cluster API key, which is used for API key based remote cluster access.\n\nTo use this API, you must have at least the `manage_security` cluster privilege.\nUsers can only update API keys that they created.\nTo update another user's API key, use the `run_as` feature to submit a request on behalf of another user.\n\nIMPORTANT: It's not possible to use an API key as the authentication credential for this API.\nTo update an API key, the owner user's credentials are required.\n\nIt's not possible to update expired API keys, or API keys that have been invalidated by the invalidate API key API.\n\nThis API supports updates to an API key's access scope, metadata, and expiration.\nThe owner user's information, such as the `username` and `realm`, is also updated automatically on every call.\n\nNOTE: This API cannot update REST API keys, which should be updated by either the update API key or bulk update API keys API.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/remote-clusters-api-key.html"
        },
        "operationId": "security-update-cross-cluster-api-key",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the cross-cluster API key to update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access": {
                    "$ref": "#/components/schemas/security._types:Access"
                  },
                  "expiration": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  }
                },
                "required": [
                  "access"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "updated": {
                      "description": "If `true`, the API key was updated.\nIf `false`, the API key didnâ€™t change because no change was detected.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "updated"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/profile/{uid}/_data": {
      "put": {
        "tags": [
          "security"
        ],
        "summary": "Update user profile data",
        "description": "Update specific data for the user profile that is associated with a unique ID.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nTo use this API, you must have one of the following privileges:\n\n* The `manage_user_profile` cluster privilege.\n* The `update_profile_data` global privilege for the namespaces that are referenced in the request.\n\nThis API updates the `labels` and `data` fields of an existing user profile document with JSON objects.\nNew keys and their values are added to the profile document and conflicting keys are replaced by data that's included in the request.\n\nFor both labels and data, content is namespaced by the top-level fields.\nThe `update_profile_data` global privilege grants privileges for updating only the allowed namespaces.",
        "operationId": "security-update-user-profile-data",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#uid"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.update_user_profile_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.update_user_profile_data#200"
          }
        },
        "x-state": "Added in 8.2.0"
      },
      "post": {
        "tags": [
          "security"
        ],
        "summary": "Update user profile data",
        "description": "Update specific data for the user profile that is associated with a unique ID.\n\nNOTE: The user profile feature is designed only for use by Kibana and Elastic's Observability, Enterprise Search, and Elastic Security solutions.\nIndividual users and external applications should not call this API directly.\nElastic reserves the right to change or remove this feature in future releases without prior notice.\n\nTo use this API, you must have one of the following privileges:\n\n* The `manage_user_profile` cluster privilege.\n* The `update_profile_data` global privilege for the namespaces that are referenced in the request.\n\nThis API updates the `labels` and `data` fields of an existing user profile document with JSON objects.\nNew keys and their values are added to the profile document and conflicting keys are replaced by data that's included in the request.\n\nFor both labels and data, content is namespaced by the top-level fields.\nThe `update_profile_data` global privilege grants privileges for updating only the allowed namespaces.",
        "operationId": "security-update-user-profile-data-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#uid"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.update_user_profile_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.update_user_profile_data#200"
          }
        },
        "x-state": "Added in 8.2.0"
      }
    },
    "/_nodes/{node_id}/shutdown": {
      "get": {
        "tags": [
          "shutdown"
        ],
        "summary": "Get the shutdown status",
        "description": "Get information about nodes that are ready to be shut down, have shut down preparations still in progress, or have stalled.\nThe API returns status information for each part of the shut down process.\n\nNOTE: This feature is designed for indirect use by Elasticsearch Service, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.\n\nIf the operator privileges feature is enabled, you must be an operator to use this API.",
        "operationId": "shutdown-get-node-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/shutdown.get_node#node_id"
          },
          {
            "$ref": "#/components/parameters/shutdown.get_node#master_timeout"
          },
          {
            "$ref": "#/components/parameters/shutdown.get_node#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/shutdown.get_node#200"
          }
        },
        "x-state": "Added in 7.13.0"
      },
      "put": {
        "tags": [
          "shutdown"
        ],
        "summary": "Prepare a node to be shut down",
        "description": "NOTE: This feature is designed for indirect use by Elastic Cloud, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.\n\nIf you specify a node that is offline, it will be prepared for shut down when it rejoins the cluster.\n\nIf the operator privileges feature is enabled, you must be an operator to use this API.\n\nThe API migrates ongoing tasks and index shards to other nodes as needed to prepare a node to be restarted or shut down and removed from the cluster.\nThis ensures that Elasticsearch can be stopped safely with minimal disruption to the cluster.\n\nYou must specify the type of shutdown: `restart`, `remove`, or `replace`.\nIf a node is already being prepared for shutdown, you can use this API to change the shutdown type.\n\nIMPORTANT: This API does NOT terminate the Elasticsearch process.\nMonitor the node shutdown status to determine when it is safe to stop Elasticsearch.",
        "operationId": "shutdown-put-node",
        "parameters": [
          {
            "in": "path",
            "name": "node_id",
            "description": "The node identifier.\nThis parameter is not validated against the cluster's active nodes.\nThis enables you to register a node for shut down while it is offline.\nNo error is thrown if you specify an invalid node ID.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:NodeId"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "type": {
                    "$ref": "#/components/schemas/shutdown._types:Type"
                  },
                  "reason": {
                    "description": "A human-readable reason that the node is being shut down.\nThis field provides information for other cluster operators; it does not affect the shut down process.",
                    "type": "string"
                  },
                  "allocation_delay": {
                    "description": "Only valid if type is restart.\nControls how long Elasticsearch will wait for the node to restart and join the cluster before reassigning its shards to other nodes.\nThis works the same as delaying allocation with the index.unassigned.node_left.delayed_timeout setting.\nIf you specify both a restart allocation delay and an index-level allocation delay, the longer of the two is used.",
                    "type": "string"
                  },
                  "target_node_name": {
                    "description": "Only valid if type is replace.\nSpecifies the name of the node that is replacing the node being shut down.\nShards from the shut down node are only allowed to be allocated to the target node, and no other data will be allocated to the target node.\nDuring relocation of data certain allocation rules are ignored, such as disk watermarks or user attribute filtering rules.",
                    "type": "string"
                  }
                },
                "required": [
                  "type",
                  "reason"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      },
      "delete": {
        "tags": [
          "shutdown"
        ],
        "summary": "Cancel node shutdown preparations",
        "description": "Remove a node from the shutdown list so it can resume normal operations.\nYou must explicitly clear the shutdown request when a node rejoins the cluster or when a node has permanently left the cluster.\nShutdown requests are never removed automatically by Elasticsearch.\n\nNOTE: This feature is designed for indirect use by Elastic Cloud, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes.\nDirect use is not supported.\n\nIf the operator privileges feature is enabled, you must be an operator to use this API.",
        "operationId": "shutdown-delete-node",
        "parameters": [
          {
            "in": "path",
            "name": "node_id",
            "description": "The node id of node to be removed from the shutdown state",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:NodeId"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:TimeUnit"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_nodes/shutdown": {
      "get": {
        "tags": [
          "shutdown"
        ],
        "summary": "Get the shutdown status",
        "description": "Get information about nodes that are ready to be shut down, have shut down preparations still in progress, or have stalled.\nThe API returns status information for each part of the shut down process.\n\nNOTE: This feature is designed for indirect use by Elasticsearch Service, Elastic Cloud Enterprise, and Elastic Cloud on Kubernetes. Direct use is not supported.\n\nIf the operator privileges feature is enabled, you must be an operator to use this API.",
        "operationId": "shutdown-get-node",
        "parameters": [
          {
            "$ref": "#/components/parameters/shutdown.get_node#master_timeout"
          },
          {
            "$ref": "#/components/parameters/shutdown.get_node#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/shutdown.get_node#200"
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_ingest/_simulate": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate data ingestion",
        "description": "Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.\n\nThis API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.\n\nThe API runs the default and final pipeline for that index against a set of documents provided in the body of the request.\nIf a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.\nNo data is indexed into Elasticsearch.\nInstead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.\nThe transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.\n\nThis API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.\nThe simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.\n\nBy default, the pipeline definitions that are currently in the system are used.\nHowever, you can supply substitute pipeline definitions in the body of the request.\nThese will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.",
        "operationId": "simulate-ingest",
        "parameters": [
          {
            "$ref": "#/components/parameters/simulate.ingest#pipeline"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/simulate.ingest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/simulate.ingest#200"
          }
        },
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate data ingestion",
        "description": "Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.\n\nThis API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.\n\nThe API runs the default and final pipeline for that index against a set of documents provided in the body of the request.\nIf a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.\nNo data is indexed into Elasticsearch.\nInstead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.\nThe transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.\n\nThis API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.\nThe simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.\n\nBy default, the pipeline definitions that are currently in the system are used.\nHowever, you can supply substitute pipeline definitions in the body of the request.\nThese will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.",
        "operationId": "simulate-ingest-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/simulate.ingest#pipeline"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/simulate.ingest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/simulate.ingest#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_ingest/{index}/_simulate": {
      "get": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate data ingestion",
        "description": "Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.\n\nThis API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.\n\nThe API runs the default and final pipeline for that index against a set of documents provided in the body of the request.\nIf a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.\nNo data is indexed into Elasticsearch.\nInstead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.\nThe transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.\n\nThis API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.\nThe simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.\n\nBy default, the pipeline definitions that are currently in the system are used.\nHowever, you can supply substitute pipeline definitions in the body of the request.\nThese will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.",
        "operationId": "simulate-ingest-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/simulate.ingest#index"
          },
          {
            "$ref": "#/components/parameters/simulate.ingest#pipeline"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/simulate.ingest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/simulate.ingest#200"
          }
        },
        "x-state": "Technical preview"
      },
      "post": {
        "tags": [
          "ingest"
        ],
        "summary": "Simulate data ingestion",
        "description": "Run ingest pipelines against a set of provided documents, optionally with substitute pipeline definitions, to simulate ingesting data into an index.\n\nThis API is meant to be used for troubleshooting or pipeline development, as it does not actually index any data into Elasticsearch.\n\nThe API runs the default and final pipeline for that index against a set of documents provided in the body of the request.\nIf a pipeline contains a reroute processor, it follows that reroute processor to the new index, running that index's pipelines as well the same way that a non-simulated ingest would.\nNo data is indexed into Elasticsearch.\nInstead, the transformed document is returned, along with the list of pipelines that have been run and the name of the index where the document would have been indexed if this were not a simulation.\nThe transformed document is validated against the mappings that would apply to this index, and any validation error is reported in the result.\n\nThis API differs from the simulate pipeline API in that you specify a single pipeline for that API, and it runs only that one pipeline.\nThe simulate pipeline API is more useful for developing a single pipeline, while the simulate ingest API is more useful for troubleshooting the interaction of the various pipelines that get applied when ingesting into an index.\n\nBy default, the pipeline definitions that are currently in the system are used.\nHowever, you can supply substitute pipeline definitions in the body of the request.\nThese will be used in place of the pipeline definitions that are already in the system. This can be used to replace existing pipeline definitions or to create new ones. The pipeline substitutions are used only within this request.",
        "operationId": "simulate-ingest-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/simulate.ingest#index"
          },
          {
            "$ref": "#/components/parameters/simulate.ingest#pipeline"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/simulate.ingest"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/simulate.ingest#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_slm/policy/{policy_id}": {
      "get": {
        "tags": [
          "slm"
        ],
        "summary": "Get policy information",
        "description": "Get snapshot lifecycle policy definitions and information about the latest snapshot attempts.",
        "operationId": "slm-get-lifecycle",
        "parameters": [
          {
            "$ref": "#/components/parameters/slm.get_lifecycle#policy_id"
          },
          {
            "$ref": "#/components/parameters/slm.get_lifecycle#master_timeout"
          },
          {
            "$ref": "#/components/parameters/slm.get_lifecycle#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/slm.get_lifecycle#200"
          }
        },
        "x-state": "Added in 7.4.0"
      },
      "put": {
        "tags": [
          "slm"
        ],
        "summary": "Create or update a policy",
        "description": "Create or update a snapshot lifecycle policy.\nIf the policy already exists, this request increments the policy version.\nOnly the latest version of a policy is stored.",
        "operationId": "slm-put-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "policy_id",
            "description": "The identifier for the snapshot lifecycle policy you want to create or update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "config": {
                    "$ref": "#/components/schemas/slm._types:Configuration"
                  },
                  "name": {
                    "$ref": "#/components/schemas/_types:Name"
                  },
                  "repository": {
                    "description": "Repository used to store snapshots created by this policy. This repository must exist prior to the policyâ€™s creation. You can create a repository using the snapshot repository API.",
                    "type": "string"
                  },
                  "retention": {
                    "$ref": "#/components/schemas/slm._types:Retention"
                  },
                  "schedule": {
                    "$ref": "#/components/schemas/watcher._types:CronExpression"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.4.0"
      },
      "delete": {
        "tags": [
          "slm"
        ],
        "summary": "Delete a policy",
        "description": "Delete a snapshot lifecycle policy definition.\nThis operation prevents any future snapshots from being taken but does not cancel in-progress snapshots or remove previously-taken snapshots.",
        "operationId": "slm-delete-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "policy_id",
            "description": "The id of the snapshot lifecycle policy to remove",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.4.0"
      }
    },
    "/_slm/policy/{policy_id}/_execute": {
      "put": {
        "tags": [
          "slm"
        ],
        "summary": "Run a policy",
        "description": "Immediately create a snapshot according to the snapshot lifecycle policy without waiting for the scheduled time.\nThe snapshot policy is normally applied according to its schedule, but you might want to manually run a policy before performing an upgrade or other maintenance.",
        "operationId": "slm-execute-lifecycle",
        "parameters": [
          {
            "in": "path",
            "name": "policy_id",
            "description": "The id of the snapshot lifecycle policy to be executed",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "snapshot_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    }
                  },
                  "required": [
                    "snapshot_name"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.4.0"
      }
    },
    "/_slm/_execute_retention": {
      "post": {
        "tags": [
          "slm"
        ],
        "summary": "Run a retention policy",
        "description": "Manually apply the retention policy to force immediate removal of snapshots that are expired according to the snapshot lifecycle policy retention rules.\nThe retention policy is normally applied according to its schedule.",
        "operationId": "slm-execute-retention",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_slm/policy": {
      "get": {
        "tags": [
          "slm"
        ],
        "summary": "Get policy information",
        "description": "Get snapshot lifecycle policy definitions and information about the latest snapshot attempts.",
        "operationId": "slm-get-lifecycle-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/slm.get_lifecycle#master_timeout"
          },
          {
            "$ref": "#/components/parameters/slm.get_lifecycle#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/slm.get_lifecycle#200"
          }
        },
        "x-state": "Added in 7.4.0"
      }
    },
    "/_slm/stats": {
      "get": {
        "tags": [
          "slm"
        ],
        "summary": "Get snapshot lifecycle management statistics",
        "description": "Get global and policy-level statistics about actions taken by snapshot lifecycle management.",
        "operationId": "slm-get-stats",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "retention_deletion_time": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "retention_deletion_time_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "retention_failed": {
                      "type": "number"
                    },
                    "retention_runs": {
                      "type": "number"
                    },
                    "retention_timed_out": {
                      "type": "number"
                    },
                    "total_snapshots_deleted": {
                      "type": "number"
                    },
                    "total_snapshot_deletion_failures": {
                      "type": "number"
                    },
                    "total_snapshots_failed": {
                      "type": "number"
                    },
                    "total_snapshots_taken": {
                      "type": "number"
                    },
                    "policy_stats": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "retention_deletion_time",
                    "retention_deletion_time_millis",
                    "retention_failed",
                    "retention_runs",
                    "retention_timed_out",
                    "total_snapshots_deleted",
                    "total_snapshot_deletion_failures",
                    "total_snapshots_failed",
                    "total_snapshots_taken",
                    "policy_stats"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_slm/status": {
      "get": {
        "tags": [
          "slm"
        ],
        "summary": "Get the snapshot lifecycle management status",
        "operationId": "slm-get-status",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "operation_mode": {
                      "$ref": "#/components/schemas/_types:LifecycleOperationMode"
                    }
                  },
                  "required": [
                    "operation_mode"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.6.0"
      }
    },
    "/_slm/start": {
      "post": {
        "tags": [
          "slm"
        ],
        "summary": "Start snapshot lifecycle management",
        "description": "Snapshot lifecycle management (SLM) starts automatically when a cluster is formed.\nManually starting SLM is necessary only if it has been stopped using the stop SLM API.",
        "operationId": "slm-start",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.6.0"
      }
    },
    "/_slm/stop": {
      "post": {
        "tags": [
          "slm"
        ],
        "summary": "Stop snapshot lifecycle management",
        "description": "Stop all snapshot lifecycle management (SLM) operations and the SLM plugin.\nThis API is useful when you are performing maintenance on a cluster and need to prevent SLM from performing any actions on your data streams or indices.\nStopping SLM does not stop any snapshots that are in progress.\nYou can manually trigger snapshots with the run snapshot lifecycle policy API even if SLM is stopped.\n\nThe API returns a response as soon as the request is acknowledged, but the plugin might continue to run until in-progress operations complete and it can be safely stopped.\nUse the get snapshot lifecycle management status API to see if SLM is running.",
        "operationId": "slm-stop",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.6.0"
      }
    },
    "/_snapshot/{repository}/_cleanup": {
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Clean up the snapshot repository",
        "description": "Trigger the review of the contents of a snapshot repository and delete any stale data not referenced by existing snapshots.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-register-repository.html#snapshots-repository-cleanup"
        },
        "operationId": "snapshot-cleanup-repository",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "Snapshot repository to clean up.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "results": {
                      "$ref": "#/components/schemas/snapshot.cleanup_repository:CleanupRepositoryResults"
                    }
                  },
                  "required": [
                    "results"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.4.0"
      }
    },
    "/_snapshot/{repository}/{snapshot}/_clone/{target_snapshot}": {
      "put": {
        "tags": [
          "snapshot"
        ],
        "summary": "Clone a snapshot",
        "description": "Clone part of all of a snapshot into another snapshot in the same repository.",
        "operationId": "snapshot-clone",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "A repository name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot",
            "description": "The name of the snapshot to clone from",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "target_snapshot",
            "description": "The name of the cloned snapshot to create",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "indices": {
                    "type": "string"
                  }
                },
                "required": [
                  "indices"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.10.0"
      }
    },
    "/_snapshot/{repository}/{snapshot}": {
      "get": {
        "tags": [
          "snapshot"
        ],
        "summary": "Get snapshot information",
        "operationId": "snapshot-get",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "Comma-separated list of snapshot repository names used to limit the request. Wildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot",
            "description": "Comma-separated list of snapshot names to retrieve. Also accepts wildcards (*).\n- To get information about all snapshots in a registered repository, use a wildcard (*) or _all.\n- To get information about any snapshots that are currently running, use _current.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If false, the request returns an error for any snapshots that are unavailable.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "verbose",
            "description": "If true, returns additional information about each snapshot such as the version of Elasticsearch which took the snapshot, the start and end times of the snapshot, and the number of shards snapshotted.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "index_details",
            "description": "If true, returns additional information about each index in the snapshot comprising the number of shards in the index, the total size of the index in bytes, and the maximum number of segments per shard in the index. Defaults to false, meaning that this information is omitted.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "index_names",
            "description": "If true, returns the name of each index in each snapshot.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_repository",
            "description": "If true, returns the repository name in each snapshot.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "sort",
            "description": "Allows setting a sort order for the result. Defaults to start_time, i.e. sorting by snapshot start time stamp.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/snapshot._types:SnapshotSort"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Maximum number of snapshots to return. Defaults to 0 which means return all that match the request without limit.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "order",
            "description": "Sort order. Valid values are asc for ascending and desc for descending order. Defaults to asc, meaning ascending order.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SortOrder"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "after",
            "description": "Offset identifier to start pagination from as returned by the next field in the response body.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "offset",
            "description": "Numeric offset to start pagination from based on the snapshots matching this request. Using a non-zero value for this parameter is mutually exclusive with using the after parameter. Defaults to 0.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from_sort_value",
            "description": "Value of the current sort column at which to start retrieval. Can either be a string snapshot- or repository name when sorting by snapshot or repository name, a millisecond time value or a number when sorting by index- or shard count.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "slm_policy_filter",
            "description": "Filter snapshots by a comma-separated list of SLM policy names that snapshots belong to. Also accepts wildcards (*) and combinations of wildcards followed by exclude patterns starting with -. To include snapshots not created by an SLM policy you can use the special pattern _none that will match all snapshots without an SLM policy.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "responses": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/snapshot.get:SnapshotResponseItem"
                      }
                    },
                    "snapshots": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/snapshot._types:SnapshotInfo"
                      }
                    },
                    "total": {
                      "description": "The total number of snapshots that match the request when ignoring size limit or after query parameter.",
                      "type": "number"
                    },
                    "remaining": {
                      "description": "The number of remaining snapshots that were not returned due to size limits and that can be fetched by additional requests using the next field value.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "total",
                    "remaining"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 0.0.0"
      },
      "put": {
        "tags": [
          "snapshot"
        ],
        "summary": "Create a snapshot",
        "description": "Take a snapshot of a cluster or of data streams and indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-take-snapshot.html"
        },
        "operationId": "snapshot-create",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.create#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.create#snapshot"
          },
          {
            "$ref": "#/components/parameters/snapshot.create#master_timeout"
          },
          {
            "$ref": "#/components/parameters/snapshot.create#wait_for_completion"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/snapshot.create"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.create#200"
          }
        },
        "x-state": "Added in 0.0.0"
      },
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Create a snapshot",
        "description": "Take a snapshot of a cluster or of data streams and indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-take-snapshot.html"
        },
        "operationId": "snapshot-create-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.create#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.create#snapshot"
          },
          {
            "$ref": "#/components/parameters/snapshot.create#master_timeout"
          },
          {
            "$ref": "#/components/parameters/snapshot.create#wait_for_completion"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/snapshot.create"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.create#200"
          }
        },
        "x-state": "Added in 0.0.0"
      },
      "delete": {
        "tags": [
          "snapshot"
        ],
        "summary": "Delete snapshots",
        "operationId": "snapshot-delete",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "A repository name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot",
            "description": "A comma-separated list of snapshot names",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_snapshot/{repository}": {
      "get": {
        "tags": [
          "snapshot"
        ],
        "summary": "Get snapshot repository information",
        "operationId": "snapshot-get-repository-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.get_repository#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.get_repository#local"
          },
          {
            "$ref": "#/components/parameters/snapshot.get_repository#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.get_repository#200"
          }
        },
        "x-state": "Added in 0.0.0"
      },
      "put": {
        "tags": [
          "snapshot"
        ],
        "summary": "Create or update a snapshot repository",
        "description": "IMPORTANT: If you are migrating searchable snapshots, the repository name must be identical in the source and destination clusters.\nTo register a snapshot repository, the cluster's global metadata must be writeable.\nEnsure there are no cluster blocks (for example, `cluster.blocks.read_only` and `clsuter.blocks.read_only_allow_delete` settings) that prevent write access.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-register-repository.html"
        },
        "operationId": "snapshot-create-repository",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.create_repository#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.create_repository#master_timeout"
          },
          {
            "$ref": "#/components/parameters/snapshot.create_repository#timeout"
          },
          {
            "$ref": "#/components/parameters/snapshot.create_repository#verify"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/snapshot.create_repository"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.create_repository#200"
          }
        },
        "x-state": "Added in 0.0.0"
      },
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Create or update a snapshot repository",
        "description": "IMPORTANT: If you are migrating searchable snapshots, the repository name must be identical in the source and destination clusters.\nTo register a snapshot repository, the cluster's global metadata must be writeable.\nEnsure there are no cluster blocks (for example, `cluster.blocks.read_only` and `clsuter.blocks.read_only_allow_delete` settings) that prevent write access.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-register-repository.html"
        },
        "operationId": "snapshot-create-repository-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.create_repository#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.create_repository#master_timeout"
          },
          {
            "$ref": "#/components/parameters/snapshot.create_repository#timeout"
          },
          {
            "$ref": "#/components/parameters/snapshot.create_repository#verify"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/snapshot.create_repository"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.create_repository#200"
          }
        },
        "x-state": "Added in 0.0.0"
      },
      "delete": {
        "tags": [
          "snapshot"
        ],
        "summary": "Delete snapshot repositories",
        "description": "When a repository is unregistered, Elasticsearch removes only the reference to the location where the repository is storing the snapshots.\nThe snapshots themselves are left untouched and in place.",
        "operationId": "snapshot-delete-repository",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "Name of the snapshot repository to unregister. Wildcard (`*`) patterns are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 0.0.0"
      }
    },
    "/_snapshot": {
      "get": {
        "tags": [
          "snapshot"
        ],
        "summary": "Get snapshot repository information",
        "operationId": "snapshot-get-repository",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.get_repository#local"
          },
          {
            "$ref": "#/components/parameters/snapshot.get_repository#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.get_repository#200"
          }
        },
        "x-state": "Added in 0.0.0"
      }
    },
    "/_snapshot/{repository}/_analyze": {
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Analyze a snapshot repository",
        "description": "Analyze the performance characteristics and any incorrect behaviour found in a repository.\n\nThe response exposes implementation details of the analysis which may change from version to version.\nThe response body format is therefore not considered stable and may be different in newer versions.\n\nThere are a large number of third-party storage systems available, not all of which are suitable for use as a snapshot repository by Elasticsearch.\nSome storage systems behave incorrectly, or perform poorly, especially when accessed concurrently by multiple clients as the nodes of an Elasticsearch cluster do. This API performs a collection of read and write operations on your repository which are designed to detect incorrect behaviour and to measure the performance characteristics of your storage system.\n\nThe default values for the parameters are deliberately low to reduce the impact of running an analysis inadvertently and to provide a sensible starting point for your investigations.\nRun your first analysis with the default parameter values to check for simple problems.\nIf successful, run a sequence of increasingly large analyses until you encounter a failure or you reach a `blob_count` of at least `2000`, a `max_blob_size` of at least `2gb`, a `max_total_data_size` of at least `1tb`, and a `register_operation_count` of at least `100`.\nAlways specify a generous timeout, possibly `1h` or longer, to allow time for each analysis to run to completion.\nPerform the analyses using a multi-node cluster of a similar size to your production cluster so that it can detect any problems that only arise when the repository is accessed by many nodes at once.\n\nIf the analysis fails, Elasticsearch detected that your repository behaved unexpectedly.\nThis usually means you are using a third-party storage system with an incorrect or incompatible implementation of the API it claims to support.\nIf so, this storage system is not suitable for use as a snapshot repository.\nYou will need to work with the supplier of your storage system to address the incompatibilities that Elasticsearch detects.\n\nIf the analysis is successful, the API returns details of the testing process, optionally including how long each operation took.\nYou can use this information to determine the performance of your storage system.\nIf any operation fails or returns an incorrect result, the API returns an error.\nIf the API returns an error, it may not have removed all the data it wrote to the repository.\nThe error will indicate the location of any leftover data and this path is also recorded in the Elasticsearch logs.\nYou should verify that this location has been cleaned up correctly.\nIf there is still leftover data at the specified location, you should manually remove it.\n\nIf the connection from your client to Elasticsearch is closed while the client is waiting for the result of the analysis, the test is cancelled.\nSome clients are configured to close their connection if no response is received within a certain timeout.\nAn analysis takes a long time to complete so you might need to relax any such client-side timeouts.\nOn cancellation the analysis attempts to clean up the data it was writing, but it may not be able to remove it all.\nThe path to the leftover data is recorded in the Elasticsearch logs.\nYou should verify that this location has been cleaned up correctly.\nIf there is still leftover data at the specified location, you should manually remove it.\n\nIf the analysis is successful then it detected no incorrect behaviour, but this does not mean that correct behaviour is guaranteed.\nThe analysis attempts to detect common bugs but it does not offer 100% coverage.\nAdditionally, it does not test the following:\n\n* Your repository must perform durable writes. Once a blob has been written it must remain in place until it is deleted, even after a power loss or similar disaster.\n* Your repository must not suffer from silent data corruption. Once a blob has been written, its contents must remain unchanged until it is deliberately modified or deleted.\n* Your repository must behave correctly even if connectivity from the cluster is disrupted. Reads and writes may fail in this case, but they must not return incorrect results.\n\nIMPORTANT: An analysis writes a substantial amount of data to your repository and then reads it back again.\nThis consumes bandwidth on the network between the cluster and the repository, and storage space and I/O bandwidth on the repository itself.\nYou must ensure this load does not affect other users of these systems.\nAnalyses respect the repository settings `max_snapshot_bytes_per_sec` and `max_restore_bytes_per_sec` if available and the cluster setting `indices.recovery.max_bytes_per_sec` which you can use to limit the bandwidth they consume.\n\nNOTE: This API is intended for exploratory use by humans. You should expect the request parameters and the response format to vary in future versions.\n\nNOTE: Different versions of Elasticsearch may perform different checks for repository compatibility, with newer versions typically being stricter than older ones.\nA storage system that passes repository analysis with one version of Elasticsearch may fail with a different version.\nThis indicates it behaves incorrectly in ways that the former version did not detect.\nYou must work with the supplier of your storage system to address the incompatibilities detected by the repository analysis API in any version of Elasticsearch.\n\nNOTE: This API may not work correctly in a mixed-version cluster.\n\n*Implementation details*\n\nNOTE: This section of documentation describes how the repository analysis API works in this version of Elasticsearch, but you should expect the implementation to vary between versions. The request parameters and response format depend on details of the implementation so may also be different in newer versions.\n\nThe analysis comprises a number of blob-level tasks, as set by the `blob_count` parameter and a number of compare-and-exchange operations on linearizable registers, as set by the `register_operation_count` parameter.\nThese tasks are distributed over the data and master-eligible nodes in the cluster for execution.\n\nFor most blob-level tasks, the executing node first writes a blob to the repository and then instructs some of the other nodes in the cluster to attempt to read the data it just wrote.\nThe size of the blob is chosen randomly, according to the `max_blob_size` and `max_total_data_size` parameters.\nIf any of these reads fails then the repository does not implement the necessary read-after-write semantics that Elasticsearch requires.\n\nFor some blob-level tasks, the executing node will instruct some of its peers to attempt to read the data before the writing process completes.\nThese reads are permitted to fail, but must not return partial data.\nIf any read returns partial data then the repository does not implement the necessary atomicity semantics that Elasticsearch requires.\n\nFor some blob-level tasks, the executing node will overwrite the blob while its peers are reading it.\nIn this case the data read may come from either the original or the overwritten blob, but the read operation must not return partial data or a mix of data from the two blobs.\nIf any of these reads returns partial data or a mix of the two blobs then the repository does not implement the necessary atomicity semantics that Elasticsearch requires for overwrites.\n\nThe executing node will use a variety of different methods to write the blob.\nFor instance, where applicable, it will use both single-part and multi-part uploads.\nSimilarly, the reading nodes will use a variety of different methods to read the data back again.\nFor instance they may read the entire blob from start to end or may read only a subset of the data.\n\nFor some blob-level tasks, the executing node will cancel the write before it is complete.\nIn this case, it still instructs some of the other nodes in the cluster to attempt to read the blob but all of these reads must fail to find the blob.\n\nLinearizable registers are special blobs that Elasticsearch manipulates using an atomic compare-and-exchange operation.\nThis operation ensures correct and strongly-consistent behavior even when the blob is accessed by multiple nodes at the same time.\nThe detailed implementation of the compare-and-exchange operation on linearizable registers varies by repository type.\nRepository analysis verifies that that uncontended compare-and-exchange operations on a linearizable register blob always succeed.\nRepository analysis also verifies that contended operations either succeed or report the contention but do not return incorrect results.\nIf an operation fails due to contention, Elasticsearch retries the operation until it succeeds.\nMost of the compare-and-exchange operations performed by repository analysis atomically increment a counter which is represented as an 8-byte blob.\nSome operations also verify the behavior on small blobs with sizes other than 8 bytes.",
        "operationId": "snapshot-repository-analyze",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "The name of the repository.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "blob_count",
            "description": "The total number of blobs to write to the repository during the test.\nFor realistic experiments, you should set it to at least `2000`.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "concurrency",
            "description": "The number of operations to run concurrently during the test.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "detailed",
            "description": "Indicates whether to return detailed results, including timing information for every operation performed during the analysis.\nIf false, it returns only a summary of the analysis.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "early_read_node_count",
            "description": "The number of nodes on which to perform an early read operation while writing each blob.\nEarly read operations are only rarely performed.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_blob_size",
            "description": "The maximum size of a blob to be written during the test.\nFor realistic experiments, you should set it to at least `2gb`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ByteSize"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_total_data_size",
            "description": "An upper limit on the total size of all the blobs written during the test.\nFor realistic experiments, you should set it to at least `1tb`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ByteSize"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "rare_action_probability",
            "description": "The probability of performing a rare action such as an early read, an overwrite, or an aborted write on each blob.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "rarely_abort_writes",
            "description": "Indicates whether to rarely cancel writes before they complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "read_node_count",
            "description": "The number of nodes on which to read a blob after writing.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "register_operation_count",
            "description": "The minimum number of linearizable register operations to perform in total.\nFor realistic experiments, you should set it to at least `100`.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "seed",
            "description": "The seed for the pseudo-random number generator used to generate the list of operations performed during the test.\nTo repeat the same set of operations in multiple experiments, use the same seed in each experiment.\nNote that the operations are performed concurrently so might not always happen in the same order on each run.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period of time to wait for the test to complete.\nIf no response is received before the timeout expires, the test is cancelled and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "blob_count": {
                      "description": "The number of blobs written to the repository during the test.",
                      "type": "number"
                    },
                    "blob_path": {
                      "description": "The path in the repository under which all the blobs were written during the test.",
                      "type": "string"
                    },
                    "concurrency": {
                      "description": "The number of write operations performed concurrently during the test.",
                      "type": "number"
                    },
                    "coordinating_node": {
                      "$ref": "#/components/schemas/snapshot.repository_analyze:SnapshotNodeInfo"
                    },
                    "delete_elapsed": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "delete_elapsed_nanos": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
                    },
                    "details": {
                      "$ref": "#/components/schemas/snapshot.repository_analyze:DetailsInfo"
                    },
                    "early_read_node_count": {
                      "description": "The limit on the number of nodes on which early read operations were performed after writing each blob.",
                      "type": "number"
                    },
                    "issues_detected": {
                      "description": "A list of correctness issues detected, which is empty if the API succeeded.\nIt is included to emphasize that a successful response does not guarantee correct behaviour in future.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "listing_elapsed": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "listing_elapsed_nanos": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
                    },
                    "max_blob_size": {
                      "$ref": "#/components/schemas/_types:ByteSize"
                    },
                    "max_blob_size_bytes": {
                      "description": "The limit, in bytes, on the size of a blob written during the test.",
                      "type": "number"
                    },
                    "max_total_data_size": {
                      "$ref": "#/components/schemas/_types:ByteSize"
                    },
                    "max_total_data_size_bytes": {
                      "description": "The limit, in bytes, on the total size of all blob written during the test.",
                      "type": "number"
                    },
                    "rare_action_probability": {
                      "description": "The probability of performing rare actions during the test.",
                      "type": "number"
                    },
                    "read_node_count": {
                      "description": "The limit on the number of nodes on which read operations were performed after writing each blob.",
                      "type": "number"
                    },
                    "repository": {
                      "description": "The name of the repository that was the subject of the analysis.",
                      "type": "string"
                    },
                    "seed": {
                      "description": "The seed for the pseudo-random number generator used to generate the operations used during the test.",
                      "type": "number"
                    },
                    "summary": {
                      "$ref": "#/components/schemas/snapshot.repository_analyze:SummaryInfo"
                    }
                  },
                  "required": [
                    "blob_count",
                    "blob_path",
                    "concurrency",
                    "coordinating_node",
                    "delete_elapsed",
                    "delete_elapsed_nanos",
                    "details",
                    "early_read_node_count",
                    "issues_detected",
                    "listing_elapsed",
                    "listing_elapsed_nanos",
                    "max_blob_size",
                    "max_blob_size_bytes",
                    "max_total_data_size",
                    "max_total_data_size_bytes",
                    "rare_action_probability",
                    "read_node_count",
                    "repository",
                    "seed",
                    "summary"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.12.0"
      }
    },
    "/_snapshot/{repository}/_verify_integrity": {
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Verify the repository integrity",
        "description": "Verify the integrity of the contents of a snapshot repository.\n\nThis API enables you to perform a comprehensive check of the contents of a repository, looking for any anomalies in its data or metadata which might prevent you from restoring snapshots from the repository or which might cause future snapshot create or delete operations to fail.\n\nIf you suspect the integrity of the contents of one of your snapshot repositories, cease all write activity to this repository immediately, set its `read_only` option to `true`, and use this API to verify its integrity.\nUntil you do so:\n\n* It may not be possible to restore some snapshots from this repository.\n* Searchable snapshots may report errors when searched or may have unassigned shards.\n* Taking snapshots into this repository may fail or may appear to succeed but have created a snapshot which cannot be restored.\n* Deleting snapshots from this repository may fail or may appear to succeed but leave the underlying data on disk.\n* Continuing to write to the repository while it is in an invalid state may causing additional damage to its contents.\n\nIf the API finds any problems with the integrity of the contents of your repository, Elasticsearch will not be able to repair the damage.\nThe only way to bring the repository back into a fully working state after its contents have been damaged is by restoring its contents from a repository backup which was taken before the damage occurred.\nYou must also identify what caused the damage and take action to prevent it from happening again.\n\nIf you cannot restore a repository backup, register a new repository and use this for all future snapshot operations.\nIn some cases it may be possible to recover some of the contents of a damaged repository, either by restoring as many of its snapshots as needed and taking new snapshots of the restored data, or by using the reindex API to copy data from any searchable snapshots mounted from the damaged repository.\n\nAvoid all operations which write to the repository while the verify repository integrity API is running.\nIf something changes the repository contents while an integrity verification is running then Elasticsearch may incorrectly report having detected some anomalies in its contents due to the concurrent writes.\nIt may also incorrectly fail to report some anomalies that the concurrent writes prevented it from detecting.\n\nNOTE: This API is intended for exploratory use by humans. You should expect the request parameters and the response format to vary in future versions.\n\nNOTE: This API may not work correctly in a mixed-version cluster.",
        "operationId": "snapshot-repository-verify-integrity",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "A repository name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "meta_thread_pool_concurrency",
            "description": "Number of threads to use for reading metadata",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "blob_thread_pool_concurrency",
            "description": "Number of threads to use for reading blob contents",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "snapshot_verification_concurrency",
            "description": "Number of snapshots to verify concurrently",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "index_verification_concurrency",
            "description": "Number of indices to verify concurrently",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "index_snapshot_verification_concurrency",
            "description": "Number of snapshots to verify concurrently within each index",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_failed_shard_snapshots",
            "description": "Maximum permitted number of failed shard snapshots",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "verify_blob_contents",
            "description": "Whether to verify the contents of individual blobs",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_bytes_per_sec",
            "description": "Rate limit for individual blob verification",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_snapshot/{repository}/{snapshot}/_restore": {
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Restore a snapshot",
        "description": "Restore a snapshot of a cluster or data streams and indices.\n\nYou can restore a snapshot only to a running cluster with an elected master node.\nThe snapshot repository must be registered and available to the cluster.\nThe snapshot and cluster versions must be compatible.\n\nTo restore a snapshot, the cluster's global metadata must be writable. Ensure there are't any cluster blocks that prevent writes. The restore operation ignores index blocks.\n\nBefore you restore a data stream, ensure the cluster contains a matching index template with data streams enabled. To check, use the index management feature in Kibana or the get index template API:\n\n```\nGET _index_template/*?filter_path=index_templates.name,index_templates.index_template.index_patterns,index_templates.index_template.data_stream\n```\n\nIf no such template exists, you can create one or restore a cluster state that contains one. Without a matching index template, a data stream can't roll over or create backing indices.\n\nIf your snapshot contains data from App Search or Workplace Search, you must restore the Enterprise Search encryption key before you restore the snapshot.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-restore-snapshot.html"
        },
        "operationId": "snapshot-restore",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "A repository name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot",
            "description": "A snapshot name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "Should this request wait until the operation has completed before returning",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "feature_states": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "ignore_index_settings": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "ignore_unavailable": {
                    "type": "boolean"
                  },
                  "include_aliases": {
                    "type": "boolean"
                  },
                  "include_global_state": {
                    "type": "boolean"
                  },
                  "index_settings": {
                    "$ref": "#/components/schemas/indices._types:IndexSettings"
                  },
                  "indices": {
                    "$ref": "#/components/schemas/_types:Indices"
                  },
                  "partial": {
                    "type": "boolean"
                  },
                  "rename_pattern": {
                    "type": "string"
                  },
                  "rename_replacement": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "accepted": {
                      "type": "boolean"
                    },
                    "snapshot": {
                      "$ref": "#/components/schemas/snapshot.restore:SnapshotRestore"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 0.0.0"
      }
    },
    "/_snapshot/_status": {
      "get": {
        "tags": [
          "snapshot"
        ],
        "summary": "Get the snapshot status",
        "description": "Get a detailed description of the current state for each shard participating in the snapshot.\nNote that this API should be used only to obtain detailed shard-level information for ongoing snapshots.\nIf this detail is not needed or you want to obtain information about one or more existing snapshots, use the get snapshot API.\n\nWARNING: Using the API to return the status of any snapshots other than currently running snapshots can be expensive.\nThe API requires a read from the repository for each shard in each snapshot.\nFor example, if you have 100 snapshots with 1,000 shards each, an API request that includes all snapshots will require 100,000 reads (100 snapshots x 1,000 shards).\n\nDepending on the latency of your storage, such requests can take an extremely long time to return results.\nThese requests can also tax machine resources and, when using cloud storage, incur high processing costs.",
        "operationId": "snapshot-status",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.status#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/snapshot.status#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.status#200"
          }
        },
        "x-state": "Added in 7.8.0"
      }
    },
    "/_snapshot/{repository}/_status": {
      "get": {
        "tags": [
          "snapshot"
        ],
        "summary": "Get the snapshot status",
        "description": "Get a detailed description of the current state for each shard participating in the snapshot.\nNote that this API should be used only to obtain detailed shard-level information for ongoing snapshots.\nIf this detail is not needed or you want to obtain information about one or more existing snapshots, use the get snapshot API.\n\nWARNING: Using the API to return the status of any snapshots other than currently running snapshots can be expensive.\nThe API requires a read from the repository for each shard in each snapshot.\nFor example, if you have 100 snapshots with 1,000 shards each, an API request that includes all snapshots will require 100,000 reads (100 snapshots x 1,000 shards).\n\nDepending on the latency of your storage, such requests can take an extremely long time to return results.\nThese requests can also tax machine resources and, when using cloud storage, incur high processing costs.",
        "operationId": "snapshot-status-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.status#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.status#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/snapshot.status#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.status#200"
          }
        },
        "x-state": "Added in 7.8.0"
      }
    },
    "/_snapshot/{repository}/{snapshot}/_status": {
      "get": {
        "tags": [
          "snapshot"
        ],
        "summary": "Get the snapshot status",
        "description": "Get a detailed description of the current state for each shard participating in the snapshot.\nNote that this API should be used only to obtain detailed shard-level information for ongoing snapshots.\nIf this detail is not needed or you want to obtain information about one or more existing snapshots, use the get snapshot API.\n\nWARNING: Using the API to return the status of any snapshots other than currently running snapshots can be expensive.\nThe API requires a read from the repository for each shard in each snapshot.\nFor example, if you have 100 snapshots with 1,000 shards each, an API request that includes all snapshots will require 100,000 reads (100 snapshots x 1,000 shards).\n\nDepending on the latency of your storage, such requests can take an extremely long time to return results.\nThese requests can also tax machine resources and, when using cloud storage, incur high processing costs.",
        "operationId": "snapshot-status-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/snapshot.status#repository"
          },
          {
            "$ref": "#/components/parameters/snapshot.status#snapshot"
          },
          {
            "$ref": "#/components/parameters/snapshot.status#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/snapshot.status#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/snapshot.status#200"
          }
        },
        "x-state": "Added in 7.8.0"
      }
    },
    "/_snapshot/{repository}/_verify": {
      "post": {
        "tags": [
          "snapshot"
        ],
        "summary": "Verify a snapshot repository",
        "description": "Check for common misconfigurations in a snapshot repository.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/snapshots-register-repository.html#snapshots-repository-verification"
        },
        "operationId": "snapshot-verify-repository",
        "parameters": [
          {
            "in": "path",
            "name": "repository",
            "description": "A repository name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/snapshot.verify_repository:CompactNodeInfo"
                      }
                    }
                  },
                  "required": [
                    "nodes"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 0.0.0"
      }
    },
    "/_sql/close": {
      "post": {
        "tags": [
          "sql"
        ],
        "summary": "Clear an SQL search cursor",
        "operationId": "sql-clear-cursor",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "cursor": {
                    "description": "Cursor to clear.",
                    "type": "string"
                  }
                },
                "required": [
                  "cursor"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "succeeded": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "succeeded"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_sql/async/delete/{id}": {
      "delete": {
        "tags": [
          "sql"
        ],
        "summary": "Delete an async SQL search",
        "description": "Delete an async SQL search or a stored synchronous SQL search.\nIf the search is still running, the API cancels it.\n\nIf the Elasticsearch security features are enabled, only the following users can use this API to delete a search:\n\n* Users with the `cancel_task` cluster privilege.\n* The user who first submitted the search.",
        "operationId": "sql-delete-async",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The identifier for the search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.15.0"
      }
    },
    "/_sql/async/{id}": {
      "get": {
        "tags": [
          "sql"
        ],
        "summary": "Get async SQL search results",
        "description": "Get the current status and available results for an async SQL search or stored synchronous SQL search.\n\nIf the Elasticsearch security features are enabled, only the user who first submitted the SQL search can retrieve the search using this API.",
        "operationId": "sql-get-async",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The identifier for the search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "delimiter",
            "description": "The separator for CSV results.\nThe API supports this parameter only for CSV responses.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "format",
            "description": "The format for the response.\nYou must specify a format using this parameter or the `Accept` HTTP header.\nIf you specify both, the API uses this parameter.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "The retention period for the search and its results.\nIt defaults to the `keep_alive` period for the original SQL search.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion_timeout",
            "description": "The period to wait for complete results.\nIt defaults to no timeout, meaning the request waits for complete search results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "is_running": {
                      "description": "If `true`, the search is still running.\nIf `false`, the search has finished.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.",
                      "type": "boolean"
                    },
                    "is_partial": {
                      "description": "If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.",
                      "type": "boolean"
                    },
                    "columns": {
                      "description": "Column headings for the search results. Each object is a column.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/sql:Column"
                      }
                    },
                    "cursor": {
                      "description": "The cursor for the next set of paginated results.\nFor CSV, TSV, and TXT responses, this value is returned in the `Cursor` HTTP header.",
                      "type": "string"
                    },
                    "rows": {
                      "description": "The values for the search results.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/sql:Row"
                      }
                    }
                  },
                  "required": [
                    "id",
                    "is_running",
                    "is_partial",
                    "rows"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.15.0"
      }
    },
    "/_sql/async/status/{id}": {
      "get": {
        "tags": [
          "sql"
        ],
        "summary": "Get the async SQL search status",
        "description": "Get the current status of an async SQL search or a stored synchronous SQL search.",
        "operationId": "sql-get-async-status",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The identifier for the search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "expiration_time_in_millis": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "id": {
                      "description": "The identifier for the search.",
                      "type": "string"
                    },
                    "is_running": {
                      "description": "If `true`, the search is still running.\nIf `false`, the search has finished.",
                      "type": "boolean"
                    },
                    "is_partial": {
                      "description": "If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.",
                      "type": "boolean"
                    },
                    "start_time_in_millis": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "completion_status": {
                      "$ref": "#/components/schemas/_types:uint"
                    }
                  },
                  "required": [
                    "expiration_time_in_millis",
                    "id",
                    "is_running",
                    "is_partial",
                    "start_time_in_millis"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.15.0"
      }
    },
    "/_sql": {
      "get": {
        "tags": [
          "sql"
        ],
        "summary": "Get SQL search results",
        "description": "Run an SQL request.",
        "operationId": "sql-query-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/sql.query#format"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/sql.query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/sql.query#200"
          }
        },
        "x-state": "Added in 6.3.0"
      },
      "post": {
        "tags": [
          "sql"
        ],
        "summary": "Get SQL search results",
        "description": "Run an SQL request.",
        "operationId": "sql-query",
        "parameters": [
          {
            "$ref": "#/components/parameters/sql.query#format"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/sql.query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/sql.query#200"
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_sql/translate": {
      "get": {
        "tags": [
          "sql"
        ],
        "summary": "Translate SQL into Elasticsearch queries",
        "description": "Translate an SQL search into a search API request containing Query DSL.\nIt accepts the same request body parameters as the SQL search API, excluding `cursor`.",
        "operationId": "sql-translate-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/sql.translate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/sql.translate#200"
          }
        },
        "x-state": "Added in 6.3.0"
      },
      "post": {
        "tags": [
          "sql"
        ],
        "summary": "Translate SQL into Elasticsearch queries",
        "description": "Translate an SQL search into a search API request containing Query DSL.\nIt accepts the same request body parameters as the SQL search API, excluding `cursor`.",
        "operationId": "sql-translate",
        "requestBody": {
          "$ref": "#/components/requestBodies/sql.translate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/sql.translate#200"
          }
        },
        "x-state": "Added in 6.3.0"
      }
    },
    "/_ssl/certificates": {
      "get": {
        "tags": [
          "security"
        ],
        "summary": "Get SSL certificates",
        "description": "Get information about the X.509 certificates that are used to encrypt communications in the cluster.\nThe API returns a list that includes certificates from all TLS contexts including:\n\n- Settings for transport and HTTP interfaces\n- TLS settings that are used within authentication realms\n- TLS settings for remote monitoring exporters\n\nThe list includes certificates that are used for configuring trust, such as those configured in the `xpack.security.transport.ssl.truststore` and `xpack.security.transport.ssl.certificate_authorities` settings.\nIt also includes certificates that are used for configuring server identity, such as `xpack.security.http.ssl.keystore` and `xpack.security.http.ssl.certificate settings`.\n\nThe list does not include certificates that are sourced from the default SSL context of the Java Runtime Environment (JRE), even if those certificates are in use within Elasticsearch.\n\nNOTE: When a PKCS#11 token is configured as the truststore of the JRE, the API returns all the certificates that are included in the PKCS#11 token irrespective of whether these are used in the Elasticsearch TLS configuration.\n\nIf Elasticsearch is configured to use a keystore or truststore, the API output includes all certificates in that store, even though some of the certificates might not be in active use within the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-basic-setup.html#encrypt-internode-communication"
        },
        "operationId": "ssl-certificates",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ssl.certificates:CertificateInformation"
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 6.2.0"
      }
    },
    "/_synonyms/{id}": {
      "get": {
        "tags": [
          "synonyms"
        ],
        "summary": "Get a synonym set",
        "operationId": "synonyms-get-synonym",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The synonyms set identifier to retrieve.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "from",
            "description": "The starting offset for query rules to retrieve.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "The max number of query rules to retrieve.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "description": "The total number of synonyms rules that the synonyms set contains.",
                      "type": "number"
                    },
                    "synonyms_set": {
                      "description": "Synonym rule details.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/synonyms._types:SynonymRuleRead"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "synonyms_set"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      },
      "put": {
        "tags": [
          "synonyms"
        ],
        "summary": "Create or update a synonym set",
        "description": "Synonyms sets are limited to a maximum of 10,000 synonym rules per set.\nIf you need to manage more synonym rules, you can create multiple synonym sets.\n\nWhen an existing synonyms set is updated, the search analyzers that use the synonyms set are reloaded automatically for all indices.\nThis is equivalent to invoking the reload search analyzers API for all indices that use the synonyms set.",
        "operationId": "synonyms-put-synonym",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the synonyms set to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "synonyms_set": {
                    "description": "The synonym rules definitions for the synonyms set.",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/synonyms._types:SynonymRule"
                      },
                      {
                        "type": "array",
                        "items": {
                          "$ref": "#/components/schemas/synonyms._types:SynonymRule"
                        }
                      }
                    ]
                  }
                },
                "required": [
                  "synonyms_set"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    },
                    "reload_analyzers_details": {
                      "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadResult"
                    }
                  },
                  "required": [
                    "result",
                    "reload_analyzers_details"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      },
      "delete": {
        "tags": [
          "synonyms"
        ],
        "summary": "Delete a synonym set",
        "description": "You can only delete a synonyms set that is not in use by any index analyzer.\n\nSynonyms sets can be used in synonym graph token filters and synonym token filters.\nThese synonym filters can be used as part of search analyzers.\n\nAnalyzers need to be loaded when an index is restored (such as when a node starts, or the index becomes open).\nEven if the analyzer is not used on any field mapping, it still needs to be loaded on the index recovery phase.\n\nIf any analyzers cannot be loaded, the index becomes unavailable and the cluster status becomes red or yellow as index shards are not available.\nTo prevent that, synonyms sets that are used in analyzers can't be deleted.\nA delete request in this case will return a 400 response code.\n\nTo remove a synonyms set, you must first remove all indices that contain analyzers using it.\nYou can migrate an index by creating a new index that does not contain the token filter with the synonyms set, and use the reindex API in order to copy over the index data.\nOnce finished, you can delete the index.\nWhen the synonyms set is not used in analyzers, you will be able to delete it.",
        "operationId": "synonyms-delete-synonym",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The synonyms set identifier to delete.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      }
    },
    "/_synonyms/{set_id}/{rule_id}": {
      "get": {
        "tags": [
          "synonyms"
        ],
        "summary": "Get a synonym rule",
        "description": "Get a synonym rule from a synonym set.",
        "operationId": "synonyms-get-synonym-rule",
        "parameters": [
          {
            "in": "path",
            "name": "set_id",
            "description": "The ID of the synonym set to retrieve the synonym rule from.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The ID of the synonym rule to retrieve.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/synonyms._types:SynonymRuleRead"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      },
      "put": {
        "tags": [
          "synonyms"
        ],
        "summary": "Create or update a synonym rule",
        "description": "Create or update a synonym rule in a synonym set.\n\nIf any of the synonym rules included is invalid, the API returns an error.\n\nWhen you update a synonym rule, all analyzers using the synonyms set will be reloaded automatically to reflect the new rule.",
        "operationId": "synonyms-put-synonym-rule",
        "parameters": [
          {
            "in": "path",
            "name": "set_id",
            "description": "The ID of the synonym set.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The ID of the synonym rule to be updated or created.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "synonyms": {
                    "$ref": "#/components/schemas/synonyms._types:SynonymString"
                  }
                },
                "required": [
                  "synonyms"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/synonyms._types:SynonymsUpdateResult"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      },
      "delete": {
        "tags": [
          "synonyms"
        ],
        "summary": "Delete a synonym rule",
        "description": "Delete a synonym rule from a synonym set.",
        "operationId": "synonyms-delete-synonym-rule",
        "parameters": [
          {
            "in": "path",
            "name": "set_id",
            "description": "The ID of the synonym set to update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The ID of the synonym rule to delete.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/synonyms._types:SynonymsUpdateResult"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      }
    },
    "/_synonyms": {
      "get": {
        "tags": [
          "synonyms"
        ],
        "summary": "Get all synonym sets",
        "description": "Get a summary of all defined synonym sets.",
        "operationId": "synonyms-get-synonyms-sets",
        "parameters": [
          {
            "in": "query",
            "name": "from",
            "description": "The starting offset for synonyms sets to retrieve.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "The maximum number of synonyms sets to retrieve.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "description": "The total number of synonyms sets defined.",
                      "type": "number"
                    },
                    "results": {
                      "description": "The identifier and total number of defined synonym rules for each synonyms set.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/synonyms.get_synonyms_sets:SynonymsSetItem"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 8.10.0"
      }
    },
    "/_tasks/_cancel": {
      "post": {
        "tags": [
          "tasks"
        ],
        "summary": "Cancel a task",
        "description": "WARNING: The task management API is new and should still be considered a beta feature.\nThe API may change in ways that are not backwards compatible.\n\nA task may continue to run for some time after it has been cancelled because it may not be able to safely stop its current activity straight away.\nIt is also possible that Elasticsearch must complete its work on other tasks before it can process the cancellation.\nThe get task information API will continue to list these cancelled tasks until they complete.\nThe cancelled flag in the response indicates that the cancellation command has been processed and the task will stop as soon as possible.\n\nTo troubleshoot why a cancelled task does not complete promptly, use the get task information API with the `?detailed` parameter to identify the other tasks the system is running.\nYou can also use the node hot threads API to obtain detailed information about the work the system is doing instead of completing the cancelled task.",
        "operationId": "tasks-cancel",
        "parameters": [
          {
            "$ref": "#/components/parameters/tasks.cancel#actions"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#nodes"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#parent_task_id"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#wait_for_completion"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/tasks.cancel#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_tasks/{task_id}/_cancel": {
      "post": {
        "tags": [
          "tasks"
        ],
        "summary": "Cancel a task",
        "description": "WARNING: The task management API is new and should still be considered a beta feature.\nThe API may change in ways that are not backwards compatible.\n\nA task may continue to run for some time after it has been cancelled because it may not be able to safely stop its current activity straight away.\nIt is also possible that Elasticsearch must complete its work on other tasks before it can process the cancellation.\nThe get task information API will continue to list these cancelled tasks until they complete.\nThe cancelled flag in the response indicates that the cancellation command has been processed and the task will stop as soon as possible.\n\nTo troubleshoot why a cancelled task does not complete promptly, use the get task information API with the `?detailed` parameter to identify the other tasks the system is running.\nYou can also use the node hot threads API to obtain detailed information about the work the system is doing instead of completing the cancelled task.",
        "operationId": "tasks-cancel-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/tasks.cancel#task_id"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#actions"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#nodes"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#parent_task_id"
          },
          {
            "$ref": "#/components/parameters/tasks.cancel#wait_for_completion"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/tasks.cancel#200"
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_tasks/{task_id}": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get task information",
        "description": "Get information about a task currently running in the cluster.\n\nWARNING: The task management API is new and should still be considered a beta feature.\nThe API may change in ways that are not backwards compatible.\n\nIf the task identifier is not found, a 404 response code indicates that there are no resources that match the request.",
        "operationId": "tasks-get",
        "parameters": [
          {
            "in": "path",
            "name": "task_id",
            "description": "The task identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the task has completed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "completed": {
                      "type": "boolean"
                    },
                    "task": {
                      "$ref": "#/components/schemas/tasks._types:TaskInfo"
                    },
                    "response": {
                      "type": "object"
                    },
                    "error": {
                      "$ref": "#/components/schemas/_types:ErrorCause"
                    }
                  },
                  "required": [
                    "completed",
                    "task"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/_tasks": {
      "get": {
        "tags": [
          "tasks"
        ],
        "summary": "Get all tasks",
        "description": "Get information about the tasks currently running on one or more nodes in the cluster.\n\nWARNING: The task management API is new and should still be considered a beta feature.\nThe API may change in ways that are not backwards compatible.\n\n**Identifying running tasks**\n\nThe `X-Opaque-Id header`, when provided on the HTTP request header, is going to be returned as a header in the response as well as in the headers field for in the task information.\nThis enables you to track certain calls or associate certain tasks with the client that started them.\nFor example:\n\n```\ncurl -i -H \"X-Opaque-Id: 123456\" \"http://localhost:9200/_tasks?group_by=parents\"\n```\n\nThe API returns the following result:\n\n```\nHTTP/1.1 200 OK\nX-Opaque-Id: 123456\ncontent-type: application/json; charset=UTF-8\ncontent-length: 831\n\n{\n  \"tasks\" : {\n    \"u5lcZHqcQhu-rUoFaqDphA:45\" : {\n      \"node\" : \"u5lcZHqcQhu-rUoFaqDphA\",\n      \"id\" : 45,\n      \"type\" : \"transport\",\n      \"action\" : \"cluster:monitor/tasks/lists\",\n      \"start_time_in_millis\" : 1513823752749,\n      \"running_time_in_nanos\" : 293139,\n      \"cancellable\" : false,\n      \"headers\" : {\n        \"X-Opaque-Id\" : \"123456\"\n      },\n      \"children\" : [\n        {\n          \"node\" : \"u5lcZHqcQhu-rUoFaqDphA\",\n          \"id\" : 46,\n          \"type\" : \"direct\",\n          \"action\" : \"cluster:monitor/tasks/lists[n]\",\n          \"start_time_in_millis\" : 1513823752750,\n          \"running_time_in_nanos\" : 92133,\n          \"cancellable\" : false,\n          \"parent_task_id\" : \"u5lcZHqcQhu-rUoFaqDphA:45\",\n          \"headers\" : {\n            \"X-Opaque-Id\" : \"123456\"\n          }\n        }\n      ]\n    }\n  }\n }\n```\nIn this example, `X-Opaque-Id: 123456` is the ID as a part of the response header.\nThe `X-Opaque-Id` in the task `headers` is the ID for the task that was initiated by the REST request.\nThe `X-Opaque-Id` in the children `headers` is the child task of the task that was initiated by the REST request.",
        "operationId": "tasks-list",
        "parameters": [
          {
            "in": "query",
            "name": "actions",
            "description": "A comma-separated list or wildcard expression of actions used to limit the request.\nFor example, you can use `cluser:*` to retrieve all cluster-related tasks.",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "detailed",
            "description": "If `true`, the response includes detailed information about the running tasks.\nThis information is useful to distinguish tasks from each other but is more costly to run.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "group_by",
            "description": "A key that is used to group tasks in the response.\nThe task lists can be grouped either by nodes or by parent tasks.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/tasks._types:GroupBy"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "nodes",
            "description": "A comma-separated list of node IDs or names that is used to limit the returned information.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:NodeIds"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "parent_task_id",
            "description": "A parent task identifier that is used to limit returned information.\nTo return all tasks, omit this parameter or use a value of `-1`.\nIf the parent task is not found, the API does not return a 404 response code.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for each node to respond.\nIf a node does not respond before its timeout expires, the response does not include its information.\nHowever, timed out nodes are included in the `node_failures` property.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the operation is complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/tasks._types:TaskListResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Technical preview"
      }
    },
    "/{index}/_terms_enum": {
      "get": {
        "tags": [
          "search"
        ],
        "summary": "Get terms in an index",
        "description": "Discover terms that match a partial string in an index.\nThis API is designed for low-latency look-ups used in auto-complete scenarios.\n\n> info\n> The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.",
        "operationId": "terms-enum",
        "parameters": [
          {
            "$ref": "#/components/parameters/terms_enum#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/terms_enum"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/terms_enum#200"
          }
        },
        "x-state": "Added in 7.14.0"
      },
      "post": {
        "tags": [
          "search"
        ],
        "summary": "Get terms in an index",
        "description": "Discover terms that match a partial string in an index.\nThis API is designed for low-latency look-ups used in auto-complete scenarios.\n\n> info\n> The terms enum API may return terms from deleted documents. Deleted documents are initially only marked as deleted. It is not until their segments are merged that documents are actually deleted. Until that happens, the terms enum API will return terms from these documents.",
        "operationId": "terms-enum-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/terms_enum#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/terms_enum"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/terms_enum#200"
          }
        },
        "x-state": "Added in 7.14.0"
      }
    },
    "/{index}/_termvectors/{id}": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get term vector information",
        "description": "Get information and statistics about terms in the fields of a particular document.\n\nYou can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.\nYou can specify the fields you are interested in through the `fields` parameter or by adding the fields to the request body.\nFor example:\n\n```\nGET /my-index-000001/_termvectors/1?fields=message\n```\n\nFields can be specified using wildcards, similar to the multi match query.\n\nTerm vectors are real-time by default, not near real-time.\nThis can be changed by setting `realtime` parameter to `false`.\n\nYou can request three types of values: _term information_, _term statistics_, and _field statistics_.\nBy default, all term information and field statistics are returned for all fields but term statistics are excluded.\n\n**Term information**\n\n* term frequency in the field (always returned)\n* term positions (`positions: true`)\n* start and end offsets (`offsets: true`)\n* term payloads (`payloads: true`), as base64 encoded bytes\n\nIf the requested information wasn't stored in the index, it will be computed on the fly if possible.\nAdditionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.\n\n> warn\n> Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.\n\n**Behaviour**\n\nThe term and field statistics are not accurate.\nDeleted documents are not taken into account.\nThe information is only retrieved for the shard the requested document resides in.\nThe term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.\nBy default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.\nUse `routing` only to hit a particular shard.",
        "operationId": "termvectors",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#id"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Get term vector information",
        "description": "Get information and statistics about terms in the fields of a particular document.\n\nYou can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.\nYou can specify the fields you are interested in through the `fields` parameter or by adding the fields to the request body.\nFor example:\n\n```\nGET /my-index-000001/_termvectors/1?fields=message\n```\n\nFields can be specified using wildcards, similar to the multi match query.\n\nTerm vectors are real-time by default, not near real-time.\nThis can be changed by setting `realtime` parameter to `false`.\n\nYou can request three types of values: _term information_, _term statistics_, and _field statistics_.\nBy default, all term information and field statistics are returned for all fields but term statistics are excluded.\n\n**Term information**\n\n* term frequency in the field (always returned)\n* term positions (`positions: true`)\n* start and end offsets (`offsets: true`)\n* term payloads (`payloads: true`), as base64 encoded bytes\n\nIf the requested information wasn't stored in the index, it will be computed on the fly if possible.\nAdditionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.\n\n> warn\n> Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.\n\n**Behaviour**\n\nThe term and field statistics are not accurate.\nDeleted documents are not taken into account.\nThe information is only retrieved for the shard the requested document resides in.\nThe term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.\nBy default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.\nUse `routing` only to hit a particular shard.",
        "operationId": "termvectors-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#id"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      }
    },
    "/{index}/_termvectors": {
      "get": {
        "tags": [
          "document"
        ],
        "summary": "Get term vector information",
        "description": "Get information and statistics about terms in the fields of a particular document.\n\nYou can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.\nYou can specify the fields you are interested in through the `fields` parameter or by adding the fields to the request body.\nFor example:\n\n```\nGET /my-index-000001/_termvectors/1?fields=message\n```\n\nFields can be specified using wildcards, similar to the multi match query.\n\nTerm vectors are real-time by default, not near real-time.\nThis can be changed by setting `realtime` parameter to `false`.\n\nYou can request three types of values: _term information_, _term statistics_, and _field statistics_.\nBy default, all term information and field statistics are returned for all fields but term statistics are excluded.\n\n**Term information**\n\n* term frequency in the field (always returned)\n* term positions (`positions: true`)\n* start and end offsets (`offsets: true`)\n* term payloads (`payloads: true`), as base64 encoded bytes\n\nIf the requested information wasn't stored in the index, it will be computed on the fly if possible.\nAdditionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.\n\n> warn\n> Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.\n\n**Behaviour**\n\nThe term and field statistics are not accurate.\nDeleted documents are not taken into account.\nThe information is only retrieved for the shard the requested document resides in.\nThe term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.\nBy default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.\nUse `routing` only to hit a particular shard.",
        "operationId": "termvectors-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      },
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Get term vector information",
        "description": "Get information and statistics about terms in the fields of a particular document.\n\nYou can retrieve term vectors for documents stored in the index or for artificial documents passed in the body of the request.\nYou can specify the fields you are interested in through the `fields` parameter or by adding the fields to the request body.\nFor example:\n\n```\nGET /my-index-000001/_termvectors/1?fields=message\n```\n\nFields can be specified using wildcards, similar to the multi match query.\n\nTerm vectors are real-time by default, not near real-time.\nThis can be changed by setting `realtime` parameter to `false`.\n\nYou can request three types of values: _term information_, _term statistics_, and _field statistics_.\nBy default, all term information and field statistics are returned for all fields but term statistics are excluded.\n\n**Term information**\n\n* term frequency in the field (always returned)\n* term positions (`positions: true`)\n* start and end offsets (`offsets: true`)\n* term payloads (`payloads: true`), as base64 encoded bytes\n\nIf the requested information wasn't stored in the index, it will be computed on the fly if possible.\nAdditionally, term vectors could be computed for documents not even existing in the index, but instead provided by the user.\n\n> warn\n> Start and end offsets assume UTF-16 encoding is being used. If you want to use these offsets in order to get the original text that produced this token, you should make sure that the string you are taking a sub-string of is also encoded using UTF-16.\n\n**Behaviour**\n\nThe term and field statistics are not accurate.\nDeleted documents are not taken into account.\nThe information is only retrieved for the shard the requested document resides in.\nThe term and field statistics are therefore only useful as relative measures whereas the absolute numbers have no meaning in this context.\nBy default, when requesting term vectors of artificial documents, a shard to get the statistics from is randomly selected.\nUse `routing` only to hit a particular shard.",
        "operationId": "termvectors-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      }
    },
    "/_text_structure/find_field_structure": {
      "get": {
        "tags": [
          "text_structure"
        ],
        "summary": "Find the structure of a text field",
        "description": "Find the structure of a text field in an Elasticsearch index.\n\nThis API provides a starting point for extracting further information from log messages already ingested into Elasticsearch.\nFor example, if you have ingested data into a very simple index that has just `@timestamp` and message fields, you can use this API to see what common structure exists in the message field.\n\nThe response from the API contains:\n\n* Sample messages.\n* Statistics that reveal the most common values for all fields detected within the text and basic numeric statistics for numeric fields.\n* Information about the structure of the text, which is useful when you write ingest configurations to index it or similarly formatted text.\n* Appropriate mappings for an Elasticsearch index, which you could use to ingest the text.\n\nAll this information can be calculated by the structure finder with no guidance.\nHowever, you can optionally override some of the decisions about the text structure by specifying one or more query parameters.\n\nIf the structure finder produces unexpected results, specify the `explain` query parameter and an explanation will appear in the response.\nIt helps determine why the returned structure was chosen.",
        "operationId": "text-structure-find-field-structure",
        "parameters": [
          {
            "in": "query",
            "name": "column_names",
            "description": "If `format` is set to `delimited`, you can specify the column names in a comma-separated list.\nIf this parameter is not specified, the structure finder uses the column names from the header row of the text.\nIf the text does not have a header row, columns are named \"column1\", \"column2\", \"column3\", for example.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delimiter",
            "description": "If you have set `format` to `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "documents_to_sample",
            "description": "The number of documents to include in the structural analysis.\nThe minimum value is 2.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:uint"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ecs_compatibility",
            "description": "The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nThis setting primarily has an impact when a whole message Grok pattern such as `%{CATALINALOG}` matches the input.\nIf the structure finder identifies a common structure but has no idea of the meaning then generic field names such as `path`, `ipaddress`, `field1`, and `field2` are used in the `grok_pattern` output.\nThe intention in that situation is that a user who knows the meanings will rename the fields before using them.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/text_structure._types:EcsCompatibilityType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "explain",
            "description": "If `true`, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "field",
            "description": "The field that should be analyzed.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Field"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "format",
            "description": "The high level structure of the text.\nBy default, the API chooses the format.\nIn this default scenario, all rows must have the same number of fields for a delimited format to be detected.\nIf the format is set to delimited and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/text_structure._types:FormatType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "grok_pattern",
            "description": "If the format is `semi_structured_text`, you can specify a Grok pattern that is used to extract fields from every message in the text.\nThe name of the timestamp field in the Grok pattern must match what is specified in the `timestamp_field` parameter.\nIf that parameter is not specified, the name of the timestamp field in the Grok pattern must match \"timestamp\".\nIf `grok_pattern` is not specified, the structure finder creates a Grok pattern.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:GrokPattern"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "index",
            "description": "The name of the index that contains the analyzed field.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "quote",
            "description": "If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`\"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "should_trim_fields",
            "description": "If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is true.\nOtherwise, the default value is `false`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The maximum amount of time that the structure analysis can take.\nIf the analysis is still running when the timeout expires, it will be stopped.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timestamp_field",
            "description": "The name of the field that contains the primary timestamp of each record in the text.\nIn particular, if the text was ingested into an index, this is the field that would be used to populate the `@timestamp` field.\n\nIf the format is `semi_structured_text`, this field must match the name of the appropriate extraction in the `grok_pattern`.\nTherefore, for semi-structured text, it is best not to specify this parameter unless `grok_pattern` is also specified.\n\nFor structured text, if you specify this parameter, the field must exist within the text.\n\nIf this parameter is not specified, the structure finder makes a decision about which field (if any) is the primary timestamp field.\nFor structured text, it is not compulsory to have a timestamp in the text.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Field"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timestamp_format",
            "description": "The Java time format of the timestamp field in the text.\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).\nSpacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS 'in' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "charset": {
                      "type": "string"
                    },
                    "ecs_compatibility": {
                      "$ref": "#/components/schemas/text_structure._types:EcsCompatibilityType"
                    },
                    "field_stats": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/text_structure._types:FieldStat"
                      }
                    },
                    "format": {
                      "$ref": "#/components/schemas/text_structure._types:FormatType"
                    },
                    "grok_pattern": {
                      "$ref": "#/components/schemas/_types:GrokPattern"
                    },
                    "java_timestamp_formats": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "joda_timestamp_formats": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "ingest_pipeline": {
                      "$ref": "#/components/schemas/ingest._types:PipelineConfig"
                    },
                    "mappings": {
                      "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                    },
                    "multiline_start_pattern": {
                      "type": "string"
                    },
                    "need_client_timezone": {
                      "type": "boolean"
                    },
                    "num_lines_analyzed": {
                      "type": "number"
                    },
                    "num_messages_analyzed": {
                      "type": "number"
                    },
                    "sample_start": {
                      "type": "string"
                    },
                    "timestamp_field": {
                      "$ref": "#/components/schemas/_types:Field"
                    }
                  },
                  "required": [
                    "charset",
                    "field_stats",
                    "format",
                    "ingest_pipeline",
                    "mappings",
                    "need_client_timezone",
                    "num_lines_analyzed",
                    "num_messages_analyzed",
                    "sample_start"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_text_structure/find_message_structure": {
      "get": {
        "tags": [
          "text_structure"
        ],
        "summary": "Find the structure of text messages",
        "description": "Find the structure of a list of text messages.\nThe messages must contain data that is suitable to be ingested into Elasticsearch.\n\nThis API provides a starting point for ingesting data into Elasticsearch in a format that is suitable for subsequent use with other Elastic Stack functionality.\nUse this API rather than the find text structure API if your input text has already been split up into separate messages by some other process.\n\nThe response from the API contains:\n\n* Sample messages.\n* Statistics that reveal the most common values for all fields detected within the text and basic numeric statistics for numeric fields.\n* Information about the structure of the text, which is useful when you write ingest configurations to index it or similarly formatted text.\nAppropriate mappings for an Elasticsearch index, which you could use to ingest the text.\n\nAll this information can be calculated by the structure finder with no guidance.\nHowever, you can optionally override some of the decisions about the text structure by specifying one or more query parameters.\n\nIf the structure finder produces unexpected results, specify the `explain` query parameter and an explanation will appear in the response.\nIt helps determine why the returned structure was chosen.",
        "operationId": "text-structure-find-message-structure",
        "parameters": [
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#column_names"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#delimiter"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#ecs_compatibility"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#explain"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#format"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#grok_pattern"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#quote"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#should_trim_fields"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#timeout"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#timestamp_field"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#timestamp_format"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/text_structure.find_message_structure"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/text_structure.find_message_structure#200"
          }
        }
      },
      "post": {
        "tags": [
          "text_structure"
        ],
        "summary": "Find the structure of text messages",
        "description": "Find the structure of a list of text messages.\nThe messages must contain data that is suitable to be ingested into Elasticsearch.\n\nThis API provides a starting point for ingesting data into Elasticsearch in a format that is suitable for subsequent use with other Elastic Stack functionality.\nUse this API rather than the find text structure API if your input text has already been split up into separate messages by some other process.\n\nThe response from the API contains:\n\n* Sample messages.\n* Statistics that reveal the most common values for all fields detected within the text and basic numeric statistics for numeric fields.\n* Information about the structure of the text, which is useful when you write ingest configurations to index it or similarly formatted text.\nAppropriate mappings for an Elasticsearch index, which you could use to ingest the text.\n\nAll this information can be calculated by the structure finder with no guidance.\nHowever, you can optionally override some of the decisions about the text structure by specifying one or more query parameters.\n\nIf the structure finder produces unexpected results, specify the `explain` query parameter and an explanation will appear in the response.\nIt helps determine why the returned structure was chosen.",
        "operationId": "text-structure-find-message-structure-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#column_names"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#delimiter"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#ecs_compatibility"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#explain"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#format"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#grok_pattern"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#quote"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#should_trim_fields"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#timeout"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#timestamp_field"
          },
          {
            "$ref": "#/components/parameters/text_structure.find_message_structure#timestamp_format"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/text_structure.find_message_structure"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/text_structure.find_message_structure#200"
          }
        }
      }
    },
    "/_text_structure/find_structure": {
      "post": {
        "tags": [
          "text_structure"
        ],
        "summary": "Find the structure of a text file",
        "description": "The text file must contain data that is suitable to be ingested into Elasticsearch.\n\nThis API provides a starting point for ingesting data into Elasticsearch in a format that is suitable for subsequent use with other Elastic Stack functionality.\nUnlike other Elasticsearch endpoints, the data that is posted to this endpoint does not need to be UTF-8 encoded and in JSON format.\nIt must, however, be text; binary text formats are not currently supported.\nThe size is limited to the Elasticsearch HTTP receive buffer size, which defaults to 100 Mb.\n\nThe response from the API contains:\n\n* A couple of messages from the beginning of the text.\n* Statistics that reveal the most common values for all fields detected within the text and basic numeric statistics for numeric fields.\n* Information about the structure of the text, which is useful when you write ingest configurations to index it or similarly formatted text.\n* Appropriate mappings for an Elasticsearch index, which you could use to ingest the text.\n\nAll this information can be calculated by the structure finder with no guidance.\nHowever, you can optionally override some of the decisions about the text structure by specifying one or more query parameters.",
        "operationId": "text-structure-find-structure",
        "parameters": [
          {
            "in": "query",
            "name": "charset",
            "description": "The text's character set.\nIt must be a character set that is supported by the JVM that Elasticsearch uses.\nFor example, `UTF-8`, `UTF-16LE`, `windows-1252`, or `EUC-JP`.\nIf this parameter is not specified, the structure finder chooses an appropriate character set.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "column_names",
            "description": "If you have set format to `delimited`, you can specify the column names in a comma-separated list.\nIf this parameter is not specified, the structure finder uses the column names from the header row of the text.\nIf the text does not have a header role, columns are named \"column1\", \"column2\", \"column3\", for example.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delimiter",
            "description": "If you have set `format` to `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ecs_compatibility",
            "description": "The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nValid values are `disabled` and `v1`.\nThis setting primarily has an impact when a whole message Grok pattern such as `%{CATALINALOG}` matches the input.\nIf the structure finder identifies a common structure but has no idea of meaning then generic field names such as `path`, `ipaddress`, `field1`, and `field2` are used in the `grok_pattern` output, with the intention that a user who knows the meanings rename these fields before using it.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "explain",
            "description": "If this parameter is set to `true`, the response includes a field named explanation, which is an array of strings that indicate how the structure finder produced its result.\nIf the structure finder produces unexpected results for some text, use this query parameter to help you determine why the returned structure was chosen.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "format",
            "description": "The high level structure of the text.\nValid values are `ndjson`, `xml`, `delimited`, and `semi_structured_text`.\nBy default, the API chooses the format.\nIn this default scenario, all rows must have the same number of fields for a delimited format to be detected.\nIf the format is set to `delimited` and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "grok_pattern",
            "description": "If you have set `format` to `semi_structured_text`, you can specify a Grok pattern that is used to extract fields from every message in the text.\nThe name of the timestamp field in the Grok pattern must match what is specified in the `timestamp_field` parameter.\nIf that parameter is not specified, the name of the timestamp field in the Grok pattern must match \"timestamp\".\nIf `grok_pattern` is not specified, the structure finder creates a Grok pattern.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:GrokPattern"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "has_header_row",
            "description": "If you have set `format` to `delimited`, you can use this parameter to indicate whether the column names are in the first row of the text.\nIf this parameter is not specified, the structure finder guesses based on the similarity of the first row of the text to other rows.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "line_merge_size_limit",
            "description": "The maximum number of characters in a message when lines are merged to form messages while analyzing semi-structured text.\nIf you have extremely long messages you may need to increase this, but be aware that this may lead to very long processing times if the way to group lines into messages is misdetected.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:uint"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lines_to_sample",
            "description": "The number of lines to include in the structural analysis, starting from the beginning of the text.\nThe minimum is 2.\nIf the value of this parameter is greater than the number of lines in the text, the analysis proceeds (as long as there are at least two lines in the text) for all of the lines.\n\nNOTE: The number of lines and the variation of the lines affects the speed of the analysis.\nFor example, if you upload text where the first 1000 lines are all variations on the same message, the analysis will find more commonality than would be seen with a bigger sample.\nIf possible, however, it is more efficient to upload sample text with more variety in the first 1000 lines than to request analysis of 100000 lines to achieve some variety.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:uint"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "quote",
            "description": "If you have set `format` to `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`\"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "should_trim_fields",
            "description": "If you have set `format` to `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is `true`.\nOtherwise, the default value is `false`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The maximum amount of time that the structure analysis can take.\nIf the analysis is still running when the timeout expires then it will be stopped.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timestamp_field",
            "description": "The name of the field that contains the primary timestamp of each record in the text.\nIn particular, if the text were ingested into an index, this is the field that would be used to populate the `@timestamp` field.\n\nIf the `format` is `semi_structured_text`, this field must match the name of the appropriate extraction in the `grok_pattern`.\nTherefore, for semi-structured text, it is best not to specify this parameter unless `grok_pattern` is also specified.\n\nFor structured text, if you specify this parameter, the field must exist within the text.\n\nIf this parameter is not specified, the structure finder makes a decision about which field (if any) is the primary timestamp field.\nFor structured text, it is not compulsory to have a timestamp in the text.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Field"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timestamp_format",
            "description": "The Java time format of the timestamp field in the text.\n\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and separated from the `ss` by a `.`, `,` or `:`.\nSpacing and punctuation is also permitted with the exception of `?`, newline and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS 'in' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text this will result in the structure finder treating the text as single-line messages.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "object"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "charset": {
                      "description": "The character encoding used to parse the text.",
                      "type": "string"
                    },
                    "has_header_row": {
                      "type": "boolean"
                    },
                    "has_byte_order_marker": {
                      "description": "For UTF character encodings, it indicates whether the text begins with a byte order marker.",
                      "type": "boolean"
                    },
                    "format": {
                      "description": "Valid values include `ndjson`, `xml`, `delimited`, and `semi_structured_text`.",
                      "type": "string"
                    },
                    "field_stats": {
                      "description": "The most common values of each field, plus basic numeric statistics for the numeric `page_count` field.\nThis information may provide clues that the data needs to be cleaned or transformed prior to use by other Elastic Stack functionality.",
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/text_structure._types:FieldStat"
                      }
                    },
                    "sample_start": {
                      "description": "The first two messages in the text verbatim.\nThis may help diagnose parse errors or accidental uploads of the wrong text.",
                      "type": "string"
                    },
                    "num_messages_analyzed": {
                      "description": "The number of distinct messages the lines contained.\nFor NDJSON, this value is the same as `num_lines_analyzed`.\nFor other text formats, messages can span several lines.",
                      "type": "number"
                    },
                    "mappings": {
                      "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                    },
                    "quote": {
                      "type": "string"
                    },
                    "delimiter": {
                      "type": "string"
                    },
                    "need_client_timezone": {
                      "description": "If a timestamp format is detected that does not include a timezone, `need_client_timezone` is `true`.\nThe server that parses the text must therefore be told the correct timezone by the client.",
                      "type": "boolean"
                    },
                    "num_lines_analyzed": {
                      "description": "The number of lines of the text that were analyzed.",
                      "type": "number"
                    },
                    "column_names": {
                      "description": "If `format` is `delimited`, the `column_names` field lists the column names in the order they appear in the sample.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "explanation": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "grok_pattern": {
                      "$ref": "#/components/schemas/_types:GrokPattern"
                    },
                    "multiline_start_pattern": {
                      "type": "string"
                    },
                    "exclude_lines_pattern": {
                      "type": "string"
                    },
                    "java_timestamp_formats": {
                      "description": "The Java time formats recognized in the time fields.\nElasticsearch mappings and ingest pipelines use this format.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "joda_timestamp_formats": {
                      "description": "Information that is used to tell Logstash how to parse timestamps.",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "timestamp_field": {
                      "$ref": "#/components/schemas/_types:Field"
                    },
                    "should_trim_fields": {
                      "type": "boolean"
                    },
                    "ingest_pipeline": {
                      "$ref": "#/components/schemas/ingest._types:PipelineConfig"
                    }
                  },
                  "required": [
                    "charset",
                    "has_byte_order_marker",
                    "format",
                    "field_stats",
                    "sample_start",
                    "num_messages_analyzed",
                    "mappings",
                    "need_client_timezone",
                    "num_lines_analyzed",
                    "ingest_pipeline"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.13.0"
      }
    },
    "/_text_structure/test_grok_pattern": {
      "get": {
        "tags": [
          "text_structure"
        ],
        "summary": "Test a Grok pattern",
        "description": "Test a Grok pattern on one or more lines of text.\nThe API indicates whether the lines match the pattern together with the offsets and lengths of the matched substrings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/grok.html"
        },
        "operationId": "text-structure-test-grok-pattern",
        "parameters": [
          {
            "$ref": "#/components/parameters/text_structure.test_grok_pattern#ecs_compatibility"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/text_structure.test_grok_pattern"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/text_structure.test_grok_pattern#200"
          }
        },
        "x-state": "Added in 8.13.0"
      },
      "post": {
        "tags": [
          "text_structure"
        ],
        "summary": "Test a Grok pattern",
        "description": "Test a Grok pattern on one or more lines of text.\nThe API indicates whether the lines match the pattern together with the offsets and lengths of the matched substrings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/grok.html"
        },
        "operationId": "text-structure-test-grok-pattern-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/text_structure.test_grok_pattern#ecs_compatibility"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/text_structure.test_grok_pattern"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/text_structure.test_grok_pattern#200"
          }
        },
        "x-state": "Added in 8.13.0"
      }
    },
    "/_transform/{transform_id}": {
      "get": {
        "tags": [
          "transform"
        ],
        "summary": "Get transforms",
        "description": "Retrieves configuration information for transforms.",
        "operationId": "transform-get-transform",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.get_transform#transform_id"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#from"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#size"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.get_transform#200"
          }
        },
        "x-state": "Added in 7.5.0"
      },
      "put": {
        "tags": [
          "transform"
        ],
        "summary": "Create a transform",
        "description": "Creates a transform.\n\nA transform copies data from source indices, transforms it, and persists it into an entity-centric destination index. You can also think of the destination index as a two-dimensional tabular data structure (known as\na data frame). The ID for each document in the data frame is generated from a hash of the entity, so there is a\nunique row per entity.\n\nYou must choose either the latest or pivot method for your transform; you cannot use both in a single transform. If\nyou choose to use the pivot method for your transform, the entities are defined by the set of `group_by` fields in\nthe pivot object. If you choose to use the latest method, the entities are defined by the `unique_key` field values\nin the latest object.\n\nYou must have `create_index`, `index`, and `read` privileges on the destination index and `read` and\n`view_index_metadata` privileges on the source indices. When Elasticsearch security features are enabled, the\ntransform remembers which roles the user that created it had at the time of creation and uses those same roles. If\nthose roles do not have the required privileges on the source and destination indices, the transform fails when it\nattempts unauthorized operations.\n\nNOTE: You must use Kibana or this API to create a transform. Do not add a transform directly into any\n`.transform-internal*` indices using the Elasticsearch index API. If Elasticsearch security features are enabled, do\nnot give users any privileges on `.transform-internal*` indices. If you used transforms prior to 7.5, also do not\ngive users any privileges on `.data-frame-internal*` indices.",
        "operationId": "transform-put-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. This identifier can contain lowercase alphanumeric characters (a-z and 0-9),\nhyphens, and underscores. It has a 64 character limit and must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "defer_validation",
            "description": "When the transform is created, a series of validations occur to ensure its success. For example, there is a\ncheck for the existence of the source indices and a check that the destination index is not part of the source\nindex pattern. You can use this parameter to skip the checks, for example when the source index does not exist\nuntil after the transform is created. The validations are always run when you start the transform, however, with\nthe exception of privilege checks.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "dest": {
                    "$ref": "#/components/schemas/transform._types:Destination"
                  },
                  "description": {
                    "description": "Free text description of the transform.",
                    "type": "string"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "latest": {
                    "$ref": "#/components/schemas/transform._types:Latest"
                  },
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "pivot": {
                    "$ref": "#/components/schemas/transform._types:Pivot"
                  },
                  "retention_policy": {
                    "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                  },
                  "settings": {
                    "$ref": "#/components/schemas/transform._types:Settings"
                  },
                  "source": {
                    "$ref": "#/components/schemas/transform._types:Source"
                  },
                  "sync": {
                    "$ref": "#/components/schemas/transform._types:SyncContainer"
                  }
                },
                "required": [
                  "dest",
                  "source"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.2.0"
      },
      "delete": {
        "tags": [
          "transform"
        ],
        "summary": "Delete a transform",
        "description": "Deletes a transform.",
        "operationId": "transform-delete-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If this value is false, the transform must be stopped before it can be deleted. If true, the transform is\ndeleted regardless of its current state.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delete_dest_index",
            "description": "If this value is true, the destination index is deleted together with the transform. If false, the destination\nindex will not be deleted",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_transform": {
      "get": {
        "tags": [
          "transform"
        ],
        "summary": "Get transforms",
        "description": "Retrieves configuration information for transforms.",
        "operationId": "transform-get-transform-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.get_transform#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#from"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#size"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.get_transform#200"
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_transform/{transform_id}/_stats": {
      "get": {
        "tags": [
          "transform"
        ],
        "summary": "Get transform stats",
        "description": "Retrieves usage information for transforms.",
        "operationId": "transform-get-transform-stats",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. It can be a transform identifier or a\nwildcard expression. You can get information for all transforms by using\n`_all`, by specifying `*` as the `<transform_id>`, or by omitting the\n`<transform_id>`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Skips the specified number of transforms.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies the maximum number of transforms to obtain.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait for the stats",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "transforms": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/transform.get_transform_stats:TransformStats"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "transforms"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_transform/{transform_id}/_preview": {
      "get": {
        "tags": [
          "transform"
        ],
        "summary": "Preview a transform",
        "description": "Generates a preview of the results that you will get when you create a transform with the same configuration.\n\nIt returns a maximum of 100 results. The calculations are based on all the current data in the source index. It also\ngenerates a list of mappings and settings for the destination index. These values are determined based on the field\ntypes of the source index and the transform aggregations.",
        "operationId": "transform-preview-transform",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#transform_id"
          },
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        },
        "x-state": "Added in 7.2.0"
      },
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Preview a transform",
        "description": "Generates a preview of the results that you will get when you create a transform with the same configuration.\n\nIt returns a maximum of 100 results. The calculations are based on all the current data in the source index. It also\ngenerates a list of mappings and settings for the destination index. These values are determined based on the field\ntypes of the source index and the transform aggregations.",
        "operationId": "transform-preview-transform-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#transform_id"
          },
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        },
        "x-state": "Added in 7.2.0"
      }
    },
    "/_transform/_preview": {
      "get": {
        "tags": [
          "transform"
        ],
        "summary": "Preview a transform",
        "description": "Generates a preview of the results that you will get when you create a transform with the same configuration.\n\nIt returns a maximum of 100 results. The calculations are based on all the current data in the source index. It also\ngenerates a list of mappings and settings for the destination index. These values are determined based on the field\ntypes of the source index and the transform aggregations.",
        "operationId": "transform-preview-transform-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        },
        "x-state": "Added in 7.2.0"
      },
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Preview a transform",
        "description": "Generates a preview of the results that you will get when you create a transform with the same configuration.\n\nIt returns a maximum of 100 results. The calculations are based on all the current data in the source index. It also\ngenerates a list of mappings and settings for the destination index. These values are determined based on the field\ntypes of the source index and the transform aggregations.",
        "operationId": "transform-preview-transform-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        },
        "x-state": "Added in 7.2.0"
      }
    },
    "/_transform/{transform_id}/_reset": {
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Reset a transform",
        "description": "Resets a transform.\nBefore you can reset it, you must stop it; alternatively, use the `force` query parameter.\nIf the destination index was created by the transform, it is deleted.",
        "operationId": "transform-reset-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. This identifier can contain lowercase alphanumeric characters (a-z and 0-9),\nhyphens, and underscores. It has a 64 character limit and must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If this value is `true`, the transform is reset regardless of its current state. If it's `false`, the transform\nmust be stopped before it can be reset.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.1.0"
      }
    },
    "/_transform/{transform_id}/_schedule_now": {
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Schedule a transform to start now",
        "description": "Instantly runs a transform to process data.\n\nIf you _schedule_now a transform, it will process the new data instantly,\nwithout waiting for the configured frequency interval. After _schedule_now API is called,\nthe transform will be processed again at now + frequency unless _schedule_now API\nis called again in the meantime.",
        "operationId": "transform-schedule-now-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait for the scheduling to take place",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 8.7.0"
      }
    },
    "/_transform/{transform_id}/_start": {
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Start a transform",
        "description": "Starts a transform.\n\nWhen you start a transform, it creates the destination index if it does not already exist. The `number_of_shards` is\nset to `1` and the `auto_expand_replicas` is set to `0-1`. If it is a pivot transform, it deduces the mapping\ndefinitions for the destination index from the source indices and the transform aggregations. If fields in the\ndestination index are derived from scripts (as in the case of `scripted_metric` or `bucket_script` aggregations),\nthe transform uses dynamic mappings unless an index template exists. If it is a latest transform, it does not deduce\nmapping definitions; it uses dynamic mappings. To use explicit mappings, create the destination index before you\nstart the transform. Alternatively, you can create an index template, though it does not affect the deduced mappings\nin a pivot transform.\n\nWhen the transform starts, a series of validations occur to ensure its success. If you deferred validation when you\ncreated the transform, they occur when you start the transformâ€”â€‹with the exception of privilege checks. When\nElasticsearch security features are enabled, the transform remembers which roles the user that created it had at the\ntime of creation and uses those same roles. If those roles do not have the required privileges on the source and\ndestination indices, the transform fails when it attempts unauthorized operations.",
        "operationId": "transform-start-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Restricts the set of transformed entities to those changed after this time. Relative times like now-30d are supported. Only applicable for continuous transforms.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_transform/{transform_id}/_stop": {
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Stop transforms",
        "description": "Stops one or more transforms.",
        "operationId": "transform-stop-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. To stop multiple transforms, use a comma-separated list or a wildcard expression.\nTo stop all transforms, use `_all` or `*` as the identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request: contains wildcard expressions and there are no transforms that match;\ncontains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there\nare only partial matches.\n\nIf it is true, the API returns a successful acknowledgement message when there are no matches. When there are\nonly partial matches, the API stops the appropriate transforms.\n\nIf it is false, the request returns a 404 status code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If it is true, the API forcefully stops the transforms.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response when `wait_for_completion` is `true`. If no response is received before the\ntimeout expires, the request returns a timeout exception. However, the request continues processing and\neventually moves the transform to a STOPPED state.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_checkpoint",
            "description": "If it is true, the transform does not completely stop until the current checkpoint is completed. If it is false,\nthe transform stops as soon as possible.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If it is true, the API blocks until the indexer state completely stops. If it is false, the API returns\nimmediately and the indexer is stopped asynchronously in the background.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        },
        "x-state": "Added in 7.5.0"
      }
    },
    "/_transform/{transform_id}/_update": {
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Update a transform",
        "description": "Updates certain properties of a transform.\n\nAll updated properties except `description` do not take effect until after the transform starts the next checkpoint,\nthus there is data consistency in each checkpoint. To use this API, you must have `read` and `view_index_metadata`\nprivileges for the source indices. You must also have `index` and `read` privileges for the destination index. When\nElasticsearch security features are enabled, the transform remembers which roles the user who updated it had at the\ntime of update and runs with those privileges.",
        "operationId": "transform-update-transform",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "defer_validation",
            "description": "When true, deferrable validations are not run. This behavior may be\ndesired if the source index does not exist until after the transform is\ncreated.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the\ntimeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "dest": {
                    "$ref": "#/components/schemas/transform._types:Destination"
                  },
                  "description": {
                    "description": "Free text description of the transform.",
                    "type": "string"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "source": {
                    "$ref": "#/components/schemas/transform._types:Source"
                  },
                  "settings": {
                    "$ref": "#/components/schemas/transform._types:Settings"
                  },
                  "sync": {
                    "$ref": "#/components/schemas/transform._types:SyncContainer"
                  },
                  "retention_policy": {
                    "description": "Defines a retention policy for the transform. Data that meets the defined\ncriteria is deleted from the destination index.",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                      },
                      {
                        "nullable": true,
                        "type": "string"
                      }
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:TransformAuthorization"
                    },
                    "create_time": {
                      "type": "number"
                    },
                    "description": {
                      "type": "string"
                    },
                    "dest": {
                      "$ref": "#/components/schemas/_global.reindex:Destination"
                    },
                    "frequency": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "latest": {
                      "$ref": "#/components/schemas/transform._types:Latest"
                    },
                    "pivot": {
                      "$ref": "#/components/schemas/transform._types:Pivot"
                    },
                    "retention_policy": {
                      "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                    },
                    "settings": {
                      "$ref": "#/components/schemas/transform._types:Settings"
                    },
                    "source": {
                      "$ref": "#/components/schemas/_global.reindex:Source"
                    },
                    "sync": {
                      "$ref": "#/components/schemas/transform._types:SyncContainer"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    },
                    "_meta": {
                      "$ref": "#/components/schemas/_types:Metadata"
                    }
                  },
                  "required": [
                    "create_time",
                    "description",
                    "dest",
                    "id",
                    "settings",
                    "source",
                    "version"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.2.0"
      }
    },
    "/_transform/_upgrade": {
      "post": {
        "tags": [
          "transform"
        ],
        "summary": "Upgrade all transforms",
        "description": "Transforms are compatible across minor versions and between supported major versions.\nHowever, over time, the format of transform configuration information may change.\nThis API identifies transforms that have a legacy configuration format and upgrades them to the latest version.\nIt also cleans up the internal data structures that store the transform state and checkpoints.\nThe upgrade does not affect the source and destination indices.\nThe upgrade also does not affect the roles that transforms use when Elasticsearch security features are enabled; the role used to read source data and write to the destination index remains unchanged.\n\nIf a transform upgrade step fails, the upgrade stops and an error is returned about the underlying issue.\nResolve the issue then re-run the process again.\nA summary is returned when the upgrade is finished.\n\nTo ensure continuous transforms remain running during a major version upgrade of the cluster â€“ for example, from 7.16 to 8.0 â€“ it is recommended to upgrade transforms before upgrading the cluster.\nYou may want to perform a recent cluster backup prior to the upgrade.",
        "operationId": "transform-upgrade-transforms",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "description": "When true, the request checks for updates but does not run them.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and\nreturns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "needs_update": {
                      "description": "The number of transforms that need to be upgraded.",
                      "type": "number"
                    },
                    "no_action": {
                      "description": "The number of transforms that donâ€™t require upgrading.",
                      "type": "number"
                    },
                    "updated": {
                      "description": "The number of transforms that have been upgraded.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "needs_update",
                    "no_action",
                    "updated"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 7.16.0"
      }
    },
    "/{index}/_update/{id}": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Update a document",
        "description": "Update a document by running a script or passing a partial document.\n\nIf the Elasticsearch security features are enabled, you must have the `index` or `write` index privilege for the target index or index alias.\n\nThe script can update, delete, or skip modifying the document.\nThe API also supports passing a partial document, which is merged into the existing document.\nTo fully replace an existing document, use the index API.\nThis operation:\n\n* Gets the document (collocated with the shard) from the index.\n* Runs the specified script.\n* Indexes the result.\n\nThe document must still be reindexed, but using this API removes some network roundtrips and reduces chances of version conflicts between the GET and the index operation.\n\nThe `_source` field must be enabled to use this API.\nIn addition to `_source`, you can access the following variables through the `ctx` map: `_index`, `_type`, `_id`, `_version`, `_routing`, and `_now` (the current timestamp).",
        "operationId": "update",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the target index.\nBy default, the index is created automatically if it doesn't exist.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the document to be updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "if_primary_term",
            "description": "Only perform the operation if the document has this primary term.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "if_seq_no",
            "description": "Only perform the operation if the document has this sequence number.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SequenceNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lang",
            "description": "The script language.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation visible to search.\nIf 'wait_for', it waits for a refresh to make this operation visible to search.\nIf 'false', it does nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "require_alias",
            "description": "If `true`, the destination must be an index alias.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "retry_on_conflict",
            "description": "The number of times the operation should be retried when a conflict occurs.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for the following operations: dynamic mapping updates and waiting for active shards.\nElasticsearch waits for at least the timeout period before failing.\nThe actual wait time could be longer, particularly when multiple waits occur.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of copies of each shard that must be active before proceeding with the operation.\nSet to 'all' or any positive integer up to the total number of shards in the index (`number_of_replicas`+1).\nThe default value of `1` means it waits for each primary shard to be active.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "If `false`, source retrieval is turned off.\nYou can also specify a comma-separated list of the fields you want to retrieve.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "The source fields you want to exclude.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "The source fields you want to retrieve.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "detect_noop": {
                    "description": "If `true`, the `result` in the response is set to `noop` (no operation) when there are no changes to the document.",
                    "type": "boolean"
                  },
                  "doc": {
                    "description": "A partial update to an existing document.\nIf both `doc` and `script` are specified, `doc` is ignored.",
                    "type": "object"
                  },
                  "doc_as_upsert": {
                    "description": "If `true`, use the contents of 'doc' as the value of 'upsert'.\nNOTE: Using ingest pipelines with `doc_as_upsert` is not supported.",
                    "type": "boolean"
                  },
                  "script": {
                    "$ref": "#/components/schemas/_types:Script"
                  },
                  "scripted_upsert": {
                    "description": "If `true`, run the script whether or not the document exists.",
                    "type": "boolean"
                  },
                  "_source": {
                    "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                  },
                  "upsert": {
                    "description": "If the document does not already exist, the contents of 'upsert' are inserted as a new document.\nIf the document exists, the 'script' is run.",
                    "type": "object"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_global.update:UpdateWriteResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_update_by_query": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Update documents",
        "description": "Updates documents that match the specified query.\nIf no query is specified, performs an update on every document in the data stream or index without modifying the source, which is useful for picking up mapping changes.\n\nIf the Elasticsearch security features are enabled, you must have the following index privileges for the target data stream, index, or alias:\n\n* `read`\n* `index` or `write`\n\nYou can specify the query criteria in the request URI or the request body using the same syntax as the search API.\n\nWhen you submit an update by query request, Elasticsearch gets a snapshot of the data stream or index when it begins processing the request and updates matching documents using internal versioning.\nWhen the versions match, the document is updated and the version number is incremented.\nIf a document changes between the time that the snapshot is taken and the update operation is processed, it results in a version conflict and the operation fails.\nYou can opt to count version conflicts instead of halting and returning by setting `conflicts` to `proceed`.\nNote that if you opt to count version conflicts, the operation could attempt to update more documents from the source than `max_docs` until it has successfully updated `max_docs` documents or it has gone through every document in the source query.\n\nNOTE: Documents with a version equal to 0 cannot be updated using update by query because internal versioning does not support 0 as a valid version number.\n\nWhile processing an update by query request, Elasticsearch performs multiple search requests sequentially to find all of the matching documents.\nA bulk update request is performed for each batch of matching documents.\nAny query or update failures cause the update by query request to fail and the failures are shown in the response.\nAny update requests that completed successfully still stick, they are not rolled back.\n\n**Throttling update requests**\n\nTo control the rate at which update by query issues batches of update operations, you can set `requests_per_second` to any positive decimal number.\nThis pads each batch with a wait time to throttle the rate.\nSet `requests_per_second` to `-1` to turn off throttling.\n\nThrottling uses a wait time between batches so that the internal scroll requests can be given a timeout that takes the request padding into account.\nThe padding time is the difference between the batch size divided by the `requests_per_second` and the time spent writing.\nBy default the batch size is 1000, so if `requests_per_second` is set to `500`:\n\n```\ntarget_time = 1000 / 500 per second = 2 seconds\nwait_time = target_time - write_time = 2 seconds - .5 seconds = 1.5 seconds\n```\n\nSince the batch is issued as a single _bulk request, large batch sizes cause Elasticsearch to create many requests and wait before starting the next set.\nThis is \"bursty\" instead of \"smooth\".\n\n**Slicing**\n\nUpdate by query supports sliced scroll to parallelize the update process.\nThis can improve efficiency and provide a convenient way to break the request down into smaller parts.\n\nSetting `slices` to `auto` chooses a reasonable number for most data streams and indices.\nThis setting will use one slice per shard, up to a certain limit.\nIf there are multiple source data streams or indices, it will choose the number of slices based on the index or backing index with the smallest number of shards.\n\nAdding `slices` to `_update_by_query` just automates the manual process of creating sub-requests, which means it has some quirks:\n\n* You can see these requests in the tasks APIs. These sub-requests are \"child\" tasks of the task for the request with slices.\n* Fetching the status of the task for the request with `slices` only contains the status of completed slices.\n* These sub-requests are individually addressable for things like cancellation and rethrottling.\n* Rethrottling the request with `slices` will rethrottle the unfinished sub-request proportionally.\n* Canceling the request with slices will cancel each sub-request.\n* Due to the nature of slices each sub-request won't get a perfectly even portion of the documents. All documents will be addressed, but some slices may be larger than others. Expect larger slices to have a more even distribution.\n* Parameters like `requests_per_second` and `max_docs` on a request with slices are distributed proportionally to each sub-request. Combine that with the point above about distribution being uneven and you should conclude that using `max_docs` with `slices` might not result in exactly `max_docs` documents being updated.\n* Each sub-request gets a slightly different snapshot of the source data stream or index though these are all taken at approximately the same time.\n\nIf you're slicing manually or otherwise tuning automatic slicing, keep in mind that:\n\n* Query performance is most efficient when the number of slices is equal to the number of shards in the index or backing index. If that number is large (for example, 500), choose a lower number as too many slices hurts performance. Setting slices higher than the number of shards generally does not improve efficiency and adds overhead.\n* Update performance scales linearly across available resources with the number of slices.\n\nWhether query or update performance dominates the runtime depends on the documents being reindexed and cluster resources.\n\n**Update the document source**\n\nUpdate by query supports scripts to update the document source.\nAs with the update API, you can set `ctx.op` to change the operation that is performed.\n\nSet `ctx.op = \"noop\"` if your script decides that it doesn't have to make any changes.\nThe update by query operation skips updating the document and increments the `noop` counter.\n\nSet `ctx.op = \"delete\"` if your script decides that the document should be deleted.\nThe update by query operation deletes the document and increments the `deleted` counter.\n\nUpdate by query supports only `index`, `noop`, and `delete`.\nSetting `ctx.op` to anything else is an error.\nSetting any other field in `ctx` is an error.\nThis API enables you to only modify the source of matching documents; you cannot move them.",
        "operationId": "update-by-query",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).\nTo search all data streams or indices, omit this parameter or use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyzer",
            "description": "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyze_wildcard",
            "description": "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "conflicts",
            "description": "The preferred behavior when update by query hits version conflicts: `abort` or `proceed`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Conflicts"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "default_operator",
            "description": "The default operator for query string query: `AND` or `OR`.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types.query_dsl:Operator"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "df",
            "description": "The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nIt supports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lenient",
            "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_docs",
            "description": "The maximum number of documents to process.\nIt defaults to all documents.\nWhen set to a value less then or equal to `scroll_size` then a scroll will not be used to retrieve the results for the operation.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "pipeline",
            "description": "The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "The node or shard the operation should be performed on.\nIt is random by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "q",
            "description": "A query in the Lucene query string syntax.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes affected shards to make the operation visible to search after the request completes.\nThis is different than the update API's `refresh` parameter, which causes just the shard that received the request to be refreshed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "request_cache",
            "description": "If `true`, the request cache is used for this request.\nIt defaults to the index-level setting.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "A custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll",
            "description": "The period to retain the search context for scrolling.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll_size",
            "description": "The size of the scroll request that powers the operation.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_timeout",
            "description": "An explicit timeout for each search request.\nBy default, there is no timeout.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_type",
            "description": "The type of the search operation. Available options include `query_then_fetch` and `dfs_query_then_fetch`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SearchType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "slices",
            "description": "The number of slices this task should be divided into.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Slices"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "sort",
            "description": "A comma-separated list of <field>:<direction> pairs.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stats",
            "description": "The specific `tag` of the request for logging and statistical purposes.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "terminate_after",
            "description": "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period each update request waits for the following operations: dynamic mapping updates, waiting for active shards.\nBy default, it is one minute.\nThis guarantees Elasticsearch waits for at least the timeout before failing.\nThe actual wait time could be longer, particularly when multiple waits occur.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "If `true`, returns the document version as part of a hit.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Should the document increment the version number (internal) on hit or not (reindex)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe `timeout` parameter controls how long each write request waits for unavailable shards to become available.\nBoth work exactly the way they work in the bulk API.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the operation is complete.\nIf `false`, Elasticsearch performs some preflight checks, launches the request, and returns a task ID that you can use to cancel or get the status of the task.\nElasticsearch creates a record of this task as a document at `.tasks/task/${taskId}`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "max_docs": {
                    "description": "The maximum number of documents to update.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "script": {
                    "$ref": "#/components/schemas/_types:Script"
                  },
                  "slice": {
                    "$ref": "#/components/schemas/_types:SlicedScroll"
                  },
                  "conflicts": {
                    "$ref": "#/components/schemas/_types:Conflicts"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "batches": {
                      "description": "The number of scroll responses pulled back by the update by query.",
                      "type": "number"
                    },
                    "failures": {
                      "description": "Array of failures if there were any unrecoverable errors during the process.\nIf this is non-empty then the request ended because of those failures.\nUpdate by query is implemented using batches.\nAny failure causes the entire process to end, but all failures in the current batch are collected into the array.\nYou can use the `conflicts` option to prevent reindex from ending when version conflicts occur.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:BulkIndexByScrollFailure"
                      }
                    },
                    "noops": {
                      "description": "The number of documents that were ignored because the script used for the update by query returned a noop value for `ctx.op`.",
                      "type": "number"
                    },
                    "deleted": {
                      "description": "The number of documents that were successfully deleted.",
                      "type": "number"
                    },
                    "requests_per_second": {
                      "description": "The number of requests per second effectively run during the update by query.",
                      "type": "number"
                    },
                    "retries": {
                      "$ref": "#/components/schemas/_types:Retries"
                    },
                    "task": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    },
                    "timed_out": {
                      "description": "If true, some requests timed out during the update by query.",
                      "type": "boolean"
                    },
                    "took": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "total": {
                      "description": "The number of documents that were successfully processed.",
                      "type": "number"
                    },
                    "updated": {
                      "description": "The number of documents that were successfully updated.",
                      "type": "number"
                    },
                    "version_conflicts": {
                      "description": "The number of version conflicts that the update by query hit.",
                      "type": "number"
                    },
                    "throttled": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "throttled_until": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_until_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    }
                  }
                }
              }
            }
          }
        },
        "x-state": "Added in 2.4.0"
      }
    },
    "/_update_by_query/{task_id}/_rethrottle": {
      "post": {
        "tags": [
          "document"
        ],
        "summary": "Throttle an update by query operation",
        "description": "Change the number of requests per second for a particular update by query operation.\nRethrottling that speeds up the query takes effect immediately but rethrotting that slows down the query takes effect after completing the current batch to prevent scroll timeouts.",
        "operationId": "update-by-query-rethrottle",
        "parameters": [
          {
            "in": "path",
            "name": "task_id",
            "description": "The ID for the task.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.\nTo turn off throttling, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_global.update_by_query_rethrottle:UpdateByQueryRethrottleNode"
                      }
                    }
                  },
                  "required": [
                    "nodes"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 6.5.0"
      }
    },
    "/_watcher/watch/{watch_id}/_ack": {
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Acknowledge a watch",
        "description": "Acknowledging a watch enables you to manually throttle the execution of the watch's actions.\n\nThe acknowledgement state of an action is stored in the `status.actions.<id>.ack.state` structure.\n\nIMPORTANT: If the specified watch is currently being executed, this API will return an error\nThe reason for this behavior is to prevent overwriting the watch status from a watch execution.\n\nAcknowledging an action throttles further executions of that action until its `ack.state` is reset to `awaits_successful_execution`.\nThis happens when the condition of the watch is not met (the condition evaluates to false).",
        "operationId": "watcher-ack-watch",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.ack_watch#watch_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.ack_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Acknowledge a watch",
        "description": "Acknowledging a watch enables you to manually throttle the execution of the watch's actions.\n\nThe acknowledgement state of an action is stored in the `status.actions.<id>.ack.state` structure.\n\nIMPORTANT: If the specified watch is currently being executed, this API will return an error\nThe reason for this behavior is to prevent overwriting the watch status from a watch execution.\n\nAcknowledging an action throttles further executions of that action until its `ack.state` is reset to `awaits_successful_execution`.\nThis happens when the condition of the watch is not met (the condition evaluates to false).",
        "operationId": "watcher-ack-watch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.ack_watch#watch_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.ack_watch#200"
          }
        }
      }
    },
    "/_watcher/watch/{watch_id}/_ack/{action_id}": {
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Acknowledge a watch",
        "description": "Acknowledging a watch enables you to manually throttle the execution of the watch's actions.\n\nThe acknowledgement state of an action is stored in the `status.actions.<id>.ack.state` structure.\n\nIMPORTANT: If the specified watch is currently being executed, this API will return an error\nThe reason for this behavior is to prevent overwriting the watch status from a watch execution.\n\nAcknowledging an action throttles further executions of that action until its `ack.state` is reset to `awaits_successful_execution`.\nThis happens when the condition of the watch is not met (the condition evaluates to false).",
        "operationId": "watcher-ack-watch-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.ack_watch#watch_id"
          },
          {
            "$ref": "#/components/parameters/watcher.ack_watch#action_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.ack_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Acknowledge a watch",
        "description": "Acknowledging a watch enables you to manually throttle the execution of the watch's actions.\n\nThe acknowledgement state of an action is stored in the `status.actions.<id>.ack.state` structure.\n\nIMPORTANT: If the specified watch is currently being executed, this API will return an error\nThe reason for this behavior is to prevent overwriting the watch status from a watch execution.\n\nAcknowledging an action throttles further executions of that action until its `ack.state` is reset to `awaits_successful_execution`.\nThis happens when the condition of the watch is not met (the condition evaluates to false).",
        "operationId": "watcher-ack-watch-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.ack_watch#watch_id"
          },
          {
            "$ref": "#/components/parameters/watcher.ack_watch#action_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.ack_watch#200"
          }
        }
      }
    },
    "/_watcher/watch/{watch_id}/_activate": {
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Activate a watch",
        "description": "A watch can be either active or inactive.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/how-watcher-works.html"
        },
        "operationId": "watcher-activate-watch",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.activate_watch#watch_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.activate_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Activate a watch",
        "description": "A watch can be either active or inactive.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/how-watcher-works.html"
        },
        "operationId": "watcher-activate-watch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.activate_watch#watch_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.activate_watch#200"
          }
        }
      }
    },
    "/_watcher/watch/{watch_id}/_deactivate": {
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Deactivate a watch",
        "description": "A watch can be either active or inactive.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/how-watcher-works.html"
        },
        "operationId": "watcher-deactivate-watch",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.deactivate_watch#watch_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.deactivate_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Deactivate a watch",
        "description": "A watch can be either active or inactive.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/how-watcher-works.html"
        },
        "operationId": "watcher-deactivate-watch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.deactivate_watch#watch_id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.deactivate_watch#200"
          }
        }
      }
    },
    "/_watcher/watch/{id}": {
      "get": {
        "tags": [
          "watcher"
        ],
        "summary": "Get a watch",
        "operationId": "watcher-get-watch",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The watch identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "type": "boolean"
                    },
                    "_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "status": {
                      "$ref": "#/components/schemas/watcher._types:WatchStatus"
                    },
                    "watch": {
                      "$ref": "#/components/schemas/watcher._types:Watch"
                    },
                    "_primary_term": {
                      "type": "number"
                    },
                    "_seq_no": {
                      "$ref": "#/components/schemas/_types:SequenceNumber"
                    },
                    "_version": {
                      "$ref": "#/components/schemas/_types:VersionNumber"
                    }
                  },
                  "required": [
                    "found",
                    "_id"
                  ]
                }
              }
            }
          }
        },
        "x-state": "Added in 5.6.0"
      },
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Create or update a watch",
        "description": "When a watch is registered, a new document that represents the watch is added to the `.watches` index and its trigger is immediately registered with the relevant trigger engine.\nTypically for the `schedule` trigger, the scheduler is the trigger engine.\n\nIMPORTANT: You must use Kibana or this API to create a watch.\nDo not add a watch directly to the `.watches` index by using the Elasticsearch index API.\nIf Elasticsearch security features are enabled, do not give users write privileges on the `.watches` index.\n\nWhen you add a watch you can also define its initial active state by setting the *active* parameter.\n\nWhen Elasticsearch security features are enabled, your watch can index or search only on indices for which the user that stored the watch has privileges.\nIf the user is able to read index `a`, but not index `b`, the same will apply when the watch runs.",
        "operationId": "watcher-put-watch",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.put_watch#id"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#active"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#version"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.put_watch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.put_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Create or update a watch",
        "description": "When a watch is registered, a new document that represents the watch is added to the `.watches` index and its trigger is immediately registered with the relevant trigger engine.\nTypically for the `schedule` trigger, the scheduler is the trigger engine.\n\nIMPORTANT: You must use Kibana or this API to create a watch.\nDo not add a watch directly to the `.watches` index by using the Elasticsearch index API.\nIf Elasticsearch security features are enabled, do not give users write privileges on the `.watches` index.\n\nWhen you add a watch you can also define its initial active state by setting the *active* parameter.\n\nWhen Elasticsearch security features are enabled, your watch can index or search only on indices for which the user that stored the watch has privileges.\nIf the user is able to read index `a`, but not index `b`, the same will apply when the watch runs.",
        "operationId": "watcher-put-watch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.put_watch#id"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#active"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/watcher.put_watch#version"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.put_watch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.put_watch#200"
          }
        }
      },
      "delete": {
        "tags": [
          "watcher"
        ],
        "summary": "Delete a watch",
        "description": "When the watch is removed, the document representing the watch in the `.watches` index is gone and it will never be run again.\n\nDeleting a watch does not delete any watch execution records related to this watch from the watch history.\n\nIMPORTANT: Deleting a watch must be done by using only this API.\nDo not delete the watch directly from the `.watches` index using the Elasticsearch delete document API\nWhen Elasticsearch security features are enabled, make sure no write privileges are granted to anyone for the `.watches` index.",
        "operationId": "watcher-delete-watch",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The watch identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "type": "boolean"
                    },
                    "_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "_version": {
                      "$ref": "#/components/schemas/_types:VersionNumber"
                    }
                  },
                  "required": [
                    "found",
                    "_id",
                    "_version"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_watcher/watch/{id}/_execute": {
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Run a watch",
        "description": "This API can be used to force execution of the watch outside of its triggering logic or to simulate the watch execution for debugging purposes.\n\nFor testing and debugging purposes, you also have fine-grained control on how the watch runs.\nYou can run the watch without running all of its actions or alternatively by simulating them.\nYou can also force execution by ignoring the watch condition and control whether a watch record would be written to the watch history after it runs.\n\nYou can use the run watch API to run watches that are not yet registered by specifying the watch definition inline.\nThis serves as great tool for testing and debugging your watches prior to adding them to Watcher.\n\nWhen Elasticsearch security features are enabled on your cluster, watches are run with the privileges of the user that stored the watches.\nIf your user is allowed to read index `a`, but not index `b`, then the exact same set of rules will apply during execution of a watch.\n\nWhen using the run watch API, the authorization data of the user that called the API will be used as a base, instead of the information who stored the watch.",
        "operationId": "watcher-execute-watch",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.execute_watch#id"
          },
          {
            "$ref": "#/components/parameters/watcher.execute_watch#debug"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.execute_watch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.execute_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Run a watch",
        "description": "This API can be used to force execution of the watch outside of its triggering logic or to simulate the watch execution for debugging purposes.\n\nFor testing and debugging purposes, you also have fine-grained control on how the watch runs.\nYou can run the watch without running all of its actions or alternatively by simulating them.\nYou can also force execution by ignoring the watch condition and control whether a watch record would be written to the watch history after it runs.\n\nYou can use the run watch API to run watches that are not yet registered by specifying the watch definition inline.\nThis serves as great tool for testing and debugging your watches prior to adding them to Watcher.\n\nWhen Elasticsearch security features are enabled on your cluster, watches are run with the privileges of the user that stored the watches.\nIf your user is allowed to read index `a`, but not index `b`, then the exact same set of rules will apply during execution of a watch.\n\nWhen using the run watch API, the authorization data of the user that called the API will be used as a base, instead of the information who stored the watch.",
        "operationId": "watcher-execute-watch-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.execute_watch#id"
          },
          {
            "$ref": "#/components/parameters/watcher.execute_watch#debug"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.execute_watch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.execute_watch#200"
          }
        }
      }
    },
    "/_watcher/watch/_execute": {
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Run a watch",
        "description": "This API can be used to force execution of the watch outside of its triggering logic or to simulate the watch execution for debugging purposes.\n\nFor testing and debugging purposes, you also have fine-grained control on how the watch runs.\nYou can run the watch without running all of its actions or alternatively by simulating them.\nYou can also force execution by ignoring the watch condition and control whether a watch record would be written to the watch history after it runs.\n\nYou can use the run watch API to run watches that are not yet registered by specifying the watch definition inline.\nThis serves as great tool for testing and debugging your watches prior to adding them to Watcher.\n\nWhen Elasticsearch security features are enabled on your cluster, watches are run with the privileges of the user that stored the watches.\nIf your user is allowed to read index `a`, but not index `b`, then the exact same set of rules will apply during execution of a watch.\n\nWhen using the run watch API, the authorization data of the user that called the API will be used as a base, instead of the information who stored the watch.",
        "operationId": "watcher-execute-watch-2",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.execute_watch#debug"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.execute_watch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.execute_watch#200"
          }
        }
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Run a watch",
        "description": "This API can be used to force execution of the watch outside of its triggering logic or to simulate the watch execution for debugging purposes.\n\nFor testing and debugging purposes, you also have fine-grained control on how the watch runs.\nYou can run the watch without running all of its actions or alternatively by simulating them.\nYou can also force execution by ignoring the watch condition and control whether a watch record would be written to the watch history after it runs.\n\nYou can use the run watch API to run watches that are not yet registered by specifying the watch definition inline.\nThis serves as great tool for testing and debugging your watches prior to adding them to Watcher.\n\nWhen Elasticsearch security features are enabled on your cluster, watches are run with the privileges of the user that stored the watches.\nIf your user is allowed to read index `a`, but not index `b`, then the exact same set of rules will apply during execution of a watch.\n\nWhen using the run watch API, the authorization data of the user that called the API will be used as a base, instead of the information who stored the watch.",
        "operationId": "watcher-execute-watch-3",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.execute_watch#debug"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.execute_watch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.execute_watch#200"
          }
        }
      }
    },
    "/_watcher/settings": {
      "get": {
        "tags": [
          "watcher"
        ],
        "summary": "Get Watcher index settings",
        "description": "Get settings for the Watcher internal index (`.watches`).\nOnly a subset of settings are shown, for example `index.auto_expand_replicas` and `index.number_of_replicas`.",
        "operationId": "watcher-get-settings",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "index": {
                      "$ref": "#/components/schemas/indices._types:IndexSettings"
                    }
                  },
                  "required": [
                    "index"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "tags": [
          "watcher"
        ],
        "summary": "Update Watcher index settings",
        "description": "Update settings for the Watcher internal index (`.watches`).\nOnly a subset of settings can be modified.\nThis includes `index.auto_expand_replicas` and `index.number_of_replicas`.",
        "operationId": "watcher-update-settings",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "index.auto_expand_replicas": {
                    "type": "string"
                  },
                  "index.number_of_replicas": {
                    "type": "number"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_watcher/_query/watches": {
      "get": {
        "tags": [
          "watcher"
        ],
        "summary": "Query watches",
        "description": "Get all registered watches in a paginated manner and optionally filter watches by a query.\n\nNote that only the `_id` and `metadata.*` fields are queryable or sortable.",
        "operationId": "watcher-query-watches",
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.query_watches"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.query_watches#200"
          }
        },
        "x-state": "Added in 7.11.0"
      },
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Query watches",
        "description": "Get all registered watches in a paginated manner and optionally filter watches by a query.\n\nNote that only the `_id` and `metadata.*` fields are queryable or sortable.",
        "operationId": "watcher-query-watches-1",
        "requestBody": {
          "$ref": "#/components/requestBodies/watcher.query_watches"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.query_watches#200"
          }
        },
        "x-state": "Added in 7.11.0"
      }
    },
    "/_watcher/_start": {
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Start the watch service",
        "description": "Start the Watcher service if it is not already running.",
        "operationId": "watcher-start",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_watcher/stats": {
      "get": {
        "tags": [
          "watcher"
        ],
        "summary": "Get Watcher statistics",
        "description": "This API always returns basic metrics.\nYou retrieve more metrics by using the metric parameter.",
        "operationId": "watcher-stats",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.stats#emit_stacktraces"
          },
          {
            "$ref": "#/components/parameters/watcher.stats#metric_"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.stats#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_watcher/stats/{metric}": {
      "get": {
        "tags": [
          "watcher"
        ],
        "summary": "Get Watcher statistics",
        "description": "This API always returns basic metrics.\nYou retrieve more metrics by using the metric parameter.",
        "operationId": "watcher-stats-1",
        "parameters": [
          {
            "$ref": "#/components/parameters/watcher.stats#metric"
          },
          {
            "$ref": "#/components/parameters/watcher.stats#emit_stacktraces"
          },
          {
            "$ref": "#/components/parameters/watcher.stats#metric_"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/watcher.stats#200"
          }
        },
        "x-state": "Added in 5.5.0"
      }
    },
    "/_watcher/_stop": {
      "post": {
        "tags": [
          "watcher"
        ],
        "summary": "Stop the watch service",
        "description": "Stop the Watcher service if it is running.",
        "operationId": "watcher-stop",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for the master node.\nIf the master node is not available before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_xpack": {
      "get": {
        "tags": [
          "xpack"
        ],
        "summary": "Get information",
        "description": "The information provided by the API includes:\n\n* Build information including the build number and timestamp.\n* License information about the currently installed license.\n* Feature information for the features that are currently enabled and available under the current license.",
        "operationId": "xpack-info",
        "parameters": [
          {
            "in": "query",
            "name": "categories",
            "description": "A comma-separated list of the information categories to include in the response.\nFor example, `build,license,features`.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/xpack.info:XPackCategory"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "accept_enterprise",
            "description": "If this param is used it must be set to true",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "human",
            "description": "Defines whether additional human-readable information is included in the response.\nIn particular, it adds descriptions and a tag line.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "build": {
                      "$ref": "#/components/schemas/xpack.info:BuildInformation"
                    },
                    "features": {
                      "$ref": "#/components/schemas/xpack.info:Features"
                    },
                    "license": {
                      "$ref": "#/components/schemas/xpack.info:MinimalLicenseInformation"
                    },
                    "tagline": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "build",
                    "features",
                    "license",
                    "tagline"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_xpack/usage": {
      "get": {
        "tags": [
          "xpack"
        ],
        "summary": "Get usage information",
        "description": "Get information about the features that are currently enabled and available under the current license.\nThe API also provides some usage statistics.",
        "operationId": "xpack-usage",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nTo indicate that the request should never timeout, set it to `-1`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "aggregate_metric": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "analytics": {
                      "$ref": "#/components/schemas/xpack.usage:Analytics"
                    },
                    "archive": {
                      "$ref": "#/components/schemas/xpack.usage:Archive"
                    },
                    "watcher": {
                      "$ref": "#/components/schemas/xpack.usage:Watcher"
                    },
                    "ccr": {
                      "$ref": "#/components/schemas/xpack.usage:Ccr"
                    },
                    "data_frame": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "data_science": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "data_streams": {
                      "$ref": "#/components/schemas/xpack.usage:DataStreams"
                    },
                    "data_tiers": {
                      "$ref": "#/components/schemas/xpack.usage:DataTiers"
                    },
                    "enrich": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "eql": {
                      "$ref": "#/components/schemas/xpack.usage:Eql"
                    },
                    "flattened": {
                      "$ref": "#/components/schemas/xpack.usage:Flattened"
                    },
                    "frozen_indices": {
                      "$ref": "#/components/schemas/xpack.usage:FrozenIndices"
                    },
                    "graph": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "health_api": {
                      "$ref": "#/components/schemas/xpack.usage:HealthStatistics"
                    },
                    "ilm": {
                      "$ref": "#/components/schemas/xpack.usage:Ilm"
                    },
                    "logstash": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "ml": {
                      "$ref": "#/components/schemas/xpack.usage:MachineLearning"
                    },
                    "monitoring": {
                      "$ref": "#/components/schemas/xpack.usage:Monitoring"
                    },
                    "rollup": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "runtime_fields": {
                      "$ref": "#/components/schemas/xpack.usage:RuntimeFieldTypes"
                    },
                    "spatial": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "searchable_snapshots": {
                      "$ref": "#/components/schemas/xpack.usage:SearchableSnapshots"
                    },
                    "security": {
                      "$ref": "#/components/schemas/xpack.usage:Security"
                    },
                    "slm": {
                      "$ref": "#/components/schemas/xpack.usage:Slm"
                    },
                    "sql": {
                      "$ref": "#/components/schemas/xpack.usage:Sql"
                    },
                    "transform": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    },
                    "vectors": {
                      "$ref": "#/components/schemas/xpack.usage:Vector"
                    },
                    "voting_only": {
                      "$ref": "#/components/schemas/xpack.usage:Base"
                    }
                  },
                  "required": [
                    "aggregate_metric",
                    "analytics",
                    "archive",
                    "watcher",
                    "ccr",
                    "data_tiers",
                    "eql",
                    "frozen_indices",
                    "graph",
                    "ilm",
                    "logstash",
                    "ml",
                    "monitoring",
                    "rollup",
                    "spatial",
                    "searchable_snapshots",
                    "security",
                    "slm",
                    "sql",
                    "transform",
                    "voting_only"
                  ]
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "_types:Id": {
        "type": "string"
      },
      "_types:AcknowledgedResponseBase": {
        "type": "object",
        "properties": {
          "acknowledged": {
            "description": "For a successful response, this value is always true. On failure, an exception is returned instead.",
            "type": "boolean"
          }
        },
        "required": [
          "acknowledged"
        ]
      },
      "_types:Duration": {
        "description": "A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and\n`d` (days). Also accepts \"0\" without a unit and \"-1\" to indicate an unspecified value.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "string",
            "enum": [
              "-1"
            ]
          },
          {
            "type": "string",
            "enum": [
              "0"
            ]
          }
        ]
      },
      "async_search._types:AsyncSearchDocumentResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/async_search._types:AsyncSearchResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "response": {
                "$ref": "#/components/schemas/async_search._types:AsyncSearch"
              }
            },
            "required": [
              "response"
            ]
          }
        ]
      },
      "async_search._types:AsyncSearch": {
        "type": "object",
        "properties": {
          "aggregations": {
            "description": "Partial aggregations results, coming from the shards that have already completed the execution of the query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:Aggregate"
            }
          },
          "_clusters": {
            "$ref": "#/components/schemas/_types:ClusterStatistics"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "hits": {
            "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
          },
          "max_score": {
            "type": "number"
          },
          "num_reduce_phases": {
            "description": "Indicates how many reductions of the results have been performed.\nIf this number increases compared to the last retrieved results for a get asynch search request, you can expect additional results included in the search response.",
            "type": "number"
          },
          "profile": {
            "$ref": "#/components/schemas/_global.search._types:Profile"
          },
          "pit_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_scroll_id": {
            "$ref": "#/components/schemas/_types:ScrollId"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "suggest": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.search._types:Suggest"
              }
            }
          },
          "terminated_early": {
            "type": "boolean"
          },
          "timed_out": {
            "type": "boolean"
          },
          "took": {
            "type": "number"
          }
        },
        "required": [
          "hits",
          "_shards",
          "timed_out",
          "took"
        ]
      },
      "_types.aggregations:Aggregate": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CardinalityAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HdrPercentilesAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HdrPercentileRanksAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TDigestPercentilesAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TDigestPercentileRanksAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesBucketAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MedianAbsoluteDeviationAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MinAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MaxAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SumAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:AvgAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:WeightedAvgAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ValueCountAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SimpleValueAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DerivativeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketMetricValueAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsBucketAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsBucketAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoBoundsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoCentroidAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DateHistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:AutoDateHistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:LongTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DoubleTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:LongRareTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringRareTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedRareTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MissingAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:NestedAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ReverseNestedAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GlobalAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FilterAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ChildrenAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ParentAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SamplerAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedSamplerAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoHashGridAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoTileGridAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoHexGridAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DateRangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoDistanceAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:IpRangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:IpPrefixAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FiltersAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantLongTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantStringTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedSignificantTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TimeSeriesAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ScriptedMetricAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TopHitsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:InferenceAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringStatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:BoxPlotAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TopMetricsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TTestAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:RateAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CumulativeCardinalityAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MatrixStatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoLineAggregate"
          }
        ]
      },
      "_types.aggregations:CardinalityAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:AggregateBase": {
        "type": "object",
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        }
      },
      "_types:Metadata": {
        "type": "object",
        "additionalProperties": {
          "type": "object"
        }
      },
      "_types.aggregations:HdrPercentilesAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:PercentilesAggregateBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/_types.aggregations:Percentiles"
              }
            },
            "required": [
              "values"
            ]
          }
        ]
      },
      "_types.aggregations:Percentiles": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:KeyedPercentiles"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:ArrayPercentilesItem"
            }
          }
        ]
      },
      "_types.aggregations:KeyedPercentiles": {
        "type": "object",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "nullable": true,
              "type": "string"
            }
          ]
        }
      },
      "_types.aggregations:ArrayPercentilesItem": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "value_as_string": {
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ]
      },
      "_types.aggregations:HdrPercentileRanksAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TDigestPercentilesAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TDigestPercentileRanksAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:PercentilesBucketAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MedianAbsoluteDeviationAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SingleMetricAggregateBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "description": "The metric value. A missing value generally means that there was no data to aggregate,\nunless specified otherwise.",
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:MinAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MaxAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SumAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:AvgAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:WeightedAvgAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ValueCountAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SimpleValueAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:DerivativeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "normalized_value": {
                "type": "number"
              },
              "normalized_value_as_string": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketMetricValueAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "keys": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "keys"
            ]
          }
        ]
      },
      "_types.aggregations:StatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "min": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "max": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "avg": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "sum": {
                "type": "number"
              },
              "min_as_string": {
                "type": "string"
              },
              "max_as_string": {
                "type": "string"
              },
              "avg_as_string": {
                "type": "string"
              },
              "sum_as_string": {
                "type": "string"
              }
            },
            "required": [
              "count",
              "min",
              "max",
              "avg",
              "sum"
            ]
          }
        ]
      },
      "_types.aggregations:StatsBucketAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ExtendedStatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsAggregate"
          },
          {
            "type": "object",
            "properties": {
              "sum_of_squares": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "variance": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "variance_population": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "variance_sampling": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation_population": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation_sampling": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:StandardDeviationBounds"
              },
              "sum_of_squares_as_string": {
                "type": "string"
              },
              "variance_as_string": {
                "type": "string"
              },
              "variance_population_as_string": {
                "type": "string"
              },
              "variance_sampling_as_string": {
                "type": "string"
              },
              "std_deviation_as_string": {
                "type": "string"
              },
              "std_deviation_bounds_as_string": {
                "$ref": "#/components/schemas/_types.aggregations:StandardDeviationBoundsAsString"
              }
            },
            "required": [
              "sum_of_squares",
              "variance",
              "variance_population",
              "variance_sampling",
              "std_deviation",
              "std_deviation_population",
              "std_deviation_sampling"
            ]
          }
        ]
      },
      "_types.aggregations:StandardDeviationBounds": {
        "type": "object",
        "properties": {
          "upper": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "lower": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "upper_population": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "lower_population": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "upper_sampling": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "lower_sampling": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "upper",
          "lower",
          "upper_population",
          "lower_population",
          "upper_sampling",
          "lower_sampling"
        ]
      },
      "_types.aggregations:StandardDeviationBoundsAsString": {
        "type": "object",
        "properties": {
          "upper": {
            "type": "string"
          },
          "lower": {
            "type": "string"
          },
          "upper_population": {
            "type": "string"
          },
          "lower_population": {
            "type": "string"
          },
          "upper_sampling": {
            "type": "string"
          },
          "lower_sampling": {
            "type": "string"
          }
        },
        "required": [
          "upper",
          "lower",
          "upper_population",
          "lower_population",
          "upper_sampling",
          "lower_sampling"
        ]
      },
      "_types.aggregations:ExtendedStatsBucketAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GeoBoundsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              }
            }
          }
        ]
      },
      "_types:GeoBounds": {
        "description": "A geo bounding box. It can be represented in various ways:\n- as 4 top/bottom/left/right coordinates\n- as 2 top_left / bottom_right points\n- as 2 top_right / bottom_left points\n- as a WKT bounding box",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:CoordsGeoBounds"
          },
          {
            "$ref": "#/components/schemas/_types:TopLeftBottomRightGeoBounds"
          },
          {
            "$ref": "#/components/schemas/_types:TopRightBottomLeftGeoBounds"
          },
          {
            "$ref": "#/components/schemas/_types:WktGeoBounds"
          }
        ]
      },
      "_types:CoordsGeoBounds": {
        "type": "object",
        "properties": {
          "top": {
            "type": "number"
          },
          "bottom": {
            "type": "number"
          },
          "left": {
            "type": "number"
          },
          "right": {
            "type": "number"
          }
        },
        "required": [
          "top",
          "bottom",
          "left",
          "right"
        ]
      },
      "_types:TopLeftBottomRightGeoBounds": {
        "type": "object",
        "properties": {
          "top_left": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          },
          "bottom_right": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          }
        },
        "required": [
          "top_left",
          "bottom_right"
        ]
      },
      "_types:GeoLocation": {
        "description": "A latitude/longitude as a 2 dimensional point. It can be represented in various ways:\n- as a `{lat, long}` object\n- as a geo hash value\n- as a `[lon, lat]` array\n- as a string in `\"<lat>, <lon>\"` or WKT point formats",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:LatLonGeoLocation"
          },
          {
            "$ref": "#/components/schemas/_types:GeoHashLocation"
          },
          {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:LatLonGeoLocation": {
        "type": "object",
        "properties": {
          "lat": {
            "description": "Latitude",
            "type": "number"
          },
          "lon": {
            "description": "Longitude",
            "type": "number"
          }
        },
        "required": [
          "lat",
          "lon"
        ]
      },
      "_types:GeoHashLocation": {
        "type": "object",
        "properties": {
          "geohash": {
            "$ref": "#/components/schemas/_types:GeoHash"
          }
        },
        "required": [
          "geohash"
        ]
      },
      "_types:GeoHash": {
        "type": "string"
      },
      "_types:TopRightBottomLeftGeoBounds": {
        "type": "object",
        "properties": {
          "top_right": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          },
          "bottom_left": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          }
        },
        "required": [
          "top_right",
          "bottom_left"
        ]
      },
      "_types:WktGeoBounds": {
        "type": "object",
        "properties": {
          "wkt": {
            "type": "string"
          }
        },
        "required": [
          "wkt"
        ]
      },
      "_types.aggregations:GeoCentroidAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "location": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              }
            },
            "required": [
              "count"
            ]
          }
        ]
      },
      "_types.aggregations:HistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseHistogramBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsHistogramBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsHistogramBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:HistogramBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:HistogramBucket"
            }
          }
        ]
      },
      "_types.aggregations:HistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key_as_string": {
                "type": "string"
              },
              "key": {
                "type": "number"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:MultiBucketBase": {
        "type": "object",
        "properties": {
          "doc_count": {
            "type": "number"
          }
        },
        "required": [
          "doc_count"
        ]
      },
      "_types.aggregations:DateHistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseDateHistogramBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseDateHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsDateHistogramBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsDateHistogramBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:DateHistogramBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:DateHistogramBucket"
            }
          }
        ]
      },
      "_types.aggregations:DateHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key_as_string": {
                "type": "string"
              },
              "key": {
                "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:EpochTimeUnitMillis": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitMillis"
          }
        ]
      },
      "_types:UnitMillis": {
        "description": "Time unit for milliseconds",
        "type": "number"
      },
      "_types.aggregations:AutoDateHistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseDateHistogramBucket"
          },
          {
            "type": "object",
            "properties": {
              "interval": {
                "$ref": "#/components/schemas/_types:DurationLarge"
              }
            },
            "required": [
              "interval"
            ]
          }
        ]
      },
      "_types:DurationLarge": {
        "description": "A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and\n`y` (year)",
        "type": "string"
      },
      "_types.aggregations:VariableWidthHistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVariableWidthHistogramBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseVariableWidthHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsVariableWidthHistogramBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsVariableWidthHistogramBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramBucket"
            }
          }
        ]
      },
      "_types.aggregations:VariableWidthHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "min": {
                "type": "number"
              },
              "key": {
                "type": "number"
              },
              "max": {
                "type": "number"
              },
              "min_as_string": {
                "type": "string"
              },
              "key_as_string": {
                "type": "string"
              },
              "max_as_string": {
                "type": "string"
              }
            },
            "required": [
              "min",
              "key",
              "max"
            ]
          }
        ]
      },
      "_types.aggregations:StringTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseStringTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseStringTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsStringTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsStringTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:StringTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:StringTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:StringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:FieldValue"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:FieldValue": {
        "description": "A field value.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "number"
          },
          {
            "type": "string"
          },
          {
            "type": "boolean"
          },
          {
            "nullable": true,
            "type": "string"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsBucketBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:LongTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseLongTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseLongTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsLongTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsLongTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:LongTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:LongTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:LongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:DoubleTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseDoubleTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseDoubleTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseDoubleTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseDoubleTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsDoubleTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsDoubleTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:DoubleTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:DoubleTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:DoubleTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:UnmappedTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseVoid"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseVoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVoid"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseVoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsVoid"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsVoid": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_spec_utils:Void"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_spec_utils:Void"
            }
          }
        ]
      },
      "_spec_utils:Void": {
        "description": "The absence of any type. This is commonly used in APIs that don't return a body.\n\nAlthough \"void\" is generally used for the unit type that has only one value, this is to be interpreted as\nthe bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.\n\nSee https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type",
        "type": "object"
      },
      "_types.aggregations:LongRareTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseLongRareTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseLongRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsLongRareTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsLongRareTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:LongRareTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:LongRareTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:LongRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:StringRareTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseStringRareTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseStringRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsStringRareTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsStringRareTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:StringRareTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:StringRareTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:StringRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:UnmappedRareTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVoid"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseMultiTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseMultiTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseMultiTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseMultiTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsMultiTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsMultiTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:MultiTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:MultiTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:MultiTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:FieldValue"
                }
              },
              "key_as_string": {
                "type": "string"
              },
              "doc_count_error_upper_bound": {
                "type": "number"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:MissingAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SingleBucketAggregateBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_count": {
                "type": "number"
              }
            },
            "required": [
              "doc_count"
            ]
          }
        ]
      },
      "_types.aggregations:NestedAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ReverseNestedAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GlobalAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:FilterAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ChildrenAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ParentAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SamplerAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:UnmappedSamplerAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GeoHashGridAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseGeoHashGridBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseGeoHashGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsGeoHashGridBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsGeoHashGridBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHashGridBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHashGridBucket"
            }
          }
        ]
      },
      "_types.aggregations:GeoHashGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:GeoHash"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:GeoTileGridAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseGeoTileGridBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseGeoTileGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsGeoTileGridBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsGeoTileGridBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:GeoTileGridBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:GeoTileGridBucket"
            }
          }
        ]
      },
      "_types.aggregations:GeoTileGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:GeoTile"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:GeoTile": {
        "description": "A map tile reference, represented as `{zoom}/{x}/{y}`",
        "type": "string"
      },
      "_types.aggregations:GeoHexGridAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseGeoHexGridBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseGeoHexGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsGeoHexGridBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsGeoHexGridBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHexGridBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHexGridBucket"
            }
          }
        ]
      },
      "_types.aggregations:GeoHexGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:GeoHexCell"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:GeoHexCell": {
        "description": "A map hex cell (H3) reference",
        "type": "string"
      },
      "_types.aggregations:RangeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseRangeBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseRangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsRangeBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsRangeBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:RangeBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:RangeBucket"
            }
          }
        ]
      },
      "_types.aggregations:RangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "from": {
                "type": "number"
              },
              "to": {
                "type": "number"
              },
              "from_as_string": {
                "type": "string"
              },
              "to_as_string": {
                "type": "string"
              },
              "key": {
                "description": "The bucket key. Present if the aggregation is _not_ keyed",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:DateRangeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GeoDistanceAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:IpRangeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseIpRangeBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseIpRangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsIpRangeBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsIpRangeBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:IpRangeBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:IpRangeBucket"
            }
          }
        ]
      },
      "_types.aggregations:IpRangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "from": {
                "type": "string"
              },
              "to": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:IpPrefixAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseIpPrefixBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseIpPrefixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsIpPrefixBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsIpPrefixBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:IpPrefixBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:IpPrefixBucket"
            }
          }
        ]
      },
      "_types.aggregations:IpPrefixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "is_ipv6": {
                "type": "boolean"
              },
              "key": {
                "type": "string"
              },
              "prefix_length": {
                "type": "number"
              },
              "netmask": {
                "type": "string"
              }
            },
            "required": [
              "is_ipv6",
              "key",
              "prefix_length"
            ]
          }
        ]
      },
      "_types.aggregations:FiltersAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseFiltersBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseFiltersBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsFiltersBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsFiltersBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:FiltersBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:FiltersBucket"
            }
          }
        ]
      },
      "_types.aggregations:FiltersBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:AdjacencyMatrixAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseAdjacencyMatrixBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseAdjacencyMatrixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsAdjacencyMatrixBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsAdjacencyMatrixBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixBucket"
            }
          }
        ]
      },
      "_types.aggregations:AdjacencyMatrixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:SignificantLongTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregateBaseSignificantLongTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregateBaseSignificantLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseSignificantLongTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "bg_count": {
                "type": "number"
              },
              "doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseSignificantLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsSignificantLongTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsSignificantLongTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantLongTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantLongTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:SignificantLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:SignificantTermsBucketBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "score": {
                "type": "number"
              },
              "bg_count": {
                "type": "number"
              }
            },
            "required": [
              "score",
              "bg_count"
            ]
          }
        ]
      },
      "_types.aggregations:SignificantStringTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregateBaseSignificantStringTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregateBaseSignificantStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseSignificantStringTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "bg_count": {
                "type": "number"
              },
              "doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseSignificantStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsSignificantStringTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsSignificantStringTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantStringTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantStringTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:SignificantStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:UnmappedSignificantTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregateBaseVoid"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregateBaseVoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVoid"
          },
          {
            "type": "object",
            "properties": {
              "bg_count": {
                "type": "number"
              },
              "doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseCompositeBucket"
          },
          {
            "type": "object",
            "properties": {
              "after_key": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregateKey"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregateKey": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/_types:FieldValue"
        }
      },
      "_types.aggregations:MultiBucketAggregateBaseCompositeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsCompositeBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsCompositeBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:CompositeBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:CompositeBucket"
            }
          }
        ]
      },
      "_types.aggregations:CompositeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregateKey"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:FrequentItemSetsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseFrequentItemSetsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseFrequentItemSetsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsFrequentItemSetsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsFrequentItemSetsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsBucket"
            }
          }
        ]
      },
      "_types.aggregations:FrequentItemSetsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "support": {
                "type": "number"
              }
            },
            "required": [
              "key",
              "support"
            ]
          }
        ]
      },
      "_types.aggregations:TimeSeriesAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseTimeSeriesBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseTimeSeriesBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsTimeSeriesBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsTimeSeriesBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:TimeSeriesBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:TimeSeriesBucket"
            }
          }
        ]
      },
      "_types.aggregations:TimeSeriesBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types:FieldValue"
                }
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:ScriptedMetricAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "object"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:TopHitsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "hits": {
                "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
              }
            },
            "required": [
              "hits"
            ]
          }
        ]
      },
      "_global.search._types:HitsMetadata": {
        "type": "object",
        "properties": {
          "total": {
            "description": "Total hit count information, present only if `track_total_hits` wasn't `false` in the search request.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_global.search._types:TotalHits"
              },
              {
                "type": "number"
              }
            ]
          },
          "hits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:Hit"
            }
          },
          "max_score": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "hits"
        ]
      },
      "_global.search._types:TotalHits": {
        "type": "object",
        "properties": {
          "relation": {
            "$ref": "#/components/schemas/_global.search._types:TotalHitsRelation"
          },
          "value": {
            "type": "number"
          }
        },
        "required": [
          "relation",
          "value"
        ]
      },
      "_global.search._types:TotalHitsRelation": {
        "type": "string",
        "enum": [
          "eq",
          "gte"
        ]
      },
      "_global.search._types:Hit": {
        "type": "object",
        "properties": {
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_score": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "_explanation": {
            "$ref": "#/components/schemas/_global.explain:Explanation"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "highlight": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "inner_hits": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_global.search._types:InnerHitsResult"
            }
          },
          "matched_queries": {
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              {
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              }
            ]
          },
          "_nested": {
            "$ref": "#/components/schemas/_global.search._types:NestedIdentity"
          },
          "_ignored": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "ignored_field_values": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_types:FieldValue"
              }
            }
          },
          "_shard": {
            "type": "string"
          },
          "_node": {
            "type": "string"
          },
          "_routing": {
            "type": "string"
          },
          "_source": {
            "type": "object"
          },
          "_rank": {
            "type": "number"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_primary_term": {
            "type": "number"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:SortResults"
          }
        },
        "required": [
          "_index"
        ]
      },
      "_types:IndexName": {
        "type": "string"
      },
      "_global.explain:Explanation": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.explain:ExplanationDetail"
            }
          },
          "value": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "details",
          "value"
        ]
      },
      "_global.explain:ExplanationDetail": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.explain:ExplanationDetail"
            }
          },
          "value": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "value"
        ]
      },
      "_global.search._types:InnerHitsResult": {
        "type": "object",
        "properties": {
          "hits": {
            "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
          }
        },
        "required": [
          "hits"
        ]
      },
      "_global.search._types:NestedIdentity": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "offset": {
            "type": "number"
          },
          "_nested": {
            "$ref": "#/components/schemas/_global.search._types:NestedIdentity"
          }
        },
        "required": [
          "field",
          "offset"
        ]
      },
      "_types:Field": {
        "description": "Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.",
        "type": "string"
      },
      "_types:SequenceNumber": {
        "type": "number"
      },
      "_types:VersionNumber": {
        "type": "number"
      },
      "_types:SortResults": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/_types:FieldValue"
        }
      },
      "_types.aggregations:InferenceAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "feature_importance": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:InferenceFeatureImportance"
                }
              },
              "top_classes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:InferenceTopClassEntry"
                }
              },
              "warning": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:InferenceFeatureImportance": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          },
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:InferenceClassImportance"
            }
          }
        },
        "required": [
          "feature_name"
        ]
      },
      "_types.aggregations:InferenceClassImportance": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "importance"
        ]
      },
      "_types.aggregations:InferenceTopClassEntry": {
        "type": "object",
        "properties": {
          "class_name": {
            "$ref": "#/components/schemas/_types:FieldValue"
          },
          "class_probability": {
            "type": "number"
          },
          "class_score": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "class_probability",
          "class_score"
        ]
      },
      "_types.aggregations:StringStatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "min_length": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "max_length": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "avg_length": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "entropy": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "distribution": {
                "oneOf": [
                  {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "min_length_as_string": {
                "type": "string"
              },
              "max_length_as_string": {
                "type": "string"
              },
              "avg_length_as_string": {
                "type": "string"
              }
            },
            "required": [
              "count",
              "min_length",
              "max_length",
              "avg_length",
              "entropy"
            ]
          }
        ]
      },
      "_types.aggregations:BoxPlotAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "min": {
                "type": "number"
              },
              "max": {
                "type": "number"
              },
              "q1": {
                "type": "number"
              },
              "q2": {
                "type": "number"
              },
              "q3": {
                "type": "number"
              },
              "lower": {
                "type": "number"
              },
              "upper": {
                "type": "number"
              },
              "min_as_string": {
                "type": "string"
              },
              "max_as_string": {
                "type": "string"
              },
              "q1_as_string": {
                "type": "string"
              },
              "q2_as_string": {
                "type": "string"
              },
              "q3_as_string": {
                "type": "string"
              },
              "lower_as_string": {
                "type": "string"
              },
              "upper_as_string": {
                "type": "string"
              }
            },
            "required": [
              "min",
              "max",
              "q1",
              "q2",
              "q3",
              "lower",
              "upper"
            ]
          }
        ]
      },
      "_types.aggregations:TopMetricsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "top": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:TopMetrics"
                }
              }
            },
            "required": [
              "top"
            ]
          }
        ]
      },
      "_types.aggregations:TopMetrics": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:FieldValue"
                },
                {
                  "nullable": true,
                  "type": "string"
                }
              ]
            }
          },
          "metrics": {
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:FieldValue"
                },
                {
                  "nullable": true,
                  "type": "string"
                }
              ]
            }
          }
        },
        "required": [
          "sort",
          "metrics"
        ]
      },
      "_types.aggregations:TTestAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:RateAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:CumulativeCardinalityAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:MatrixStatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_count": {
                "type": "number"
              },
              "fields": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:MatrixStatsFields"
                }
              }
            },
            "required": [
              "doc_count"
            ]
          }
        ]
      },
      "_types.aggregations:MatrixStatsFields": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "count": {
            "type": "number"
          },
          "mean": {
            "type": "number"
          },
          "variance": {
            "type": "number"
          },
          "skewness": {
            "type": "number"
          },
          "kurtosis": {
            "type": "number"
          },
          "covariance": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "correlation": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "name",
          "count",
          "mean",
          "variance",
          "skewness",
          "kurtosis",
          "covariance",
          "correlation"
        ]
      },
      "_types.aggregations:GeoLineAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "geometry": {
                "$ref": "#/components/schemas/_types:GeoLine"
              },
              "properties": {
                "type": "object"
              }
            },
            "required": [
              "type",
              "geometry",
              "properties"
            ]
          }
        ]
      },
      "_types:GeoLine": {
        "type": "object",
        "properties": {
          "type": {
            "description": "Always `\"LineString\"`",
            "type": "string"
          },
          "coordinates": {
            "description": "Array of `[lon, lat]` coordinates",
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number"
              }
            }
          }
        },
        "required": [
          "type",
          "coordinates"
        ]
      },
      "_types:ClusterStatistics": {
        "type": "object",
        "properties": {
          "skipped": {
            "type": "number"
          },
          "successful": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "running": {
            "type": "number"
          },
          "partial": {
            "type": "number"
          },
          "failed": {
            "type": "number"
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ClusterDetails"
            }
          }
        },
        "required": [
          "skipped",
          "successful",
          "total",
          "running",
          "partial",
          "failed"
        ]
      },
      "_types:ClusterDetails": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/_types:ClusterSearchStatus"
          },
          "indices": {
            "type": "string"
          },
          "took": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "timed_out": {
            "type": "boolean"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ShardFailure"
            }
          }
        },
        "required": [
          "status",
          "indices",
          "timed_out"
        ]
      },
      "_types:ClusterSearchStatus": {
        "type": "string",
        "enum": [
          "running",
          "successful",
          "partial",
          "skipped",
          "failed"
        ]
      },
      "_types:DurationValueUnitMillis": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitMillis"
          }
        ]
      },
      "_types:ShardStatistics": {
        "type": "object",
        "properties": {
          "failed": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "successful": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "total": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ShardFailure"
            }
          },
          "skipped": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "failed",
          "successful",
          "total"
        ]
      },
      "_types:uint": {
        "type": "number"
      },
      "_types:ShardFailure": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "node": {
            "type": "string"
          },
          "reason": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "shard": {
            "type": "number"
          },
          "status": {
            "type": "string"
          },
          "primary": {
            "type": "boolean"
          }
        },
        "required": [
          "reason"
        ]
      },
      "_types:ErrorCause": {
        "type": "object",
        "properties": {
          "type": {
            "description": "The type of error",
            "type": "string"
          },
          "reason": {
            "description": "A human-readable explanation of the error, in English.",
            "type": "string"
          },
          "stack_trace": {
            "description": "The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.",
            "type": "string"
          },
          "caused_by": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "root_cause": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          },
          "suppressed": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_global.search._types:Profile": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:ShardProfile"
            }
          }
        },
        "required": [
          "shards"
        ]
      },
      "_global.search._types:ShardProfile": {
        "type": "object",
        "properties": {
          "aggregations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:AggregationProfile"
            }
          },
          "cluster": {
            "type": "string"
          },
          "dfs": {
            "$ref": "#/components/schemas/_global.search._types:DfsProfile"
          },
          "fetch": {
            "$ref": "#/components/schemas/_global.search._types:FetchProfile"
          },
          "id": {
            "type": "string"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "searches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:SearchProfile"
            }
          },
          "shard_id": {
            "type": "number"
          }
        },
        "required": [
          "aggregations",
          "cluster",
          "id",
          "index",
          "node_id",
          "searches",
          "shard_id"
        ]
      },
      "_global.search._types:AggregationProfile": {
        "type": "object",
        "properties": {
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:AggregationBreakdown"
          },
          "description": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "type": {
            "type": "string"
          },
          "debug": {
            "$ref": "#/components/schemas/_global.search._types:AggregationProfileDebug"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:AggregationProfile"
            }
          }
        },
        "required": [
          "breakdown",
          "description",
          "time_in_nanos",
          "type"
        ]
      },
      "_global.search._types:AggregationBreakdown": {
        "type": "object",
        "properties": {
          "build_aggregation": {
            "type": "number"
          },
          "build_aggregation_count": {
            "type": "number"
          },
          "build_leaf_collector": {
            "type": "number"
          },
          "build_leaf_collector_count": {
            "type": "number"
          },
          "collect": {
            "type": "number"
          },
          "collect_count": {
            "type": "number"
          },
          "initialize": {
            "type": "number"
          },
          "initialize_count": {
            "type": "number"
          },
          "post_collection": {
            "type": "number"
          },
          "post_collection_count": {
            "type": "number"
          },
          "reduce": {
            "type": "number"
          },
          "reduce_count": {
            "type": "number"
          }
        },
        "required": [
          "build_aggregation",
          "build_aggregation_count",
          "build_leaf_collector",
          "build_leaf_collector_count",
          "collect",
          "collect_count",
          "initialize",
          "initialize_count",
          "reduce",
          "reduce_count"
        ]
      },
      "_types:DurationValueUnitNanos": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitNanos"
          }
        ]
      },
      "_types:UnitNanos": {
        "description": "Time unit for nanoseconds",
        "type": "number"
      },
      "_global.search._types:AggregationProfileDebug": {
        "type": "object",
        "properties": {
          "segments_with_multi_valued_ords": {
            "type": "number"
          },
          "collection_strategy": {
            "type": "string"
          },
          "segments_with_single_valued_ords": {
            "type": "number"
          },
          "total_buckets": {
            "type": "number"
          },
          "built_buckets": {
            "type": "number"
          },
          "result_strategy": {
            "type": "string"
          },
          "has_filter": {
            "type": "boolean"
          },
          "delegate": {
            "type": "string"
          },
          "delegate_debug": {
            "$ref": "#/components/schemas/_global.search._types:AggregationProfileDebug"
          },
          "chars_fetched": {
            "type": "number"
          },
          "extract_count": {
            "type": "number"
          },
          "extract_ns": {
            "type": "number"
          },
          "values_fetched": {
            "type": "number"
          },
          "collect_analyzed_ns": {
            "type": "number"
          },
          "collect_analyzed_count": {
            "type": "number"
          },
          "surviving_buckets": {
            "type": "number"
          },
          "ordinals_collectors_used": {
            "type": "number"
          },
          "ordinals_collectors_overhead_too_high": {
            "type": "number"
          },
          "string_hashing_collectors_used": {
            "type": "number"
          },
          "numeric_collectors_used": {
            "type": "number"
          },
          "empty_collectors_used": {
            "type": "number"
          },
          "deferred_aggregators": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "segments_with_doc_count_field": {
            "type": "number"
          },
          "segments_with_deleted_docs": {
            "type": "number"
          },
          "filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:AggregationProfileDelegateDebugFilter"
            }
          },
          "segments_counted": {
            "type": "number"
          },
          "segments_collected": {
            "type": "number"
          },
          "map_reducer": {
            "type": "string"
          },
          "brute_force_used": {
            "type": "number"
          },
          "dynamic_pruning_attempted": {
            "type": "number"
          },
          "dynamic_pruning_used": {
            "type": "number"
          },
          "skipped_due_to_no_data": {
            "type": "number"
          }
        }
      },
      "_global.search._types:AggregationProfileDelegateDebugFilter": {
        "type": "object",
        "properties": {
          "results_from_metadata": {
            "type": "number"
          },
          "query": {
            "type": "string"
          },
          "specialized_for": {
            "type": "string"
          },
          "segments_counted_in_constant_time": {
            "type": "number"
          }
        }
      },
      "_global.search._types:DfsProfile": {
        "type": "object",
        "properties": {
          "statistics": {
            "$ref": "#/components/schemas/_global.search._types:DfsStatisticsProfile"
          },
          "knn": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:DfsKnnProfile"
            }
          }
        }
      },
      "_global.search._types:DfsStatisticsProfile": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:DfsStatisticsBreakdown"
          },
          "debug": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:DfsStatisticsProfile"
            }
          }
        },
        "required": [
          "type",
          "description",
          "time_in_nanos",
          "breakdown"
        ]
      },
      "_global.search._types:DfsStatisticsBreakdown": {
        "type": "object",
        "properties": {
          "collection_statistics": {
            "type": "number"
          },
          "collection_statistics_count": {
            "type": "number"
          },
          "create_weight": {
            "type": "number"
          },
          "create_weight_count": {
            "type": "number"
          },
          "rewrite": {
            "type": "number"
          },
          "rewrite_count": {
            "type": "number"
          },
          "term_statistics": {
            "type": "number"
          },
          "term_statistics_count": {
            "type": "number"
          }
        },
        "required": [
          "collection_statistics",
          "collection_statistics_count",
          "create_weight",
          "create_weight_count",
          "rewrite",
          "rewrite_count",
          "term_statistics",
          "term_statistics_count"
        ]
      },
      "_global.search._types:DfsKnnProfile": {
        "type": "object",
        "properties": {
          "vector_operations_count": {
            "type": "number"
          },
          "query": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:KnnQueryProfileResult"
            }
          },
          "rewrite_time": {
            "type": "number"
          },
          "collector": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:KnnCollectorResult"
            }
          }
        },
        "required": [
          "query",
          "rewrite_time",
          "collector"
        ]
      },
      "_global.search._types:KnnQueryProfileResult": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:KnnQueryProfileBreakdown"
          },
          "debug": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:KnnQueryProfileResult"
            }
          }
        },
        "required": [
          "type",
          "description",
          "time_in_nanos",
          "breakdown"
        ]
      },
      "_global.search._types:KnnQueryProfileBreakdown": {
        "type": "object",
        "properties": {
          "advance": {
            "type": "number"
          },
          "advance_count": {
            "type": "number"
          },
          "build_scorer": {
            "type": "number"
          },
          "build_scorer_count": {
            "type": "number"
          },
          "compute_max_score": {
            "type": "number"
          },
          "compute_max_score_count": {
            "type": "number"
          },
          "count_weight": {
            "type": "number"
          },
          "count_weight_count": {
            "type": "number"
          },
          "create_weight": {
            "type": "number"
          },
          "create_weight_count": {
            "type": "number"
          },
          "match": {
            "type": "number"
          },
          "match_count": {
            "type": "number"
          },
          "next_doc": {
            "type": "number"
          },
          "next_doc_count": {
            "type": "number"
          },
          "score": {
            "type": "number"
          },
          "score_count": {
            "type": "number"
          },
          "set_min_competitive_score": {
            "type": "number"
          },
          "set_min_competitive_score_count": {
            "type": "number"
          },
          "shallow_advance": {
            "type": "number"
          },
          "shallow_advance_count": {
            "type": "number"
          }
        },
        "required": [
          "advance",
          "advance_count",
          "build_scorer",
          "build_scorer_count",
          "compute_max_score",
          "compute_max_score_count",
          "count_weight",
          "count_weight_count",
          "create_weight",
          "create_weight_count",
          "match",
          "match_count",
          "next_doc",
          "next_doc_count",
          "score",
          "score_count",
          "set_min_competitive_score",
          "set_min_competitive_score_count",
          "shallow_advance",
          "shallow_advance_count"
        ]
      },
      "_global.search._types:KnnCollectorResult": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "reason": {
            "type": "string"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:KnnCollectorResult"
            }
          }
        },
        "required": [
          "name",
          "reason",
          "time_in_nanos"
        ]
      },
      "_global.search._types:FetchProfile": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:FetchProfileBreakdown"
          },
          "debug": {
            "$ref": "#/components/schemas/_global.search._types:FetchProfileDebug"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:FetchProfile"
            }
          }
        },
        "required": [
          "type",
          "description",
          "time_in_nanos",
          "breakdown"
        ]
      },
      "_global.search._types:FetchProfileBreakdown": {
        "type": "object",
        "properties": {
          "load_source": {
            "type": "number"
          },
          "load_source_count": {
            "type": "number"
          },
          "load_stored_fields": {
            "type": "number"
          },
          "load_stored_fields_count": {
            "type": "number"
          },
          "next_reader": {
            "type": "number"
          },
          "next_reader_count": {
            "type": "number"
          },
          "process_count": {
            "type": "number"
          },
          "process": {
            "type": "number"
          }
        }
      },
      "_global.search._types:FetchProfileDebug": {
        "type": "object",
        "properties": {
          "stored_fields": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "fast_path": {
            "type": "number"
          }
        }
      },
      "_types:NodeId": {
        "type": "string"
      },
      "_global.search._types:SearchProfile": {
        "type": "object",
        "properties": {
          "collector": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:Collector"
            }
          },
          "query": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:QueryProfile"
            }
          },
          "rewrite_time": {
            "type": "number"
          }
        },
        "required": [
          "collector",
          "query",
          "rewrite_time"
        ]
      },
      "_global.search._types:Collector": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "reason": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:Collector"
            }
          }
        },
        "required": [
          "name",
          "reason",
          "time_in_nanos"
        ]
      },
      "_global.search._types:QueryProfile": {
        "type": "object",
        "properties": {
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:QueryBreakdown"
          },
          "description": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "type": {
            "type": "string"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:QueryProfile"
            }
          }
        },
        "required": [
          "breakdown",
          "description",
          "time_in_nanos",
          "type"
        ]
      },
      "_global.search._types:QueryBreakdown": {
        "type": "object",
        "properties": {
          "advance": {
            "type": "number"
          },
          "advance_count": {
            "type": "number"
          },
          "build_scorer": {
            "type": "number"
          },
          "build_scorer_count": {
            "type": "number"
          },
          "create_weight": {
            "type": "number"
          },
          "create_weight_count": {
            "type": "number"
          },
          "match": {
            "type": "number"
          },
          "match_count": {
            "type": "number"
          },
          "shallow_advance": {
            "type": "number"
          },
          "shallow_advance_count": {
            "type": "number"
          },
          "next_doc": {
            "type": "number"
          },
          "next_doc_count": {
            "type": "number"
          },
          "score": {
            "type": "number"
          },
          "score_count": {
            "type": "number"
          },
          "compute_max_score": {
            "type": "number"
          },
          "compute_max_score_count": {
            "type": "number"
          },
          "count_weight": {
            "type": "number"
          },
          "count_weight_count": {
            "type": "number"
          },
          "set_min_competitive_score": {
            "type": "number"
          },
          "set_min_competitive_score_count": {
            "type": "number"
          }
        },
        "required": [
          "advance",
          "advance_count",
          "build_scorer",
          "build_scorer_count",
          "create_weight",
          "create_weight_count",
          "match",
          "match_count",
          "shallow_advance",
          "shallow_advance_count",
          "next_doc",
          "next_doc_count",
          "score",
          "score_count",
          "compute_max_score",
          "compute_max_score_count",
          "count_weight",
          "count_weight_count",
          "set_min_competitive_score",
          "set_min_competitive_score_count"
        ]
      },
      "_types:ScrollId": {
        "type": "string"
      },
      "_global.search._types:Suggest": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:CompletionSuggest"
          },
          {
            "$ref": "#/components/schemas/_global.search._types:PhraseSuggest"
          },
          {
            "$ref": "#/components/schemas/_global.search._types:TermSuggest"
          }
        ]
      },
      "_global.search._types:CompletionSuggest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:SuggestBase"
          },
          {
            "type": "object",
            "properties": {
              "options": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.search._types:CompletionSuggestOption"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:CompletionSuggestOption"
                    }
                  }
                ]
              }
            },
            "required": [
              "options"
            ]
          }
        ]
      },
      "_global.search._types:CompletionSuggestOption": {
        "type": "object",
        "properties": {
          "collate_match": {
            "type": "boolean"
          },
          "contexts": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.search._types:Context"
              }
            }
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "_id": {
            "type": "string"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_score": {
            "type": "number"
          },
          "_source": {
            "type": "object"
          },
          "text": {
            "type": "string"
          },
          "score": {
            "type": "number"
          }
        },
        "required": [
          "text"
        ]
      },
      "_global.search._types:Context": {
        "description": "Text or location that we want similar documents for or a lookup to a document's field for the text.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types:GeoLocation"
          }
        ]
      },
      "_types:Routing": {
        "type": "string"
      },
      "_global.search._types:SuggestBase": {
        "type": "object",
        "properties": {
          "length": {
            "type": "number"
          },
          "offset": {
            "type": "number"
          },
          "text": {
            "type": "string"
          }
        },
        "required": [
          "length",
          "offset",
          "text"
        ]
      },
      "_global.search._types:PhraseSuggest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:SuggestBase"
          },
          {
            "type": "object",
            "properties": {
              "options": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.search._types:PhraseSuggestOption"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:PhraseSuggestOption"
                    }
                  }
                ]
              }
            },
            "required": [
              "options"
            ]
          }
        ]
      },
      "_global.search._types:PhraseSuggestOption": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "score": {
            "type": "number"
          },
          "highlighted": {
            "type": "string"
          },
          "collate_match": {
            "type": "boolean"
          }
        },
        "required": [
          "text",
          "score"
        ]
      },
      "_global.search._types:TermSuggest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:SuggestBase"
          },
          {
            "type": "object",
            "properties": {
              "options": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.search._types:TermSuggestOption"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:TermSuggestOption"
                    }
                  }
                ]
              }
            },
            "required": [
              "options"
            ]
          }
        ]
      },
      "_global.search._types:TermSuggestOption": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "score": {
            "type": "number"
          },
          "freq": {
            "type": "number"
          },
          "highlighted": {
            "type": "string"
          },
          "collate_match": {
            "type": "boolean"
          }
        },
        "required": [
          "text",
          "score",
          "freq"
        ]
      },
      "async_search._types:AsyncSearchResponseBase": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "is_partial": {
            "description": "When the query is no longer running, this property indicates whether the search failed or was successfully completed on all shards.\nWhile the query is running, `is_partial` is always set to `true`.",
            "type": "boolean"
          },
          "is_running": {
            "description": "Indicates whether the search is still running or has completed.\nNOTE: If the search failed after some shards returned their results or the node that is coordinating the async search dies, results may be partial even though `is_running` is `false`.",
            "type": "boolean"
          },
          "expiration_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "expiration_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "completion_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "completion_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "is_partial",
          "is_running",
          "expiration_time_in_millis",
          "start_time_in_millis"
        ]
      },
      "_types:DateTime": {
        "description": "A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a\nnumber of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string\nrepresentation.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        ]
      },
      "async_search.status:StatusResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/async_search._types:AsyncSearchResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "_shards": {
                "$ref": "#/components/schemas/_types:ShardStatistics"
              },
              "_clusters": {
                "$ref": "#/components/schemas/_types:ClusterStatistics"
              },
              "completion_status": {
                "description": "If the async search completed, this field shows the status code of the search.\nFor example, 200 indicates that the async search was successfully completed.\n503 indicates that the async search was completed with an error.",
                "type": "number"
              }
            },
            "required": [
              "_shards"
            ]
          }
        ]
      },
      "_types:Indices": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          }
        ]
      },
      "_types.query_dsl:Operator": {
        "type": "string",
        "enum": [
          "and",
          "AND",
          "or",
          "OR"
        ]
      },
      "_types:Fields": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Field"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          }
        ]
      },
      "_types:ExpandWildcards": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ExpandWildcard"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ExpandWildcard"
            }
          }
        ]
      },
      "_types:ExpandWildcard": {
        "type": "string",
        "enum": [
          "all",
          "open",
          "closed",
          "hidden",
          "none"
        ]
      },
      "_types:VersionString": {
        "type": "string"
      },
      "_types:SearchType": {
        "type": "string",
        "enum": [
          "query_then_fetch",
          "dfs_query_then_fetch"
        ]
      },
      "_types:SuggestMode": {
        "type": "string",
        "enum": [
          "missing",
          "popular",
          "always"
        ]
      },
      "_global.search._types:TrackHits": {
        "description": "Number of hits matching the query to count accurately. If true, the exact\nnumber of hits is returned at the cost of some performance. If false, the\nresponse does not include the total number of hits matching the query.\nDefaults to 10,000 hits.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "type": "number"
          }
        ]
      },
      "_global.search._types:SourceConfigParam": {
        "description": "Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.\nUsed as a query parameter along with the `_source_includes` and `_source_excludes` parameters.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "$ref": "#/components/schemas/_types:Fields"
          }
        ]
      },
      "_types.aggregations:AggregationContainer": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "aggregations": {
                "description": "Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                }
              },
              "meta": {
                "$ref": "#/components/schemas/_types:Metadata"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "adjacency_matrix": {
                "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixAggregation"
              },
              "auto_date_histogram": {
                "$ref": "#/components/schemas/_types.aggregations:AutoDateHistogramAggregation"
              },
              "avg": {
                "$ref": "#/components/schemas/_types.aggregations:AverageAggregation"
              },
              "avg_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:AverageBucketAggregation"
              },
              "boxplot": {
                "$ref": "#/components/schemas/_types.aggregations:BoxplotAggregation"
              },
              "bucket_script": {
                "$ref": "#/components/schemas/_types.aggregations:BucketScriptAggregation"
              },
              "bucket_selector": {
                "$ref": "#/components/schemas/_types.aggregations:BucketSelectorAggregation"
              },
              "bucket_sort": {
                "$ref": "#/components/schemas/_types.aggregations:BucketSortAggregation"
              },
              "bucket_count_ks_test": {
                "$ref": "#/components/schemas/_types.aggregations:BucketKsAggregation"
              },
              "bucket_correlation": {
                "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationAggregation"
              },
              "cardinality": {
                "$ref": "#/components/schemas/_types.aggregations:CardinalityAggregation"
              },
              "categorize_text": {
                "$ref": "#/components/schemas/_types.aggregations:CategorizeTextAggregation"
              },
              "children": {
                "$ref": "#/components/schemas/_types.aggregations:ChildrenAggregation"
              },
              "composite": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregation"
              },
              "cumulative_cardinality": {
                "$ref": "#/components/schemas/_types.aggregations:CumulativeCardinalityAggregation"
              },
              "cumulative_sum": {
                "$ref": "#/components/schemas/_types.aggregations:CumulativeSumAggregation"
              },
              "date_histogram": {
                "$ref": "#/components/schemas/_types.aggregations:DateHistogramAggregation"
              },
              "date_range": {
                "$ref": "#/components/schemas/_types.aggregations:DateRangeAggregation"
              },
              "derivative": {
                "$ref": "#/components/schemas/_types.aggregations:DerivativeAggregation"
              },
              "diversified_sampler": {
                "$ref": "#/components/schemas/_types.aggregations:DiversifiedSamplerAggregation"
              },
              "extended_stats": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsAggregation"
              },
              "extended_stats_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsBucketAggregation"
              },
              "frequent_item_sets": {
                "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsAggregation"
              },
              "filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "filters": {
                "$ref": "#/components/schemas/_types.aggregations:FiltersAggregation"
              },
              "geo_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:GeoBoundsAggregation"
              },
              "geo_centroid": {
                "$ref": "#/components/schemas/_types.aggregations:GeoCentroidAggregation"
              },
              "geo_distance": {
                "$ref": "#/components/schemas/_types.aggregations:GeoDistanceAggregation"
              },
              "geohash_grid": {
                "$ref": "#/components/schemas/_types.aggregations:GeoHashGridAggregation"
              },
              "geo_line": {
                "$ref": "#/components/schemas/_types.aggregations:GeoLineAggregation"
              },
              "geotile_grid": {
                "$ref": "#/components/schemas/_types.aggregations:GeoTileGridAggregation"
              },
              "geohex_grid": {
                "$ref": "#/components/schemas/_types.aggregations:GeohexGridAggregation"
              },
              "global": {
                "$ref": "#/components/schemas/_types.aggregations:GlobalAggregation"
              },
              "histogram": {
                "$ref": "#/components/schemas/_types.aggregations:HistogramAggregation"
              },
              "ip_range": {
                "$ref": "#/components/schemas/_types.aggregations:IpRangeAggregation"
              },
              "ip_prefix": {
                "$ref": "#/components/schemas/_types.aggregations:IpPrefixAggregation"
              },
              "inference": {
                "$ref": "#/components/schemas/_types.aggregations:InferenceAggregation"
              },
              "line": {
                "$ref": "#/components/schemas/_types.aggregations:GeoLineAggregation"
              },
              "matrix_stats": {
                "$ref": "#/components/schemas/_types.aggregations:MatrixStatsAggregation"
              },
              "max": {
                "$ref": "#/components/schemas/_types.aggregations:MaxAggregation"
              },
              "max_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:MaxBucketAggregation"
              },
              "median_absolute_deviation": {
                "$ref": "#/components/schemas/_types.aggregations:MedianAbsoluteDeviationAggregation"
              },
              "min": {
                "$ref": "#/components/schemas/_types.aggregations:MinAggregation"
              },
              "min_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:MinBucketAggregation"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:MissingAggregation"
              },
              "moving_avg": {
                "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregation"
              },
              "moving_percentiles": {
                "$ref": "#/components/schemas/_types.aggregations:MovingPercentilesAggregation"
              },
              "moving_fn": {
                "$ref": "#/components/schemas/_types.aggregations:MovingFunctionAggregation"
              },
              "multi_terms": {
                "$ref": "#/components/schemas/_types.aggregations:MultiTermsAggregation"
              },
              "nested": {
                "$ref": "#/components/schemas/_types.aggregations:NestedAggregation"
              },
              "normalize": {
                "$ref": "#/components/schemas/_types.aggregations:NormalizeAggregation"
              },
              "parent": {
                "$ref": "#/components/schemas/_types.aggregations:ParentAggregation"
              },
              "percentile_ranks": {
                "$ref": "#/components/schemas/_types.aggregations:PercentileRanksAggregation"
              },
              "percentiles": {
                "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregation"
              },
              "percentiles_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:PercentilesBucketAggregation"
              },
              "range": {
                "$ref": "#/components/schemas/_types.aggregations:RangeAggregation"
              },
              "rare_terms": {
                "$ref": "#/components/schemas/_types.aggregations:RareTermsAggregation"
              },
              "rate": {
                "$ref": "#/components/schemas/_types.aggregations:RateAggregation"
              },
              "reverse_nested": {
                "$ref": "#/components/schemas/_types.aggregations:ReverseNestedAggregation"
              },
              "random_sampler": {
                "$ref": "#/components/schemas/_types.aggregations:RandomSamplerAggregation"
              },
              "sampler": {
                "$ref": "#/components/schemas/_types.aggregations:SamplerAggregation"
              },
              "scripted_metric": {
                "$ref": "#/components/schemas/_types.aggregations:ScriptedMetricAggregation"
              },
              "serial_diff": {
                "$ref": "#/components/schemas/_types.aggregations:SerialDifferencingAggregation"
              },
              "significant_terms": {
                "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregation"
              },
              "significant_text": {
                "$ref": "#/components/schemas/_types.aggregations:SignificantTextAggregation"
              },
              "stats": {
                "$ref": "#/components/schemas/_types.aggregations:StatsAggregation"
              },
              "stats_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:StatsBucketAggregation"
              },
              "string_stats": {
                "$ref": "#/components/schemas/_types.aggregations:StringStatsAggregation"
              },
              "sum": {
                "$ref": "#/components/schemas/_types.aggregations:SumAggregation"
              },
              "sum_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:SumBucketAggregation"
              },
              "terms": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregation"
              },
              "time_series": {
                "$ref": "#/components/schemas/_types.aggregations:TimeSeriesAggregation"
              },
              "top_hits": {
                "$ref": "#/components/schemas/_types.aggregations:TopHitsAggregation"
              },
              "t_test": {
                "$ref": "#/components/schemas/_types.aggregations:TTestAggregation"
              },
              "top_metrics": {
                "$ref": "#/components/schemas/_types.aggregations:TopMetricsAggregation"
              },
              "value_count": {
                "$ref": "#/components/schemas/_types.aggregations:ValueCountAggregation"
              },
              "weighted_avg": {
                "$ref": "#/components/schemas/_types.aggregations:WeightedAverageAggregation"
              },
              "variable_width_histogram": {
                "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramAggregation"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.aggregations:AdjacencyMatrixAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "filters": {
                "description": "Filters used to create buckets.\nAt least one filter is required.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              },
              "separator": {
                "description": "Separator used to concatenate filter names. Defaults to &.",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.query_dsl:QueryContainer": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html"
        },
        "description": "An Elasticsearch Query DSL (Domain Specific Language) object that defines a query.",
        "type": "object",
        "properties": {
          "bool": {
            "$ref": "#/components/schemas/_types.query_dsl:BoolQuery"
          },
          "boosting": {
            "$ref": "#/components/schemas/_types.query_dsl:BoostingQuery"
          },
          "common": {
            "deprecated": true,
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:CommonTermsQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "combined_fields": {
            "$ref": "#/components/schemas/_types.query_dsl:CombinedFieldsQuery"
          },
          "constant_score": {
            "$ref": "#/components/schemas/_types.query_dsl:ConstantScoreQuery"
          },
          "dis_max": {
            "$ref": "#/components/schemas/_types.query_dsl:DisMaxQuery"
          },
          "distance_feature": {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQuery"
          },
          "exists": {
            "$ref": "#/components/schemas/_types.query_dsl:ExistsQuery"
          },
          "function_score": {
            "$ref": "#/components/schemas/_types.query_dsl:FunctionScoreQuery"
          },
          "fuzzy": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html"
            },
            "description": "Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:FuzzyQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "geo_bounding_box": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoBoundingBoxQuery"
          },
          "geo_distance": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoDistanceQuery"
          },
          "geo_grid": {
            "description": "Matches `geo_point` and `geo_shape` values that intersect a grid cell from a GeoGrid aggregation.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:GeoGridQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "geo_polygon": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoPolygonQuery"
          },
          "geo_shape": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoShapeQuery"
          },
          "has_child": {
            "$ref": "#/components/schemas/_types.query_dsl:HasChildQuery"
          },
          "has_parent": {
            "$ref": "#/components/schemas/_types.query_dsl:HasParentQuery"
          },
          "ids": {
            "$ref": "#/components/schemas/_types.query_dsl:IdsQuery"
          },
          "intervals": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-intervals-query.html"
            },
            "description": "Returns documents based on the order and proximity of matching terms.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:IntervalsQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "knn": {
            "$ref": "#/components/schemas/_types:KnnQuery"
          },
          "match": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html"
            },
            "description": "Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_all": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchAllQuery"
          },
          "match_bool_prefix": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-bool-prefix-query.html"
            },
            "description": "Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchBoolPrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_none": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchNoneQuery"
          },
          "match_phrase": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html"
            },
            "description": "Analyzes the text and creates a phrase query out of the analyzed text.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchPhraseQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_phrase_prefix": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html"
            },
            "description": "Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchPhrasePrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "more_like_this": {
            "$ref": "#/components/schemas/_types.query_dsl:MoreLikeThisQuery"
          },
          "multi_match": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiMatchQuery"
          },
          "nested": {
            "$ref": "#/components/schemas/_types.query_dsl:NestedQuery"
          },
          "parent_id": {
            "$ref": "#/components/schemas/_types.query_dsl:ParentIdQuery"
          },
          "percolate": {
            "$ref": "#/components/schemas/_types.query_dsl:PercolateQuery"
          },
          "pinned": {
            "$ref": "#/components/schemas/_types.query_dsl:PinnedQuery"
          },
          "prefix": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html"
            },
            "description": "Returns documents that contain a specific prefix in a provided field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:PrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryStringQuery"
          },
          "range": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html"
            },
            "description": "Returns documents that contain terms within a provided range.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RangeQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "rank_feature": {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureQuery"
          },
          "regexp": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html"
            },
            "description": "Returns documents that contain terms matching a regular expression.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RegexpQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "rule": {
            "$ref": "#/components/schemas/_types.query_dsl:RuleQuery"
          },
          "script": {
            "$ref": "#/components/schemas/_types.query_dsl:ScriptQuery"
          },
          "script_score": {
            "$ref": "#/components/schemas/_types.query_dsl:ScriptScoreQuery"
          },
          "semantic": {
            "$ref": "#/components/schemas/_types.query_dsl:SemanticQuery"
          },
          "shape": {
            "$ref": "#/components/schemas/_types.query_dsl:ShapeQuery"
          },
          "simple_query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringQuery"
          },
          "span_containing": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanContainingQuery"
          },
          "span_field_masking": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFieldMaskingQuery"
          },
          "span_first": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFirstQuery"
          },
          "span_multi": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanMultiTermQuery"
          },
          "span_near": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNearQuery"
          },
          "span_not": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNotQuery"
          },
          "span_or": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanOrQuery"
          },
          "span_term": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-term-query.html"
            },
            "description": "Matches spans containing a term.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:SpanTermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "span_within": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanWithinQuery"
          },
          "sparse_vector": {
            "$ref": "#/components/schemas/_types.query_dsl:SparseVectorQuery"
          },
          "term": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html"
            },
            "description": "Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "terms": {
            "$ref": "#/components/schemas/_types.query_dsl:TermsQuery"
          },
          "terms_set": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-set-query.html"
            },
            "description": "Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermsSetQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "text_expansion": {
            "deprecated": true,
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-text-expansion-query.html"
            },
            "description": "Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a sparse vector or rank features field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TextExpansionQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "weighted_tokens": {
            "deprecated": true,
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-weighted-tokens-query.html"
            },
            "description": "Supports returning text_expansion query results by sending in precomputed tokens with the query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:WeightedTokensQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "wildcard": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html"
            },
            "description": "Returns documents that contain terms matching a wildcard pattern.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:WildcardQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "wrapper": {
            "$ref": "#/components/schemas/_types.query_dsl:WrapperQuery"
          },
          "type": {
            "$ref": "#/components/schemas/_types.query_dsl:TypeQuery"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:BoolQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "description": "The clause (query) must appear in matching documents.\nHowever, unlike `must`, the score of the query will be ignored.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "must": {
                "description": "The clause (query) must appear in matching documents and will contribute to the score.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "must_not": {
                "description": "The clause (query) must not appear in the matching documents.\nBecause scoring is ignored, a score of `0` is returned for all documents.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "should": {
                "description": "The clause (query) should appear in the matching document.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "_types:MinimumShouldMatch": {
        "description": "The minimum number of terms that should match as integer, percentage or range",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.query_dsl:QueryBase": {
        "type": "object",
        "properties": {
          "boost": {
            "description": "Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score.",
            "type": "number"
          },
          "_name": {
            "type": "string"
          }
        }
      },
      "_types.query_dsl:BoostingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "negative_boost": {
                "description": "Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.",
                "type": "number"
              },
              "negative": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "positive": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              }
            },
            "required": [
              "negative_boost",
              "negative",
              "positive"
            ]
          }
        ]
      },
      "_types.query_dsl:CommonTermsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "cutoff_frequency": {
                "type": "number"
              },
              "high_freq_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "low_freq_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "query": {
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:CombinedFieldsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "fields": {
                "description": "List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "query": {
                "description": "Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If true, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:CombinedFieldsOperator"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:CombinedFieldsZeroTerms"
              }
            },
            "required": [
              "fields",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:CombinedFieldsOperator": {
        "type": "string",
        "enum": [
          "or",
          "and"
        ]
      },
      "_types.query_dsl:CombinedFieldsZeroTerms": {
        "type": "string",
        "enum": [
          "none",
          "all"
        ]
      },
      "_types.query_dsl:ConstantScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              }
            },
            "required": [
              "filter"
            ]
          }
        ]
      },
      "_types.query_dsl:DisMaxQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "queries": {
                "description": "One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Elasticsearch uses the highest relevance score.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              },
              "tie_breaker": {
                "description": "Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.",
                "type": "number"
              }
            },
            "required": [
              "queries"
            ]
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQuery": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-distance-feature-query.html"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:UntypedDistanceFeatureQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:GeoDistanceFeatureQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:DateDistanceFeatureQuery"
          }
        ]
      },
      "_types.query_dsl:UntypedDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQueryBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "description": "Date or point of origin used to calculate distances.\nIf the `field` value is a `date` or `date_nanos` field, the `origin` value must be a date.\nDate Math, such as `now-1h`, is supported.\nIf the field value is a `geo_point` field, the `origin` value must be a geopoint.",
                "type": "object"
              },
              "pivot": {
                "description": "Distance from the `origin` at which relevance scores receive half of the `boost` value.\nIf the `field` value is a `date` or `date_nanos` field, the `pivot` value must be a time unit, such as `1h` or `10d`. If the `field` value is a `geo_point` field, the `pivot` value must be a distance unit, such as `1km` or `12m`.",
                "type": "object"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:GeoDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQueryBaseGeoLocationDistance"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQueryBaseGeoLocationDistance": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              },
              "pivot": {
                "$ref": "#/components/schemas/_types:Distance"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "_types:Distance": {
        "type": "string"
      },
      "_types.query_dsl:DateDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQueryBaseDateMathDuration"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQueryBaseDateMathDuration": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "pivot": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "_types:DateMath": {
        "type": "string"
      },
      "_types.query_dsl:ExistsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:FunctionScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "boost_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:FunctionBoostMode"
              },
              "functions": {
                "description": "One or more functions that compute a new score for each document returned by the query.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:FunctionScoreContainer"
                }
              },
              "max_boost": {
                "description": "Restricts the new score to not exceed the provided limit.",
                "type": "number"
              },
              "min_score": {
                "description": "Excludes documents that do not meet the provided score threshold.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:FunctionScoreMode"
              }
            }
          }
        ]
      },
      "_types.query_dsl:FunctionBoostMode": {
        "type": "string",
        "enum": [
          "multiply",
          "replace",
          "sum",
          "avg",
          "max",
          "min"
        ]
      },
      "_types.query_dsl:FunctionScoreContainer": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "weight": {
                "type": "number"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "exp": {
                "$ref": "#/components/schemas/_types.query_dsl:DecayFunction"
              },
              "gauss": {
                "$ref": "#/components/schemas/_types.query_dsl:DecayFunction"
              },
              "linear": {
                "$ref": "#/components/schemas/_types.query_dsl:DecayFunction"
              },
              "field_value_factor": {
                "$ref": "#/components/schemas/_types.query_dsl:FieldValueFactorScoreFunction"
              },
              "random_score": {
                "$ref": "#/components/schemas/_types.query_dsl:RandomScoreFunction"
              },
              "script_score": {
                "$ref": "#/components/schemas/_types.query_dsl:ScriptScoreFunction"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.query_dsl:DecayFunction": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:UntypedDecayFunction"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:DateDecayFunction"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:NumericDecayFunction"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:GeoDecayFunction"
          }
        ]
      },
      "_types.query_dsl:UntypedDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DecayFunctionBase": {
        "type": "object",
        "properties": {
          "multi_value_mode": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiValueMode"
          }
        }
      },
      "_types.query_dsl:MultiValueMode": {
        "type": "string",
        "enum": [
          "min",
          "max",
          "avg",
          "sum"
        ]
      },
      "_types.query_dsl:DateDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBaseDateMathDuration"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DecayFunctionBaseDateMathDuration": {
        "type": "object",
        "properties": {
          "multi_value_mode": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiValueMode"
          }
        }
      },
      "_types.query_dsl:NumericDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBasedoubledouble"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DecayFunctionBasedoubledouble": {
        "type": "object",
        "properties": {
          "multi_value_mode": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiValueMode"
          }
        }
      },
      "_types.query_dsl:GeoDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBaseGeoLocationDistance"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DecayFunctionBaseGeoLocationDistance": {
        "type": "object",
        "properties": {
          "multi_value_mode": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiValueMode"
          }
        }
      },
      "_types.query_dsl:FieldValueFactorScoreFunction": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "factor": {
            "description": "Optional factor to multiply the field value with.",
            "type": "number"
          },
          "missing": {
            "description": "Value used if the document doesnâ€™t have that field.\nThe modifier and factor are still applied to it as though it were read from the document.",
            "type": "number"
          },
          "modifier": {
            "$ref": "#/components/schemas/_types.query_dsl:FieldValueFactorModifier"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.query_dsl:FieldValueFactorModifier": {
        "type": "string",
        "enum": [
          "none",
          "log",
          "log1p",
          "log2p",
          "ln",
          "ln1p",
          "ln2p",
          "square",
          "sqrt",
          "reciprocal"
        ]
      },
      "_types.query_dsl:RandomScoreFunction": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "seed": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "_types.query_dsl:ScriptScoreFunction": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types:Script": {
        "type": "object",
        "properties": {
          "source": {
            "description": "The script source.",
            "type": "string"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "description": "Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "lang": {
            "$ref": "#/components/schemas/_types:ScriptLanguage"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "_types:ScriptLanguage": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "painless",
              "expression",
              "mustache",
              "java"
            ]
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.query_dsl:FunctionScoreMode": {
        "type": "string",
        "enum": [
          "multiply",
          "sum",
          "avg",
          "first",
          "max",
          "min"
        ]
      },
      "_types.query_dsl:FuzzyQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "max_expansions": {
                "description": "Maximum number of variations created.",
                "type": "number"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged when creating expansions.",
                "type": "number"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "transpositions": {
                "description": "Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`).",
                "type": "boolean"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "value": {
                "description": "Term you wish to find in the provided field.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types:MultiTermQueryRewrite": {
        "type": "string"
      },
      "_types:Fuzziness": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "_types.query_dsl:GeoBoundingBoxQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoExecution"
              },
              "validation_method": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoValidationMethod"
              },
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:GeoExecution": {
        "type": "string",
        "enum": [
          "memory",
          "indexed"
        ]
      },
      "_types.query_dsl:GeoValidationMethod": {
        "type": "string",
        "enum": [
          "coerce",
          "ignore_malformed",
          "strict"
        ]
      },
      "_types.query_dsl:GeoDistanceQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "distance": {
                "$ref": "#/components/schemas/_types:Distance"
              },
              "distance_type": {
                "$ref": "#/components/schemas/_types:GeoDistanceType"
              },
              "validation_method": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoValidationMethod"
              },
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            },
            "required": [
              "distance"
            ]
          }
        ]
      },
      "_types:GeoDistanceType": {
        "type": "string",
        "enum": [
          "arc",
          "plane"
        ]
      },
      "_types.query_dsl:GeoGridQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "geogrid": {
                "$ref": "#/components/schemas/_types:GeoTile"
              },
              "geohash": {
                "$ref": "#/components/schemas/_types:GeoHash"
              },
              "geohex": {
                "$ref": "#/components/schemas/_types:GeoHexCell"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.query_dsl:GeoPolygonQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "validation_method": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoValidationMethod"
              },
              "ignore_unmapped": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:GeoShapeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:HasChildQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              "max_children": {
                "description": "Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results.",
                "type": "number"
              },
              "min_children": {
                "description": "Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:ChildScoreMode"
              },
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            },
            "required": [
              "query",
              "type"
            ]
          }
        ]
      },
      "_global.search._types:InnerHits": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "size": {
            "description": "The maximum number of hits to return per `inner_hits`.",
            "type": "number"
          },
          "from": {
            "description": "Inner hit starting document offset.",
            "type": "number"
          },
          "collapse": {
            "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
          },
          "docvalue_fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
            }
          },
          "explain": {
            "type": "boolean"
          },
          "highlight": {
            "$ref": "#/components/schemas/_global.search._types:Highlight"
          },
          "ignore_unmapped": {
            "type": "boolean"
          },
          "script_fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "seq_no_primary_term": {
            "type": "boolean"
          },
          "fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:Sort"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "stored_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "track_scores": {
            "type": "boolean"
          },
          "version": {
            "type": "boolean"
          }
        }
      },
      "_types:Name": {
        "type": "string"
      },
      "_global.search._types:FieldCollapse": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "inner_hits": {
            "description": "The number of inner hits and their sort order",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_global.search._types:InnerHits"
                }
              }
            ]
          },
          "max_concurrent_group_searches": {
            "description": "The number of concurrent requests allowed to retrieve the inner_hits per group",
            "type": "number"
          },
          "collapse": {
            "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.query_dsl:FieldAndFormat": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "format": {
            "description": "The format in which the values are returned.",
            "type": "string"
          },
          "include_unmapped": {
            "type": "boolean"
          }
        },
        "required": [
          "field"
        ]
      },
      "_global.search._types:Highlight": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:HighlightBase"
          },
          {
            "type": "object",
            "properties": {
              "encoder": {
                "$ref": "#/components/schemas/_global.search._types:HighlighterEncoder"
              },
              "fields": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_global.search._types:HighlightField"
                }
              }
            },
            "required": [
              "fields"
            ]
          }
        ]
      },
      "_global.search._types:HighlighterEncoder": {
        "type": "string",
        "enum": [
          "default",
          "html"
        ]
      },
      "_global.search._types:HighlightField": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:HighlightBase"
          },
          {
            "type": "object",
            "properties": {
              "fragment_offset": {
                "type": "number"
              },
              "matched_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              }
            }
          }
        ]
      },
      "_global.search._types:HighlightBase": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterType"
          },
          "boundary_chars": {
            "description": "A string that contains each boundary character.",
            "type": "string"
          },
          "boundary_max_scan": {
            "description": "How far to scan for boundary characters.",
            "type": "number"
          },
          "boundary_scanner": {
            "$ref": "#/components/schemas/_global.search._types:BoundaryScanner"
          },
          "boundary_scanner_locale": {
            "description": "Controls which locale is used to search for sentence and word boundaries.\nThis parameter takes a form of a language tag, for example: `\"en-US\"`, `\"fr-FR\"`, `\"ja-JP\"`.",
            "type": "string"
          },
          "force_source": {
            "deprecated": true,
            "type": "boolean"
          },
          "fragmenter": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterFragmenter"
          },
          "fragment_size": {
            "description": "The size of the highlighted fragment in characters.",
            "type": "number"
          },
          "highlight_filter": {
            "type": "boolean"
          },
          "highlight_query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "max_fragment_length": {
            "type": "number"
          },
          "max_analyzed_offset": {
            "description": "If set to a non-negative value, highlighting stops at this defined maximum limit.\nThe rest of the text is not processed, thus not highlighted and no error is returned\nThe `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when itâ€™s set to lower value than the query setting.",
            "type": "number"
          },
          "no_match_size": {
            "description": "The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.",
            "type": "number"
          },
          "number_of_fragments": {
            "description": "The maximum number of fragments to return.\nIf the number of fragments is set to `0`, no fragments are returned.\nInstead, the entire field contents are highlighted and returned.\nThis can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.\nIf `number_of_fragments` is `0`, `fragment_size` is ignored.",
            "type": "number"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "order": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterOrder"
          },
          "phrase_limit": {
            "description": "Controls the number of matching phrases in a document that are considered.\nPrevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.\nWhen using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.\nOnly supported by the `fvh` highlighter.",
            "type": "number"
          },
          "post_tags": {
            "description": "Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "pre_tags": {
            "description": "Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "require_field_match": {
            "description": "By default, only fields that contains a query match are highlighted.\nSet to `false` to highlight all fields.",
            "type": "boolean"
          },
          "tags_schema": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterTagsSchema"
          }
        }
      },
      "_global.search._types:HighlighterType": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "plain",
              "fvh",
              "unified"
            ]
          },
          {
            "type": "string"
          }
        ]
      },
      "_global.search._types:BoundaryScanner": {
        "type": "string",
        "enum": [
          "chars",
          "sentence",
          "word"
        ]
      },
      "_global.search._types:HighlighterFragmenter": {
        "type": "string",
        "enum": [
          "simple",
          "span"
        ]
      },
      "_global.search._types:HighlighterOrder": {
        "type": "string",
        "enum": [
          "score"
        ]
      },
      "_global.search._types:HighlighterTagsSchema": {
        "type": "string",
        "enum": [
          "styled"
        ]
      },
      "_types:ScriptField": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "ignore_failure": {
            "type": "boolean"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types:Sort": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:SortCombinations"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:SortCombinations"
            }
          }
        ]
      },
      "_types:SortCombinations": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Field"
          },
          {
            "$ref": "#/components/schemas/_types:SortOptions"
          }
        ]
      },
      "_types:SortOptions": {
        "type": "object",
        "properties": {
          "_score": {
            "$ref": "#/components/schemas/_types:ScoreSort"
          },
          "_doc": {
            "$ref": "#/components/schemas/_types:ScoreSort"
          },
          "_geo_distance": {
            "$ref": "#/components/schemas/_types:GeoDistanceSort"
          },
          "_script": {
            "$ref": "#/components/schemas/_types:ScriptSort"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:ScoreSort": {
        "type": "object",
        "properties": {
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          }
        }
      },
      "_types:SortOrder": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ]
      },
      "_types:GeoDistanceSort": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/_types:SortMode"
          },
          "distance_type": {
            "$ref": "#/components/schemas/_types:GeoDistanceType"
          },
          "ignore_unmapped": {
            "type": "boolean"
          },
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          },
          "unit": {
            "$ref": "#/components/schemas/_types:DistanceUnit"
          },
          "nested": {
            "$ref": "#/components/schemas/_types:NestedSortValue"
          }
        }
      },
      "_types:SortMode": {
        "type": "string",
        "enum": [
          "min",
          "max",
          "sum",
          "avg",
          "median"
        ]
      },
      "_types:DistanceUnit": {
        "type": "string",
        "enum": [
          "in",
          "ft",
          "yd",
          "mi",
          "nmi",
          "km",
          "m",
          "cm",
          "mm"
        ]
      },
      "_types:NestedSortValue": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "max_children": {
            "type": "number"
          },
          "nested": {
            "$ref": "#/components/schemas/_types:NestedSortValue"
          },
          "path": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "path"
        ]
      },
      "_types:ScriptSort": {
        "type": "object",
        "properties": {
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "type": {
            "$ref": "#/components/schemas/_types:ScriptSortType"
          },
          "mode": {
            "$ref": "#/components/schemas/_types:SortMode"
          },
          "nested": {
            "$ref": "#/components/schemas/_types:NestedSortValue"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types:ScriptSortType": {
        "type": "string",
        "enum": [
          "string",
          "number",
          "version"
        ]
      },
      "_global.search._types:SourceConfig": {
        "description": "Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "$ref": "#/components/schemas/_global.search._types:SourceFilter"
          }
        ]
      },
      "_global.search._types:SourceFilter": {
        "type": "object",
        "properties": {
          "excludes": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "includes": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        }
      },
      "_types.query_dsl:ChildScoreMode": {
        "type": "string",
        "enum": [
          "none",
          "avg",
          "sum",
          "max",
          "min"
        ]
      },
      "_types:RelationName": {
        "type": "string"
      },
      "_types.query_dsl:HasParentQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              "parent_type": {
                "$ref": "#/components/schemas/_types:RelationName"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score": {
                "description": "Indicates whether the relevance score of a matching parent document is aggregated into its child documents.",
                "type": "boolean"
              }
            },
            "required": [
              "parent_type",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:IdsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/_types:Ids"
              }
            }
          }
        ]
      },
      "_types:Ids": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Id"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          }
        ]
      },
      "_types.query_dsl:IntervalsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-intervals-query.html"
            },
            "type": "object",
            "properties": {
              "all_of": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsAllOf"
              },
              "any_of": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsAnyOf"
              },
              "fuzzy": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsFuzzy"
              },
              "match": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsMatch"
              },
              "prefix": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsPrefix"
              },
              "wildcard": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsWildcard"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.query_dsl:IntervalsAllOf": {
        "type": "object",
        "properties": {
          "intervals": {
            "description": "An array of rules to combine. All rules must produce a match in a document for the overall source to match.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
            }
          },
          "max_gaps": {
            "description": "Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches.",
            "type": "number"
          },
          "ordered": {
            "description": "If `true`, intervals produced by the rules should appear in the order in which they are specified.",
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFilter"
          }
        },
        "required": [
          "intervals"
        ]
      },
      "_types.query_dsl:IntervalsContainer": {
        "type": "object",
        "properties": {
          "all_of": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsAllOf"
          },
          "any_of": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsAnyOf"
          },
          "fuzzy": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFuzzy"
          },
          "match": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsMatch"
          },
          "prefix": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsPrefix"
          },
          "wildcard": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsWildcard"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:IntervalsAnyOf": {
        "type": "object",
        "properties": {
          "intervals": {
            "description": "An array of rules to match.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
            }
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFilter"
          }
        },
        "required": [
          "intervals"
        ]
      },
      "_types.query_dsl:IntervalsFilter": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "before": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "contained_by": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "containing": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "not_contained_by": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "not_containing": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "not_overlapping": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "overlapping": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:IntervalsFuzzy": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to normalize the term.",
            "type": "string"
          },
          "fuzziness": {
            "$ref": "#/components/schemas/_types:Fuzziness"
          },
          "prefix_length": {
            "description": "Number of beginning characters left unchanged when creating expansions.",
            "type": "number"
          },
          "term": {
            "description": "The term to match.",
            "type": "string"
          },
          "transpositions": {
            "description": "Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).",
            "type": "boolean"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "term"
        ]
      },
      "_types.query_dsl:IntervalsMatch": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze terms in the query.",
            "type": "string"
          },
          "max_gaps": {
            "description": "Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches.",
            "type": "number"
          },
          "ordered": {
            "description": "If `true`, matching terms must appear in their specified order.",
            "type": "boolean"
          },
          "query": {
            "description": "Text you wish to find in the provided field.",
            "type": "string"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFilter"
          }
        },
        "required": [
          "query"
        ]
      },
      "_types.query_dsl:IntervalsPrefix": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze the `prefix`.",
            "type": "string"
          },
          "prefix": {
            "description": "Beginning characters of terms you wish to find in the top-level field.",
            "type": "string"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "prefix"
        ]
      },
      "_types.query_dsl:IntervalsWildcard": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze the `pattern`.\nDefaults to the top-level field's analyzer.",
            "type": "string"
          },
          "pattern": {
            "description": "Wildcard pattern used to find matching terms.",
            "type": "string"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "pattern"
        ]
      },
      "_types:KnnQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "query_vector": {
                "$ref": "#/components/schemas/_types:QueryVector"
              },
              "query_vector_builder": {
                "$ref": "#/components/schemas/_types:QueryVectorBuilder"
              },
              "num_candidates": {
                "description": "The number of nearest neighbor candidates to consider per shard",
                "type": "number"
              },
              "k": {
                "description": "The final number of nearest neighbors to return as top hits",
                "type": "number"
              },
              "filter": {
                "description": "Filters for the kNN search query",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "similarity": {
                "description": "The minimum similarity for a vector to be considered a match",
                "type": "number"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types:QueryVector": {
        "type": "array",
        "items": {
          "type": "number"
        }
      },
      "_types:QueryVectorBuilder": {
        "type": "object",
        "properties": {
          "text_embedding": {
            "$ref": "#/components/schemas/_types:TextEmbedding"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:TextEmbedding": {
        "type": "object",
        "properties": {
          "model_id": {
            "type": "string"
          },
          "model_text": {
            "type": "string"
          }
        },
        "required": [
          "model_id",
          "model_text"
        ]
      },
      "_types.query_dsl:MatchQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "cutoff_frequency": {
                "deprecated": true,
                "type": "number"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "query": {
                "description": "Text, number, boolean value or date you wish to find in the provided field.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:ZeroTermsQuery": {
        "type": "string",
        "enum": [
          "all",
          "none"
        ]
      },
      "_types.query_dsl:MatchAllQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:MatchBoolPrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "number"
              },
              "query": {
                "description": "Terms you wish to find in the provided field.\nThe last term is used in a prefix query.",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:MatchNoneQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:MatchPhraseQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "query": {
                "description": "Query terms that are analyzed and turned into a phrase query.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:MatchPhrasePrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert text in the query value into tokens.",
                "type": "string"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the last provided term of the query value will expand.",
                "type": "number"
              },
              "query": {
                "description": "Text you wish to find in the provided field.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:MoreLikeThisQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields.",
                "type": "string"
              },
              "boost_terms": {
                "description": "Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0).",
                "type": "number"
              },
              "fail_on_unsupported_field": {
                "description": "Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`).",
                "type": "boolean"
              },
              "fields": {
                "description": "A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "include": {
                "description": "Specifies whether the input documents should also be included in the search results returned.",
                "type": "boolean"
              },
              "like": {
                "description": "Specifies free form text and/or a single or multiple documents for which you want to find similar documents.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:Like"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:Like"
                    }
                  }
                ]
              },
              "max_doc_freq": {
                "description": "The maximum document frequency above which the terms are ignored from the input document.",
                "type": "number"
              },
              "max_query_terms": {
                "description": "The maximum number of query terms that can be selected.",
                "type": "number"
              },
              "max_word_length": {
                "description": "The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`).",
                "type": "number"
              },
              "min_doc_freq": {
                "description": "The minimum document frequency below which the terms are ignored from the input document.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "min_term_freq": {
                "description": "The minimum term frequency below which the terms are ignored from the input document.",
                "type": "number"
              },
              "min_word_length": {
                "description": "The minimum word length below which the terms are ignored.",
                "type": "number"
              },
              "routing": {
                "$ref": "#/components/schemas/_types:Routing"
              },
              "stop_words": {
                "$ref": "#/components/schemas/_types.analysis:StopWords"
              },
              "unlike": {
                "description": "Used in combination with `like` to exclude documents that match a set of terms.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:Like"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:Like"
                    }
                  }
                ]
              },
              "version": {
                "$ref": "#/components/schemas/_types:VersionNumber"
              },
              "version_type": {
                "$ref": "#/components/schemas/_types:VersionType"
              }
            },
            "required": [
              "like"
            ]
          }
        ]
      },
      "_types.query_dsl:Like": {
        "description": "Text that we want similar documents for or a lookup to a document's field for the text.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:LikeDocument"
          }
        ]
      },
      "_types.query_dsl:LikeDocument": {
        "type": "object",
        "properties": {
          "doc": {
            "description": "A document not present in the index.",
            "type": "object"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "per_field_analyzer": {
            "description": "Overrides the default analyzer.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        }
      },
      "_types:VersionType": {
        "type": "string",
        "enum": [
          "internal",
          "external",
          "external_gte",
          "force"
        ]
      },
      "_types.analysis:StopWords": {
        "description": "Language value, such as _arabic_ or _thai_. Defaults to _english_.\nEach language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.\nAlso accepts an array of stop words.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "_types.query_dsl:MultiMatchQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "cutoff_frequency": {
                "deprecated": true,
                "type": "number"
              },
              "fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "query": {
                "description": "Text, number, boolean value or date you wish to find in the provided field.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "tie_breaker": {
                "description": "Determines how scores for each per-term blended query and scores across groups are combined.",
                "type": "number"
              },
              "type": {
                "$ref": "#/components/schemas/_types.query_dsl:TextQueryType"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:TextQueryType": {
        "type": "string",
        "enum": [
          "best_fields",
          "most_fields",
          "cross_fields",
          "phrase",
          "phrase_prefix",
          "bool_prefix"
        ]
      },
      "_types.query_dsl:NestedQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped path and not return any documents instead of an error.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:ChildScoreMode"
              }
            },
            "required": [
              "path",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:ParentIdQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
                "type": "boolean"
              },
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            }
          }
        ]
      },
      "_types.query_dsl:PercolateQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "document": {
                "description": "The source of the document being percolated.",
                "type": "object"
              },
              "documents": {
                "description": "An array of sources of the documents being percolated.",
                "type": "array",
                "items": {
                  "type": "object"
                }
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "index": {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              "name": {
                "description": "The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified.",
                "type": "string"
              },
              "preference": {
                "description": "Preference used to fetch document to percolate.",
                "type": "string"
              },
              "routing": {
                "$ref": "#/components/schemas/_types:Routing"
              },
              "version": {
                "$ref": "#/components/schemas/_types:VersionNumber"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:PinnedQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-pinned-query.html"
            },
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "organic": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  }
                },
                "required": [
                  "organic"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "ids": {
                    "description": "Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "docs": {
                    "description": "Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:PinnedDoc"
                    }
                  }
                },
                "minProperties": 1,
                "maxProperties": 1
              }
            ]
          }
        ]
      },
      "_types.query_dsl:PinnedDoc": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "_id",
          "_index"
        ]
      },
      "_types.query_dsl:PrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "value": {
                "description": "Beginning characters of terms you wish to find in the provided field.",
                "type": "string"
              },
              "case_insensitive": {
                "description": "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:QueryStringQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "allow_leading_wildcard": {
                "description": "If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string.",
                "type": "boolean"
              },
              "analyzer": {
                "description": "Analyzer used to convert text in the query string into tokens.",
                "type": "string"
              },
              "analyze_wildcard": {
                "description": "If `true`, the query attempts to analyze wildcard terms in the query string.",
                "type": "boolean"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "default_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "default_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "enable_position_increments": {
                "description": "If `true`, enable position increments in queries constructed from a `query_string` search.",
                "type": "boolean"
              },
              "escape": {
                "type": "boolean"
              },
              "fields": {
                "description": "Array of fields to search. Supports wildcards (`*`).",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_max_expansions": {
                "description": "Maximum number of terms to which the query expands for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_determinized_states": {
                "description": "Maximum number of automaton states required for the query.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "phrase_slop": {
                "description": "Maximum number of positions allowed between matching tokens for phrases.",
                "type": "number"
              },
              "query": {
                "description": "Query string you wish to parse and use for search.",
                "type": "string"
              },
              "quote_analyzer": {
                "description": "Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.",
                "type": "string"
              },
              "quote_field_suffix": {
                "description": "Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches.",
                "type": "string"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "tie_breaker": {
                "description": "How to combine the queries generated from the individual search terms in the resulting `dis_max` query.",
                "type": "number"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              },
              "type": {
                "$ref": "#/components/schemas/_types.query_dsl:TextQueryType"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types:TimeZone": {
        "type": "string"
      },
      "_types.query_dsl:RangeQuery": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:UntypedRangeQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:DateRangeQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:NumberRangeQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:TermRangeQuery"
          }
        ]
      },
      "_types.query_dsl:UntypedRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RangeQueryBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "$ref": "#/components/schemas/_types:DateFormat"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types:DateFormat": {
        "type": "string"
      },
      "_types.query_dsl:RangeQueryBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "relation": {
                "$ref": "#/components/schemas/_types.query_dsl:RangeRelation"
              },
              "gt": {
                "description": "Greater than.",
                "type": "object"
              },
              "gte": {
                "description": "Greater than or equal to.",
                "type": "object"
              },
              "lt": {
                "description": "Less than.",
                "type": "object"
              },
              "lte": {
                "description": "Less than or equal to.",
                "type": "object"
              },
              "from": {
                "deprecated": true,
                "oneOf": [
                  {
                    "type": "object"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "deprecated": true,
                "oneOf": [
                  {
                    "type": "object"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              }
            }
          }
        ]
      },
      "_types.query_dsl:RangeRelation": {
        "type": "string",
        "enum": [
          "within",
          "contains",
          "intersects"
        ]
      },
      "_types.query_dsl:DateRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RangeQueryBaseDateMath"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "$ref": "#/components/schemas/_types:DateFormat"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types.query_dsl:RangeQueryBaseDateMath": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "relation": {
                "$ref": "#/components/schemas/_types.query_dsl:RangeRelation"
              },
              "gt": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "gte": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "lt": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "lte": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "from": {
                "deprecated": true,
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types:DateMath"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "deprecated": true,
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types:DateMath"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              }
            }
          }
        ]
      },
      "_types.query_dsl:NumberRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RangeQueryBasedouble"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:RangeQueryBasedouble": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "relation": {
                "$ref": "#/components/schemas/_types.query_dsl:RangeRelation"
              },
              "gt": {
                "description": "Greater than.",
                "type": "number"
              },
              "gte": {
                "description": "Greater than or equal to.",
                "type": "number"
              },
              "lt": {
                "description": "Less than.",
                "type": "number"
              },
              "lte": {
                "description": "Less than or equal to.",
                "type": "number"
              },
              "from": {
                "deprecated": true,
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "deprecated": true,
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              }
            }
          }
        ]
      },
      "_types.query_dsl:TermRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RangeQueryBasestring"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:RangeQueryBasestring": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "relation": {
                "$ref": "#/components/schemas/_types.query_dsl:RangeRelation"
              },
              "gt": {
                "description": "Greater than.",
                "type": "string"
              },
              "gte": {
                "description": "Greater than or equal to.",
                "type": "string"
              },
              "lt": {
                "description": "Less than.",
                "type": "string"
              },
              "lte": {
                "description": "Less than or equal to.",
                "type": "string"
              },
              "from": {
                "deprecated": true,
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "deprecated": true,
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              }
            }
          }
        ]
      },
      "_types.query_dsl:RankFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "saturation": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionSaturation"
              },
              "log": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionLogarithm"
              },
              "linear": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionLinear"
              },
              "sigmoid": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionSigmoid"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunctionSaturation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "pivot": {
                "description": "Configurable pivot value so that the result will be less than 0.5.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunction": {
        "type": "object"
      },
      "_types.query_dsl:RankFeatureFunctionLogarithm": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "scaling_factor": {
                "description": "Configurable scaling factor.",
                "type": "number"
              }
            },
            "required": [
              "scaling_factor"
            ]
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunctionLinear": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunctionSigmoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "pivot": {
                "description": "Configurable pivot value so that the result will be less than 0.5.",
                "type": "number"
              },
              "exponent": {
                "description": "Configurable Exponent.",
                "type": "number"
              }
            },
            "required": [
              "pivot",
              "exponent"
            ]
          }
        ]
      },
      "_types.query_dsl:RegexpQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "case_insensitive": {
                "description": "Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              },
              "flags": {
                "description": "Enables optional operators for the regular expression.",
                "type": "string"
              },
              "max_determinized_states": {
                "description": "Maximum number of automaton states required for the query.",
                "type": "number"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "value": {
                "description": "Regular expression for terms you wish to find in the provided field.",
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:RuleQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "organic": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "ruleset_ids": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Id"
                }
              },
              "match_criteria": {
                "type": "object"
              }
            },
            "required": [
              "organic",
              "ruleset_ids",
              "match_criteria"
            ]
          }
        ]
      },
      "_types.query_dsl:ScriptQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "script"
            ]
          }
        ]
      },
      "_types.query_dsl:ScriptScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "min_score": {
                "description": "Documents with a score lower than this floating point number are excluded from the search results.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "query",
              "script"
            ]
          }
        ]
      },
      "_types.query_dsl:SemanticQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "description": "The field to query, which must be a semantic_text field type",
                "type": "string"
              },
              "query": {
                "description": "The query text",
                "type": "string"
              }
            },
            "required": [
              "field",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:ShapeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "When set to `true` the query ignores an unmapped field and will not match any documents.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:SimpleQueryStringQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "description": "Analyzer used to convert text in the query string into tokens.",
                "type": "string"
              },
              "analyze_wildcard": {
                "description": "If `true`, the query attempts to analyze wildcard terms in the query string.",
                "type": "boolean"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, the parser creates a match_phrase query for each multi-position token.",
                "type": "boolean"
              },
              "default_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "fields": {
                "description": "Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "flags": {
                "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringFlags"
              },
              "fuzzy_max_expansions": {
                "description": "Maximum number of terms to which the query expands for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "query": {
                "description": "Query string in the simple query string syntax you wish to parse and use for search.",
                "type": "string"
              },
              "quote_field_suffix": {
                "description": "Suffix appended to quoted text in the query string.",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:SimpleQueryStringFlags": {
        "description": "Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`",
        "allOf": [
          {
            "$ref": "#/components/schemas/_spec_utils:PipeSeparatedFlagsSimpleQueryStringFlag"
          }
        ]
      },
      "_spec_utils:PipeSeparatedFlagsSimpleQueryStringFlag": {
        "description": "A set of flags that can be represented as a single enum value or a set of values that are encoded\nas a pipe-separated string\n\nDepending on the target language, code generators can use this hint to generate language specific\nflags enum constructs and the corresponding (de-)serialization code.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringFlag"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.query_dsl:SimpleQueryStringFlag": {
        "type": "string",
        "enum": [
          "NONE",
          "AND",
          "NOT",
          "OR",
          "PREFIX",
          "PHRASE",
          "PRECEDENCE",
          "ESCAPE",
          "WHITESPACE",
          "FUZZY",
          "NEAR",
          "SLOP",
          "ALL"
        ]
      },
      "_types.query_dsl:SpanContainingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "big": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "little": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "big",
              "little"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanQuery": {
        "type": "object",
        "properties": {
          "span_containing": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanContainingQuery"
          },
          "span_field_masking": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFieldMaskingQuery"
          },
          "span_first": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFirstQuery"
          },
          "span_gap": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanGapQuery"
          },
          "span_multi": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanMultiTermQuery"
          },
          "span_near": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNearQuery"
          },
          "span_not": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNotQuery"
          },
          "span_or": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanOrQuery"
          },
          "span_term": {
            "description": "The equivalent of the `term` query but for use with other span queries.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:SpanTermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "span_within": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanWithinQuery"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:SpanFieldMaskingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "field",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanFirstQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "end": {
                "description": "Controls the maximum end position permitted in a match.",
                "type": "number"
              },
              "match": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "end",
              "match"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanGapQuery": {
        "description": "Can only be used as a clause in a span_near query.",
        "type": "object",
        "additionalProperties": {
          "type": "number"
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:SpanMultiTermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "match": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              }
            },
            "required": [
              "match"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanNearQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "clauses": {
                "description": "Array of one or more other span type queries.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
                }
              },
              "in_order": {
                "description": "Controls whether matches are required to be in-order.",
                "type": "boolean"
              },
              "slop": {
                "description": "Controls the maximum number of intervening unmatched positions permitted.",
                "type": "number"
              }
            },
            "required": [
              "clauses"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanNotQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "dist": {
                "description": "The number of tokens from within the include span that canâ€™t have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`.",
                "type": "number"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "include": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "post": {
                "description": "The number of tokens after the include span that canâ€™t have overlap with the exclude span.",
                "type": "number"
              },
              "pre": {
                "description": "The number of tokens before the include span that canâ€™t have overlap with the exclude span.",
                "type": "number"
              }
            },
            "required": [
              "exclude",
              "include"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanOrQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "clauses": {
                "description": "Array of one or more other span type queries.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
                }
              }
            },
            "required": [
              "clauses"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanTermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanWithinQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "big": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "little": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "big",
              "little"
            ]
          }
        ]
      },
      "_types.query_dsl:SparseVectorQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-sparse-vector-query.html"
            },
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "field": {
                    "$ref": "#/components/schemas/_types:Field"
                  },
                  "query": {
                    "description": "The query text you want to use for search.\nIf inference_id is specified, query must also be specified.",
                    "type": "string"
                  },
                  "prune": {
                    "description": "Whether to perform pruning, omitting the non-significant tokens from the query to improve query performance.\nIf prune is true but the pruning_config is not specified, pruning will occur but default values will be used.\nDefault: false",
                    "x-state": "Technical preview",
                    "type": "boolean"
                  },
                  "pruning_config": {
                    "$ref": "#/components/schemas/_types.query_dsl:TokenPruningConfig"
                  }
                },
                "required": [
                  "field"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "query_vector": {
                    "description": "Dictionary of precomputed sparse vectors and their associated weights.\nOnly one of inference_id or query_vector may be supplied in a request.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  },
                  "inference_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  }
                },
                "minProperties": 1,
                "maxProperties": 1
              }
            ]
          }
        ]
      },
      "_types.query_dsl:TokenPruningConfig": {
        "type": "object",
        "properties": {
          "tokens_freq_ratio_threshold": {
            "description": "Tokens whose frequency is more than this threshold times the average frequency of all tokens in the specified field are considered outliers and pruned.",
            "type": "number"
          },
          "tokens_weight_threshold": {
            "description": "Tokens whose weight is less than this threshold are considered nonsignificant and pruned.",
            "type": "number"
          },
          "only_score_pruned_tokens": {
            "description": "Whether to only score pruned tokens, vs only scoring kept tokens.",
            "type": "boolean"
          }
        }
      },
      "_types.query_dsl:TermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "case_insensitive": {
                "description": "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:TermsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:TermsSetQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "minimum_should_match_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "minimum_should_match_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "terms": {
                "description": "Array of terms you wish to find in the provided field.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "terms"
            ]
          }
        ]
      },
      "_types.query_dsl:TextExpansionQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "description": "The text expansion NLP model to use",
                "type": "string"
              },
              "model_text": {
                "description": "The query text",
                "type": "string"
              },
              "pruning_config": {
                "$ref": "#/components/schemas/_types.query_dsl:TokenPruningConfig"
              }
            },
            "required": [
              "model_id",
              "model_text"
            ]
          }
        ]
      },
      "_types.query_dsl:WeightedTokensQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "tokens": {
                "description": "The tokens representing this query",
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              },
              "pruning_config": {
                "$ref": "#/components/schemas/_types.query_dsl:TokenPruningConfig"
              }
            },
            "required": [
              "tokens"
            ]
          }
        ]
      },
      "_types.query_dsl:WildcardQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "case_insensitive": {
                "description": "Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying fieldâ€™s mapping.",
                "type": "boolean"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "value": {
                "description": "Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.",
                "type": "string"
              },
              "wildcard": {
                "description": "Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.query_dsl:WrapperQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "query": {
                "description": "A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:TypeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:BucketAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:Aggregation": {
        "type": "object"
      },
      "_types.aggregations:AutoDateHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "description": "The target number of buckets.",
                "type": "number"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "format": {
                "description": "The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.",
                "type": "string"
              },
              "minimum_interval": {
                "$ref": "#/components/schemas/_types.aggregations:MinimumInterval"
              },
              "missing": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "offset": {
                "description": "Time zone specified as a ISO 8601 UTC offset.",
                "type": "string"
              },
              "params": {
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types.aggregations:MinimumInterval": {
        "type": "string",
        "enum": [
          "second",
          "minute",
          "hour",
          "day",
          "month",
          "year"
        ]
      },
      "_types.aggregations:AverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:FormatMetricAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:MetricAggregationBase": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing": {
            "$ref": "#/components/schemas/_types.aggregations:Missing"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        }
      },
      "_types.aggregations:Missing": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "_types.aggregations:AverageBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:PipelineAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketPathAggregation"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "description": "`DecimalFormat` pattern for the output value.\nIf specified, the formatted value is returned in the aggregationâ€™s `value_as_string` property.",
                "type": "string"
              },
              "gap_policy": {
                "$ref": "#/components/schemas/_types.aggregations:GapPolicy"
              }
            }
          }
        ]
      },
      "_types.aggregations:GapPolicy": {
        "type": "string",
        "enum": [
          "skip",
          "insert_zeros",
          "keep_values"
        ]
      },
      "_types.aggregations:BucketPathAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "buckets_path": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsPath"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketsPath": {
        "description": "Buckets path can be expressed in different ways, and an aggregation may accept some or all of these\nforms depending on its type. Please refer to each aggregation's documentation to know what buckets\npath forms they accept.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        ]
      },
      "_types.aggregations:BoxplotAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "compression": {
                "description": "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketScriptAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketSelectorAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketSortAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "from": {
                "description": "Buckets in positions prior to `from` will be truncated.",
                "type": "number"
              },
              "gap_policy": {
                "$ref": "#/components/schemas/_types.aggregations:GapPolicy"
              },
              "size": {
                "description": "The number of buckets to return.\nDefaults to all buckets of the parent aggregation.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketKsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketPathAggregation"
          },
          {
            "type": "object",
            "properties": {
              "alternative": {
                "description": "A list of string values indicating which K-S test alternative to calculate. The valid values\nare: \"greater\", \"less\", \"two_sided\". This parameter is key for determining the K-S statistic used\nwhen calculating the K-S test. Default value is all possible alternative hypotheses.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "fractions": {
                "description": "A list of doubles indicating the distribution of the samples with which to compare to the `buckets_path` results.\nIn typical usage this is the overall proportion of documents in each bucket, which is compared with the actual\ndocument proportions in each bucket from the sibling aggregation counts. The default is to assume that overall\ndocuments are uniformly distributed on these buckets, which they would be if one used equal percentiles of a\nmetric to define the bucket end points.",
                "type": "array",
                "items": {
                  "type": "number"
                }
              },
              "sampling_method": {
                "description": "Indicates the sampling methodology when calculating the K-S test. Note, this is sampling of the returned values.\nThis determines the cumulative distribution function (CDF) points used comparing the two samples. Default is\n`upper_tail`, which emphasizes the upper end of the CDF points. Valid options are: `upper_tail`, `uniform`,\nand `lower_tail`.",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketCorrelationAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketPathAggregation"
          },
          {
            "type": "object",
            "properties": {
              "function": {
                "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationFunction"
              }
            },
            "required": [
              "function"
            ]
          }
        ]
      },
      "_types.aggregations:BucketCorrelationFunction": {
        "type": "object",
        "properties": {
          "count_correlation": {
            "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationFunctionCountCorrelation"
          }
        },
        "required": [
          "count_correlation"
        ]
      },
      "_types.aggregations:BucketCorrelationFunctionCountCorrelation": {
        "type": "object",
        "properties": {
          "indicator": {
            "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationFunctionCountCorrelationIndicator"
          }
        },
        "required": [
          "indicator"
        ]
      },
      "_types.aggregations:BucketCorrelationFunctionCountCorrelationIndicator": {
        "type": "object",
        "properties": {
          "doc_count": {
            "description": "The total number of documents that initially created the expectations. Itâ€™s required to be greater\nthan or equal to the sum of all values in the buckets_path as this is the originating superset of data\nto which the term values are correlated.",
            "type": "number"
          },
          "expectations": {
            "description": "An array of numbers with which to correlate the configured `bucket_path` values.\nThe length of this value must always equal the number of buckets returned by the `bucket_path`.",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "fractions": {
            "description": "An array of fractions to use when averaging and calculating variance. This should be used if\nthe pre-calculated data and the buckets_path have known gaps. The length of fractions, if provided,\nmust equal expectations.",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "doc_count",
          "expectations"
        ]
      },
      "_types.aggregations:CardinalityAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "precision_threshold": {
                "description": "A unique count below which counts are expected to be close to accurate.\nThis allows to trade memory for accuracy.",
                "type": "number"
              },
              "rehash": {
                "type": "boolean"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:CardinalityExecutionMode"
              }
            }
          }
        ]
      },
      "_types.aggregations:CardinalityExecutionMode": {
        "type": "string",
        "enum": [
          "global_ordinals",
          "segment_ordinals",
          "direct",
          "save_memory_heuristic",
          "save_time_heuristic"
        ]
      },
      "_types.aggregations:CategorizeTextAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "max_unique_tokens": {
                "description": "The maximum number of unique tokens at any position up to max_matched_tokens. Must be larger than 1.\nSmaller values use less memory and create fewer categories. Larger values will use more memory and\ncreate narrower categories. Max allowed value is 100.",
                "type": "number"
              },
              "max_matched_tokens": {
                "description": "The maximum number of token positions to match on before attempting to merge categories. Larger\nvalues will use more memory and create narrower categories. Max allowed value is 100.",
                "type": "number"
              },
              "similarity_threshold": {
                "description": "The minimum percentage of tokens that must match for text to be added to the category bucket. Must\nbe between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory\nusage and create narrower categories.",
                "type": "number"
              },
              "categorization_filters": {
                "description": "This property expects an array of regular expressions. The expressions are used to filter out matching\nsequences from the categorization field values. You can use this functionality to fine tune the categorization\nby excluding sequences from consideration when categories are defined. For example, you can exclude SQL\nstatements that appear in your log files. This property cannot be used at the same time as categorization_analyzer.\nIf you only want to define simple regular expression filters that are applied prior to tokenization, setting\nthis property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering,\nuse the categorization_analyzer property instead and include the filters as pattern_replace character filters.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "categorization_analyzer": {
                "$ref": "#/components/schemas/_types.aggregations:CategorizeTextAnalyzer"
              },
              "shard_size": {
                "description": "The number of categorization buckets to return from each shard before merging all the results.",
                "type": "number"
              },
              "size": {
                "description": "The number of buckets to return.",
                "type": "number"
              },
              "min_doc_count": {
                "description": "The minimum number of documents in a bucket to be returned to the results.",
                "type": "number"
              },
              "shard_min_doc_count": {
                "description": "The minimum number of documents in a bucket to be returned from the shard before merging.",
                "type": "number"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.aggregations:CategorizeTextAnalyzer": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CustomCategorizeTextAnalyzer"
          }
        ]
      },
      "_types.aggregations:CustomCategorizeTextAnalyzer": {
        "type": "object",
        "properties": {
          "char_filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "tokenizer": {
            "type": "string"
          },
          "filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "_types.aggregations:ChildrenAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "after": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregateKey"
              },
              "size": {
                "description": "The number of composite buckets that should be returned.",
                "type": "number"
              },
              "sources": {
                "description": "The value sources used to build composite buckets.\nKeys are returned in the order of the `sources` definition.",
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationSource"
                  }
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregationSource": {
        "type": "object",
        "properties": {
          "terms": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeTermsAggregation"
          },
          "histogram": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeHistogramAggregation"
          },
          "date_histogram": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeDateHistogramAggregation"
          },
          "geotile_grid": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeGeoTileGridAggregation"
          }
        }
      },
      "_types.aggregations:CompositeTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:CompositeAggregationBase": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing_bucket": {
            "type": "boolean"
          },
          "missing_order": {
            "$ref": "#/components/schemas/_types.aggregations:MissingOrder"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "value_type": {
            "$ref": "#/components/schemas/_types.aggregations:ValueType"
          },
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          }
        }
      },
      "_types.aggregations:MissingOrder": {
        "type": "string",
        "enum": [
          "first",
          "last",
          "default"
        ]
      },
      "_types.aggregations:ValueType": {
        "type": "string",
        "enum": [
          "string",
          "long",
          "double",
          "number",
          "date",
          "date_nanos",
          "ip",
          "numeric",
          "geo_point",
          "boolean"
        ]
      },
      "_types.aggregations:CompositeHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "interval": {
                "type": "number"
              }
            },
            "required": [
              "interval"
            ]
          }
        ]
      },
      "_types.aggregations:CompositeDateHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              },
              "calendar_interval": {
                "$ref": "#/components/schemas/_types:DurationLarge"
              },
              "fixed_interval": {
                "$ref": "#/components/schemas/_types:DurationLarge"
              },
              "offset": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeGeoTileGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "precision": {
                "type": "number"
              },
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              }
            }
          }
        ]
      },
      "_types.aggregations:CumulativeCardinalityAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:CumulativeSumAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:DateHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "calendar_interval": {
                "$ref": "#/components/schemas/_types.aggregations:CalendarInterval"
              },
              "extended_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsFieldDateMath"
              },
              "hard_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsFieldDateMath"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "fixed_interval": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "format": {
                "description": "The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.",
                "type": "string"
              },
              "interval": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "min_doc_count": {
                "description": "Only returns buckets that have `min_doc_count` number of documents.\nBy default, all buckets between the first bucket that matches documents and the last one are returned.",
                "type": "number"
              },
              "missing": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "offset": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "params": {
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:CalendarInterval": {
        "type": "string",
        "enum": [
          "second",
          "1s",
          "minute",
          "1m",
          "hour",
          "1h",
          "day",
          "1d",
          "week",
          "1w",
          "month",
          "1M",
          "quarter",
          "1q",
          "year",
          "1y"
        ]
      },
      "_types.aggregations:ExtendedBoundsFieldDateMath": {
        "type": "object",
        "properties": {
          "max": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          },
          "min": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          }
        }
      },
      "_types.aggregations:FieldDateMath": {
        "description": "A date range limit, represented either as a DateMath expression or a number expressed\naccording to the target field's precision.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:DateMath"
          },
          {
            "type": "number"
          }
        ]
      },
      "_types.aggregations:AggregateOrder": {
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:SortOrder"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/_types:SortOrder"
              },
              "minProperties": 1,
              "maxProperties": 1
            }
          }
        ]
      },
      "_types.aggregations:DateRangeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "format": {
                "description": "The date format used to format `from` and `to` in the response.",
                "type": "string"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              },
              "ranges": {
                "description": "Array of date ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:DateRangeExpression"
                }
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:DateRangeExpression": {
        "type": "object",
        "properties": {
          "from": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          },
          "key": {
            "description": "Custom key to return the range with.",
            "type": "string"
          },
          "to": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          }
        }
      },
      "_types.aggregations:DerivativeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:DiversifiedSamplerAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:SamplerAggregationExecutionHint"
              },
              "max_docs_per_value": {
                "description": "Limits how many documents are permitted per choice of de-duplicating value.",
                "type": "number"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "shard_size": {
                "description": "Limits how many top-scoring documents are collected in the sample processed on each shard.",
                "type": "number"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            }
          }
        ]
      },
      "_types.aggregations:SamplerAggregationExecutionHint": {
        "type": "string",
        "enum": [
          "map",
          "global_ordinals",
          "bytes_hash"
        ]
      },
      "_types.aggregations:ExtendedStatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "sigma": {
                "description": "The number of standard deviations above/below the mean to display.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:ExtendedStatsBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "sigma": {
                "description": "The number of standard deviations above/below the mean to display.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:FrequentItemSetsAggregation": {
        "type": "object",
        "properties": {
          "fields": {
            "description": "Fields to analyze.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsField"
            }
          },
          "minimum_set_size": {
            "description": "The minimum size of one item set.",
            "type": "number"
          },
          "minimum_support": {
            "description": "The minimum support of one item set.",
            "type": "number"
          },
          "size": {
            "description": "The number of top item sets to return.",
            "type": "number"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "fields"
        ]
      },
      "_types.aggregations:FrequentItemSetsField": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "exclude": {
            "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
          },
          "include": {
            "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:TermsExclude": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "_types.aggregations:TermsInclude": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsPartition"
          }
        ]
      },
      "_types.aggregations:TermsPartition": {
        "type": "object",
        "properties": {
          "num_partitions": {
            "description": "The number of partitions.",
            "type": "number"
          },
          "partition": {
            "description": "The partition number for this request.",
            "type": "number"
          }
        },
        "required": [
          "num_partitions",
          "partition"
        ]
      },
      "_types.aggregations:FiltersAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "filters": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsQueryContainer"
              },
              "other_bucket": {
                "description": "Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters.",
                "type": "boolean"
              },
              "other_bucket_key": {
                "description": "The key with which the other bucket is returned.",
                "type": "string"
              },
              "keyed": {
                "description": "By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketsQueryContainer": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
            }
          }
        ]
      },
      "_types.aggregations:GeoBoundsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "wrap_longitude": {
                "description": "Specifies whether the bounding box should be allowed to overlap the international date line.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:GeoCentroidAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "location": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              }
            }
          }
        ]
      },
      "_types.aggregations:GeoDistanceAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "distance_type": {
                "$ref": "#/components/schemas/_types:GeoDistanceType"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "origin": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              },
              "ranges": {
                "description": "An array of ranges used to bucket documents.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:AggregationRange"
                }
              },
              "unit": {
                "$ref": "#/components/schemas/_types:DistanceUnit"
              }
            }
          }
        ]
      },
      "_types.aggregations:AggregationRange": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Start of the range (inclusive).",
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "key": {
            "description": "Custom key to return the range with.",
            "type": "string"
          },
          "to": {
            "description": "End of the range (exclusive).",
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "_types.aggregations:GeoHashGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision": {
                "$ref": "#/components/schemas/_types:GeoHashPrecision"
              },
              "shard_size": {
                "description": "Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.",
                "type": "number"
              },
              "size": {
                "description": "The maximum number of geohash buckets to return.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types:GeoHashPrecision": {
        "description": "A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like \"1km\", \"10m\".",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.aggregations:GeoLineAggregation": {
        "type": "object",
        "properties": {
          "point": {
            "$ref": "#/components/schemas/_types.aggregations:GeoLinePoint"
          },
          "sort": {
            "$ref": "#/components/schemas/_types.aggregations:GeoLineSort"
          },
          "include_sort": {
            "description": "When `true`, returns an additional array of the sort values in the feature properties.",
            "type": "boolean"
          },
          "sort_order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          },
          "size": {
            "description": "The maximum length of the line represented in the aggregation.\nValid sizes are between 1 and 10000.",
            "type": "number"
          }
        },
        "required": [
          "point",
          "sort"
        ]
      },
      "_types.aggregations:GeoLinePoint": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:GeoLineSort": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:GeoTileGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision": {
                "$ref": "#/components/schemas/_types:GeoTilePrecision"
              },
              "shard_size": {
                "description": "Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.",
                "type": "number"
              },
              "size": {
                "description": "The maximum number of buckets to return.",
                "type": "number"
              },
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              }
            }
          }
        ]
      },
      "_types:GeoTilePrecision": {
        "type": "number"
      },
      "_types.aggregations:GeohexGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision": {
                "description": "Integer zoom of the key used to defined cells or buckets\nin the results. Value should be between 0-15.",
                "type": "number"
              },
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              },
              "size": {
                "description": "Maximum number of buckets to return.",
                "type": "number"
              },
              "shard_size": {
                "description": "Number of buckets returned from each shard.",
                "type": "number"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.aggregations:GlobalAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:HistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "extended_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsdouble"
              },
              "hard_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsdouble"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "interval": {
                "description": "The interval for the buckets.\nMust be a positive decimal.",
                "type": "number"
              },
              "min_doc_count": {
                "description": "Only returns buckets that have `min_doc_count` number of documents.\nBy default, the response will fill gaps in the histogram with empty buckets.",
                "type": "number"
              },
              "missing": {
                "description": "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.",
                "type": "number"
              },
              "offset": {
                "description": "By default, the bucket keys start with 0 and then continue in even spaced steps of `interval`.\nThe bucket boundaries can be shifted by using the `offset` option.",
                "type": "number"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "format": {
                "type": "string"
              },
              "keyed": {
                "description": "If `true`, returns buckets as a hash instead of an array, keyed by the bucket keys.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:ExtendedBoundsdouble": {
        "type": "object",
        "properties": {
          "max": {
            "description": "Maximum value for the bound.",
            "type": "number"
          },
          "min": {
            "description": "Minimum value for the bound.",
            "type": "number"
          }
        }
      },
      "_types.aggregations:IpRangeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ranges": {
                "description": "Array of IP ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:IpRangeAggregationRange"
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:IpRangeAggregationRange": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Start of the range.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "mask": {
            "description": "IP range defined as a CIDR mask.",
            "type": "string"
          },
          "to": {
            "description": "End of the range.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "_types.aggregations:IpPrefixAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "prefix_length": {
                "description": "Length of the network prefix. For IPv4 addresses the accepted range is [0, 32].\nFor IPv6 addresses the accepted range is [0, 128].",
                "type": "number"
              },
              "is_ipv6": {
                "description": "Defines whether the prefix applies to IPv6 addresses.",
                "type": "boolean"
              },
              "append_prefix_length": {
                "description": "Defines whether the prefix length is appended to IP address keys in the response.",
                "type": "boolean"
              },
              "keyed": {
                "description": "Defines whether buckets are returned as a hash rather than an array in the response.",
                "type": "boolean"
              },
              "min_doc_count": {
                "description": "Minimum number of documents in a bucket for it to be included in the response.",
                "type": "number"
              }
            },
            "required": [
              "field",
              "prefix_length"
            ]
          }
        ]
      },
      "_types.aggregations:InferenceAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "inference_config": {
                "$ref": "#/components/schemas/_types.aggregations:InferenceConfigContainer"
              }
            },
            "required": [
              "model_id"
            ]
          }
        ]
      },
      "_types.aggregations:InferenceConfigContainer": {
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ml._types:RegressionInferenceOptions"
          },
          "classification": {
            "$ref": "#/components/schemas/ml._types:ClassificationInferenceOptions"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:RegressionInferenceOptions": {
        "type": "object",
        "properties": {
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "num_top_feature_importance_values": {
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          }
        }
      },
      "ml._types:ClassificationInferenceOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "num_top_feature_importance_values": {
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          },
          "prediction_field_type": {
            "description": "Specifies the type of the predicted field to write. Acceptable values are: string, number, boolean. When boolean is provided 1.0 is transformed to true and 0.0 to false.",
            "type": "string"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "top_classes_results_field": {
            "description": "Specifies the field to which the top classes are written. Defaults to top_classes.",
            "type": "string"
          }
        }
      },
      "_types.aggregations:MatrixStatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MatrixAggregation"
          },
          {
            "type": "object",
            "properties": {
              "mode": {
                "$ref": "#/components/schemas/_types:SortMode"
              }
            }
          }
        ]
      },
      "_types.aggregations:MatrixAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "missing": {
                "description": "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.",
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:MaxAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MaxBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MedianAbsoluteDeviationAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "compression": {
                "description": "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MinAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MinBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MissingAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              }
            }
          }
        ]
      },
      "_types.aggregations:MovingAverageAggregation": {
        "discriminator": {
          "propertyName": "model"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:LinearMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SimpleMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:EwmaMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HoltMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HoltWintersMovingAverageAggregation"
          }
        ]
      },
      "_types.aggregations:LinearMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "linear"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types:EmptyObject": {
        "type": "object"
      },
      "_types.aggregations:MovingAverageAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "minimize": {
                "type": "boolean"
              },
              "predict": {
                "type": "number"
              },
              "window": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:SimpleMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "simple"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:EwmaMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "ewma"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types.aggregations:EwmaModelSettings"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:EwmaModelSettings": {
        "type": "object",
        "properties": {
          "alpha": {
            "type": "number"
          }
        }
      },
      "_types.aggregations:HoltMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "holt"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types.aggregations:HoltLinearModelSettings"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:HoltLinearModelSettings": {
        "type": "object",
        "properties": {
          "alpha": {
            "type": "number"
          },
          "beta": {
            "type": "number"
          }
        }
      },
      "_types.aggregations:HoltWintersMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "holt_winters"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types.aggregations:HoltWintersModelSettings"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:HoltWintersModelSettings": {
        "type": "object",
        "properties": {
          "alpha": {
            "type": "number"
          },
          "beta": {
            "type": "number"
          },
          "gamma": {
            "type": "number"
          },
          "pad": {
            "type": "boolean"
          },
          "period": {
            "type": "number"
          },
          "type": {
            "$ref": "#/components/schemas/_types.aggregations:HoltWintersType"
          }
        }
      },
      "_types.aggregations:HoltWintersType": {
        "type": "string",
        "enum": [
          "add",
          "mult"
        ]
      },
      "_types.aggregations:MovingPercentilesAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "window": {
                "description": "The size of window to \"slide\" across the histogram.",
                "type": "number"
              },
              "shift": {
                "description": "By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.",
                "type": "number"
              },
              "keyed": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:MovingFunctionAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "description": "The script that should be executed on each window of data.",
                "type": "string"
              },
              "shift": {
                "description": "By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.",
                "type": "number"
              },
              "window": {
                "description": "The size of window to \"slide\" across the histogram.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "collect_mode": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationCollectMode"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "min_doc_count": {
                "description": "The minimum number of documents in a bucket for it to be returned.",
                "type": "number"
              },
              "shard_min_doc_count": {
                "description": "The minimum number of documents in a bucket on each shard for it to be returned.",
                "type": "number"
              },
              "shard_size": {
                "description": "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "show_term_doc_count_error": {
                "description": "Calculates the doc count error on per term basis.",
                "type": "boolean"
              },
              "size": {
                "description": "The number of term buckets should be returned out of the overall terms list.",
                "type": "number"
              },
              "terms": {
                "description": "The field from which to generate sets of terms.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:MultiTermLookup"
                }
              }
            },
            "required": [
              "terms"
            ]
          }
        ]
      },
      "_types.aggregations:TermsAggregationCollectMode": {
        "type": "string",
        "enum": [
          "depth_first",
          "breadth_first"
        ]
      },
      "_types.aggregations:MultiTermLookup": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing": {
            "$ref": "#/components/schemas/_types.aggregations:Missing"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:NestedAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              }
            }
          }
        ]
      },
      "_types.aggregations:NormalizeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "method": {
                "$ref": "#/components/schemas/_types.aggregations:NormalizeMethod"
              }
            }
          }
        ]
      },
      "_types.aggregations:NormalizeMethod": {
        "type": "string",
        "enum": [
          "rescale_0_1",
          "rescale_0_100",
          "percent_of_sum",
          "mean",
          "z-score",
          "softmax"
        ]
      },
      "_types.aggregations:ParentAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            }
          }
        ]
      },
      "_types.aggregations:PercentileRanksAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "keyed": {
                "description": "By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.",
                "type": "boolean"
              },
              "values": {
                "description": "An array of values for which to calculate the percentile ranks.",
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "type": "number"
                    }
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "hdr": {
                "$ref": "#/components/schemas/_types.aggregations:HdrMethod"
              },
              "tdigest": {
                "$ref": "#/components/schemas/_types.aggregations:TDigest"
              }
            }
          }
        ]
      },
      "_types.aggregations:HdrMethod": {
        "type": "object",
        "properties": {
          "number_of_significant_value_digits": {
            "description": "Specifies the resolution of values for the histogram in number of significant digits.",
            "type": "number"
          }
        }
      },
      "_types.aggregations:TDigest": {
        "type": "object",
        "properties": {
          "compression": {
            "description": "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.",
            "type": "number"
          }
        }
      },
      "_types.aggregations:PercentilesAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "keyed": {
                "description": "By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.",
                "type": "boolean"
              },
              "percents": {
                "description": "The percentiles to calculate.",
                "type": "array",
                "items": {
                  "type": "number"
                }
              },
              "hdr": {
                "$ref": "#/components/schemas/_types.aggregations:HdrMethod"
              },
              "tdigest": {
                "$ref": "#/components/schemas/_types.aggregations:TDigest"
              }
            }
          }
        ]
      },
      "_types.aggregations:PercentilesBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "percents": {
                "description": "The list of percentiles to calculate.",
                "type": "array",
                "items": {
                  "type": "number"
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:RangeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "missing": {
                "description": "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.",
                "type": "number"
              },
              "ranges": {
                "description": "An array of ranges used to bucket documents.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:AggregationRange"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.",
                "type": "boolean"
              },
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:RareTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "max_doc_count": {
                "description": "The maximum number of documents a term should appear in.",
                "type": "number"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              },
              "precision": {
                "description": "The precision of the internal CuckooFilters.\nSmaller precision leads to better approximation, but higher memory usage.",
                "type": "number"
              },
              "value_type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:RateAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "unit": {
                "$ref": "#/components/schemas/_types.aggregations:CalendarInterval"
              },
              "mode": {
                "$ref": "#/components/schemas/_types.aggregations:RateMode"
              }
            }
          }
        ]
      },
      "_types.aggregations:RateMode": {
        "type": "string",
        "enum": [
          "sum",
          "value_count"
        ]
      },
      "_types.aggregations:ReverseNestedAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              }
            }
          }
        ]
      },
      "_types.aggregations:RandomSamplerAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "probability": {
                "description": "The probability that a document will be included in the aggregated data.\nMust be greater than 0, less than 0.5, or exactly 1.\nThe lower the probability, the fewer documents are matched.",
                "type": "number"
              },
              "seed": {
                "description": "The seed to generate the random sampling of documents.\nWhen a seed is provided, the random subset of documents is the same between calls.",
                "type": "number"
              },
              "shard_seed": {
                "description": "When combined with seed, setting shard_seed ensures 100% consistent sampling over shards where data is exactly the same.",
                "type": "number"
              }
            },
            "required": [
              "probability"
            ]
          }
        ]
      },
      "_types.aggregations:SamplerAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "shard_size": {
                "description": "Limits how many top-scoring documents are collected in the sample processed on each shard.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:ScriptedMetricAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "combine_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "init_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "map_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "params": {
                "description": "A global object with script parameters for `init`, `map` and `combine` scripts.\nIt is shared between the scripts.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "reduce_script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            }
          }
        ]
      },
      "_types.aggregations:SerialDifferencingAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "lag": {
                "description": "The historical bucket to subtract from the current value.\nMust be a positive, non-zero integer.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "background_filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "chi_square": {
                "$ref": "#/components/schemas/_types.aggregations:ChiSquareHeuristic"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationExecutionHint"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "gnd": {
                "$ref": "#/components/schemas/_types.aggregations:GoogleNormalizedDistanceHeuristic"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "jlh": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              },
              "min_doc_count": {
                "description": "Only return terms that are found in more than `min_doc_count` hits.",
                "type": "number"
              },
              "mutual_information": {
                "$ref": "#/components/schemas/_types.aggregations:MutualInformationHeuristic"
              },
              "percentage": {
                "$ref": "#/components/schemas/_types.aggregations:PercentageScoreHeuristic"
              },
              "script_heuristic": {
                "$ref": "#/components/schemas/_types.aggregations:ScriptedHeuristic"
              },
              "shard_min_doc_count": {
                "description": "Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.",
                "type": "number"
              },
              "shard_size": {
                "description": "Can be used to control the volumes of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "size": {
                "description": "The number of buckets returned out of the overall terms list.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:ChiSquareHeuristic": {
        "type": "object",
        "properties": {
          "background_is_superset": {
            "description": "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.",
            "type": "boolean"
          },
          "include_negatives": {
            "description": "Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.",
            "type": "boolean"
          }
        },
        "required": [
          "background_is_superset",
          "include_negatives"
        ]
      },
      "_types.aggregations:TermsAggregationExecutionHint": {
        "type": "string",
        "enum": [
          "map",
          "global_ordinals",
          "global_ordinals_hash",
          "global_ordinals_low_cardinality"
        ]
      },
      "_types.aggregations:GoogleNormalizedDistanceHeuristic": {
        "type": "object",
        "properties": {
          "background_is_superset": {
            "description": "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.",
            "type": "boolean"
          }
        }
      },
      "_types.aggregations:MutualInformationHeuristic": {
        "type": "object",
        "properties": {
          "background_is_superset": {
            "description": "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.",
            "type": "boolean"
          },
          "include_negatives": {
            "description": "Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.",
            "type": "boolean"
          }
        }
      },
      "_types.aggregations:PercentageScoreHeuristic": {
        "type": "object"
      },
      "_types.aggregations:ScriptedHeuristic": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types.aggregations:SignificantTextAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "background_filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "chi_square": {
                "$ref": "#/components/schemas/_types.aggregations:ChiSquareHeuristic"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationExecutionHint"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "filter_duplicate_text": {
                "description": "Whether to out duplicate text to deal with noisy data.",
                "type": "boolean"
              },
              "gnd": {
                "$ref": "#/components/schemas/_types.aggregations:GoogleNormalizedDistanceHeuristic"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "jlh": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              },
              "min_doc_count": {
                "description": "Only return values that are found in more than `min_doc_count` hits.",
                "type": "number"
              },
              "mutual_information": {
                "$ref": "#/components/schemas/_types.aggregations:MutualInformationHeuristic"
              },
              "percentage": {
                "$ref": "#/components/schemas/_types.aggregations:PercentageScoreHeuristic"
              },
              "script_heuristic": {
                "$ref": "#/components/schemas/_types.aggregations:ScriptedHeuristic"
              },
              "shard_min_doc_count": {
                "description": "Regulates the certainty a shard has if the values should actually be added to the candidate list or not with respect to the min_doc_count.\nValues will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.",
                "type": "number"
              },
              "shard_size": {
                "description": "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "size": {
                "description": "The number of buckets returned out of the overall terms list.",
                "type": "number"
              },
              "source_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              }
            }
          }
        ]
      },
      "_types.aggregations:StatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:StatsBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:StringStatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "show_distribution": {
                "description": "Shows the probability distribution for all characters.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:SumAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SumBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "collect_mode": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationCollectMode"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationExecutionHint"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "min_doc_count": {
                "description": "Only return values that are found in more than `min_doc_count` hits.",
                "type": "number"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              },
              "missing_order": {
                "$ref": "#/components/schemas/_types.aggregations:MissingOrder"
              },
              "missing_bucket": {
                "type": "boolean"
              },
              "value_type": {
                "description": "Coerced unmapped fields into the specified type.",
                "type": "string"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "shard_min_doc_count": {
                "description": "Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.",
                "type": "number"
              },
              "shard_size": {
                "description": "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "show_term_doc_count_error": {
                "description": "Set to `true` to return the `doc_count_error_upper_bound`, which is an upper bound to the error on the `doc_count` returned by each shard.",
                "type": "boolean"
              },
              "size": {
                "description": "The number of buckets returned out of the overall terms list.",
                "type": "number"
              },
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:TimeSeriesAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "size": {
                "description": "The maximum number of results to return.",
                "type": "number"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:TopHitsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "docvalue_fields": {
                "description": "Fields for which to return doc values.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                }
              },
              "explain": {
                "description": "If `true`, returns detailed information about score computation as part of a hit.",
                "type": "boolean"
              },
              "fields": {
                "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                }
              },
              "from": {
                "description": "Starting document offset.",
                "type": "number"
              },
              "highlight": {
                "$ref": "#/components/schemas/_global.search._types:Highlight"
              },
              "script_fields": {
                "description": "Returns the result of one or more script evaluations for each hit.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types:ScriptField"
                }
              },
              "size": {
                "description": "The maximum number of top matching hits to return per bucket.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              },
              "_source": {
                "$ref": "#/components/schemas/_global.search._types:SourceConfig"
              },
              "stored_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "track_scores": {
                "description": "If `true`, calculates and returns document scores, even if the scores are not used for sorting.",
                "type": "boolean"
              },
              "version": {
                "description": "If `true`, returns document version as part of a hit.",
                "type": "boolean"
              },
              "seq_no_primary_term": {
                "description": "If `true`, returns sequence number and primary term of the last modification of each hit.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:TTestAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "a": {
                "$ref": "#/components/schemas/_types.aggregations:TestPopulation"
              },
              "b": {
                "$ref": "#/components/schemas/_types.aggregations:TestPopulation"
              },
              "type": {
                "$ref": "#/components/schemas/_types.aggregations:TTestType"
              }
            }
          }
        ]
      },
      "_types.aggregations:TestPopulation": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:TTestType": {
        "type": "string",
        "enum": [
          "paired",
          "homoscedastic",
          "heteroscedastic"
        ]
      },
      "_types.aggregations:TopMetricsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "metrics": {
                "description": "The fields of the top document to return.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.aggregations:TopMetricsValue"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.aggregations:TopMetricsValue"
                    }
                  }
                ]
              },
              "size": {
                "description": "The number of top documents from which to return metrics.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              }
            }
          }
        ]
      },
      "_types.aggregations:TopMetricsValue": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:ValueCountAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormattableMetricAggregation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:FormattableMetricAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:WeightedAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "description": "A numeric response formatter.",
                "type": "string"
              },
              "value": {
                "$ref": "#/components/schemas/_types.aggregations:WeightedAverageValue"
              },
              "value_type": {
                "$ref": "#/components/schemas/_types.aggregations:ValueType"
              },
              "weight": {
                "$ref": "#/components/schemas/_types.aggregations:WeightedAverageValue"
              }
            }
          }
        ]
      },
      "_types.aggregations:WeightedAverageValue": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing": {
            "description": "A value or weight to use if the field is missing.",
            "type": "number"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        }
      },
      "_types.aggregations:VariableWidthHistogramAggregation": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "buckets": {
            "description": "The target number of buckets.",
            "type": "number"
          },
          "shard_size": {
            "description": "The number of buckets that the coordinating node will request from each shard.\nDefaults to `buckets * 50`.",
            "type": "number"
          },
          "initial_buffer": {
            "description": "Specifies the number of individual documents that will be stored in memory on a shard before the initial bucketing algorithm is run.\nDefaults to `min(10 * shard_size, 50000)`.",
            "type": "number"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        }
      },
      "_types:KnnSearch": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "query_vector": {
            "$ref": "#/components/schemas/_types:QueryVector"
          },
          "query_vector_builder": {
            "$ref": "#/components/schemas/_types:QueryVectorBuilder"
          },
          "k": {
            "description": "The final number of nearest neighbors to return as top hits",
            "type": "number"
          },
          "num_candidates": {
            "description": "The number of nearest neighbor candidates to consider per shard",
            "type": "number"
          },
          "boost": {
            "description": "Boost value to apply to kNN scores",
            "type": "number"
          },
          "filter": {
            "description": "Filters for the kNN search query",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            ]
          },
          "similarity": {
            "description": "The minimum similarity for a vector to be considered a match",
            "type": "number"
          },
          "inner_hits": {
            "$ref": "#/components/schemas/_global.search._types:InnerHits"
          }
        },
        "required": [
          "field"
        ]
      },
      "_global.search._types:Rescore": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "window_size": {
                "type": "number"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "query": {
                "$ref": "#/components/schemas/_global.search._types:RescoreQuery"
              },
              "learning_to_rank": {
                "$ref": "#/components/schemas/_global.search._types:LearningToRank"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_global.search._types:RescoreQuery": {
        "type": "object",
        "properties": {
          "rescore_query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "query_weight": {
            "description": "Relative importance of the original query versus the rescore query.",
            "type": "number"
          },
          "rescore_query_weight": {
            "description": "Relative importance of the rescore query versus the original query.",
            "type": "number"
          },
          "score_mode": {
            "$ref": "#/components/schemas/_global.search._types:ScoreMode"
          }
        },
        "required": [
          "rescore_query"
        ]
      },
      "_global.search._types:ScoreMode": {
        "type": "string",
        "enum": [
          "avg",
          "max",
          "min",
          "multiply",
          "total"
        ]
      },
      "_global.search._types:LearningToRank": {
        "type": "object",
        "properties": {
          "model_id": {
            "description": "The unique identifier of the trained model uploaded to Elasticsearch",
            "type": "string"
          },
          "params": {
            "description": "Named parameters to be passed to the query templates used for feature",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "model_id"
        ]
      },
      "_types:SlicedScroll": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "max"
        ]
      },
      "_global.search._types:Suggester": {
        "type": "object",
        "properties": {
          "text": {
            "description": "Global suggest text, to avoid repetition when the same text is used in several suggesters",
            "type": "string"
          }
        }
      },
      "_global.search._types:PointInTimeReference": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "keep_alive": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "id"
        ]
      },
      "_types.mapping:RuntimeFields": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/_types.mapping:RuntimeField"
        }
      },
      "_types.mapping:RuntimeField": {
        "type": "object",
        "properties": {
          "fields": {
            "description": "For type `composite`",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:CompositeSubField"
            }
          },
          "fetch_fields": {
            "description": "For type `lookup`",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.mapping:RuntimeFieldFetchFields"
            }
          },
          "format": {
            "description": "A custom format for `date` type runtime fields.",
            "type": "string"
          },
          "input_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "target_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "target_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "type": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFieldType"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:CompositeSubField": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFieldType"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:RuntimeFieldType": {
        "type": "string",
        "enum": [
          "boolean",
          "composite",
          "date",
          "double",
          "geo_point",
          "geo_shape",
          "ip",
          "keyword",
          "long",
          "lookup"
        ]
      },
      "_types.mapping:RuntimeFieldFetchFields": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "format": {
            "type": "string"
          }
        },
        "required": [
          "field"
        ]
      },
      "autoscaling.get_autoscaling_capacity:AutoscalingDeciders": {
        "type": "object",
        "properties": {
          "required_capacity": {
            "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingCapacity"
          },
          "current_capacity": {
            "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingCapacity"
          },
          "current_nodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingNode"
            }
          },
          "deciders": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingDecider"
            }
          }
        },
        "required": [
          "required_capacity",
          "current_capacity",
          "current_nodes",
          "deciders"
        ]
      },
      "autoscaling.get_autoscaling_capacity:AutoscalingCapacity": {
        "type": "object",
        "properties": {
          "node": {
            "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingResources"
          },
          "total": {
            "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingResources"
          }
        },
        "required": [
          "node",
          "total"
        ]
      },
      "autoscaling.get_autoscaling_capacity:AutoscalingResources": {
        "type": "object",
        "properties": {
          "storage": {
            "type": "number"
          },
          "memory": {
            "type": "number"
          }
        },
        "required": [
          "storage",
          "memory"
        ]
      },
      "autoscaling.get_autoscaling_capacity:AutoscalingNode": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:NodeName"
          }
        },
        "required": [
          "name"
        ]
      },
      "_types:NodeName": {
        "type": "string"
      },
      "autoscaling.get_autoscaling_capacity:AutoscalingDecider": {
        "type": "object",
        "properties": {
          "required_capacity": {
            "$ref": "#/components/schemas/autoscaling.get_autoscaling_capacity:AutoscalingCapacity"
          },
          "reason_summary": {
            "type": "string"
          },
          "reason_details": {
            "type": "object"
          }
        },
        "required": [
          "required_capacity"
        ]
      },
      "autoscaling._types:AutoscalingPolicy": {
        "type": "object",
        "properties": {
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "deciders": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/autoscaling-deciders.html"
            },
            "description": "Decider settings.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "roles",
          "deciders"
        ]
      },
      "_types:Refresh": {
        "type": "string",
        "enum": [
          "true",
          "false",
          "wait_for"
        ]
      },
      "_types:WaitForActiveShards": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "$ref": "#/components/schemas/_types:WaitForActiveShardOptions"
          }
        ]
      },
      "_types:WaitForActiveShardOptions": {
        "type": "string",
        "enum": [
          "all",
          "index-setting"
        ]
      },
      "_global.bulk:OperationContainer": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_global.bulk:IndexOperation"
          },
          "create": {
            "$ref": "#/components/schemas/_global.bulk:CreateOperation"
          },
          "update": {
            "$ref": "#/components/schemas/_global.bulk:UpdateOperation"
          },
          "delete": {
            "$ref": "#/components/schemas/_global.bulk:DeleteOperation"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_global.bulk:IndexOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:WriteOperation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.bulk:WriteOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:OperationBase"
          },
          {
            "type": "object",
            "properties": {
              "dynamic_templates": {
                "description": "A map from the full name of fields to the name of dynamic templates.\nIt defaults to an empty map.\nIf a name matches a dynamic template, that template will be applied regardless of other match predicates defined in the template.\nIf a field is already defined in the mapping, then this parameter won't be used.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "pipeline": {
                "description": "The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.",
                "type": "string"
              },
              "require_alias": {
                "description": "If `true`, the request's actions must target an index alias.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_global.bulk:OperationBase": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "if_primary_term": {
            "type": "number"
          },
          "if_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        }
      },
      "_global.bulk:CreateOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:WriteOperation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.bulk:UpdateOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:OperationBase"
          },
          {
            "type": "object",
            "properties": {
              "require_alias": {
                "description": "If `true`, the request's actions must target an index alias.",
                "type": "boolean"
              },
              "retry_on_conflict": {
                "description": "The number of times an update should be retried in the case of a version conflict.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_global.bulk:DeleteOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:OperationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.bulk:UpdateAction": {
        "type": "object",
        "properties": {
          "detect_noop": {
            "description": "If true, the `result` in the response is set to 'noop' when no changes to the document occur.",
            "type": "boolean"
          },
          "doc": {
            "description": "A partial update to an existing document.",
            "type": "object"
          },
          "doc_as_upsert": {
            "description": "Set to `true` to use the contents of `doc` as the value of `upsert`.",
            "type": "boolean"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "scripted_upsert": {
            "description": "Set to `true` to run the script whether or not the document exists.",
            "type": "boolean"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "upsert": {
            "description": "If the document does not already exist, the contents of `upsert` are inserted as a new document.\nIf the document exists, the `script` is run.",
            "type": "object"
          }
        }
      },
      "_global.bulk:ResponseItem": {
        "type": "object",
        "properties": {
          "_id": {
            "description": "The document ID associated with the operation.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "_index": {
            "description": "The name of the index associated with the operation.\nIf the operation targeted a data stream, this is the backing index into which the document was written.",
            "type": "string"
          },
          "status": {
            "description": "The HTTP status code returned for the operation.",
            "type": "number"
          },
          "failure_store": {
            "$ref": "#/components/schemas/_global.bulk:FailureStoreStatus"
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "_primary_term": {
            "description": "The primary term assigned to the document for the operation.\nThis property is returned only for successful operations.",
            "type": "number"
          },
          "result": {
            "description": "The result of the operation.\nSuccessful values are `created`, `deleted`, and `updated`.",
            "type": "string"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "forced_refresh": {
            "type": "boolean"
          },
          "get": {
            "$ref": "#/components/schemas/_types:InlineGetDictUserDefined"
          }
        },
        "required": [
          "_index",
          "status"
        ]
      },
      "_global.bulk:FailureStoreStatus": {
        "type": "string",
        "enum": [
          "not_applicable_or_unknown",
          "used",
          "not_enabled",
          "failed"
        ]
      },
      "_types:InlineGetDictUserDefined": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "found": {
            "type": "boolean"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_primary_term": {
            "type": "number"
          },
          "_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_source": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "found"
        ]
      },
      "_types:Names": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Name"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          }
        ]
      },
      "cat.aliases:AliasesRecord": {
        "type": "object",
        "properties": {
          "alias": {
            "description": "alias name",
            "type": "string"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "filter": {
            "description": "filter",
            "type": "string"
          },
          "routing.index": {
            "description": "index routing",
            "type": "string"
          },
          "routing.search": {
            "description": "search routing",
            "type": "string"
          },
          "is_write_index": {
            "description": "write index",
            "type": "string"
          }
        }
      },
      "_types:NodeIds": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:NodeId"
            }
          }
        ]
      },
      "_types:Bytes": {
        "type": "string",
        "enum": [
          "b",
          "kb",
          "mb",
          "gb",
          "tb",
          "pb"
        ]
      },
      "cat.allocation:AllocationRecord": {
        "type": "object",
        "properties": {
          "shards": {
            "description": "Number of primary and replica shards assigned to the node.",
            "type": "string"
          },
          "shards.undesired": {
            "description": "Amount of shards that are scheduled to be moved elsewhere in the cluster or -1 other than desired balance allocator is used",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "write_load.forecast": {
            "description": "Sum of index write load forecasts",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_spec_utils:Stringifieddouble"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.indices.forecast": {
            "description": "Sum of shard size forecasts",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.indices": {
            "description": "Disk space used by the nodeâ€™s shards. Does not include disk space for the translog or unassigned shards.\nIMPORTANT: This metric double-counts disk space for hard-linked files, such as those created when shrinking, splitting, or cloning an index.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.used": {
            "description": "Total disk space in use.\nElasticsearch retrieves this metric from the nodeâ€™s operating system (OS).\nThe metric includes disk space for: Elasticsearch, including the translog and unassigned shards; the nodeâ€™s operating system; any other applications or files on the node.\nUnlike `disk.indices`, this metric does not double-count disk space for hard-linked files.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.avail": {
            "description": "Free disk space available to Elasticsearch.\nElasticsearch retrieves this metric from the nodeâ€™s operating system.\nDisk-based shard allocation uses this metric to assign shards to nodes based on available disk space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.total": {
            "description": "Total disk space for the node, including in-use and available space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.percent": {
            "description": "Total percentage of disk space in use. Calculated as `disk.used / disk.total`.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Percentage"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "host": {
            "description": "Network host for the node. Set using the `network.host` setting.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Host"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "ip": {
            "description": "IP address and port for the node.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Ip"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "node": {
            "description": "Name for the node. Set using the `node.name` setting.",
            "type": "string"
          },
          "node.role": {
            "description": "Node roles",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "_spec_utils:Stringifieddouble": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:ByteSize": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:Percentage": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "_types:Host": {
        "type": "string"
      },
      "_types:Ip": {
        "type": "string"
      },
      "cat.component_templates:ComponentTemplate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "version": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "alias_count": {
            "type": "string"
          },
          "mapping_count": {
            "type": "string"
          },
          "settings_count": {
            "type": "string"
          },
          "metadata_count": {
            "type": "string"
          },
          "included_in": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "version",
          "alias_count",
          "mapping_count",
          "settings_count",
          "metadata_count",
          "included_in"
        ]
      },
      "cat.count:CountRecord": {
        "type": "object",
        "properties": {
          "epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:TimeOfDay"
          },
          "count": {
            "description": "the document count",
            "type": "string"
          }
        }
      },
      "_spec_utils:StringifiedEpochTimeUnitSeconds": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:EpochTimeUnitSeconds"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:EpochTimeUnitSeconds": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitSeconds"
          }
        ]
      },
      "_types:UnitSeconds": {
        "description": "Time unit for seconds",
        "type": "number"
      },
      "_types:TimeOfDay": {
        "description": "Time of day, expressed as HH:MM:SS",
        "type": "string"
      },
      "cat.fielddata:FielddataRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "node id",
            "type": "string"
          },
          "host": {
            "description": "host name",
            "type": "string"
          },
          "ip": {
            "description": "ip address",
            "type": "string"
          },
          "node": {
            "description": "node name",
            "type": "string"
          },
          "field": {
            "description": "field name",
            "type": "string"
          },
          "size": {
            "description": "field data usage",
            "type": "string"
          }
        }
      },
      "_types:TimeUnit": {
        "type": "string",
        "enum": [
          "nanos",
          "micros",
          "ms",
          "s",
          "m",
          "h",
          "d"
        ]
      },
      "cat.health:HealthRecord": {
        "type": "object",
        "properties": {
          "epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:TimeOfDay"
          },
          "cluster": {
            "description": "cluster name",
            "type": "string"
          },
          "status": {
            "description": "health status",
            "type": "string"
          },
          "node.total": {
            "description": "total number of nodes",
            "type": "string"
          },
          "node.data": {
            "description": "number of nodes that can store data",
            "type": "string"
          },
          "shards": {
            "description": "total number of shards",
            "type": "string"
          },
          "pri": {
            "description": "number of primary shards",
            "type": "string"
          },
          "relo": {
            "description": "number of relocating nodes",
            "type": "string"
          },
          "init": {
            "description": "number of initializing nodes",
            "type": "string"
          },
          "unassign.pri": {
            "description": "number of unassigned primary shards",
            "type": "string"
          },
          "unassign": {
            "description": "number of unassigned shards",
            "type": "string"
          },
          "pending_tasks": {
            "description": "number of pending tasks",
            "type": "string"
          },
          "max_task_wait_time": {
            "description": "wait time of longest task pending",
            "type": "string"
          },
          "active_shards_percent": {
            "description": "active number of shards in percent",
            "type": "string"
          }
        }
      },
      "_types:HealthStatus": {
        "type": "string",
        "enum": [
          "green",
          "GREEN",
          "yellow",
          "YELLOW",
          "red",
          "RED"
        ]
      },
      "cat.indices:IndicesRecord": {
        "type": "object",
        "properties": {
          "health": {
            "description": "current health status",
            "type": "string"
          },
          "status": {
            "description": "open/close status",
            "type": "string"
          },
          "index": {
            "description": "index name",
            "type": "string"
          },
          "uuid": {
            "description": "index uuid",
            "type": "string"
          },
          "pri": {
            "description": "number of primary shards",
            "type": "string"
          },
          "rep": {
            "description": "number of replica shards",
            "type": "string"
          },
          "docs.count": {
            "description": "available docs",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "docs.deleted": {
            "description": "deleted docs",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "creation.date": {
            "description": "index creation date (millisecond value)",
            "type": "string"
          },
          "creation.date.string": {
            "description": "index creation date (as string)",
            "type": "string"
          },
          "store.size": {
            "description": "store size of primaries & replicas",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "pri.store.size": {
            "description": "store size of primaries",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "dataset.size": {
            "description": "total size of dataset (including the cache for partially mounted indices)",
            "x-state": "Added in 8.11.0",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "completion.size": {
            "description": "size of completion",
            "type": "string"
          },
          "pri.completion.size": {
            "description": "size of completion",
            "type": "string"
          },
          "fielddata.memory_size": {
            "description": "used fielddata cache",
            "type": "string"
          },
          "pri.fielddata.memory_size": {
            "description": "used fielddata cache",
            "type": "string"
          },
          "fielddata.evictions": {
            "description": "fielddata evictions",
            "type": "string"
          },
          "pri.fielddata.evictions": {
            "description": "fielddata evictions",
            "type": "string"
          },
          "query_cache.memory_size": {
            "description": "used query cache",
            "type": "string"
          },
          "pri.query_cache.memory_size": {
            "description": "used query cache",
            "type": "string"
          },
          "query_cache.evictions": {
            "description": "query cache evictions",
            "type": "string"
          },
          "pri.query_cache.evictions": {
            "description": "query cache evictions",
            "type": "string"
          },
          "request_cache.memory_size": {
            "description": "used request cache",
            "type": "string"
          },
          "pri.request_cache.memory_size": {
            "description": "used request cache",
            "type": "string"
          },
          "request_cache.evictions": {
            "description": "request cache evictions",
            "type": "string"
          },
          "pri.request_cache.evictions": {
            "description": "request cache evictions",
            "type": "string"
          },
          "request_cache.hit_count": {
            "description": "request cache hit count",
            "type": "string"
          },
          "pri.request_cache.hit_count": {
            "description": "request cache hit count",
            "type": "string"
          },
          "request_cache.miss_count": {
            "description": "request cache miss count",
            "type": "string"
          },
          "pri.request_cache.miss_count": {
            "description": "request cache miss count",
            "type": "string"
          },
          "flush.total": {
            "description": "number of flushes",
            "type": "string"
          },
          "pri.flush.total": {
            "description": "number of flushes",
            "type": "string"
          },
          "flush.total_time": {
            "description": "time spent in flush",
            "type": "string"
          },
          "pri.flush.total_time": {
            "description": "time spent in flush",
            "type": "string"
          },
          "get.current": {
            "description": "number of current get ops",
            "type": "string"
          },
          "pri.get.current": {
            "description": "number of current get ops",
            "type": "string"
          },
          "get.time": {
            "description": "time spent in get",
            "type": "string"
          },
          "pri.get.time": {
            "description": "time spent in get",
            "type": "string"
          },
          "get.total": {
            "description": "number of get ops",
            "type": "string"
          },
          "pri.get.total": {
            "description": "number of get ops",
            "type": "string"
          },
          "get.exists_time": {
            "description": "time spent in successful gets",
            "type": "string"
          },
          "pri.get.exists_time": {
            "description": "time spent in successful gets",
            "type": "string"
          },
          "get.exists_total": {
            "description": "number of successful gets",
            "type": "string"
          },
          "pri.get.exists_total": {
            "description": "number of successful gets",
            "type": "string"
          },
          "get.missing_time": {
            "description": "time spent in failed gets",
            "type": "string"
          },
          "pri.get.missing_time": {
            "description": "time spent in failed gets",
            "type": "string"
          },
          "get.missing_total": {
            "description": "number of failed gets",
            "type": "string"
          },
          "pri.get.missing_total": {
            "description": "number of failed gets",
            "type": "string"
          },
          "indexing.delete_current": {
            "description": "number of current deletions",
            "type": "string"
          },
          "pri.indexing.delete_current": {
            "description": "number of current deletions",
            "type": "string"
          },
          "indexing.delete_time": {
            "description": "time spent in deletions",
            "type": "string"
          },
          "pri.indexing.delete_time": {
            "description": "time spent in deletions",
            "type": "string"
          },
          "indexing.delete_total": {
            "description": "number of delete ops",
            "type": "string"
          },
          "pri.indexing.delete_total": {
            "description": "number of delete ops",
            "type": "string"
          },
          "indexing.index_current": {
            "description": "number of current indexing ops",
            "type": "string"
          },
          "pri.indexing.index_current": {
            "description": "number of current indexing ops",
            "type": "string"
          },
          "indexing.index_time": {
            "description": "time spent in indexing",
            "type": "string"
          },
          "pri.indexing.index_time": {
            "description": "time spent in indexing",
            "type": "string"
          },
          "indexing.index_total": {
            "description": "number of indexing ops",
            "type": "string"
          },
          "pri.indexing.index_total": {
            "description": "number of indexing ops",
            "type": "string"
          },
          "indexing.index_failed": {
            "description": "number of failed indexing ops",
            "type": "string"
          },
          "pri.indexing.index_failed": {
            "description": "number of failed indexing ops",
            "type": "string"
          },
          "merges.current": {
            "description": "number of current merges",
            "type": "string"
          },
          "pri.merges.current": {
            "description": "number of current merges",
            "type": "string"
          },
          "merges.current_docs": {
            "description": "number of current merging docs",
            "type": "string"
          },
          "pri.merges.current_docs": {
            "description": "number of current merging docs",
            "type": "string"
          },
          "merges.current_size": {
            "description": "size of current merges",
            "type": "string"
          },
          "pri.merges.current_size": {
            "description": "size of current merges",
            "type": "string"
          },
          "merges.total": {
            "description": "number of completed merge ops",
            "type": "string"
          },
          "pri.merges.total": {
            "description": "number of completed merge ops",
            "type": "string"
          },
          "merges.total_docs": {
            "description": "docs merged",
            "type": "string"
          },
          "pri.merges.total_docs": {
            "description": "docs merged",
            "type": "string"
          },
          "merges.total_size": {
            "description": "size merged",
            "type": "string"
          },
          "pri.merges.total_size": {
            "description": "size merged",
            "type": "string"
          },
          "merges.total_time": {
            "description": "time spent in merges",
            "type": "string"
          },
          "pri.merges.total_time": {
            "description": "time spent in merges",
            "type": "string"
          },
          "refresh.total": {
            "description": "total refreshes",
            "type": "string"
          },
          "pri.refresh.total": {
            "description": "total refreshes",
            "type": "string"
          },
          "refresh.time": {
            "description": "time spent in refreshes",
            "type": "string"
          },
          "pri.refresh.time": {
            "description": "time spent in refreshes",
            "type": "string"
          },
          "refresh.external_total": {
            "description": "total external refreshes",
            "type": "string"
          },
          "pri.refresh.external_total": {
            "description": "total external refreshes",
            "type": "string"
          },
          "refresh.external_time": {
            "description": "time spent in external refreshes",
            "type": "string"
          },
          "pri.refresh.external_time": {
            "description": "time spent in external refreshes",
            "type": "string"
          },
          "refresh.listeners": {
            "description": "number of pending refresh listeners",
            "type": "string"
          },
          "pri.refresh.listeners": {
            "description": "number of pending refresh listeners",
            "type": "string"
          },
          "search.fetch_current": {
            "description": "current fetch phase ops",
            "type": "string"
          },
          "pri.search.fetch_current": {
            "description": "current fetch phase ops",
            "type": "string"
          },
          "search.fetch_time": {
            "description": "time spent in fetch phase",
            "type": "string"
          },
          "pri.search.fetch_time": {
            "description": "time spent in fetch phase",
            "type": "string"
          },
          "search.fetch_total": {
            "description": "total fetch ops",
            "type": "string"
          },
          "pri.search.fetch_total": {
            "description": "total fetch ops",
            "type": "string"
          },
          "search.open_contexts": {
            "description": "open search contexts",
            "type": "string"
          },
          "pri.search.open_contexts": {
            "description": "open search contexts",
            "type": "string"
          },
          "search.query_current": {
            "description": "current query phase ops",
            "type": "string"
          },
          "pri.search.query_current": {
            "description": "current query phase ops",
            "type": "string"
          },
          "search.query_time": {
            "description": "time spent in query phase",
            "type": "string"
          },
          "pri.search.query_time": {
            "description": "time spent in query phase",
            "type": "string"
          },
          "search.query_total": {
            "description": "total query phase ops",
            "type": "string"
          },
          "pri.search.query_total": {
            "description": "total query phase ops",
            "type": "string"
          },
          "search.scroll_current": {
            "description": "open scroll contexts",
            "type": "string"
          },
          "pri.search.scroll_current": {
            "description": "open scroll contexts",
            "type": "string"
          },
          "search.scroll_time": {
            "description": "time scroll contexts held open",
            "type": "string"
          },
          "pri.search.scroll_time": {
            "description": "time scroll contexts held open",
            "type": "string"
          },
          "search.scroll_total": {
            "description": "completed scroll contexts",
            "type": "string"
          },
          "pri.search.scroll_total": {
            "description": "completed scroll contexts",
            "type": "string"
          },
          "segments.count": {
            "description": "number of segments",
            "type": "string"
          },
          "pri.segments.count": {
            "description": "number of segments",
            "type": "string"
          },
          "segments.memory": {
            "description": "memory used by segments",
            "type": "string"
          },
          "pri.segments.memory": {
            "description": "memory used by segments",
            "type": "string"
          },
          "segments.index_writer_memory": {
            "description": "memory used by index writer",
            "type": "string"
          },
          "pri.segments.index_writer_memory": {
            "description": "memory used by index writer",
            "type": "string"
          },
          "segments.version_map_memory": {
            "description": "memory used by version map",
            "type": "string"
          },
          "pri.segments.version_map_memory": {
            "description": "memory used by version map",
            "type": "string"
          },
          "segments.fixed_bitset_memory": {
            "description": "memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields",
            "type": "string"
          },
          "pri.segments.fixed_bitset_memory": {
            "description": "memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields",
            "type": "string"
          },
          "warmer.current": {
            "description": "current warmer ops",
            "type": "string"
          },
          "pri.warmer.current": {
            "description": "current warmer ops",
            "type": "string"
          },
          "warmer.total": {
            "description": "total warmer ops",
            "type": "string"
          },
          "pri.warmer.total": {
            "description": "total warmer ops",
            "type": "string"
          },
          "warmer.total_time": {
            "description": "time spent in warmers",
            "type": "string"
          },
          "pri.warmer.total_time": {
            "description": "time spent in warmers",
            "type": "string"
          },
          "suggest.current": {
            "description": "number of current suggest ops",
            "type": "string"
          },
          "pri.suggest.current": {
            "description": "number of current suggest ops",
            "type": "string"
          },
          "suggest.time": {
            "description": "time spend in suggest",
            "type": "string"
          },
          "pri.suggest.time": {
            "description": "time spend in suggest",
            "type": "string"
          },
          "suggest.total": {
            "description": "number of suggest ops",
            "type": "string"
          },
          "pri.suggest.total": {
            "description": "number of suggest ops",
            "type": "string"
          },
          "memory.total": {
            "description": "total used memory",
            "type": "string"
          },
          "pri.memory.total": {
            "description": "total user memory",
            "type": "string"
          },
          "search.throttled": {
            "description": "indicates if the index is search throttled",
            "type": "string"
          },
          "bulk.total_operations": {
            "description": "number of bulk shard ops",
            "type": "string"
          },
          "pri.bulk.total_operations": {
            "description": "number of bulk shard ops",
            "type": "string"
          },
          "bulk.total_time": {
            "description": "time spend in shard bulk",
            "type": "string"
          },
          "pri.bulk.total_time": {
            "description": "time spend in shard bulk",
            "type": "string"
          },
          "bulk.total_size_in_bytes": {
            "description": "total size in bytes of shard bulk",
            "type": "string"
          },
          "pri.bulk.total_size_in_bytes": {
            "description": "total size in bytes of shard bulk",
            "type": "string"
          },
          "bulk.avg_time": {
            "description": "average time spend in shard bulk",
            "type": "string"
          },
          "pri.bulk.avg_time": {
            "description": "average time spend in shard bulk",
            "type": "string"
          },
          "bulk.avg_size_in_bytes": {
            "description": "average size in bytes of shard bulk",
            "type": "string"
          },
          "pri.bulk.avg_size_in_bytes": {
            "description": "average size in bytes of shard bulk",
            "type": "string"
          }
        }
      },
      "cat.master:MasterRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "node id",
            "type": "string"
          },
          "host": {
            "description": "host name",
            "type": "string"
          },
          "ip": {
            "description": "ip address",
            "type": "string"
          },
          "node": {
            "description": "node name",
            "type": "string"
          }
        }
      },
      "cat._types:CatDfaColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatDfaColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatDfaColumn"
            }
          }
        ]
      },
      "cat._types:CatDfaColumn": {
        "type": "string",
        "enum": [
          "assignment_explanation",
          "ae",
          "create_time",
          "ct",
          "createTime",
          "description",
          "d",
          "dest_index",
          "di",
          "destIndex",
          "failure_reason",
          "fr",
          "failureReason",
          "id",
          "model_memory_limit",
          "mml",
          "modelMemoryLimit",
          "node.address",
          "na",
          "nodeAddress",
          "node.ephemeral_id",
          "ne",
          "nodeEphemeralId",
          "node.id",
          "ni",
          "nodeId",
          "node.name",
          "nn",
          "nodeName",
          "progress",
          "p",
          "source_index",
          "si",
          "sourceIndex",
          "state",
          "s",
          "type",
          "t",
          "version",
          "v"
        ]
      },
      "cat.ml_data_frame_analytics:DataFrameAnalyticsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "type": {
            "description": "The type of analysis that the job performs.",
            "type": "string"
          },
          "create_time": {
            "description": "The time when the job was created.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "source_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "dest_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "description": {
            "description": "A description of the job.",
            "type": "string"
          },
          "model_memory_limit": {
            "description": "The approximate maximum amount of memory resources that are permitted for the job.",
            "type": "string"
          },
          "state": {
            "description": "The current status of the job.",
            "type": "string"
          },
          "failure_reason": {
            "description": "Messages about the reason why the job failed.",
            "type": "string"
          },
          "progress": {
            "description": "The progress report for the job by phase.",
            "type": "string"
          },
          "assignment_explanation": {
            "description": "Messages related to the selection of a node.",
            "type": "string"
          },
          "node.id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node.name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "node.ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node.address": {
            "description": "The network address of the assigned node.",
            "type": "string"
          }
        }
      },
      "cat._types:CatDatafeedColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatDatafeedColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatDatafeedColumn"
            }
          }
        ]
      },
      "cat._types:CatDatafeedColumn": {
        "type": "string",
        "enum": [
          "ae",
          "assignment_explanation",
          "bc",
          "buckets.count",
          "bucketsCount",
          "id",
          "na",
          "node.address",
          "nodeAddress",
          "ne",
          "node.ephemeral_id",
          "nodeEphemeralId",
          "ni",
          "node.id",
          "nodeId",
          "nn",
          "node.name",
          "nodeName",
          "sba",
          "search.bucket_avg",
          "searchBucketAvg",
          "sc",
          "search.count",
          "searchCount",
          "seah",
          "search.exp_avg_hour",
          "searchExpAvgHour",
          "st",
          "search.time",
          "searchTime",
          "s",
          "state"
        ]
      },
      "cat.ml_datafeeds:DatafeedsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The datafeed identifier.",
            "type": "string"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DatafeedState"
          },
          "assignment_explanation": {
            "description": "For started datafeeds only, contains messages relating to the selection of a node.",
            "type": "string"
          },
          "buckets.count": {
            "description": "The number of buckets processed.",
            "type": "string"
          },
          "search.count": {
            "description": "The number of searches run by the datafeed.",
            "type": "string"
          },
          "search.time": {
            "description": "The total time the datafeed spent searching, in milliseconds.",
            "type": "string"
          },
          "search.bucket_avg": {
            "description": "The average search time per bucket, in milliseconds.",
            "type": "string"
          },
          "search.exp_avg_hour": {
            "description": "The exponential average search time per hour, in milliseconds.",
            "type": "string"
          },
          "node.id": {
            "description": "The unique identifier of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          },
          "node.name": {
            "description": "The name of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          },
          "node.ephemeral_id": {
            "description": "The ephemeral identifier of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          },
          "node.address": {
            "description": "The network address of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          }
        }
      },
      "ml._types:DatafeedState": {
        "type": "string",
        "enum": [
          "started",
          "stopped",
          "starting",
          "stopping"
        ]
      },
      "cat._types:CatAnonalyDetectorColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatAnomalyDetectorColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatAnomalyDetectorColumn"
            }
          }
        ]
      },
      "cat._types:CatAnomalyDetectorColumn": {
        "type": "string",
        "enum": [
          "assignment_explanation",
          "ae",
          "buckets.count",
          "bc",
          "bucketsCount",
          "buckets.time.exp_avg",
          "btea",
          "bucketsTimeExpAvg",
          "buckets.time.exp_avg_hour",
          "bteah",
          "bucketsTimeExpAvgHour",
          "buckets.time.max",
          "btmax",
          "bucketsTimeMax",
          "buckets.time.min",
          "btmin",
          "bucketsTimeMin",
          "buckets.time.total",
          "btt",
          "bucketsTimeTotal",
          "data.buckets",
          "db",
          "dataBuckets",
          "data.earliest_record",
          "der",
          "dataEarliestRecord",
          "data.empty_buckets",
          "deb",
          "dataEmptyBuckets",
          "data.input_bytes",
          "dib",
          "dataInputBytes",
          "data.input_fields",
          "dif",
          "dataInputFields",
          "data.input_records",
          "dir",
          "dataInputRecords",
          "data.invalid_dates",
          "did",
          "dataInvalidDates",
          "data.last",
          "dl",
          "dataLast",
          "data.last_empty_bucket",
          "dleb",
          "dataLastEmptyBucket",
          "data.last_sparse_bucket",
          "dlsb",
          "dataLastSparseBucket",
          "data.latest_record",
          "dlr",
          "dataLatestRecord",
          "data.missing_fields",
          "dmf",
          "dataMissingFields",
          "data.out_of_order_timestamps",
          "doot",
          "dataOutOfOrderTimestamps",
          "data.processed_fields",
          "dpf",
          "dataProcessedFields",
          "data.processed_records",
          "dpr",
          "dataProcessedRecords",
          "data.sparse_buckets",
          "dsb",
          "dataSparseBuckets",
          "forecasts.memory.avg",
          "fmavg",
          "forecastsMemoryAvg",
          "forecasts.memory.max",
          "fmmax",
          "forecastsMemoryMax",
          "forecasts.memory.min",
          "fmmin",
          "forecastsMemoryMin",
          "forecasts.memory.total",
          "fmt",
          "forecastsMemoryTotal",
          "forecasts.records.avg",
          "fravg",
          "forecastsRecordsAvg",
          "forecasts.records.max",
          "frmax",
          "forecastsRecordsMax",
          "forecasts.records.min",
          "frmin",
          "forecastsRecordsMin",
          "forecasts.records.total",
          "frt",
          "forecastsRecordsTotal",
          "forecasts.time.avg",
          "ftavg",
          "forecastsTimeAvg",
          "forecasts.time.max",
          "ftmax",
          "forecastsTimeMax",
          "forecasts.time.min",
          "ftmin",
          "forecastsTimeMin",
          "forecasts.time.total",
          "ftt",
          "forecastsTimeTotal",
          "forecasts.total",
          "ft",
          "forecastsTotal",
          "id",
          "model.bucket_allocation_failures",
          "mbaf",
          "modelBucketAllocationFailures",
          "model.by_fields",
          "mbf",
          "modelByFields",
          "model.bytes",
          "mb",
          "modelBytes",
          "model.bytes_exceeded",
          "mbe",
          "modelBytesExceeded",
          "model.categorization_status",
          "mcs",
          "modelCategorizationStatus",
          "model.categorized_doc_count",
          "mcdc",
          "modelCategorizedDocCount",
          "model.dead_category_count",
          "mdcc",
          "modelDeadCategoryCount",
          "model.failed_category_count",
          "mdcc",
          "modelFailedCategoryCount",
          "model.frequent_category_count",
          "mfcc",
          "modelFrequentCategoryCount",
          "model.log_time",
          "mlt",
          "modelLogTime",
          "model.memory_limit",
          "mml",
          "modelMemoryLimit",
          "model.memory_status",
          "mms",
          "modelMemoryStatus",
          "model.over_fields",
          "mof",
          "modelOverFields",
          "model.partition_fields",
          "mpf",
          "modelPartitionFields",
          "model.rare_category_count",
          "mrcc",
          "modelRareCategoryCount",
          "model.timestamp",
          "mt",
          "modelTimestamp",
          "model.total_category_count",
          "mtcc",
          "modelTotalCategoryCount",
          "node.address",
          "na",
          "nodeAddress",
          "node.ephemeral_id",
          "ne",
          "nodeEphemeralId",
          "node.id",
          "ni",
          "nodeId",
          "node.name",
          "nn",
          "nodeName",
          "opened_time",
          "ot",
          "state",
          "s"
        ]
      },
      "cat.ml_jobs:JobsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:JobState"
          },
          "opened_time": {
            "description": "For open jobs only, the amount of time the job has been opened.",
            "type": "string"
          },
          "assignment_explanation": {
            "description": "For open anomaly detection jobs only, contains messages relating to the selection of a node to run the job.",
            "type": "string"
          },
          "data.processed_records": {
            "description": "The number of input documents that have been processed by the anomaly detection job.\nThis value includes documents with missing fields, since they are nonetheless analyzed.\nIf you use datafeeds and have aggregations in your search query, the `processed_record_count` is the number of aggregation results processed, not the number of Elasticsearch documents.",
            "type": "string"
          },
          "data.processed_fields": {
            "description": "The total number of fields in all the documents that have been processed by the anomaly detection job.\nOnly fields that are specified in the detector configuration object contribute to this count.\nThe timestamp is not included in this count.",
            "type": "string"
          },
          "data.input_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "data.input_records": {
            "description": "The number of input documents posted to the anomaly detection job.",
            "type": "string"
          },
          "data.input_fields": {
            "description": "The total number of fields in input documents posted to the anomaly detection job.\nThis count includes fields that are not used in the analysis.\nHowever, be aware that if you are using a datafeed, it extracts only the required fields from the documents it retrieves before posting them to the job.",
            "type": "string"
          },
          "data.invalid_dates": {
            "description": "The number of input documents with either a missing date field or a date that could not be parsed.",
            "type": "string"
          },
          "data.missing_fields": {
            "description": "The number of input documents that are missing a field that the anomaly detection job is configured to analyze.\nInput documents with missing fields are still processed because it is possible that not all fields are missing.\nIf you are using datafeeds or posting data to the job in JSON format, a high `missing_field_count` is often not an indication of data issues.\nIt is not necessarily a cause for concern.",
            "type": "string"
          },
          "data.out_of_order_timestamps": {
            "description": "The number of input documents that have a timestamp chronologically preceding the start of the current anomaly detection bucket offset by the latency window.\nThis information is applicable only when you provide data to the anomaly detection job by using the post data API.\nThese out of order documents are discarded, since jobs require time series data to be in ascending chronological order.",
            "type": "string"
          },
          "data.empty_buckets": {
            "description": "The number of buckets which did not contain any data.\nIf your data contains many empty buckets, consider increasing your `bucket_span` or using functions that are tolerant to gaps in data such as mean, `non_null_sum` or `non_zero_count`.",
            "type": "string"
          },
          "data.sparse_buckets": {
            "description": "The number of buckets that contained few data points compared to the expected number of data points.\nIf your data contains many sparse buckets, consider using a longer `bucket_span`.",
            "type": "string"
          },
          "data.buckets": {
            "description": "The total number of buckets processed.",
            "type": "string"
          },
          "data.earliest_record": {
            "description": "The timestamp of the earliest chronologically input document.",
            "type": "string"
          },
          "data.latest_record": {
            "description": "The timestamp of the latest chronologically input document.",
            "type": "string"
          },
          "data.last": {
            "description": "The timestamp at which data was last analyzed, according to server time.",
            "type": "string"
          },
          "data.last_empty_bucket": {
            "description": "The timestamp of the last bucket that did not contain any data.",
            "type": "string"
          },
          "data.last_sparse_bucket": {
            "description": "The timestamp of the last bucket that was considered sparse.",
            "type": "string"
          },
          "model.bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model.memory_status": {
            "$ref": "#/components/schemas/ml._types:MemoryStatus"
          },
          "model.bytes_exceeded": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model.memory_limit": {
            "description": "The upper limit for model memory usage, checked on increasing values.",
            "type": "string"
          },
          "model.by_fields": {
            "description": "The number of `by` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.",
            "type": "string"
          },
          "model.over_fields": {
            "description": "The number of `over` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.",
            "type": "string"
          },
          "model.partition_fields": {
            "description": "The number of `partition` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.",
            "type": "string"
          },
          "model.bucket_allocation_failures": {
            "description": "The number of buckets for which new entities in incoming data were not processed due to insufficient model memory.\nThis situation is also signified by a `hard_limit: memory_status` property value.",
            "type": "string"
          },
          "model.categorization_status": {
            "$ref": "#/components/schemas/ml._types:CategorizationStatus"
          },
          "model.categorized_doc_count": {
            "description": "The number of documents that have had a field categorized.",
            "type": "string"
          },
          "model.total_category_count": {
            "description": "The number of categories created by categorization.",
            "type": "string"
          },
          "model.frequent_category_count": {
            "description": "The number of categories that match more than 1% of categorized documents.",
            "type": "string"
          },
          "model.rare_category_count": {
            "description": "The number of categories that match just one categorized document.",
            "type": "string"
          },
          "model.dead_category_count": {
            "description": "The number of categories created by categorization that will never be assigned again because another categoryâ€™s definition makes it a superset of the dead category.\nDead categories are a side effect of the way categorization has no prior training.",
            "type": "string"
          },
          "model.failed_category_count": {
            "description": "The number of times that categorization wanted to create a new category but couldnâ€™t because the job had hit its `model_memory_limit`.\nThis count does not track which specific categories failed to be created.\nTherefore you cannot use this value to determine the number of unique categories that were missed.",
            "type": "string"
          },
          "model.log_time": {
            "description": "The timestamp when the model stats were gathered, according to server time.",
            "type": "string"
          },
          "model.timestamp": {
            "description": "The timestamp of the last record when the model stats were gathered.",
            "type": "string"
          },
          "forecasts.total": {
            "description": "The number of individual forecasts currently available for the job.\nA value of one or more indicates that forecasts exist.",
            "type": "string"
          },
          "forecasts.memory.min": {
            "description": "The minimum memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.memory.max": {
            "description": "The maximum memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.memory.avg": {
            "description": "The average memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.memory.total": {
            "description": "The total memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.min": {
            "description": "The minimum number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.max": {
            "description": "The maximum number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.avg": {
            "description": "The average number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.total": {
            "description": "The total number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.min": {
            "description": "The minimum runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.max": {
            "description": "The maximum runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.avg": {
            "description": "The average runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.total": {
            "description": "The total runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "node.id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "node.name": {
            "description": "The name of the assigned node.",
            "type": "string"
          },
          "node.ephemeral_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "node.address": {
            "description": "The network address of the assigned node.",
            "type": "string"
          },
          "buckets.count": {
            "description": "The number of bucket results produced by the job.",
            "type": "string"
          },
          "buckets.time.total": {
            "description": "The sum of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.min": {
            "description": "The minimum of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.max": {
            "description": "The maximum of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.exp_avg": {
            "description": "The exponential moving average of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.exp_avg_hour": {
            "description": "The exponential moving average of bucket processing times calculated in a one hour time window, in milliseconds.",
            "type": "string"
          }
        }
      },
      "ml._types:JobState": {
        "type": "string",
        "enum": [
          "closing",
          "closed",
          "opened",
          "failed",
          "opening"
        ]
      },
      "ml._types:MemoryStatus": {
        "type": "string",
        "enum": [
          "ok",
          "soft_limit",
          "hard_limit"
        ]
      },
      "ml._types:CategorizationStatus": {
        "type": "string",
        "enum": [
          "ok",
          "warn"
        ]
      },
      "cat._types:CatTrainedModelsColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumn"
            }
          }
        ]
      },
      "cat._types:CatTrainedModelsColumn": {
        "type": "string",
        "enum": [
          "create_time",
          "ct",
          "created_by",
          "c",
          "createdBy",
          "data_frame_analytics_id",
          "df",
          "dataFrameAnalytics",
          "dfid",
          "description",
          "d",
          "heap_size",
          "hs",
          "modelHeapSize",
          "id",
          "ingest.count",
          "ic",
          "ingestCount",
          "ingest.current",
          "icurr",
          "ingestCurrent",
          "ingest.failed",
          "if",
          "ingestFailed",
          "ingest.pipelines",
          "ip",
          "ingestPipelines",
          "ingest.time",
          "it",
          "ingestTime",
          "license",
          "l",
          "operations",
          "o",
          "modelOperations",
          "version",
          "v"
        ]
      },
      "cat.ml_trained_models:TrainedModelsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "created_by": {
            "description": "Information about the creator of the model.",
            "type": "string"
          },
          "heap_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "operations": {
            "description": "The estimated number of operations to use the model.\nThis number helps to measure the computational complexity of the model.",
            "type": "string"
          },
          "license": {
            "description": "The license level of the model.",
            "type": "string"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "description": {
            "description": "A description of the model.",
            "type": "string"
          },
          "ingest.pipelines": {
            "description": "The number of pipelines that are referencing the model.",
            "type": "string"
          },
          "ingest.count": {
            "description": "The total number of documents that are processed by the model.",
            "type": "string"
          },
          "ingest.time": {
            "description": "The total time spent processing documents with thie model.",
            "type": "string"
          },
          "ingest.current": {
            "description": "The total number of documents that are currently being handled by the model.",
            "type": "string"
          },
          "ingest.failed": {
            "description": "The total number of failed ingest attempts with the model.",
            "type": "string"
          },
          "data_frame.id": {
            "description": "The identifier for the data frame analytics job that created the model.\nOnly displayed if the job is still available.",
            "type": "string"
          },
          "data_frame.create_time": {
            "description": "The time the data frame analytics job was created.",
            "type": "string"
          },
          "data_frame.source_index": {
            "description": "The source index used to train in the data frame analysis.",
            "type": "string"
          },
          "data_frame.analysis": {
            "description": "The analysis used by the data frame to build the model.",
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        }
      },
      "cat.nodeattrs:NodeAttributesRecord": {
        "type": "object",
        "properties": {
          "node": {
            "description": "The node name.",
            "type": "string"
          },
          "id": {
            "description": "The unique node identifier.",
            "type": "string"
          },
          "pid": {
            "description": "The process identifier.",
            "type": "string"
          },
          "host": {
            "description": "The host name.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port.",
            "type": "string"
          },
          "attr": {
            "description": "The attribute name.",
            "type": "string"
          },
          "value": {
            "description": "The attribute value.",
            "type": "string"
          }
        }
      },
      "cat.nodes:NodesRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "pid": {
            "description": "The process identifier.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port.",
            "type": "string"
          },
          "http_address": {
            "description": "The bound HTTP address.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "flavor": {
            "description": "The Elasticsearch distribution flavor.",
            "type": "string"
          },
          "type": {
            "description": "The Elasticsearch distribution type.",
            "type": "string"
          },
          "build": {
            "description": "The Elasticsearch build hash.",
            "type": "string"
          },
          "jdk": {
            "description": "The Java version.",
            "type": "string"
          },
          "disk.total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "disk.used": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "disk.avail": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "disk.used_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "heap.current": {
            "description": "The used heap.",
            "type": "string"
          },
          "heap.percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "heap.max": {
            "description": "The maximum configured heap.",
            "type": "string"
          },
          "ram.current": {
            "description": "The used machine memory.",
            "type": "string"
          },
          "ram.percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "ram.max": {
            "description": "The total machine memory.",
            "type": "string"
          },
          "file_desc.current": {
            "description": "The used file descriptors.",
            "type": "string"
          },
          "file_desc.percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "file_desc.max": {
            "description": "The maximum number of file descriptors.",
            "type": "string"
          },
          "cpu": {
            "description": "The recent system CPU usage as a percentage.",
            "type": "string"
          },
          "load_1m": {
            "description": "The load average for the most recent minute.",
            "type": "string"
          },
          "load_5m": {
            "description": "The load average for the last five minutes.",
            "type": "string"
          },
          "load_15m": {
            "description": "The load average for the last fifteen minutes.",
            "type": "string"
          },
          "uptime": {
            "description": "The node uptime.",
            "type": "string"
          },
          "node.role": {
            "description": "The roles of the node.\nReturned values include `c`(cold node), `d`(data node), `f`(frozen node), `h`(hot node), `i`(ingest node), `l`(machine learning node), `m` (master eligible node), `r`(remote cluster client node), `s`(content node), `t`(transform node), `v`(voting-only node), `w`(warm node),and `-`(coordinating node only).",
            "type": "string"
          },
          "master": {
            "description": "Indicates whether the node is the elected master node.\nReturned values include `*`(elected master) and `-`(not elected master).",
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "completion.size": {
            "description": "The size of completion.",
            "type": "string"
          },
          "fielddata.memory_size": {
            "description": "The used fielddata cache.",
            "type": "string"
          },
          "fielddata.evictions": {
            "description": "The fielddata evictions.",
            "type": "string"
          },
          "query_cache.memory_size": {
            "description": "The used query cache.",
            "type": "string"
          },
          "query_cache.evictions": {
            "description": "The query cache evictions.",
            "type": "string"
          },
          "query_cache.hit_count": {
            "description": "The query cache hit counts.",
            "type": "string"
          },
          "query_cache.miss_count": {
            "description": "The query cache miss counts.",
            "type": "string"
          },
          "request_cache.memory_size": {
            "description": "The used request cache.",
            "type": "string"
          },
          "request_cache.evictions": {
            "description": "The request cache evictions.",
            "type": "string"
          },
          "request_cache.hit_count": {
            "description": "The request cache hit counts.",
            "type": "string"
          },
          "request_cache.miss_count": {
            "description": "The request cache miss counts.",
            "type": "string"
          },
          "flush.total": {
            "description": "The number of flushes.",
            "type": "string"
          },
          "flush.total_time": {
            "description": "The time spent in flush.",
            "type": "string"
          },
          "get.current": {
            "description": "The number of current get ops.",
            "type": "string"
          },
          "get.time": {
            "description": "The time spent in get.",
            "type": "string"
          },
          "get.total": {
            "description": "The number of get ops.",
            "type": "string"
          },
          "get.exists_time": {
            "description": "The time spent in successful gets.",
            "type": "string"
          },
          "get.exists_total": {
            "description": "The number of successful get operations.",
            "type": "string"
          },
          "get.missing_time": {
            "description": "The time spent in failed gets.",
            "type": "string"
          },
          "get.missing_total": {
            "description": "The number of failed gets.",
            "type": "string"
          },
          "indexing.delete_current": {
            "description": "The number of current deletions.",
            "type": "string"
          },
          "indexing.delete_time": {
            "description": "The time spent in deletions.",
            "type": "string"
          },
          "indexing.delete_total": {
            "description": "The number of delete operations.",
            "type": "string"
          },
          "indexing.index_current": {
            "description": "The number of current indexing operations.",
            "type": "string"
          },
          "indexing.index_time": {
            "description": "The time spent in indexing.",
            "type": "string"
          },
          "indexing.index_total": {
            "description": "The number of indexing operations.",
            "type": "string"
          },
          "indexing.index_failed": {
            "description": "The number of failed indexing operations.",
            "type": "string"
          },
          "merges.current": {
            "description": "The number of current merges.",
            "type": "string"
          },
          "merges.current_docs": {
            "description": "The number of current merging docs.",
            "type": "string"
          },
          "merges.current_size": {
            "description": "The size of current merges.",
            "type": "string"
          },
          "merges.total": {
            "description": "The number of completed merge operations.",
            "type": "string"
          },
          "merges.total_docs": {
            "description": "The docs merged.",
            "type": "string"
          },
          "merges.total_size": {
            "description": "The size merged.",
            "type": "string"
          },
          "merges.total_time": {
            "description": "The time spent in merges.",
            "type": "string"
          },
          "refresh.total": {
            "description": "The total refreshes.",
            "type": "string"
          },
          "refresh.time": {
            "description": "The time spent in refreshes.",
            "type": "string"
          },
          "refresh.external_total": {
            "description": "The total external refreshes.",
            "type": "string"
          },
          "refresh.external_time": {
            "description": "The time spent in external refreshes.",
            "type": "string"
          },
          "refresh.listeners": {
            "description": "The number of pending refresh listeners.",
            "type": "string"
          },
          "script.compilations": {
            "description": "The total script compilations.",
            "type": "string"
          },
          "script.cache_evictions": {
            "description": "The total compiled scripts evicted from the cache.",
            "type": "string"
          },
          "script.compilation_limit_triggered": {
            "description": "The script cache compilation limit triggered.",
            "type": "string"
          },
          "search.fetch_current": {
            "description": "The current fetch phase operations.",
            "type": "string"
          },
          "search.fetch_time": {
            "description": "The time spent in fetch phase.",
            "type": "string"
          },
          "search.fetch_total": {
            "description": "The total fetch operations.",
            "type": "string"
          },
          "search.open_contexts": {
            "description": "The open search contexts.",
            "type": "string"
          },
          "search.query_current": {
            "description": "The current query phase operations.",
            "type": "string"
          },
          "search.query_time": {
            "description": "The time spent in query phase.",
            "type": "string"
          },
          "search.query_total": {
            "description": "The total query phase operations.",
            "type": "string"
          },
          "search.scroll_current": {
            "description": "The open scroll contexts.",
            "type": "string"
          },
          "search.scroll_time": {
            "description": "The time scroll contexts held open.",
            "type": "string"
          },
          "search.scroll_total": {
            "description": "The completed scroll contexts.",
            "type": "string"
          },
          "segments.count": {
            "description": "The number of segments.",
            "type": "string"
          },
          "segments.memory": {
            "description": "The memory used by segments.",
            "type": "string"
          },
          "segments.index_writer_memory": {
            "description": "The memory used by the index writer.",
            "type": "string"
          },
          "segments.version_map_memory": {
            "description": "The memory used by the version map.",
            "type": "string"
          },
          "segments.fixed_bitset_memory": {
            "description": "The memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields.",
            "type": "string"
          },
          "suggest.current": {
            "description": "The number of current suggest operations.",
            "type": "string"
          },
          "suggest.time": {
            "description": "The time spend in suggest.",
            "type": "string"
          },
          "suggest.total": {
            "description": "The number of suggest operations.",
            "type": "string"
          },
          "bulk.total_operations": {
            "description": "The number of bulk shard operations.",
            "type": "string"
          },
          "bulk.total_time": {
            "description": "The time spend in shard bulk.",
            "type": "string"
          },
          "bulk.total_size_in_bytes": {
            "description": "The total size in bytes of shard bulk.",
            "type": "string"
          },
          "bulk.avg_time": {
            "description": "The average time spend in shard bulk.",
            "type": "string"
          },
          "bulk.avg_size_in_bytes": {
            "description": "The average size in bytes of shard bulk.",
            "type": "string"
          }
        }
      },
      "cat.pending_tasks:PendingTasksRecord": {
        "type": "object",
        "properties": {
          "insertOrder": {
            "description": "The task insertion order.",
            "type": "string"
          },
          "timeInQueue": {
            "description": "Indicates how long the task has been in queue.",
            "type": "string"
          },
          "priority": {
            "description": "The task priority.",
            "type": "string"
          },
          "source": {
            "description": "The task source.",
            "type": "string"
          }
        }
      },
      "cat.plugins:PluginsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "component": {
            "description": "The component name.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "description": {
            "description": "The plugin details.",
            "type": "string"
          },
          "type": {
            "description": "The plugin type.",
            "type": "string"
          }
        }
      },
      "cat.recovery:RecoveryRecord": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "description": "The shard name.",
            "type": "string"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "stop_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "stop_time_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "type": {
            "description": "The recovery type.",
            "type": "string"
          },
          "stage": {
            "description": "The recovery stage.",
            "type": "string"
          },
          "source_host": {
            "description": "The source host.",
            "type": "string"
          },
          "source_node": {
            "description": "The source node name.",
            "type": "string"
          },
          "target_host": {
            "description": "The target host.",
            "type": "string"
          },
          "target_node": {
            "description": "The target node name.",
            "type": "string"
          },
          "repository": {
            "description": "The repository name.",
            "type": "string"
          },
          "snapshot": {
            "description": "The snapshot name.",
            "type": "string"
          },
          "files": {
            "description": "The number of files to recover.",
            "type": "string"
          },
          "files_recovered": {
            "description": "The files recovered.",
            "type": "string"
          },
          "files_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "files_total": {
            "description": "The total number of files.",
            "type": "string"
          },
          "bytes": {
            "description": "The number of bytes to recover.",
            "type": "string"
          },
          "bytes_recovered": {
            "description": "The bytes recovered.",
            "type": "string"
          },
          "bytes_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "bytes_total": {
            "description": "The total number of bytes.",
            "type": "string"
          },
          "translog_ops": {
            "description": "The number of translog operations to recover.",
            "type": "string"
          },
          "translog_ops_recovered": {
            "description": "The translog operations recovered.",
            "type": "string"
          },
          "translog_ops_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          }
        }
      },
      "cat.repositories:RepositoriesRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The unique repository identifier.",
            "type": "string"
          },
          "type": {
            "description": "The repository type.",
            "type": "string"
          }
        }
      },
      "cat.segments:SegmentsRecord": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "description": "The shard name.",
            "type": "string"
          },
          "prirep": {
            "description": "The shard type: `primary` or `replica`.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address of the node where it lives.",
            "type": "string"
          },
          "id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "segment": {
            "description": "The segment name, which is derived from the segment generation and used internally to create file names in the directory of the shard.",
            "type": "string"
          },
          "generation": {
            "description": "The segment generation number.\nElasticsearch increments this generation number for each segment written then uses this number to derive the segment name.",
            "type": "string"
          },
          "docs.count": {
            "description": "The number of documents in the segment.\nThis excludes deleted documents and counts any nested documents separately from their parents.\nIt also excludes documents which were indexed recently and do not yet belong to a segment.",
            "type": "string"
          },
          "docs.deleted": {
            "description": "The number of deleted documents in the segment, which might be higher or lower than the number of delete operations you have performed.\nThis number excludes deletes that were performed recently and do not yet belong to a segment.\nDeleted documents are cleaned up by the automatic merge process if it makes sense to do so.\nAlso, Elasticsearch creates extra deleted documents to internally track the recent history of operations on a shard.",
            "type": "string"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size.memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "committed": {
            "description": "If `true`, the segment is synced to disk.\nSegments that are synced can survive a hard reboot.\nIf `false`, the data from uncommitted segments is also stored in the transaction log so that Elasticsearch is able to replay changes on the next start.",
            "type": "string"
          },
          "searchable": {
            "description": "If `true`, the segment is searchable.\nIf `false`, the segment has most likely been written to disk but needs a refresh to be searchable.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "compound": {
            "description": "If `true`, the segment is stored in a compound file.\nThis means Lucene merged all files from the segment in a single file to save file descriptors.",
            "type": "string"
          }
        }
      },
      "cat.shards:ShardsRecord": {
        "type": "object",
        "properties": {
          "index": {
            "description": "The index name.",
            "type": "string"
          },
          "shard": {
            "description": "The shard name.",
            "type": "string"
          },
          "prirep": {
            "description": "The shard type: `primary` or `replica`.",
            "type": "string"
          },
          "state": {
            "description": "The shard state.\nReturned values include:\n`INITIALIZING`: The shard is recovering from a peer shard or gateway.\n`RELOCATING`: The shard is relocating.\n`STARTED`: The shard has started.\n`UNASSIGNED`: The shard is not assigned to any node.",
            "type": "string"
          },
          "docs": {
            "description": "The number of documents in the shard.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "store": {
            "description": "The disk space used by the shard.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "dataset": {
            "description": "total size of dataset (including the cache for partially mounted indices)",
            "x-state": "Added in 8.11.0",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "ip": {
            "description": "The IP address of the node.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "id": {
            "description": "The unique identifier for the node.",
            "type": "string"
          },
          "node": {
            "description": "The name of node.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "sync_id": {
            "description": "The sync identifier.",
            "type": "string"
          },
          "unassigned.reason": {
            "description": "The reason for the last change to the state of an unassigned shard.\nIt does not explain why the shard is currently unassigned; use the cluster allocation explain API for that information.\nReturned values include:\n`ALLOCATION_FAILED`: Unassigned as a result of a failed allocation of the shard.\n`CLUSTER_RECOVERED`: Unassigned as a result of a full cluster recovery.\n`DANGLING_INDEX_IMPORTED`: Unassigned as a result of importing a dangling index.\n`EXISTING_INDEX_RESTORED`: Unassigned as a result of restoring into a closed index.\n`FORCED_EMPTY_PRIMARY`: The shardâ€™s allocation was last modified by forcing an empty primary using the cluster reroute API.\n`INDEX_CLOSED`: Unassigned because the index was closed.\n`INDEX_CREATED`: Unassigned as a result of an API creation of an index.\n`INDEX_REOPENED`: Unassigned as a result of opening a closed index.\n`MANUAL_ALLOCATION`: The shardâ€™s allocation was last modified by the cluster reroute API.\n`NEW_INDEX_RESTORED`: Unassigned as a result of restoring into a new index.\n`NODE_LEFT`: Unassigned as a result of the node hosting it leaving the cluster.\n`NODE_RESTARTING`: Similar to `NODE_LEFT`, except that the node was registered as restarting using the node shutdown API.\n`PRIMARY_FAILED`: The shard was initializing as a replica, but the primary shard failed before the initialization completed.\n`REALLOCATED_REPLICA`: A better replica location is identified and causes the existing replica allocation to be cancelled.\n`REINITIALIZED`: When a shard moves from started back to initializing.\n`REPLICA_ADDED`: Unassigned as a result of explicit addition of a replica.\n`REROUTE_CANCELLED`: Unassigned as a result of explicit cancel reroute command.",
            "type": "string"
          },
          "unassigned.at": {
            "description": "The time at which the shard became unassigned in Coordinated Universal Time (UTC).",
            "type": "string"
          },
          "unassigned.for": {
            "description": "The time at which the shard was requested to be unassigned in Coordinated Universal Time (UTC).",
            "type": "string"
          },
          "unassigned.details": {
            "description": "Additional details as to why the shard became unassigned.\nIt does not explain why the shard is not assigned; use the cluster allocation explain API for that information.",
            "type": "string"
          },
          "recoverysource.type": {
            "description": "The type of recovery source.",
            "type": "string"
          },
          "completion.size": {
            "description": "The size of completion.",
            "type": "string"
          },
          "fielddata.memory_size": {
            "description": "The used fielddata cache memory.",
            "type": "string"
          },
          "fielddata.evictions": {
            "description": "The fielddata cache evictions.",
            "type": "string"
          },
          "query_cache.memory_size": {
            "description": "The used query cache memory.",
            "type": "string"
          },
          "query_cache.evictions": {
            "description": "The query cache evictions.",
            "type": "string"
          },
          "flush.total": {
            "description": "The number of flushes.",
            "type": "string"
          },
          "flush.total_time": {
            "description": "The time spent in flush.",
            "type": "string"
          },
          "get.current": {
            "description": "The number of current get operations.",
            "type": "string"
          },
          "get.time": {
            "description": "The time spent in get operations.",
            "type": "string"
          },
          "get.total": {
            "description": "The number of get operations.",
            "type": "string"
          },
          "get.exists_time": {
            "description": "The time spent in successful get operations.",
            "type": "string"
          },
          "get.exists_total": {
            "description": "The number of successful get operations.",
            "type": "string"
          },
          "get.missing_time": {
            "description": "The time spent in failed get operations.",
            "type": "string"
          },
          "get.missing_total": {
            "description": "The number of failed get operations.",
            "type": "string"
          },
          "indexing.delete_current": {
            "description": "The number of current deletion operations.",
            "type": "string"
          },
          "indexing.delete_time": {
            "description": "The time spent in deletion operations.",
            "type": "string"
          },
          "indexing.delete_total": {
            "description": "The number of delete operations.",
            "type": "string"
          },
          "indexing.index_current": {
            "description": "The number of current indexing operations.",
            "type": "string"
          },
          "indexing.index_time": {
            "description": "The time spent in indexing operations.",
            "type": "string"
          },
          "indexing.index_total": {
            "description": "The number of indexing operations.",
            "type": "string"
          },
          "indexing.index_failed": {
            "description": "The number of failed indexing operations.",
            "type": "string"
          },
          "merges.current": {
            "description": "The number of current merge operations.",
            "type": "string"
          },
          "merges.current_docs": {
            "description": "The number of current merging documents.",
            "type": "string"
          },
          "merges.current_size": {
            "description": "The size of current merge operations.",
            "type": "string"
          },
          "merges.total": {
            "description": "The number of completed merge operations.",
            "type": "string"
          },
          "merges.total_docs": {
            "description": "The nuber of merged documents.",
            "type": "string"
          },
          "merges.total_size": {
            "description": "The size of current merges.",
            "type": "string"
          },
          "merges.total_time": {
            "description": "The time spent merging documents.",
            "type": "string"
          },
          "refresh.total": {
            "description": "The total number of refreshes.",
            "type": "string"
          },
          "refresh.time": {
            "description": "The time spent in refreshes.",
            "type": "string"
          },
          "refresh.external_total": {
            "description": "The total nunber of external refreshes.",
            "type": "string"
          },
          "refresh.external_time": {
            "description": "The time spent in external refreshes.",
            "type": "string"
          },
          "refresh.listeners": {
            "description": "The number of pending refresh listeners.",
            "type": "string"
          },
          "search.fetch_current": {
            "description": "The current fetch phase operations.",
            "type": "string"
          },
          "search.fetch_time": {
            "description": "The time spent in fetch phase.",
            "type": "string"
          },
          "search.fetch_total": {
            "description": "The total number of fetch operations.",
            "type": "string"
          },
          "search.open_contexts": {
            "description": "The number of open search contexts.",
            "type": "string"
          },
          "search.query_current": {
            "description": "The current query phase operations.",
            "type": "string"
          },
          "search.query_time": {
            "description": "The time spent in query phase.",
            "type": "string"
          },
          "search.query_total": {
            "description": "The total number of query phase operations.",
            "type": "string"
          },
          "search.scroll_current": {
            "description": "The open scroll contexts.",
            "type": "string"
          },
          "search.scroll_time": {
            "description": "The time scroll contexts were held open.",
            "type": "string"
          },
          "search.scroll_total": {
            "description": "The number of completed scroll contexts.",
            "type": "string"
          },
          "segments.count": {
            "description": "The number of segments.",
            "type": "string"
          },
          "segments.memory": {
            "description": "The memory used by segments.",
            "type": "string"
          },
          "segments.index_writer_memory": {
            "description": "The memory used by the index writer.",
            "type": "string"
          },
          "segments.version_map_memory": {
            "description": "The memory used by the version map.",
            "type": "string"
          },
          "segments.fixed_bitset_memory": {
            "description": "The memory used by fixed bit sets for nested object field types and export type filters for types referred in `_parent` fields.",
            "type": "string"
          },
          "seq_no.max": {
            "description": "The maximum sequence number.",
            "type": "string"
          },
          "seq_no.local_checkpoint": {
            "description": "The local checkpoint.",
            "type": "string"
          },
          "seq_no.global_checkpoint": {
            "description": "The global checkpoint.",
            "type": "string"
          },
          "warmer.current": {
            "description": "The number of current warmer operations.",
            "type": "string"
          },
          "warmer.total": {
            "description": "The total number of warmer operations.",
            "type": "string"
          },
          "warmer.total_time": {
            "description": "The time spent in warmer operations.",
            "type": "string"
          },
          "path.data": {
            "description": "The shard data path.",
            "type": "string"
          },
          "path.state": {
            "description": "The shard state path.",
            "type": "string"
          },
          "bulk.total_operations": {
            "description": "The number of bulk shard operations.",
            "type": "string"
          },
          "bulk.total_time": {
            "description": "The time spent in shard bulk operations.",
            "type": "string"
          },
          "bulk.total_size_in_bytes": {
            "description": "The total size in bytes of shard bulk operations.",
            "type": "string"
          },
          "bulk.avg_time": {
            "description": "The average time spent in shard bulk operations.",
            "type": "string"
          },
          "bulk.avg_size_in_bytes": {
            "description": "The average size in bytes of shard bulk operations.",
            "type": "string"
          }
        }
      },
      "cat.snapshots:SnapshotsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The unique identifier for the snapshot.",
            "type": "string"
          },
          "repository": {
            "description": "The repository name.",
            "type": "string"
          },
          "status": {
            "description": "The state of the snapshot process.\nReturned values include:\n`FAILED`: The snapshot process failed.\n`INCOMPATIBLE`: The snapshot process is incompatible with the current cluster version.\n`IN_PROGRESS`: The snapshot process started but has not completed.\n`PARTIAL`: The snapshot process completed with a partial success.\n`SUCCESS`: The snapshot process completed with a full success.",
            "type": "string"
          },
          "start_epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "start_time": {
            "$ref": "#/components/schemas/watcher._types:ScheduleTimeOfDay"
          },
          "end_epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "end_time": {
            "$ref": "#/components/schemas/_types:TimeOfDay"
          },
          "duration": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "indices": {
            "description": "The number of indices in the snapshot.",
            "type": "string"
          },
          "successful_shards": {
            "description": "The number of successful shards in the snapshot.",
            "type": "string"
          },
          "failed_shards": {
            "description": "The number of failed shards in the snapshot.",
            "type": "string"
          },
          "total_shards": {
            "description": "The total number of shards in the snapshot.",
            "type": "string"
          },
          "reason": {
            "description": "The reason for any snapshot failures.",
            "type": "string"
          }
        }
      },
      "watcher._types:ScheduleTimeOfDay": {
        "description": "A time of day, expressed either as `hh:mm`, `noon`, `midnight`, or an hour/minutes structure.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/watcher._types:HourAndMinute"
          }
        ]
      },
      "watcher._types:HourAndMinute": {
        "type": "object",
        "properties": {
          "hour": {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "minute": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "hour",
          "minute"
        ]
      },
      "cat.tasks:TasksRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "action": {
            "description": "The task action.",
            "type": "string"
          },
          "task_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "parent_task_id": {
            "description": "The parent task identifier.",
            "type": "string"
          },
          "type": {
            "description": "The task type.",
            "type": "string"
          },
          "start_time": {
            "description": "The start time in milliseconds.",
            "type": "string"
          },
          "timestamp": {
            "description": "The start time in `HH:MM:SS` format.",
            "type": "string"
          },
          "running_time_ns": {
            "description": "The running time in nanoseconds.",
            "type": "string"
          },
          "running_time": {
            "description": "The running time.",
            "type": "string"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "ip": {
            "description": "The IP address for the node.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port for the node.",
            "type": "string"
          },
          "node": {
            "description": "The node name.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "x_opaque_id": {
            "description": "The X-Opaque-ID header.",
            "type": "string"
          },
          "description": {
            "description": "The task action description.",
            "type": "string"
          }
        }
      },
      "cat.templates:TemplatesRecord": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "index_patterns": {
            "description": "The template index patterns.",
            "type": "string"
          },
          "order": {
            "description": "The template application order or priority number.",
            "type": "string"
          },
          "version": {
            "description": "The template version.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:VersionString"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "composed_of": {
            "description": "The component templates that comprise the index template.",
            "type": "string"
          }
        }
      },
      "cat.thread_pool:ThreadPoolRecord": {
        "type": "object",
        "properties": {
          "node_name": {
            "description": "The node name.",
            "type": "string"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "ephemeral_node_id": {
            "description": "The ephemeral node identifier.",
            "type": "string"
          },
          "pid": {
            "description": "The process identifier.",
            "type": "string"
          },
          "host": {
            "description": "The host name for the current node.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address for the current node.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port for the current node.",
            "type": "string"
          },
          "name": {
            "description": "The thread pool name.",
            "type": "string"
          },
          "type": {
            "description": "The thread pool type.\nReturned values include `fixed`, `fixed_auto_queue_size`, `direct`, and `scaling`.",
            "type": "string"
          },
          "active": {
            "description": "The number of active threads in the current thread pool.",
            "type": "string"
          },
          "pool_size": {
            "description": "The number of threads in the current thread pool.",
            "type": "string"
          },
          "queue": {
            "description": "The number of tasks currently in queue.",
            "type": "string"
          },
          "queue_size": {
            "description": "The maximum number of tasks permitted in the queue.",
            "type": "string"
          },
          "rejected": {
            "description": "The number of rejected tasks.",
            "type": "string"
          },
          "largest": {
            "description": "The highest number of active threads in the current thread pool.",
            "type": "string"
          },
          "completed": {
            "description": "The number of completed tasks.",
            "type": "string"
          },
          "core": {
            "description": "The core number of active threads allowed in a scaling thread pool.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "max": {
            "description": "The maximum number of active threads allowed in a scaling thread pool.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "size": {
            "description": "The number of active threads allowed in a fixed thread pool.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "keep_alive": {
            "description": "The thread keep alive time.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "cat._types:CatTransformColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatTransformColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatTransformColumn"
            }
          }
        ]
      },
      "cat._types:CatTransformColumn": {
        "type": "string",
        "enum": [
          "changes_last_detection_time",
          "cldt",
          "checkpoint",
          "cp",
          "checkpoint_duration_time_exp_avg",
          "cdtea",
          "checkpointTimeExpAvg",
          "checkpoint_progress",
          "c",
          "checkpointProgress",
          "create_time",
          "ct",
          "createTime",
          "delete_time",
          "dtime",
          "description",
          "d",
          "dest_index",
          "di",
          "destIndex",
          "documents_deleted",
          "docd",
          "documents_indexed",
          "doci",
          "docs_per_second",
          "dps",
          "documents_processed",
          "docp",
          "frequency",
          "f",
          "id",
          "index_failure",
          "if",
          "index_time",
          "itime",
          "index_total",
          "it",
          "indexed_documents_exp_avg",
          "idea",
          "last_search_time",
          "lst",
          "lastSearchTime",
          "max_page_search_size",
          "mpsz",
          "pages_processed",
          "pp",
          "pipeline",
          "p",
          "processed_documents_exp_avg",
          "pdea",
          "processing_time",
          "pt",
          "reason",
          "r",
          "search_failure",
          "sf",
          "search_time",
          "stime",
          "search_total",
          "st",
          "source_index",
          "si",
          "sourceIndex",
          "state",
          "s",
          "transform_type",
          "tt",
          "trigger_count",
          "tc",
          "version",
          "v"
        ]
      },
      "cat.transforms:TransformsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "description": "The status of the transform.\nReturned values include:\n`aborting`: The transform is aborting.\n`failed: The transform failed. For more information about the failure, check the `reason` field.\n`indexing`: The transform is actively processing data and creating new documents.\n`started`: The transform is running but not actively indexing data.\n`stopped`: The transform is stopped.\n`stopping`: The transform is stopping.",
            "type": "string"
          },
          "checkpoint": {
            "description": "The sequence number for the checkpoint.",
            "type": "string"
          },
          "documents_processed": {
            "description": "The number of documents that have been processed from the source index of the transform.",
            "type": "string"
          },
          "checkpoint_progress": {
            "description": "The progress of the next checkpoint that is currently in progress.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "last_search_time": {
            "description": "The timestamp of the last search in the source indices.\nThis field is shown only if the transform is running.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "changes_last_detection_time": {
            "description": "The timestamp when changes were last detected in the source indices.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "create_time": {
            "description": "The time the transform was created.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "source_index": {
            "description": "The source indices for the transform.",
            "type": "string"
          },
          "dest_index": {
            "description": "The destination index for the transform.",
            "type": "string"
          },
          "pipeline": {
            "description": "The unique identifier for the ingest pipeline.",
            "type": "string"
          },
          "description": {
            "description": "The description of the transform.",
            "type": "string"
          },
          "transform_type": {
            "description": "The type of transform: `batch` or `continuous`.",
            "type": "string"
          },
          "frequency": {
            "description": "The interval between checks for changes in the source indices when the transform is running continuously.",
            "type": "string"
          },
          "max_page_search_size": {
            "description": "The initial page size that is used for the composite aggregation for each checkpoint.",
            "type": "string"
          },
          "docs_per_second": {
            "description": "The number of input documents per second.",
            "type": "string"
          },
          "reason": {
            "description": "If a transform has a `failed` state, these details describe the reason for failure.",
            "type": "string"
          },
          "search_total": {
            "description": "The total number of search operations on the source index for the transform.",
            "type": "string"
          },
          "search_failure": {
            "description": "The total number of search failures.",
            "type": "string"
          },
          "search_time": {
            "description": "The total amount of search time, in milliseconds.",
            "type": "string"
          },
          "index_total": {
            "description": "The total number of index operations done by the transform.",
            "type": "string"
          },
          "index_failure": {
            "description": "The total number of indexing failures.",
            "type": "string"
          },
          "index_time": {
            "description": "The total time spent indexing documents, in milliseconds.",
            "type": "string"
          },
          "documents_indexed": {
            "description": "The number of documents that have been indexed into the destination index for the transform.",
            "type": "string"
          },
          "delete_time": {
            "description": "The total time spent deleting documents, in milliseconds.",
            "type": "string"
          },
          "documents_deleted": {
            "description": "The number of documents deleted from the destination index due to the retention policy for the transform.",
            "type": "string"
          },
          "trigger_count": {
            "description": "The number of times the transform has been triggered by the scheduler.\nFor example, the scheduler triggers the transform indexer to check for updates or ingest new data at an interval specified in the `frequency` property.",
            "type": "string"
          },
          "pages_processed": {
            "description": "The number of search or bulk index operations processed.\nDocuments are processed in batches instead of individually.",
            "type": "string"
          },
          "processing_time": {
            "description": "The total time spent processing results, in milliseconds.",
            "type": "string"
          },
          "checkpoint_duration_time_exp_avg": {
            "description": "The exponential moving average of the duration of the checkpoint, in milliseconds.",
            "type": "string"
          },
          "indexed_documents_exp_avg": {
            "description": "The exponential moving average of the number of new documents that have been indexed.",
            "type": "string"
          },
          "processed_documents_exp_avg": {
            "description": "The exponential moving average of the number of documents that have been processed.",
            "type": "string"
          }
        }
      },
      "ccr.follow_info:FollowerIndex": {
        "type": "object",
        "properties": {
          "follower_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "leader_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "parameters": {
            "$ref": "#/components/schemas/ccr.follow_info:FollowerIndexParameters"
          },
          "remote_cluster": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "status": {
            "$ref": "#/components/schemas/ccr.follow_info:FollowerIndexStatus"
          }
        },
        "required": [
          "follower_index",
          "leader_index",
          "remote_cluster",
          "status"
        ]
      },
      "ccr.follow_info:FollowerIndexParameters": {
        "type": "object",
        "properties": {
          "max_outstanding_read_requests": {
            "type": "number"
          },
          "max_outstanding_write_requests": {
            "type": "number"
          },
          "max_read_request_operation_count": {
            "type": "number"
          },
          "max_read_request_size": {
            "type": "string"
          },
          "max_retry_delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_write_buffer_count": {
            "type": "number"
          },
          "max_write_buffer_size": {
            "type": "string"
          },
          "max_write_request_operation_count": {
            "type": "number"
          },
          "max_write_request_size": {
            "type": "string"
          },
          "read_poll_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "max_outstanding_read_requests",
          "max_outstanding_write_requests",
          "max_read_request_operation_count",
          "max_read_request_size",
          "max_retry_delay",
          "max_write_buffer_count",
          "max_write_buffer_size",
          "max_write_request_operation_count",
          "max_write_request_size",
          "read_poll_timeout"
        ]
      },
      "ccr.follow_info:FollowerIndexStatus": {
        "type": "string",
        "enum": [
          "active",
          "paused"
        ]
      },
      "ccr._types:FollowIndexStats": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shards": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ccr._types:ShardStats"
            }
          }
        },
        "required": [
          "index",
          "shards"
        ]
      },
      "ccr._types:ShardStats": {
        "type": "object",
        "properties": {
          "bytes_read": {
            "type": "number"
          },
          "failed_read_requests": {
            "type": "number"
          },
          "failed_write_requests": {
            "type": "number"
          },
          "fatal_exception": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "follower_aliases_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "follower_global_checkpoint": {
            "type": "number"
          },
          "follower_index": {
            "type": "string"
          },
          "follower_mapping_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "follower_max_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "follower_settings_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "last_requested_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "leader_global_checkpoint": {
            "type": "number"
          },
          "leader_index": {
            "type": "string"
          },
          "leader_max_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "operations_read": {
            "type": "number"
          },
          "operations_written": {
            "type": "number"
          },
          "outstanding_read_requests": {
            "type": "number"
          },
          "outstanding_write_requests": {
            "type": "number"
          },
          "read_exceptions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ccr._types:ReadException"
            }
          },
          "remote_cluster": {
            "type": "string"
          },
          "shard_id": {
            "type": "number"
          },
          "successful_read_requests": {
            "type": "number"
          },
          "successful_write_requests": {
            "type": "number"
          },
          "time_since_last_read": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_since_last_read_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_read_remote_exec_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_read_remote_exec_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_read_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_read_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_write_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_write_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "write_buffer_operation_count": {
            "type": "number"
          },
          "write_buffer_size_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        },
        "required": [
          "bytes_read",
          "failed_read_requests",
          "failed_write_requests",
          "follower_aliases_version",
          "follower_global_checkpoint",
          "follower_index",
          "follower_mapping_version",
          "follower_max_seq_no",
          "follower_settings_version",
          "last_requested_seq_no",
          "leader_global_checkpoint",
          "leader_index",
          "leader_max_seq_no",
          "operations_read",
          "operations_written",
          "outstanding_read_requests",
          "outstanding_write_requests",
          "read_exceptions",
          "remote_cluster",
          "shard_id",
          "successful_read_requests",
          "successful_write_requests",
          "time_since_last_read_millis",
          "total_read_remote_exec_time_millis",
          "total_read_time_millis",
          "total_write_time_millis",
          "write_buffer_operation_count",
          "write_buffer_size_in_bytes"
        ]
      },
      "ccr._types:ReadException": {
        "type": "object",
        "properties": {
          "exception": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "from_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "retries": {
            "type": "number"
          }
        },
        "required": [
          "exception",
          "from_seq_no",
          "retries"
        ]
      },
      "_types:Uuid": {
        "type": "string"
      },
      "ccr.get_auto_follow_pattern:AutoFollowPattern": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "pattern": {
            "$ref": "#/components/schemas/ccr.get_auto_follow_pattern:AutoFollowPatternSummary"
          }
        },
        "required": [
          "name",
          "pattern"
        ]
      },
      "ccr.get_auto_follow_pattern:AutoFollowPatternSummary": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean"
          },
          "remote_cluster": {
            "description": "The remote cluster containing the leader indices to match against.",
            "type": "string"
          },
          "follow_index_pattern": {
            "$ref": "#/components/schemas/_types:IndexPattern"
          },
          "leader_index_patterns": {
            "$ref": "#/components/schemas/_types:IndexPatterns"
          },
          "leader_index_exclusion_patterns": {
            "$ref": "#/components/schemas/_types:IndexPatterns"
          },
          "max_outstanding_read_requests": {
            "description": "The maximum number of outstanding reads requests from the remote cluster.",
            "type": "number"
          }
        },
        "required": [
          "active",
          "remote_cluster",
          "leader_index_patterns",
          "leader_index_exclusion_patterns",
          "max_outstanding_read_requests"
        ]
      },
      "_types:IndexPattern": {
        "type": "string"
      },
      "_types:IndexPatterns": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/_types:IndexPattern"
        }
      },
      "ccr.stats:AutoFollowStats": {
        "type": "object",
        "properties": {
          "auto_followed_clusters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ccr.stats:AutoFollowedCluster"
            }
          },
          "number_of_failed_follow_indices": {
            "type": "number"
          },
          "number_of_failed_remote_cluster_state_requests": {
            "type": "number"
          },
          "number_of_successful_follow_indices": {
            "type": "number"
          },
          "recent_auto_follow_errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "auto_followed_clusters",
          "number_of_failed_follow_indices",
          "number_of_failed_remote_cluster_state_requests",
          "number_of_successful_follow_indices",
          "recent_auto_follow_errors"
        ]
      },
      "ccr.stats:AutoFollowedCluster": {
        "type": "object",
        "properties": {
          "cluster_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "last_seen_metadata_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "time_since_last_check_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "cluster_name",
          "last_seen_metadata_version",
          "time_since_last_check_millis"
        ]
      },
      "ccr.stats:FollowStats": {
        "type": "object",
        "properties": {
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ccr._types:FollowIndexStats"
            }
          }
        },
        "required": [
          "indices"
        ]
      },
      "_types:ScrollIds": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ScrollId"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ScrollId"
            }
          }
        ]
      },
      "cluster.allocation_explain:Decision": {
        "type": "string",
        "enum": [
          "yes",
          "no",
          "worse_balance",
          "throttled",
          "awaiting_info",
          "allocation_delayed",
          "no_valid_shard_copy",
          "no_attempt"
        ]
      },
      "cluster.allocation_explain:AllocationDecision": {
        "type": "object",
        "properties": {
          "decider": {
            "type": "string"
          },
          "decision": {
            "$ref": "#/components/schemas/cluster.allocation_explain:AllocationExplainDecision"
          },
          "explanation": {
            "type": "string"
          }
        },
        "required": [
          "decider",
          "decision",
          "explanation"
        ]
      },
      "cluster.allocation_explain:AllocationExplainDecision": {
        "type": "string",
        "enum": [
          "NO",
          "YES",
          "THROTTLE",
          "ALWAYS"
        ]
      },
      "cluster.allocation_explain:ClusterInfo": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.allocation_explain:NodeDiskUsage"
            }
          },
          "shard_sizes": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "shard_data_set_sizes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "shard_paths": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "reserved_sizes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.allocation_explain:ReservedSize"
            }
          }
        },
        "required": [
          "nodes",
          "shard_sizes",
          "shard_paths",
          "reserved_sizes"
        ]
      },
      "cluster.allocation_explain:NodeDiskUsage": {
        "type": "object",
        "properties": {
          "node_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "least_available": {
            "$ref": "#/components/schemas/cluster.allocation_explain:DiskUsage"
          },
          "most_available": {
            "$ref": "#/components/schemas/cluster.allocation_explain:DiskUsage"
          }
        },
        "required": [
          "node_name",
          "least_available",
          "most_available"
        ]
      },
      "cluster.allocation_explain:DiskUsage": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string"
          },
          "total_bytes": {
            "type": "number"
          },
          "used_bytes": {
            "type": "number"
          },
          "free_bytes": {
            "type": "number"
          },
          "free_disk_percent": {
            "type": "number"
          },
          "used_disk_percent": {
            "type": "number"
          }
        },
        "required": [
          "path",
          "total_bytes",
          "used_bytes",
          "free_bytes",
          "free_disk_percent",
          "used_disk_percent"
        ]
      },
      "cluster.allocation_explain:ReservedSize": {
        "type": "object",
        "properties": {
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "path": {
            "type": "string"
          },
          "total": {
            "type": "number"
          },
          "shards": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "node_id",
          "path",
          "total",
          "shards"
        ]
      },
      "cluster.allocation_explain:CurrentNode": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "weight_ranking": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "name",
          "roles",
          "attributes",
          "transport_address",
          "weight_ranking"
        ]
      },
      "_types:NodeRoles": {
        "description": "* @doc_id node-roles",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/_types:NodeRole"
        }
      },
      "_types:NodeRole": {
        "type": "string",
        "enum": [
          "master",
          "data",
          "data_cold",
          "data_content",
          "data_frozen",
          "data_hot",
          "data_warm",
          "client",
          "ingest",
          "ml",
          "voting_only",
          "transform",
          "remote_cluster_client",
          "coordinating_only"
        ]
      },
      "_types:TransportAddress": {
        "type": "string"
      },
      "cluster.allocation_explain:NodeAllocationExplanation": {
        "type": "object",
        "properties": {
          "deciders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.allocation_explain:AllocationDecision"
            }
          },
          "node_attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "node_decision": {
            "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "store": {
            "$ref": "#/components/schemas/cluster.allocation_explain:AllocationStore"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "weight_ranking": {
            "type": "number"
          }
        },
        "required": [
          "deciders",
          "node_attributes",
          "node_decision",
          "node_id",
          "node_name",
          "roles",
          "transport_address",
          "weight_ranking"
        ]
      },
      "cluster.allocation_explain:AllocationStore": {
        "type": "object",
        "properties": {
          "allocation_id": {
            "type": "string"
          },
          "found": {
            "type": "boolean"
          },
          "in_sync": {
            "type": "boolean"
          },
          "matching_size_in_bytes": {
            "type": "number"
          },
          "matching_sync_id": {
            "type": "boolean"
          },
          "store_exception": {
            "type": "string"
          }
        },
        "required": [
          "allocation_id",
          "found",
          "in_sync",
          "matching_size_in_bytes",
          "matching_sync_id",
          "store_exception"
        ]
      },
      "cluster.allocation_explain:UnassignedInformation": {
        "type": "object",
        "properties": {
          "at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_allocation_status": {
            "type": "string"
          },
          "reason": {
            "$ref": "#/components/schemas/cluster.allocation_explain:UnassignedInformationReason"
          },
          "details": {
            "type": "string"
          },
          "failed_allocation_attempts": {
            "type": "number"
          },
          "delayed": {
            "type": "boolean"
          },
          "allocation_status": {
            "type": "string"
          }
        },
        "required": [
          "at",
          "reason"
        ]
      },
      "cluster.allocation_explain:UnassignedInformationReason": {
        "type": "string",
        "enum": [
          "INDEX_CREATED",
          "CLUSTER_RECOVERED",
          "INDEX_REOPENED",
          "DANGLING_INDEX_IMPORTED",
          "NEW_INDEX_RESTORED",
          "EXISTING_INDEX_RESTORED",
          "REPLICA_ADDED",
          "ALLOCATION_FAILED",
          "NODE_LEFT",
          "REROUTE_CANCELLED",
          "REINITIALIZED",
          "REALLOCATED_REPLICA",
          "PRIMARY_FAILED",
          "FORCED_EMPTY_PRIMARY",
          "MANUAL_ALLOCATION"
        ]
      },
      "cluster._types:ComponentTemplate": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "component_template": {
            "$ref": "#/components/schemas/cluster._types:ComponentTemplateNode"
          }
        },
        "required": [
          "name",
          "component_template"
        ]
      },
      "cluster._types:ComponentTemplateNode": {
        "type": "object",
        "properties": {
          "template": {
            "$ref": "#/components/schemas/cluster._types:ComponentTemplateSummary"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "deprecated": {
            "type": "boolean"
          }
        },
        "required": [
          "template"
        ]
      },
      "cluster._types:ComponentTemplateSummary": {
        "type": "object",
        "properties": {
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "settings": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:IndexSettings"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:AliasDefinition"
            }
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          }
        }
      },
      "indices._types:IndexSettings": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "mode": {
            "type": "string"
          },
          "routing_path": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "soft_deletes": {
            "$ref": "#/components/schemas/indices._types:SoftDeletes"
          },
          "sort": {
            "$ref": "#/components/schemas/indices._types:IndexSegmentSort"
          },
          "number_of_shards": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "number_of_replicas": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "number_of_routing_shards": {
            "type": "number"
          },
          "check_on_startup": {
            "$ref": "#/components/schemas/indices._types:IndexCheckOnStartup"
          },
          "codec": {
            "type": "string"
          },
          "routing_partition_size": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          },
          "load_fixed_bitset_filters_eagerly": {
            "type": "boolean"
          },
          "hidden": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "auto_expand_replicas": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "$ref": "#/components/schemas/_spec_utils:NullValue"
              }
            ]
          },
          "merge": {
            "$ref": "#/components/schemas/indices._types:Merge"
          },
          "search": {
            "$ref": "#/components/schemas/indices._types:SettingsSearch"
          },
          "refresh_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_result_window": {
            "type": "number"
          },
          "max_inner_result_window": {
            "type": "number"
          },
          "max_rescore_window": {
            "type": "number"
          },
          "max_docvalue_fields_search": {
            "type": "number"
          },
          "max_script_fields": {
            "type": "number"
          },
          "max_ngram_diff": {
            "type": "number"
          },
          "max_shingle_diff": {
            "type": "number"
          },
          "blocks": {
            "$ref": "#/components/schemas/indices._types:IndexSettingBlocks"
          },
          "max_refresh_listeners": {
            "type": "number"
          },
          "analyze": {
            "$ref": "#/components/schemas/indices._types:SettingsAnalyze"
          },
          "highlight": {
            "$ref": "#/components/schemas/indices._types:SettingsHighlight"
          },
          "max_terms_count": {
            "type": "number"
          },
          "max_regex_length": {
            "type": "number"
          },
          "routing": {
            "$ref": "#/components/schemas/indices._types:IndexRouting"
          },
          "gc_deletes": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "default_pipeline": {
            "$ref": "#/components/schemas/_types:PipelineName"
          },
          "final_pipeline": {
            "$ref": "#/components/schemas/_types:PipelineName"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsLifecycle"
          },
          "provided_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "creation_date": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitMillis"
          },
          "creation_date_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "version": {
            "$ref": "#/components/schemas/indices._types:IndexVersioning"
          },
          "verified_before_close": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "format": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ]
          },
          "max_slices_per_scroll": {
            "type": "number"
          },
          "translog": {
            "$ref": "#/components/schemas/indices._types:Translog"
          },
          "query_string": {
            "$ref": "#/components/schemas/indices._types:SettingsQueryString"
          },
          "priority": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "top_metrics_max_size": {
            "type": "number"
          },
          "analysis": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsAnalysis"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "time_series": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsTimeSeries"
          },
          "queries": {
            "$ref": "#/components/schemas/indices._types:Queries"
          },
          "similarity": {
            "description": "Configure custom similarity settings to customize how search results are scored.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:SettingsSimilarity"
            }
          },
          "mapping": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettings"
          },
          "indexing.slowlog": {
            "$ref": "#/components/schemas/indices._types:IndexingSlowlogSettings"
          },
          "indexing_pressure": {
            "$ref": "#/components/schemas/indices._types:IndexingPressure"
          },
          "store": {
            "$ref": "#/components/schemas/indices._types:Storage"
          }
        }
      },
      "indices._types:SoftDeletes": {
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Indicates whether soft deletes are enabled on the index.",
            "type": "boolean"
          },
          "retention_lease": {
            "$ref": "#/components/schemas/indices._types:RetentionLease"
          }
        }
      },
      "indices._types:RetentionLease": {
        "type": "object",
        "properties": {
          "period": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "period"
        ]
      },
      "indices._types:IndexSegmentSort": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "order": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/indices._types:SegmentSortOrder"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/indices._types:SegmentSortOrder"
                }
              }
            ]
          },
          "mode": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/indices._types:SegmentSortMode"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/indices._types:SegmentSortMode"
                }
              }
            ]
          },
          "missing": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/indices._types:SegmentSortMissing"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/indices._types:SegmentSortMissing"
                }
              }
            ]
          }
        }
      },
      "indices._types:SegmentSortOrder": {
        "type": "string",
        "enum": [
          "asc",
          "ASC",
          "desc",
          "DESC"
        ]
      },
      "indices._types:SegmentSortMode": {
        "type": "string",
        "enum": [
          "min",
          "MIN",
          "max",
          "MAX"
        ]
      },
      "indices._types:SegmentSortMissing": {
        "type": "string",
        "enum": [
          "_last",
          "_first"
        ]
      },
      "indices._types:IndexCheckOnStartup": {
        "type": "string",
        "enum": [
          "true",
          "false",
          "checksum"
        ]
      },
      "_spec_utils:Stringifiedinteger": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_spec_utils:NullValue": {
        "nullable": true,
        "description": "A `null` value that is to be interpreted as an actual value, unless other uses of `null` that are equivalent\nto a missing value. It is used for exemple in settings, where using the `NullValue` for a setting will reset\nit to its default value.",
        "type": "string"
      },
      "indices._types:Merge": {
        "type": "object",
        "properties": {
          "scheduler": {
            "$ref": "#/components/schemas/indices._types:MergeScheduler"
          }
        }
      },
      "indices._types:MergeScheduler": {
        "type": "object",
        "properties": {
          "max_thread_count": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          },
          "max_merge_count": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          }
        }
      },
      "indices._types:SettingsSearch": {
        "type": "object",
        "properties": {
          "idle": {
            "$ref": "#/components/schemas/indices._types:SearchIdle"
          },
          "slowlog": {
            "$ref": "#/components/schemas/indices._types:SlowlogSettings"
          }
        }
      },
      "indices._types:SearchIdle": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "indices._types:SlowlogSettings": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string"
          },
          "source": {
            "type": "number"
          },
          "reformat": {
            "type": "boolean"
          },
          "threshold": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholds"
          }
        }
      },
      "indices._types:SlowlogTresholds": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholdLevels"
          },
          "fetch": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholdLevels"
          }
        }
      },
      "indices._types:SlowlogTresholdLevels": {
        "type": "object",
        "properties": {
          "warn": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "info": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "debug": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "trace": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "indices._types:IndexSettingBlocks": {
        "type": "object",
        "properties": {
          "read_only": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "read_only_allow_delete": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "read": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "write": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "metadata": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          }
        }
      },
      "_spec_utils:Stringifiedboolean": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "type": "string"
          }
        ]
      },
      "indices._types:SettingsAnalyze": {
        "type": "object",
        "properties": {
          "max_token_count": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          }
        }
      },
      "indices._types:SettingsHighlight": {
        "type": "object",
        "properties": {
          "max_analyzed_offset": {
            "type": "number"
          }
        }
      },
      "indices._types:IndexRouting": {
        "type": "object",
        "properties": {
          "allocation": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocation"
          },
          "rebalance": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingRebalance"
          }
        }
      },
      "indices._types:IndexRoutingAllocation": {
        "type": "object",
        "properties": {
          "enable": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationOptions"
          },
          "include": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationInclude"
          },
          "initial_recovery": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationInitialRecovery"
          },
          "disk": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationDisk"
          }
        }
      },
      "indices._types:IndexRoutingAllocationOptions": {
        "type": "string",
        "enum": [
          "all",
          "primaries",
          "new_primaries",
          "none"
        ]
      },
      "indices._types:IndexRoutingAllocationInclude": {
        "type": "object",
        "properties": {
          "_tier_preference": {
            "type": "string"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        }
      },
      "indices._types:IndexRoutingAllocationInitialRecovery": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        }
      },
      "indices._types:IndexRoutingAllocationDisk": {
        "type": "object",
        "properties": {
          "threshold_enabled": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "indices._types:IndexRoutingRebalance": {
        "type": "object",
        "properties": {
          "enable": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingRebalanceOptions"
          }
        },
        "required": [
          "enable"
        ]
      },
      "indices._types:IndexRoutingRebalanceOptions": {
        "type": "string",
        "enum": [
          "all",
          "primaries",
          "replicas",
          "none"
        ]
      },
      "_types:PipelineName": {
        "type": "string"
      },
      "indices._types:IndexSettingsLifecycle": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indexing_complete": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "origination_date": {
            "description": "If specified, this is the timestamp used to calculate the index age for its phase transitions. Use this setting\nif you create a new index that contains old data and want to use the original creation date to calculate the index\nage. Specified as a Unix epoch value in milliseconds.",
            "type": "number"
          },
          "parse_origination_date": {
            "description": "Set to true to parse the origination date from the index name. This origination date is used to calculate the index age\nfor its phase transitions. The index name must match the pattern ^.*-{date_format}-\\\\d+, where the date_format is\nyyyy.MM.dd and the trailing digits are optional. An index that was rolled over would normally match the full format,\nfor example logs-2016.10.31-000002). If the index name doesnâ€™t match the pattern, index creation fails.",
            "type": "boolean"
          },
          "step": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsLifecycleStep"
          },
          "rollover_alias": {
            "description": "The index alias to update when the index rolls over. Specify when using a policy that contains a rollover action.\nWhen the index rolls over, the alias is updated to reflect that the index is no longer the write index. For more\ninformation about rolling indices, see Rollover.",
            "type": "string"
          },
          "prefer_ilm": {
            "description": "Preference for the system that manages a data stream backing index (preferring ILM when both ILM and DLM are\napplicable for an index).",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "indices._types:IndexSettingsLifecycleStep": {
        "type": "object",
        "properties": {
          "wait_time_threshold": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "_spec_utils:StringifiedEpochTimeUnitMillis": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          {
            "type": "string"
          }
        ]
      },
      "indices._types:IndexVersioning": {
        "type": "object",
        "properties": {
          "created": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "created_string": {
            "type": "string"
          }
        }
      },
      "indices._types:Translog": {
        "type": "object",
        "properties": {
          "sync_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "durability": {
            "$ref": "#/components/schemas/indices._types:TranslogDurability"
          },
          "flush_threshold_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "retention": {
            "$ref": "#/components/schemas/indices._types:TranslogRetention"
          }
        }
      },
      "indices._types:TranslogDurability": {
        "type": "string",
        "enum": [
          "request",
          "REQUEST",
          "async",
          "ASYNC"
        ]
      },
      "indices._types:TranslogRetention": {
        "type": "object",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "age": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "indices._types:SettingsQueryString": {
        "type": "object",
        "properties": {
          "lenient": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          }
        },
        "required": [
          "lenient"
        ]
      },
      "indices._types:IndexSettingsAnalysis": {
        "type": "object",
        "properties": {
          "analyzer": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:Analyzer"
            }
          },
          "char_filter": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:CharFilter"
            }
          },
          "filter": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:TokenFilter"
            }
          },
          "normalizer": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:Normalizer"
            }
          },
          "tokenizer": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:Tokenizer"
            }
          }
        }
      },
      "_types.analysis:Analyzer": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CustomAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:FingerprintAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeywordAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LanguageAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NoriAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SimpleAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StandardAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StopAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WhitespaceAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SnowballAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ArabicAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ArmenianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:BasqueAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:BengaliAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:BrazilianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:BulgarianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CatalanAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ChineseAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CjkAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CzechAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DanishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DutchAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:EnglishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:EstonianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:FinnishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:FrenchAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:GalicianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:GermanAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:GreekAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:HindiAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:HungarianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IndonesianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IrishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ItalianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LatvianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LithuanianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NorwegianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PersianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PortugueseAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:RomanianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:RussianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SerbianAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SoraniAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SpanishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SwedishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TurkishAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ThaiAnalyzer"
          }
        ]
      },
      "_types.analysis:CustomAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "custom"
            ]
          },
          "char_filter": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "filter": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "position_increment_gap": {
            "type": "number"
          },
          "position_offset_gap": {
            "type": "number"
          },
          "tokenizer": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "tokenizer"
        ]
      },
      "_types.analysis:FingerprintAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "fingerprint"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "max_output_size": {
            "type": "number"
          },
          "preserve_original": {
            "type": "boolean"
          },
          "separator": {
            "type": "string"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "max_output_size",
          "preserve_original",
          "separator"
        ]
      },
      "_types.analysis:KeywordAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "keyword"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:LanguageAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "language"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "language": {
            "$ref": "#/components/schemas/_types.analysis:Language"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "language",
          "stem_exclusion"
        ]
      },
      "_types.analysis:Language": {
        "type": "string",
        "enum": [
          "Arabic",
          "Armenian",
          "Basque",
          "Brazilian",
          "Bulgarian",
          "Catalan",
          "Chinese",
          "Cjk",
          "Czech",
          "Danish",
          "Dutch",
          "English",
          "Estonian",
          "Finnish",
          "French",
          "Galician",
          "German",
          "Greek",
          "Hindi",
          "Hungarian",
          "Indonesian",
          "Irish",
          "Italian",
          "Latvian",
          "Norwegian",
          "Persian",
          "Portuguese",
          "Romanian",
          "Russian",
          "Sorani",
          "Spanish",
          "Swedish",
          "Turkish",
          "Thai"
        ]
      },
      "_types.analysis:NoriAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "nori"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "decompound_mode": {
            "$ref": "#/components/schemas/_types.analysis:NoriDecompoundMode"
          },
          "stoptags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "user_dictionary": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:NoriDecompoundMode": {
        "type": "string",
        "enum": [
          "discard",
          "none",
          "mixed"
        ]
      },
      "_types.analysis:PatternAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pattern"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "flags": {
            "type": "string"
          },
          "lowercase": {
            "type": "boolean"
          },
          "pattern": {
            "type": "string"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type",
          "pattern"
        ]
      },
      "_types.analysis:SimpleAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "simple"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:StandardAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "standard"
            ]
          },
          "max_token_length": {
            "type": "number"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:StopAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "stop"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:WhitespaceAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "whitespace"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:IcuAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "icu_analyzer"
            ]
          },
          "method": {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationType"
          },
          "mode": {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationMode"
          }
        },
        "required": [
          "type",
          "method",
          "mode"
        ]
      },
      "_types.analysis:IcuNormalizationType": {
        "type": "string",
        "enum": [
          "nfc",
          "nfkc",
          "nfkc_cf"
        ]
      },
      "_types.analysis:IcuNormalizationMode": {
        "type": "string",
        "enum": [
          "decompose",
          "compose"
        ]
      },
      "_types.analysis:KuromojiAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kuromoji"
            ]
          },
          "mode": {
            "$ref": "#/components/schemas/_types.analysis:KuromojiTokenizationMode"
          },
          "user_dictionary": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "mode"
        ]
      },
      "_types.analysis:KuromojiTokenizationMode": {
        "type": "string",
        "enum": [
          "normal",
          "search",
          "extended"
        ]
      },
      "_types.analysis:SnowballAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "snowball"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "language": {
            "$ref": "#/components/schemas/_types.analysis:SnowballLanguage"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type",
          "language"
        ]
      },
      "_types.analysis:SnowballLanguage": {
        "type": "string",
        "enum": [
          "Armenian",
          "Basque",
          "Catalan",
          "Danish",
          "Dutch",
          "English",
          "Finnish",
          "French",
          "German",
          "German2",
          "Hungarian",
          "Italian",
          "Kp",
          "Lovins",
          "Norwegian",
          "Porter",
          "Portuguese",
          "Romanian",
          "Russian",
          "Spanish",
          "Swedish",
          "Turkish"
        ]
      },
      "_types.analysis:ArabicAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "arabic"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:ArmenianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "armenian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:BasqueAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "basque"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:BengaliAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "bengali"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:BrazilianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "brazilian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:BulgarianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "bulgarian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:CatalanAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "catalan"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:ChineseAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "chinese"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:CjkAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "cjk"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:CzechAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "czech"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:DanishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "danish"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:DutchAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dutch"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:EnglishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "english"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:EstonianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "estonian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:FinnishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "finnish"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:FrenchAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "french"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:GalicianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "galician"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:GermanAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "german"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:GreekAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "greek"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:HindiAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "hindi"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:HungarianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "hungarian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:IndonesianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "indonesian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:IrishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "irish"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:ItalianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "italian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:LatvianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "latvian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:LithuanianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "lithuanian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:NorwegianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "norwegian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:PersianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "persian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:PortugueseAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "portuguese"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:RomanianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "romanian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:RussianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "russian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:SerbianAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "serbian"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:SoraniAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "sorani"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:SpanishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "spanish"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:SwedishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "swedish"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:TurkishAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "turkish"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:ThaiAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "thai"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:CharFilter": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html"
        },
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterDefinition"
          }
        ]
      },
      "_types.analysis:CharFilterDefinition": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:HtmlStripCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:MappingCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternReplaceCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiIterationMarkCharFilter"
          }
        ]
      },
      "_types.analysis:HtmlStripCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "html_strip"
                ]
              },
              "escaped_tags": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:CharFilterBase": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        }
      },
      "_types.analysis:MappingCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "mapping"
                ]
              },
              "mappings": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "mappings_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PatternReplaceCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern_replace"
                ]
              },
              "flags": {
                "type": "string"
              },
              "pattern": {
                "type": "string"
              },
              "replacement": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "pattern"
            ]
          }
        ]
      },
      "_types.analysis:IcuNormalizationCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_normalizer"
                ]
              },
              "mode": {
                "$ref": "#/components/schemas/_types.analysis:IcuNormalizationMode"
              },
              "name": {
                "$ref": "#/components/schemas/_types.analysis:IcuNormalizationType"
              },
              "unicode_set_filter": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiIterationMarkCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_iteration_mark"
                ]
              },
              "normalize_kana": {
                "type": "boolean"
              },
              "normalize_kanji": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "normalize_kana",
              "normalize_kanji"
            ]
          }
        ]
      },
      "_types.analysis:TokenFilter": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html"
        },
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterDefinition"
          }
        ]
      },
      "_types.analysis:TokenFilterDefinition": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:AsciiFoldingTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CommonGramsTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ConditionTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DelimitedPayloadTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:EdgeNGramTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ElisionTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:FingerprintTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:HunspellTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:HyphenationDecompounderTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeepTypesTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeepWordsTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeywordMarkerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KStemTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LengthTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LimitTokenCountTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LowercaseTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:MultiplexerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NGramTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NoriPartOfSpeechTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternCaptureTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternReplaceTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PorterStemTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PredicateTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:RemoveDuplicatesTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ReverseTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ShingleTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SnowballTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StemmerOverrideTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StemmerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StopTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SynonymGraphTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SynonymTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TrimTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TruncateTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:UniqueTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:UppercaseTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WordDelimiterGraphTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WordDelimiterTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiStemmerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiReadingFormTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiPartOfSpeechTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuCollationTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuFoldingTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuTransformTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PhoneticTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DictionaryDecompounderTokenFilter"
          }
        ]
      },
      "_types.analysis:AsciiFoldingTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "asciifolding"
                ]
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TokenFilterBase": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        }
      },
      "_types.analysis:CommonGramsTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "common_grams"
                ]
              },
              "common_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "common_words_path": {
                "type": "string"
              },
              "ignore_case": {
                "type": "boolean"
              },
              "query_mode": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ConditionTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "condition"
                ]
              },
              "filter": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "type",
              "filter",
              "script"
            ]
          }
        ]
      },
      "_types.analysis:DelimitedPayloadTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "delimited_payload"
                ]
              },
              "delimiter": {
                "type": "string"
              },
              "encoding": {
                "$ref": "#/components/schemas/_types.analysis:DelimitedPayloadEncoding"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:DelimitedPayloadEncoding": {
        "type": "string",
        "enum": [
          "int",
          "float",
          "identity"
        ]
      },
      "_types.analysis:EdgeNGramTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "edge_ngram"
                ]
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "side": {
                "$ref": "#/components/schemas/_types.analysis:EdgeNGramSide"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:EdgeNGramSide": {
        "type": "string",
        "enum": [
          "front",
          "back"
        ]
      },
      "_types.analysis:ElisionTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "elision"
                ]
              },
              "articles": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "articles_path": {
                "type": "string"
              },
              "articles_case": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:FingerprintTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "fingerprint"
                ]
              },
              "max_output_size": {
                "type": "number"
              },
              "separator": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:HunspellTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "hunspell"
                ]
              },
              "dedup": {
                "type": "boolean"
              },
              "dictionary": {
                "type": "string"
              },
              "locale": {
                "type": "string"
              },
              "longest_only": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "locale"
            ]
          }
        ]
      },
      "_types.analysis:HyphenationDecompounderTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CompoundWordTokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "hyphenation_decompounder"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:CompoundWordTokenFilterBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "hyphenation_patterns_path": {
                "type": "string"
              },
              "max_subword_size": {
                "type": "number"
              },
              "min_subword_size": {
                "type": "number"
              },
              "min_word_size": {
                "type": "number"
              },
              "only_longest_match": {
                "type": "boolean"
              },
              "word_list": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "word_list_path": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.analysis:KeepTypesTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keep_types"
                ]
              },
              "mode": {
                "$ref": "#/components/schemas/_types.analysis:KeepTypesMode"
              },
              "types": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KeepTypesMode": {
        "type": "string",
        "enum": [
          "include",
          "exclude"
        ]
      },
      "_types.analysis:KeepWordsTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keep"
                ]
              },
              "keep_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "keep_words_case": {
                "type": "boolean"
              },
              "keep_words_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KeywordMarkerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keyword_marker"
                ]
              },
              "ignore_case": {
                "type": "boolean"
              },
              "keywords": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "keywords_path": {
                "type": "string"
              },
              "keywords_pattern": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KStemTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kstem"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LengthTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "length"
                ]
              },
              "max": {
                "type": "number"
              },
              "min": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LimitTokenCountTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "limit"
                ]
              },
              "consume_all_tokens": {
                "type": "boolean"
              },
              "max_token_count": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LowercaseTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lowercase"
                ]
              },
              "language": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:MultiplexerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "multiplexer"
                ]
              },
              "filters": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type",
              "filters"
            ]
          }
        ]
      },
      "_types.analysis:NGramTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ngram"
                ]
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:NoriPartOfSpeechTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "nori_part_of_speech"
                ]
              },
              "stoptags": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PatternCaptureTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern_capture"
                ]
              },
              "patterns": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type",
              "patterns"
            ]
          }
        ]
      },
      "_types.analysis:PatternReplaceTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern_replace"
                ]
              },
              "all": {
                "type": "boolean"
              },
              "flags": {
                "type": "string"
              },
              "pattern": {
                "type": "string"
              },
              "replacement": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "pattern"
            ]
          }
        ]
      },
      "_types.analysis:PorterStemTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "porter_stem"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PredicateTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "predicate_token_filter"
                ]
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "type",
              "script"
            ]
          }
        ]
      },
      "_types.analysis:RemoveDuplicatesTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "remove_duplicates"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ReverseTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "reverse"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ShingleTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "shingle"
                ]
              },
              "filler_token": {
                "type": "string"
              },
              "max_shingle_size": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "min_shingle_size": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "output_unigrams": {
                "type": "boolean"
              },
              "output_unigrams_if_no_shingles": {
                "type": "boolean"
              },
              "token_separator": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SnowballTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "snowball"
                ]
              },
              "language": {
                "$ref": "#/components/schemas/_types.analysis:SnowballLanguage"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:StemmerOverrideTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stemmer_override"
                ]
              },
              "rules": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "rules_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:StemmerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stemmer"
                ]
              },
              "language": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:StopTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stop"
                ]
              },
              "ignore_case": {
                "type": "boolean"
              },
              "remove_trailing": {
                "type": "boolean"
              },
              "stopwords": {
                "$ref": "#/components/schemas/_types.analysis:StopWords"
              },
              "stopwords_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SynonymGraphTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "synonym_graph"
                ]
              },
              "expand": {
                "type": "boolean"
              },
              "format": {
                "$ref": "#/components/schemas/_types.analysis:SynonymFormat"
              },
              "lenient": {
                "type": "boolean"
              },
              "synonyms": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "synonyms_path": {
                "type": "string"
              },
              "synonyms_set": {
                "type": "string"
              },
              "tokenizer": {
                "type": "string"
              },
              "updateable": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SynonymFormat": {
        "type": "string",
        "enum": [
          "solr",
          "wordnet"
        ]
      },
      "_types.analysis:SynonymTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "synonym"
                ]
              },
              "expand": {
                "type": "boolean"
              },
              "format": {
                "$ref": "#/components/schemas/_types.analysis:SynonymFormat"
              },
              "lenient": {
                "type": "boolean"
              },
              "synonyms": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "synonyms_path": {
                "type": "string"
              },
              "synonyms_set": {
                "type": "string"
              },
              "tokenizer": {
                "type": "string"
              },
              "updateable": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TrimTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "trim"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TruncateTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "truncate"
                ]
              },
              "length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:UniqueTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unique"
                ]
              },
              "only_on_same_position": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:UppercaseTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "uppercase"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:WordDelimiterGraphTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "word_delimiter_graph"
                ]
              },
              "adjust_offsets": {
                "type": "boolean"
              },
              "catenate_all": {
                "type": "boolean"
              },
              "catenate_numbers": {
                "type": "boolean"
              },
              "catenate_words": {
                "type": "boolean"
              },
              "generate_number_parts": {
                "type": "boolean"
              },
              "generate_word_parts": {
                "type": "boolean"
              },
              "ignore_keywords": {
                "type": "boolean"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              },
              "protected_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "protected_words_path": {
                "type": "string"
              },
              "split_on_case_change": {
                "type": "boolean"
              },
              "split_on_numerics": {
                "type": "boolean"
              },
              "stem_english_possessive": {
                "type": "boolean"
              },
              "type_table": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type_table_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:WordDelimiterTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "word_delimiter"
                ]
              },
              "catenate_all": {
                "type": "boolean"
              },
              "catenate_numbers": {
                "type": "boolean"
              },
              "catenate_words": {
                "type": "boolean"
              },
              "generate_number_parts": {
                "type": "boolean"
              },
              "generate_word_parts": {
                "type": "boolean"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              },
              "protected_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "protected_words_path": {
                "type": "string"
              },
              "split_on_case_change": {
                "type": "boolean"
              },
              "split_on_numerics": {
                "type": "boolean"
              },
              "stem_english_possessive": {
                "type": "boolean"
              },
              "type_table": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type_table_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiStemmerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_stemmer"
                ]
              },
              "minimum_length": {
                "type": "number"
              }
            },
            "required": [
              "type",
              "minimum_length"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiReadingFormTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_readingform"
                ]
              },
              "use_romaji": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "use_romaji"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiPartOfSpeechTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_part_of_speech"
                ]
              },
              "stoptags": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type",
              "stoptags"
            ]
          }
        ]
      },
      "_types.analysis:IcuCollationTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_collation"
                ]
              },
              "alternate": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationAlternate"
              },
              "case_first": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationCaseFirst"
              },
              "case_level": {
                "type": "boolean"
              },
              "country": {
                "type": "string"
              },
              "decomposition": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationDecomposition"
              },
              "hiragana_quaternary_mode": {
                "type": "boolean"
              },
              "language": {
                "type": "string"
              },
              "numeric": {
                "type": "boolean"
              },
              "rules": {
                "type": "string"
              },
              "strength": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationStrength"
              },
              "variable_top": {
                "type": "string"
              },
              "variant": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:IcuCollationAlternate": {
        "type": "string",
        "enum": [
          "shifted",
          "non-ignorable"
        ]
      },
      "_types.analysis:IcuCollationCaseFirst": {
        "type": "string",
        "enum": [
          "lower",
          "upper"
        ]
      },
      "_types.analysis:IcuCollationDecomposition": {
        "type": "string",
        "enum": [
          "no",
          "identical"
        ]
      },
      "_types.analysis:IcuCollationStrength": {
        "type": "string",
        "enum": [
          "primary",
          "secondary",
          "tertiary",
          "quaternary",
          "identical"
        ]
      },
      "_types.analysis:IcuFoldingTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_folding"
                ]
              },
              "unicode_set_filter": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "unicode_set_filter"
            ]
          }
        ]
      },
      "_types.analysis:IcuNormalizationTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_normalizer"
                ]
              },
              "name": {
                "$ref": "#/components/schemas/_types.analysis:IcuNormalizationType"
              }
            },
            "required": [
              "type",
              "name"
            ]
          }
        ]
      },
      "_types.analysis:IcuTransformTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_transform"
                ]
              },
              "dir": {
                "$ref": "#/components/schemas/_types.analysis:IcuTransformDirection"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "id"
            ]
          }
        ]
      },
      "_types.analysis:IcuTransformDirection": {
        "type": "string",
        "enum": [
          "forward",
          "reverse"
        ]
      },
      "_types.analysis:PhoneticTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "phonetic"
                ]
              },
              "encoder": {
                "$ref": "#/components/schemas/_types.analysis:PhoneticEncoder"
              },
              "languageset": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.analysis:PhoneticLanguage"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.analysis:PhoneticLanguage"
                    }
                  }
                ]
              },
              "max_code_len": {
                "type": "number"
              },
              "name_type": {
                "$ref": "#/components/schemas/_types.analysis:PhoneticNameType"
              },
              "replace": {
                "type": "boolean"
              },
              "rule_type": {
                "$ref": "#/components/schemas/_types.analysis:PhoneticRuleType"
              }
            },
            "required": [
              "type",
              "encoder"
            ]
          }
        ]
      },
      "_types.analysis:PhoneticEncoder": {
        "type": "string",
        "enum": [
          "metaphone",
          "double_metaphone",
          "soundex",
          "refined_soundex",
          "caverphone1",
          "caverphone2",
          "cologne",
          "nysiis",
          "koelnerphonetik",
          "haasephonetik",
          "beider_morse",
          "daitch_mokotoff"
        ]
      },
      "_types.analysis:PhoneticLanguage": {
        "type": "string",
        "enum": [
          "any",
          "common",
          "cyrillic",
          "english",
          "french",
          "german",
          "hebrew",
          "hungarian",
          "polish",
          "romanian",
          "russian",
          "spanish"
        ]
      },
      "_types.analysis:PhoneticNameType": {
        "type": "string",
        "enum": [
          "generic",
          "ashkenazi",
          "sephardic"
        ]
      },
      "_types.analysis:PhoneticRuleType": {
        "type": "string",
        "enum": [
          "approx",
          "exact"
        ]
      },
      "_types.analysis:DictionaryDecompounderTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CompoundWordTokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "dictionary_decompounder"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:Normalizer": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:LowercaseNormalizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CustomNormalizer"
          }
        ]
      },
      "_types.analysis:LowercaseNormalizer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "lowercase"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:CustomNormalizer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "custom"
            ]
          },
          "char_filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:Tokenizer": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenizers.html"
        },
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerDefinition"
          }
        ]
      },
      "_types.analysis:TokenizerDefinition": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharGroupTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ClassicTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:EdgeNGramTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeywordTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LetterTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LowercaseTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NGramTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PathHierarchyTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SimplePatternTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SimplePatternSplitTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StandardTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ThaiTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:UaxEmailUrlTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WhitespaceTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NoriTokenizer"
          }
        ]
      },
      "_types.analysis:CharGroupTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "char_group"
                ]
              },
              "tokenize_on_chars": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type",
              "tokenize_on_chars"
            ]
          }
        ]
      },
      "_types.analysis:TokenizerBase": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        }
      },
      "_types.analysis:ClassicTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "classic"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:EdgeNGramTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "edge_ngram"
                ]
              },
              "custom_token_chars": {
                "type": "string"
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "token_chars": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.analysis:TokenChar"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TokenChar": {
        "type": "string",
        "enum": [
          "letter",
          "digit",
          "whitespace",
          "punctuation",
          "symbol",
          "custom"
        ]
      },
      "_types.analysis:KeywordTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keyword"
                ]
              },
              "buffer_size": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LetterTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "letter"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LowercaseTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lowercase"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:NGramTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ngram"
                ]
              },
              "custom_token_chars": {
                "type": "string"
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "token_chars": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.analysis:TokenChar"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PathHierarchyTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "path_hierarchy"
                ]
              },
              "buffer_size": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
              },
              "delimiter": {
                "type": "string"
              },
              "replacement": {
                "type": "string"
              },
              "reverse": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              },
              "skip": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PatternTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern"
                ]
              },
              "flags": {
                "type": "string"
              },
              "group": {
                "type": "number"
              },
              "pattern": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SimplePatternTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "simple_pattern"
                ]
              },
              "pattern": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SimplePatternSplitTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "simple_pattern_split"
                ]
              },
              "pattern": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:StandardTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "standard"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ThaiTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "thai"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:UaxEmailUrlTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "uax_url_email"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:WhitespaceTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "whitespace"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:IcuTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_tokenizer"
                ]
              },
              "rule_files": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "rule_files"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_tokenizer"
                ]
              },
              "discard_punctuation": {
                "type": "boolean"
              },
              "mode": {
                "$ref": "#/components/schemas/_types.analysis:KuromojiTokenizationMode"
              },
              "nbest_cost": {
                "type": "number"
              },
              "nbest_examples": {
                "type": "string"
              },
              "user_dictionary": {
                "type": "string"
              },
              "user_dictionary_rules": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "discard_compound_token": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "mode"
            ]
          }
        ]
      },
      "_types.analysis:NoriTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "nori_tokenizer"
                ]
              },
              "decompound_mode": {
                "$ref": "#/components/schemas/_types.analysis:NoriDecompoundMode"
              },
              "discard_punctuation": {
                "type": "boolean"
              },
              "user_dictionary": {
                "type": "string"
              },
              "user_dictionary_rules": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "indices._types:IndexSettingsTimeSeries": {
        "type": "object",
        "properties": {
          "end_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        }
      },
      "indices._types:Queries": {
        "type": "object",
        "properties": {
          "cache": {
            "$ref": "#/components/schemas/indices._types:CacheQueries"
          }
        }
      },
      "indices._types:CacheQueries": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "indices._types:SettingsSimilarity": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityBm25"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityBoolean"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityDfi"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityDfr"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityIb"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityLmd"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityLmj"
          },
          {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityScripted"
          }
        ]
      },
      "indices._types:SettingsSimilarityBm25": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "BM25"
            ]
          },
          "b": {
            "type": "number"
          },
          "discount_overlaps": {
            "type": "boolean"
          },
          "k1": {
            "type": "number"
          }
        },
        "required": [
          "type"
        ]
      },
      "indices._types:SettingsSimilarityBoolean": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "boolean"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "indices._types:SettingsSimilarityDfi": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "DFI"
            ]
          },
          "independence_measure": {
            "$ref": "#/components/schemas/_types:DFIIndependenceMeasure"
          }
        },
        "required": [
          "type",
          "independence_measure"
        ]
      },
      "_types:DFIIndependenceMeasure": {
        "type": "string",
        "enum": [
          "standardized",
          "saturated",
          "chisquared"
        ]
      },
      "indices._types:SettingsSimilarityDfr": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "DFR"
            ]
          },
          "after_effect": {
            "$ref": "#/components/schemas/_types:DFRAfterEffect"
          },
          "basic_model": {
            "$ref": "#/components/schemas/_types:DFRBasicModel"
          },
          "normalization": {
            "$ref": "#/components/schemas/_types:Normalization"
          }
        },
        "required": [
          "type",
          "after_effect",
          "basic_model",
          "normalization"
        ]
      },
      "_types:DFRAfterEffect": {
        "type": "string",
        "enum": [
          "no",
          "b",
          "l"
        ]
      },
      "_types:DFRBasicModel": {
        "type": "string",
        "enum": [
          "be",
          "d",
          "g",
          "if",
          "in",
          "ine",
          "p"
        ]
      },
      "_types:Normalization": {
        "type": "string",
        "enum": [
          "no",
          "h1",
          "h2",
          "h3",
          "z"
        ]
      },
      "indices._types:SettingsSimilarityIb": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "IB"
            ]
          },
          "distribution": {
            "$ref": "#/components/schemas/_types:IBDistribution"
          },
          "lambda": {
            "$ref": "#/components/schemas/_types:IBLambda"
          },
          "normalization": {
            "$ref": "#/components/schemas/_types:Normalization"
          }
        },
        "required": [
          "type",
          "distribution",
          "lambda",
          "normalization"
        ]
      },
      "_types:IBDistribution": {
        "type": "string",
        "enum": [
          "ll",
          "spl"
        ]
      },
      "_types:IBLambda": {
        "type": "string",
        "enum": [
          "df",
          "ttf"
        ]
      },
      "indices._types:SettingsSimilarityLmd": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "LMDirichlet"
            ]
          },
          "mu": {
            "type": "number"
          }
        },
        "required": [
          "type"
        ]
      },
      "indices._types:SettingsSimilarityLmj": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "LMJelinekMercer"
            ]
          },
          "lambda": {
            "type": "number"
          }
        },
        "required": [
          "type"
        ]
      },
      "indices._types:SettingsSimilarityScripted": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "scripted"
            ]
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "weight_script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "type",
          "script"
        ]
      },
      "indices._types:MappingLimitSettings": {
        "type": "object",
        "properties": {
          "coerce": {
            "type": "boolean"
          },
          "total_fields": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsTotalFields"
          },
          "depth": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsDepth"
          },
          "nested_fields": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsNestedFields"
          },
          "nested_objects": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsNestedObjects"
          },
          "field_name_length": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsFieldNameLength"
          },
          "dimension_fields": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsDimensionFields"
          },
          "source": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsSourceFields"
          },
          "ignore_malformed": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "indices._types:MappingLimitSettingsTotalFields": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of fields in an index. Field and object mappings, as well as field aliases count towards this limit.\nThe limit is in place to prevent mappings and searches from becoming too large. Higher values can lead to performance\ndegradations and memory issues, especially in clusters with a high load or few resources.",
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "ignore_dynamic_beyond_limit": {
            "description": "This setting determines what happens when a dynamically mapped field would exceed the total fields limit. When set\nto false (the default), the index request of the document that tries to add a dynamic field to the mapping will fail\nwith the message Limit of total fields [X] has been exceeded. When set to true, the index request will not fail.\nInstead, fields that would exceed the limit are not added to the mapping, similar to dynamic: false.\nThe fields that were not added to the mapping will be added to the _ignored field.",
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "indices._types:MappingLimitSettingsDepth": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum depth for a field, which is measured as the number of inner objects. For instance, if all fields are defined\nat the root object level, then the depth is 1. If there is one object mapping, then the depth is 2, etc.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsNestedFields": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of distinct nested mappings in an index. The nested type should only be used in special cases, when\narrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this\nsetting limits the number of unique nested types per index.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsNestedObjects": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps\nto prevent out of memory errors when a document contains too many nested objects.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsFieldNameLength": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Setting for the maximum length of a field name. This setting isnâ€™t really something that addresses mappings explosion but\nmight still be useful if you want to limit the field length. It usually shouldnâ€™t be necessary to set this setting. The\ndefault is okay unless a user starts to add a huge number of fields with really long names. Default is `Long.MAX_VALUE` (no limit).",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsDimensionFields": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "[preview] This functionality is in technical preview and may be changed or removed in a future release.\nElastic will work to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsSourceFields": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/indices._types:SourceMode"
          }
        },
        "required": [
          "mode"
        ]
      },
      "indices._types:SourceMode": {
        "type": "string",
        "enum": [
          "disabled",
          "stored",
          "synthetic"
        ]
      },
      "indices._types:IndexingSlowlogSettings": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string"
          },
          "source": {
            "type": "number"
          },
          "reformat": {
            "type": "boolean"
          },
          "threshold": {
            "$ref": "#/components/schemas/indices._types:IndexingSlowlogTresholds"
          }
        }
      },
      "indices._types:IndexingSlowlogTresholds": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholdLevels"
          }
        }
      },
      "indices._types:IndexingPressure": {
        "type": "object",
        "properties": {
          "memory": {
            "$ref": "#/components/schemas/indices._types:IndexingPressureMemory"
          }
        },
        "required": [
          "memory"
        ]
      },
      "indices._types:IndexingPressureMemory": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Number of outstanding bytes that may be consumed by indexing requests. When this limit is reached or exceeded,\nthe node will reject new coordinating and primary operations. When replica operations consume 1.5x this limit,\nthe node will reject new replica operations. Defaults to 10% of the heap.",
            "type": "number"
          }
        }
      },
      "indices._types:Storage": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/indices._types:StorageType"
          },
          "allow_mmap": {
            "description": "You can restrict the use of the mmapfs and the related hybridfs store type via the setting node.store.allow_mmap.\nThis is a boolean setting indicating whether or not memory-mapping is allowed. The default is to allow it. This\nsetting is useful, for example, if you are in an environment where you can not control the ability to create a lot\nof memory maps so you need disable the ability to use memory-mapping.",
            "type": "boolean"
          }
        },
        "required": [
          "type"
        ]
      },
      "indices._types:StorageType": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "fs",
              "niofs",
              "mmapfs",
              "hybridfs"
            ]
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.mapping:TypeMapping": {
        "type": "object",
        "properties": {
          "all_field": {
            "$ref": "#/components/schemas/_types.mapping:AllField"
          },
          "date_detection": {
            "type": "boolean"
          },
          "dynamic": {
            "$ref": "#/components/schemas/_types.mapping:DynamicMapping"
          },
          "dynamic_date_formats": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "dynamic_templates": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/_types.mapping:DynamicTemplate"
              }
            }
          },
          "_field_names": {
            "$ref": "#/components/schemas/_types.mapping:FieldNamesField"
          },
          "index_field": {
            "$ref": "#/components/schemas/_types.mapping:IndexField"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "numeric_detection": {
            "type": "boolean"
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "_routing": {
            "$ref": "#/components/schemas/_types.mapping:RoutingField"
          },
          "_size": {
            "$ref": "#/components/schemas/_types.mapping:SizeField"
          },
          "_source": {
            "$ref": "#/components/schemas/_types.mapping:SourceField"
          },
          "runtime": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:RuntimeField"
            }
          },
          "enabled": {
            "type": "boolean"
          },
          "subobjects": {
            "type": "boolean"
          },
          "_data_stream_timestamp": {
            "$ref": "#/components/schemas/_types.mapping:DataStreamTimestamp"
          }
        }
      },
      "_types.mapping:AllField": {
        "type": "object",
        "properties": {
          "analyzer": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "omit_norms": {
            "type": "boolean"
          },
          "search_analyzer": {
            "type": "string"
          },
          "similarity": {
            "type": "string"
          },
          "store": {
            "type": "boolean"
          },
          "store_term_vector_offsets": {
            "type": "boolean"
          },
          "store_term_vector_payloads": {
            "type": "boolean"
          },
          "store_term_vector_positions": {
            "type": "boolean"
          },
          "store_term_vectors": {
            "type": "boolean"
          }
        },
        "required": [
          "analyzer",
          "enabled",
          "omit_norms",
          "search_analyzer",
          "similarity",
          "store",
          "store_term_vector_offsets",
          "store_term_vector_payloads",
          "store_term_vector_positions",
          "store_term_vectors"
        ]
      },
      "_types.mapping:DynamicMapping": {
        "type": "string",
        "enum": [
          "strict",
          "runtime",
          "true",
          "false"
        ]
      },
      "_types.mapping:DynamicTemplate": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "match": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "path_match": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "unmatch": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "path_unmatch": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "match_mapping_type": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "unmatch_mapping_type": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "match_pattern": {
                "$ref": "#/components/schemas/_types.mapping:MatchType"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "mapping": {
                "$ref": "#/components/schemas/_types.mapping:Property"
              },
              "runtime": {
                "$ref": "#/components/schemas/_types.mapping:Property"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.mapping:Property": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:BinaryProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:BooleanProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DynamicProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:JoinProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:KeywordProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:MatchOnlyTextProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:PercolatorProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:RankFeatureProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:RankFeaturesProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:SearchAsYouTypeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:TextProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:VersionProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:WildcardProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DateNanosProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DateProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:AggregateMetricDoubleProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DenseVectorProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FlattenedProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:NestedProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ObjectProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:SemanticTextProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:SparseVectorProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:CompletionProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ConstantKeywordProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FieldAliasProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:HistogramProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IpProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:Murmur3HashProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:TokenCountProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:GeoPointProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:GeoShapeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:PointProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ShapeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ByteNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DoubleNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FloatNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:HalfFloatNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IntegerNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:LongNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ScaledFloatNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ShortNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:UnsignedLongNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DateRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DoubleRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FloatRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IntegerRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IpRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:LongRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IcuCollationProperty"
          }
        ]
      },
      "_types.mapping:BinaryProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "binary"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DocValuesPropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_values": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:CorePropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "copy_to": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "store": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:PropertyBase": {
        "type": "object",
        "properties": {
          "meta": {
            "description": "Metadata about the field.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "ignore_above": {
            "type": "number"
          },
          "dynamic": {
            "$ref": "#/components/schemas/_types.mapping:DynamicMapping"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "synthetic_source_keep": {
            "$ref": "#/components/schemas/_types.mapping:SyntheticSourceKeepEnum"
          }
        }
      },
      "_types.mapping:SyntheticSourceKeepEnum": {
        "type": "string",
        "enum": [
          "none",
          "arrays",
          "all"
        ]
      },
      "_types.mapping:BooleanProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "fielddata": {
                "$ref": "#/components/schemas/indices._types:NumericFielddata"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "x-state": "Technical preview",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "boolean"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "indices._types:NumericFielddata": {
        "type": "object",
        "properties": {
          "format": {
            "$ref": "#/components/schemas/indices._types:NumericFielddataFormat"
          }
        },
        "required": [
          "format"
        ]
      },
      "indices._types:NumericFielddataFormat": {
        "type": "string",
        "enum": [
          "array",
          "disabled"
        ]
      },
      "_types.mapping:OnScriptError": {
        "type": "string",
        "enum": [
          "fail",
          "continue"
        ]
      },
      "_types.mapping:DynamicProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "{dynamic_type}"
                ]
              },
              "enabled": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "boost": {
                "type": "number"
              },
              "coerce": {
                "type": "boolean"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "time_series_metric": {
                "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
              },
              "analyzer": {
                "type": "string"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "index_phrases": {
                "type": "boolean"
              },
              "index_prefixes": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.mapping:TextIndexPrefixes"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "norms": {
                "type": "boolean"
              },
              "position_increment_gap": {
                "type": "number"
              },
              "search_analyzer": {
                "type": "string"
              },
              "search_quote_analyzer": {
                "type": "string"
              },
              "term_vector": {
                "$ref": "#/components/schemas/_types.mapping:TermVectorOption"
              },
              "format": {
                "type": "string"
              },
              "precision_step": {
                "type": "number"
              },
              "locale": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:TimeSeriesMetricType": {
        "type": "string",
        "enum": [
          "gauge",
          "counter",
          "summary",
          "histogram",
          "position"
        ]
      },
      "_types.mapping:IndexOptions": {
        "type": "string",
        "enum": [
          "docs",
          "freqs",
          "positions",
          "offsets"
        ]
      },
      "_types.mapping:TextIndexPrefixes": {
        "type": "object",
        "properties": {
          "max_chars": {
            "type": "number"
          },
          "min_chars": {
            "type": "number"
          }
        },
        "required": [
          "max_chars",
          "min_chars"
        ]
      },
      "_types.mapping:TermVectorOption": {
        "type": "string",
        "enum": [
          "no",
          "yes",
          "with_offsets",
          "with_positions",
          "with_positions_offsets",
          "with_positions_offsets_payloads",
          "with_positions_payloads"
        ]
      },
      "_types.mapping:JoinProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "relations": {
                "type": "object",
                "additionalProperties": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types:RelationName"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:RelationName"
                      }
                    }
                  ]
                }
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "join"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:KeywordProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "normalizer": {
                "type": "string"
              },
              "norms": {
                "type": "boolean"
              },
              "null_value": {
                "type": "string"
              },
              "similarity": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "split_queries_on_whitespace": {
                "type": "boolean"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "x-state": "Technical preview",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "keyword"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:MatchOnlyTextProperty": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "match_only_text"
            ]
          },
          "fields": {
            "description": "Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "meta": {
            "description": "Metadata about the field.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "copy_to": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:PercolatorProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "percolator"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:RankFeatureProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "positive_score_impact": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "rank_feature"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:RankFeaturesProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "positive_score_impact": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "rank_features"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:SearchAsYouTypeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "max_shingle_size": {
                "type": "number"
              },
              "norms": {
                "type": "boolean"
              },
              "search_analyzer": {
                "type": "string"
              },
              "search_quote_analyzer": {
                "type": "string"
              },
              "similarity": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "term_vector": {
                "$ref": "#/components/schemas/_types.mapping:TermVectorOption"
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_as_you_type"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:TextProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "boost": {
                "type": "number"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "fielddata": {
                "type": "boolean"
              },
              "fielddata_frequency_filter": {
                "$ref": "#/components/schemas/indices._types:FielddataFrequencyFilter"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "index_phrases": {
                "type": "boolean"
              },
              "index_prefixes": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.mapping:TextIndexPrefixes"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "norms": {
                "type": "boolean"
              },
              "position_increment_gap": {
                "type": "number"
              },
              "search_analyzer": {
                "type": "string"
              },
              "search_quote_analyzer": {
                "type": "string"
              },
              "similarity": {
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "term_vector": {
                "$ref": "#/components/schemas/_types.mapping:TermVectorOption"
              },
              "type": {
                "type": "string",
                "enum": [
                  "text"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "indices._types:FielddataFrequencyFilter": {
        "type": "object",
        "properties": {
          "max": {
            "type": "number"
          },
          "min": {
            "type": "number"
          },
          "min_segment_size": {
            "type": "number"
          }
        },
        "required": [
          "max",
          "min",
          "min_segment_size"
        ]
      },
      "_types.mapping:VersionProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "version"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:WildcardProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "wildcard"
                ]
              },
              "null_value": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DateNanosProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "format": {
                "type": "string"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "precision_step": {
                "type": "number"
              },
              "type": {
                "type": "string",
                "enum": [
                  "date_nanos"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DateProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "fielddata": {
                "$ref": "#/components/schemas/indices._types:NumericFielddata"
              },
              "format": {
                "type": "string"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "precision_step": {
                "type": "number"
              },
              "locale": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "date"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:AggregateMetricDoubleProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "aggregate_metric_double"
                ]
              },
              "default_metric": {
                "type": "string"
              },
              "metrics": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "time_series_metric": {
                "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
              }
            },
            "required": [
              "type",
              "default_metric",
              "metrics"
            ]
          }
        ]
      },
      "_types.mapping:DenseVectorProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "dense_vector"
                ]
              },
              "dims": {
                "description": "Number of vector dimensions. Can't exceed `4096`. If `dims` is not specified, it will be set to the length of\nthe first vector added to the field.",
                "type": "number"
              },
              "element_type": {
                "$ref": "#/components/schemas/_types.mapping:DenseVectorElementType"
              },
              "index": {
                "description": "If `true`, you can search this field using the kNN search API.",
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:DenseVectorIndexOptions"
              },
              "similarity": {
                "$ref": "#/components/schemas/_types.mapping:DenseVectorSimilarity"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DenseVectorElementType": {
        "type": "string",
        "enum": [
          "bit",
          "byte",
          "float"
        ]
      },
      "_types.mapping:DenseVectorIndexOptions": {
        "type": "object",
        "properties": {
          "confidence_interval": {
            "description": "The confidence interval to use when quantizing the vectors. Can be any value between and including `0.90` and\n`1.0` or exactly `0`. When the value is `0`, this indicates that dynamic quantiles should be calculated for\noptimized quantization. When between `0.90` and `1.0`, this value restricts the values used when calculating\nthe quantization thresholds.\n\nFor example, a value of `0.95` will only use the middle `95%` of the values when calculating the quantization\nthresholds (e.g. the highest and lowest `2.5%` of values will be ignored).\n\nDefaults to `1/(dims + 1)` for `int8` quantized vectors and `0` for `int4` for dynamic quantile calculation.\n\nOnly applicable to `int8_hnsw`, `int4_hnsw`, `int8_flat`, and `int4_flat` index types.",
            "type": "number"
          },
          "ef_construction": {
            "description": "The number of candidates to track while assembling the list of nearest neighbors for each new node.\n\nOnly applicable to `hnsw`, `int8_hnsw`, and `int4_hnsw` index types.",
            "type": "number"
          },
          "m": {
            "description": "The number of neighbors each node will be connected to in the HNSW graph.\n\nOnly applicable to `hnsw`, `int8_hnsw`, and `int4_hnsw` index types.",
            "type": "number"
          },
          "type": {
            "$ref": "#/components/schemas/_types.mapping:DenseVectorIndexOptionsType"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:DenseVectorIndexOptionsType": {
        "type": "string",
        "enum": [
          "flat",
          "hnsw",
          "int4_flat",
          "int4_hnsw",
          "int8_flat",
          "int8_hnsw"
        ]
      },
      "_types.mapping:DenseVectorSimilarity": {
        "type": "string",
        "enum": [
          "cosine",
          "dot_product",
          "l2_norm",
          "max_inner_product"
        ]
      },
      "_types.mapping:FlattenedProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "depth_limit": {
                "type": "number"
              },
              "doc_values": {
                "type": "boolean"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "null_value": {
                "type": "string"
              },
              "similarity": {
                "type": "string"
              },
              "split_queries_on_whitespace": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "flattened"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:NestedProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean"
              },
              "include_in_parent": {
                "type": "boolean"
              },
              "include_in_root": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "nested"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ObjectProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean"
              },
              "subobjects": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "object"
                ]
              }
            }
          }
        ]
      },
      "_types.mapping:SemanticTextProperty": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "semantic_text"
            ]
          },
          "meta": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "inference_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "search_inference_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:SparseVectorProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "sparse_vector"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:CompletionProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "contexts": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.mapping:SuggestContext"
                }
              },
              "max_input_length": {
                "type": "number"
              },
              "preserve_position_increments": {
                "type": "boolean"
              },
              "preserve_separators": {
                "type": "boolean"
              },
              "search_analyzer": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "completion"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:SuggestContext": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "path": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "type": {
            "type": "string"
          },
          "precision": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "_types.mapping:ConstantKeywordProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "object"
              },
              "type": {
                "type": "string",
                "enum": [
                  "constant_keyword"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:FieldAliasProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "type": {
                "type": "string",
                "enum": [
                  "alias"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:HistogramProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_malformed": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "histogram"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IpProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "index": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "null_value": {
                "type": "string"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "x-state": "Technical preview",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "ip"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:Murmur3HashProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "murmur3"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:TokenCountProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "boost": {
                "type": "number"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "type": "number"
              },
              "enable_position_increments": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "token_count"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:GeoPointProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              },
              "index": {
                "type": "boolean"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "type": {
                "type": "string",
                "enum": [
                  "geo_point"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:GeoShapeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "coerce": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "orientation": {
                "$ref": "#/components/schemas/_types.mapping:GeoOrientation"
              },
              "strategy": {
                "$ref": "#/components/schemas/_types.mapping:GeoStrategy"
              },
              "type": {
                "type": "string",
                "enum": [
                  "geo_shape"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:GeoOrientation": {
        "type": "string",
        "enum": [
          "right",
          "RIGHT",
          "counterclockwise",
          "ccw",
          "left",
          "LEFT",
          "clockwise",
          "cw"
        ]
      },
      "_types.mapping:GeoStrategy": {
        "type": "string",
        "enum": [
          "recursive",
          "term"
        ]
      },
      "_types.mapping:PointProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "null_value": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "point"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ShapeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "coerce": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "orientation": {
                "$ref": "#/components/schemas/_types.mapping:GeoOrientation"
              },
              "type": {
                "type": "string",
                "enum": [
                  "shape"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ByteNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "byte"
                ]
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:byte"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types:byte": {
        "type": "number"
      },
      "_types.mapping:NumberPropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "coerce": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_series_metric": {
                "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "x-state": "Technical preview",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:DoubleNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "double"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:FloatNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "float"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:HalfFloatNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "half_float"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IntegerNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "integer"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:LongNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "long"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ScaledFloatNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "scaled_float"
                ]
              },
              "null_value": {
                "type": "number"
              },
              "scaling_factor": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ShortNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "short"
                ]
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:short"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types:short": {
        "type": "number"
      },
      "_types.mapping:UnsignedLongNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unsigned_long"
                ]
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:ulong"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types:ulong": {
        "type": "number"
      },
      "_types.mapping:DateRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "date_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:RangePropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "coerce": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:DoubleRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "double_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:FloatRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "float_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IntegerRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "integer_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IpRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ip_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:LongRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "long_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IcuCollationProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_collation_keyword"
                ]
              },
              "norms": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "index": {
                "description": "Should the field be searchable?",
                "type": "boolean"
              },
              "null_value": {
                "description": "Accepts a string value which is substituted for any explicit null values. Defaults to null, which means the field is treated as missing.",
                "type": "string"
              },
              "rules": {
                "type": "string"
              },
              "language": {
                "type": "string"
              },
              "country": {
                "type": "string"
              },
              "variant": {
                "type": "string"
              },
              "strength": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationStrength"
              },
              "decomposition": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationDecomposition"
              },
              "alternate": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationAlternate"
              },
              "case_level": {
                "type": "boolean"
              },
              "case_first": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationCaseFirst"
              },
              "numeric": {
                "type": "boolean"
              },
              "variable_top": {
                "type": "string"
              },
              "hiragana_quaternary_mode": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:MatchType": {
        "type": "string",
        "enum": [
          "simple",
          "regex"
        ]
      },
      "_types.mapping:FieldNamesField": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types.mapping:IndexField": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types.mapping:RoutingField": {
        "type": "object",
        "properties": {
          "required": {
            "type": "boolean"
          }
        },
        "required": [
          "required"
        ]
      },
      "_types.mapping:SizeField": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types.mapping:SourceField": {
        "type": "object",
        "properties": {
          "compress": {
            "type": "boolean"
          },
          "compress_threshold": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "excludes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "includes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mode": {
            "$ref": "#/components/schemas/_types.mapping:SourceFieldMode"
          }
        }
      },
      "_types.mapping:SourceFieldMode": {
        "type": "string",
        "enum": [
          "disabled",
          "stored",
          "synthetic"
        ]
      },
      "_types.mapping:DataStreamTimestamp": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "indices._types:AliasDefinition": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "index_routing": {
            "description": "Value used to route indexing operations to a specific shard.\nIf specified, this overwrites the `routing` value for indexing operations.",
            "type": "string"
          },
          "is_write_index": {
            "description": "If `true`, the index is the write index for the alias.",
            "type": "boolean"
          },
          "routing": {
            "description": "Value used to route indexing and search operations to a specific shard.",
            "type": "string"
          },
          "search_routing": {
            "description": "Value used to route search operations to a specific shard.\nIf specified, this overwrites the `routing` value for search operations.",
            "type": "string"
          },
          "is_hidden": {
            "description": "If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.",
            "type": "boolean"
          }
        }
      },
      "indices._types:DataStreamLifecycleWithRollover": {
        "type": "object",
        "properties": {
          "data_retention": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "downsampling": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleDownsampling"
          },
          "rollover": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleRolloverConditions"
          }
        }
      },
      "indices._types:DataStreamLifecycleDownsampling": {
        "type": "object",
        "properties": {
          "rounds": {
            "description": "The list of downsampling rounds to execute as part of this downsampling configuration",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices._types:DownsamplingRound"
            }
          }
        },
        "required": [
          "rounds"
        ]
      },
      "indices._types:DownsamplingRound": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "config": {
            "$ref": "#/components/schemas/indices._types:DownsampleConfig"
          }
        },
        "required": [
          "after",
          "config"
        ]
      },
      "indices._types:DownsampleConfig": {
        "type": "object",
        "properties": {
          "fixed_interval": {
            "$ref": "#/components/schemas/_types:DurationLarge"
          }
        },
        "required": [
          "fixed_interval"
        ]
      },
      "indices._types:DataStreamLifecycleRolloverConditions": {
        "type": "object",
        "properties": {
          "min_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_age": {
            "type": "string"
          },
          "min_docs": {
            "type": "number"
          },
          "max_docs": {
            "type": "number"
          },
          "min_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_docs": {
            "type": "number"
          },
          "max_primary_shard_docs": {
            "type": "number"
          }
        }
      },
      "_types:Level": {
        "type": "string",
        "enum": [
          "cluster",
          "indices",
          "shards"
        ]
      },
      "_types:WaitForEvents": {
        "type": "string",
        "enum": [
          "immediate",
          "urgent",
          "high",
          "normal",
          "low",
          "languid"
        ]
      },
      "cluster.health:HealthResponseBody": {
        "type": "object",
        "properties": {
          "active_primary_shards": {
            "description": "The number of active primary shards.",
            "type": "number"
          },
          "active_shards": {
            "description": "The total number of active primary and replica shards.",
            "type": "number"
          },
          "active_shards_percent_as_number": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "cluster_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "delayed_unassigned_shards": {
            "description": "The number of shards whose allocation has been delayed by the timeout settings.",
            "type": "number"
          },
          "indices": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.health:IndexHealthStats"
            }
          },
          "initializing_shards": {
            "description": "The number of shards that are under initialization.",
            "type": "number"
          },
          "number_of_data_nodes": {
            "description": "The number of nodes that are dedicated data nodes.",
            "type": "number"
          },
          "number_of_in_flight_fetch": {
            "description": "The number of unfinished fetches.",
            "type": "number"
          },
          "number_of_nodes": {
            "description": "The number of nodes within the cluster.",
            "type": "number"
          },
          "number_of_pending_tasks": {
            "description": "The number of cluster-level changes that have not yet been executed.",
            "type": "number"
          },
          "relocating_shards": {
            "description": "The number of shards that are under relocation.",
            "type": "number"
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "task_max_waiting_in_queue": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "task_max_waiting_in_queue_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "timed_out": {
            "description": "If false the response returned within the period of time that is specified by the timeout parameter (30s by default)",
            "type": "boolean"
          },
          "unassigned_primary_shards": {
            "description": "The number of primary shards that are not allocated.",
            "type": "number"
          },
          "unassigned_shards": {
            "description": "The number of shards that are not allocated.",
            "type": "number"
          }
        },
        "required": [
          "active_primary_shards",
          "active_shards",
          "active_shards_percent_as_number",
          "cluster_name",
          "delayed_unassigned_shards",
          "initializing_shards",
          "number_of_data_nodes",
          "number_of_in_flight_fetch",
          "number_of_nodes",
          "number_of_pending_tasks",
          "relocating_shards",
          "status",
          "task_max_waiting_in_queue_millis",
          "timed_out",
          "unassigned_primary_shards",
          "unassigned_shards"
        ]
      },
      "cluster.health:IndexHealthStats": {
        "type": "object",
        "properties": {
          "active_primary_shards": {
            "type": "number"
          },
          "active_shards": {
            "type": "number"
          },
          "initializing_shards": {
            "type": "number"
          },
          "number_of_replicas": {
            "type": "number"
          },
          "number_of_shards": {
            "type": "number"
          },
          "relocating_shards": {
            "type": "number"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.health:ShardHealthStats"
            }
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "unassigned_shards": {
            "type": "number"
          },
          "unassigned_primary_shards": {
            "type": "number"
          }
        },
        "required": [
          "active_primary_shards",
          "active_shards",
          "initializing_shards",
          "number_of_replicas",
          "number_of_shards",
          "relocating_shards",
          "status",
          "unassigned_shards",
          "unassigned_primary_shards"
        ]
      },
      "cluster.health:ShardHealthStats": {
        "type": "object",
        "properties": {
          "active_shards": {
            "type": "number"
          },
          "initializing_shards": {
            "type": "number"
          },
          "primary_active": {
            "type": "boolean"
          },
          "relocating_shards": {
            "type": "number"
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "unassigned_shards": {
            "type": "number"
          },
          "unassigned_primary_shards": {
            "type": "number"
          }
        },
        "required": [
          "active_shards",
          "initializing_shards",
          "primary_active",
          "relocating_shards",
          "status",
          "unassigned_shards",
          "unassigned_primary_shards"
        ]
      },
      "_types:ClusterInfoTargets": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ClusterInfoTarget"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ClusterInfoTarget"
            }
          }
        ]
      },
      "_types:ClusterInfoTarget": {
        "type": "string",
        "enum": [
          "_all",
          "http",
          "ingest",
          "thread_pool",
          "script"
        ]
      },
      "nodes._types:Http": {
        "type": "object",
        "properties": {
          "current_open": {
            "description": "Current number of open HTTP connections for the node.",
            "type": "number"
          },
          "total_opened": {
            "description": "Total number of HTTP connections opened for the node.",
            "type": "number"
          },
          "clients": {
            "description": "Information on current and recently-closed HTTP client connections.\nClients that have been closed longer than the `http.client_stats.closed_channels.max_age` setting will not be represented here.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:Client"
            }
          },
          "routes": {
            "description": "Detailed HTTP stats broken down by route",
            "x-state": "Added in 8.12.0",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:HttpRoute"
            }
          }
        },
        "required": [
          "routes"
        ]
      },
      "nodes._types:Client": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Unique ID for the HTTP client.",
            "type": "number"
          },
          "agent": {
            "description": "Reported agent for the HTTP client.\nIf unavailable, this property is not included in the response.",
            "type": "string"
          },
          "local_address": {
            "description": "Local address for the HTTP connection.",
            "type": "string"
          },
          "remote_address": {
            "description": "Remote address for the HTTP connection.",
            "type": "string"
          },
          "last_uri": {
            "description": "The URI of the clientâ€™s most recent request.",
            "type": "string"
          },
          "opened_time_millis": {
            "description": "Time at which the client opened the connection.",
            "type": "number"
          },
          "closed_time_millis": {
            "description": "Time at which the client closed the connection if the connection is closed.",
            "type": "number"
          },
          "last_request_time_millis": {
            "description": "Time of the most recent request from this client.",
            "type": "number"
          },
          "request_count": {
            "description": "Number of requests from this client.",
            "type": "number"
          },
          "request_size_bytes": {
            "description": "Cumulative size in bytes of all requests from this client.",
            "type": "number"
          },
          "x_opaque_id": {
            "description": "Value from the clientâ€™s `x-opaque-id` HTTP header.\nIf unavailable, this property is not included in the response.",
            "type": "string"
          }
        }
      },
      "nodes._types:HttpRoute": {
        "type": "object",
        "properties": {
          "requests": {
            "$ref": "#/components/schemas/nodes._types:HttpRouteRequests"
          },
          "responses": {
            "$ref": "#/components/schemas/nodes._types:HttpRouteResponses"
          }
        },
        "required": [
          "requests",
          "responses"
        ]
      },
      "nodes._types:HttpRouteRequests": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "total_size_in_bytes": {
            "type": "number"
          },
          "size_histogram": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:SizeHttpHistogram"
            }
          }
        },
        "required": [
          "count",
          "total_size_in_bytes",
          "size_histogram"
        ]
      },
      "nodes._types:SizeHttpHistogram": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "ge_bytes": {
            "type": "number"
          },
          "lt_bytes": {
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "nodes._types:HttpRouteResponses": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "total_size_in_bytes": {
            "type": "number"
          },
          "handling_time_histogram": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:TimeHttpHistogram"
            }
          },
          "size_histogram": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:SizeHttpHistogram"
            }
          }
        },
        "required": [
          "count",
          "total_size_in_bytes",
          "handling_time_histogram",
          "size_histogram"
        ]
      },
      "nodes._types:TimeHttpHistogram": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "ge_millis": {
            "type": "number"
          },
          "lt_millis": {
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "nodes._types:Ingest": {
        "type": "object",
        "properties": {
          "pipelines": {
            "description": "Contains statistics about ingest pipelines for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:IngestStats"
            }
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:IngestTotal"
          }
        }
      },
      "nodes._types:IngestStats": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of documents ingested during the lifetime of this node.",
            "type": "number"
          },
          "current": {
            "description": "Total number of documents currently being ingested.",
            "type": "number"
          },
          "failed": {
            "description": "Total number of failed ingest operations during the lifetime of this node.",
            "type": "number"
          },
          "processors": {
            "description": "Total number of ingest processors.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/nodes._types:KeyedProcessor"
              }
            }
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "ingested_as_first_pipeline_in_bytes": {
            "description": "Total number of bytes of all documents ingested by the pipeline.\nThis field is only present on pipelines which are the first to process a document.\nThus, it is not present on pipelines which only serve as a final pipeline after a default pipeline, a pipeline run after a reroute processor, or pipelines in pipeline processors.",
            "x-state": "Added in 8.15.0",
            "type": "number"
          },
          "produced_as_first_pipeline_in_bytes": {
            "description": "Total number of bytes of all documents produced by the pipeline.\nThis field is only present on pipelines which are the first to process a document.\nThus, it is not present on pipelines which only serve as a final pipeline after a default pipeline, a pipeline run after a reroute processor, or pipelines in pipeline processors.\nIn situations where there are subsequent pipelines, the value represents the size of the document after all pipelines have run.",
            "x-state": "Added in 8.15.0",
            "type": "number"
          }
        },
        "required": [
          "count",
          "current",
          "failed",
          "processors",
          "time_in_millis",
          "ingested_as_first_pipeline_in_bytes",
          "produced_as_first_pipeline_in_bytes"
        ]
      },
      "nodes._types:KeyedProcessor": {
        "type": "object",
        "properties": {
          "stats": {
            "$ref": "#/components/schemas/nodes._types:Processor"
          },
          "type": {
            "type": "string"
          }
        }
      },
      "nodes._types:Processor": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of documents transformed by the processor.",
            "type": "number"
          },
          "current": {
            "description": "Number of documents currently being transformed by the processor.",
            "type": "number"
          },
          "failed": {
            "description": "Number of failed operations for the processor.",
            "type": "number"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        }
      },
      "nodes._types:IngestTotal": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of documents ingested during the lifetime of this node.",
            "type": "number"
          },
          "current": {
            "description": "Total number of documents currently being ingested.",
            "type": "number"
          },
          "failed": {
            "description": "Total number of failed ingest operations during the lifetime of this node.",
            "type": "number"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "count",
          "current",
          "failed",
          "time_in_millis"
        ]
      },
      "nodes._types:ThreadCount": {
        "type": "object",
        "properties": {
          "active": {
            "description": "Number of active threads in the thread pool.",
            "type": "number"
          },
          "completed": {
            "description": "Number of tasks completed by the thread pool executor.",
            "type": "number"
          },
          "largest": {
            "description": "Highest number of active threads in the thread pool.",
            "type": "number"
          },
          "queue": {
            "description": "Number of tasks in queue for the thread pool.",
            "type": "number"
          },
          "rejected": {
            "description": "Number of tasks rejected by the thread pool executor.",
            "type": "number"
          },
          "threads": {
            "description": "Number of threads in the thread pool.",
            "type": "number"
          }
        }
      },
      "nodes._types:Scripting": {
        "type": "object",
        "properties": {
          "cache_evictions": {
            "description": "Total number of times the script cache has evicted old data.",
            "type": "number"
          },
          "compilations": {
            "description": "Total number of inline script compilations performed by the node.",
            "type": "number"
          },
          "compilations_history": {
            "description": "Contains this recent history of script compilations.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "compilation_limit_triggered": {
            "description": "Total number of times the script compilation circuit breaker has limited inline script compilations.",
            "type": "number"
          },
          "contexts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:Context"
            }
          }
        }
      },
      "nodes._types:Context": {
        "type": "object",
        "properties": {
          "context": {
            "type": "string"
          },
          "compilations": {
            "type": "number"
          },
          "cache_evictions": {
            "type": "number"
          },
          "compilation_limit_triggered": {
            "type": "number"
          }
        }
      },
      "cluster.pending_tasks:PendingTask": {
        "type": "object",
        "properties": {
          "executing": {
            "description": "Indicates whether the pending tasks are currently executing or not.",
            "type": "boolean"
          },
          "insert_order": {
            "description": "The number that represents when the task has been inserted into the task queue.",
            "type": "number"
          },
          "priority": {
            "description": "The priority of the pending task.\nThe valid priorities in descending priority order are: `IMMEDIATE` > `URGENT` > `HIGH` > `NORMAL` > `LOW` > `LANGUID`.",
            "type": "string"
          },
          "source": {
            "description": "A general description of the cluster task that may include a reason and origin.",
            "type": "string"
          },
          "time_in_queue": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_queue_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "executing",
          "insert_order",
          "priority",
          "source",
          "time_in_queue_millis"
        ]
      },
      "indices._types:IndexState": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "defaults": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "data_stream": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycle"
          }
        }
      },
      "indices._types:Alias": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "index_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "is_hidden": {
            "description": "If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.",
            "type": "boolean"
          },
          "is_write_index": {
            "description": "If `true`, the index is the write index for the alias.",
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "search_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          }
        }
      },
      "_types:DataStreamName": {
        "type": "string"
      },
      "indices._types:DataStreamLifecycle": {
        "type": "object",
        "properties": {
          "data_retention": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "downsampling": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleDownsampling"
          }
        }
      },
      "cluster.remote_info:ClusterRemoteInfo": {
        "discriminator": {
          "propertyName": "mode"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/cluster.remote_info:ClusterRemoteSniffInfo"
          },
          {
            "$ref": "#/components/schemas/cluster.remote_info:ClusterRemoteProxyInfo"
          }
        ]
      },
      "cluster.remote_info:ClusterRemoteSniffInfo": {
        "type": "object",
        "properties": {
          "mode": {
            "type": "string",
            "enum": [
              "sniff"
            ]
          },
          "connected": {
            "type": "boolean"
          },
          "max_connections_per_cluster": {
            "type": "number"
          },
          "num_nodes_connected": {
            "type": "number"
          },
          "initial_connect_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "skip_unavailable": {
            "type": "boolean"
          },
          "seeds": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "mode",
          "connected",
          "max_connections_per_cluster",
          "num_nodes_connected",
          "initial_connect_timeout",
          "skip_unavailable",
          "seeds"
        ]
      },
      "cluster.remote_info:ClusterRemoteProxyInfo": {
        "type": "object",
        "properties": {
          "mode": {
            "type": "string",
            "enum": [
              "proxy"
            ]
          },
          "connected": {
            "type": "boolean"
          },
          "initial_connect_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "skip_unavailable": {
            "type": "boolean"
          },
          "proxy_address": {
            "type": "string"
          },
          "server_name": {
            "type": "string"
          },
          "num_proxy_sockets_connected": {
            "type": "number"
          },
          "max_proxy_socket_connections": {
            "type": "number"
          }
        },
        "required": [
          "mode",
          "connected",
          "initial_connect_timeout",
          "skip_unavailable",
          "proxy_address",
          "server_name",
          "num_proxy_sockets_connected",
          "max_proxy_socket_connections"
        ]
      },
      "_types:Metrics": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "cluster.reroute:Command": {
        "type": "object",
        "properties": {
          "cancel": {
            "$ref": "#/components/schemas/cluster.reroute:CommandCancelAction"
          },
          "move": {
            "$ref": "#/components/schemas/cluster.reroute:CommandMoveAction"
          },
          "allocate_replica": {
            "$ref": "#/components/schemas/cluster.reroute:CommandAllocateReplicaAction"
          },
          "allocate_stale_primary": {
            "$ref": "#/components/schemas/cluster.reroute:CommandAllocatePrimaryAction"
          },
          "allocate_empty_primary": {
            "$ref": "#/components/schemas/cluster.reroute:CommandAllocatePrimaryAction"
          }
        }
      },
      "cluster.reroute:CommandCancelAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "node": {
            "type": "string"
          },
          "allow_primary": {
            "type": "boolean"
          }
        },
        "required": [
          "index",
          "shard",
          "node"
        ]
      },
      "cluster.reroute:CommandMoveAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "from_node": {
            "description": "The node to move the shard from",
            "type": "string"
          },
          "to_node": {
            "description": "The node to move the shard to",
            "type": "string"
          }
        },
        "required": [
          "index",
          "shard",
          "from_node",
          "to_node"
        ]
      },
      "cluster.reroute:CommandAllocateReplicaAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "node": {
            "type": "string"
          }
        },
        "required": [
          "index",
          "shard",
          "node"
        ]
      },
      "cluster.reroute:CommandAllocatePrimaryAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "node": {
            "type": "string"
          },
          "accept_data_loss": {
            "description": "If a node which has a copy of the data rejoins the cluster later on, that data will be deleted. To ensure that these implications are well-understood, this command requires the flag accept_data_loss to be explicitly set to true",
            "type": "boolean"
          }
        },
        "required": [
          "index",
          "shard",
          "node",
          "accept_data_loss"
        ]
      },
      "cluster.reroute:RerouteExplanation": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string"
          },
          "decisions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.reroute:RerouteDecision"
            }
          },
          "parameters": {
            "$ref": "#/components/schemas/cluster.reroute:RerouteParameters"
          }
        },
        "required": [
          "command",
          "decisions",
          "parameters"
        ]
      },
      "cluster.reroute:RerouteDecision": {
        "type": "object",
        "properties": {
          "decider": {
            "type": "string"
          },
          "decision": {
            "type": "string"
          },
          "explanation": {
            "type": "string"
          }
        },
        "required": [
          "decider",
          "decision",
          "explanation"
        ]
      },
      "cluster.reroute:RerouteParameters": {
        "type": "object",
        "properties": {
          "allow_primary": {
            "type": "boolean"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "shard": {
            "type": "number"
          },
          "from_node": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "to_node": {
            "$ref": "#/components/schemas/_types:NodeName"
          }
        },
        "required": [
          "allow_primary",
          "index",
          "node",
          "shard"
        ]
      },
      "cluster.stats:StatsResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "cluster_uuid": {
                "$ref": "#/components/schemas/_types:Uuid"
              },
              "indices": {
                "$ref": "#/components/schemas/cluster.stats:ClusterIndices"
              },
              "nodes": {
                "$ref": "#/components/schemas/cluster.stats:ClusterNodes"
              },
              "status": {
                "$ref": "#/components/schemas/_types:HealthStatus"
              },
              "timestamp": {
                "description": "Unix timestamp, in milliseconds, for the last time the cluster statistics were refreshed.",
                "type": "number"
              }
            },
            "required": [
              "cluster_name",
              "cluster_uuid",
              "indices",
              "nodes",
              "status",
              "timestamp"
            ]
          }
        ]
      },
      "cluster.stats:ClusterIndices": {
        "type": "object",
        "properties": {
          "analysis": {
            "$ref": "#/components/schemas/cluster.stats:CharFilterTypes"
          },
          "completion": {
            "$ref": "#/components/schemas/_types:CompletionStats"
          },
          "count": {
            "description": "Total number of indices with shards assigned to selected nodes.",
            "type": "number"
          },
          "docs": {
            "$ref": "#/components/schemas/_types:DocStats"
          },
          "fielddata": {
            "$ref": "#/components/schemas/_types:FielddataStats"
          },
          "query_cache": {
            "$ref": "#/components/schemas/_types:QueryCacheStats"
          },
          "segments": {
            "$ref": "#/components/schemas/_types:SegmentsStats"
          },
          "shards": {
            "$ref": "#/components/schemas/cluster.stats:ClusterIndicesShards"
          },
          "store": {
            "$ref": "#/components/schemas/_types:StoreStats"
          },
          "mappings": {
            "$ref": "#/components/schemas/cluster.stats:FieldTypesMappings"
          },
          "versions": {
            "description": "Contains statistics about analyzers and analyzer components used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:IndicesVersions"
            }
          }
        },
        "required": [
          "analysis",
          "completion",
          "count",
          "docs",
          "fielddata",
          "query_cache",
          "segments",
          "shards",
          "store",
          "mappings"
        ]
      },
      "cluster.stats:CharFilterTypes": {
        "type": "object",
        "properties": {
          "analyzer_types": {
            "description": "Contains statistics about analyzer types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_analyzers": {
            "description": "Contains statistics about built-in analyzers used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_char_filters": {
            "description": "Contains statistics about built-in character filters used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_filters": {
            "description": "Contains statistics about built-in token filters used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_tokenizers": {
            "description": "Contains statistics about built-in tokenizers used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "char_filter_types": {
            "description": "Contains statistics about character filter types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "filter_types": {
            "description": "Contains statistics about token filter types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "tokenizer_types": {
            "description": "Contains statistics about tokenizer types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          }
        },
        "required": [
          "analyzer_types",
          "built_in_analyzers",
          "built_in_char_filters",
          "built_in_filters",
          "built_in_tokenizers",
          "char_filter_types",
          "filter_types",
          "tokenizer_types"
        ]
      },
      "cluster.stats:FieldTypes": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "count": {
            "description": "The number of occurrences of the field type in selected nodes.",
            "type": "number"
          },
          "index_count": {
            "description": "The number of indices containing the field type in selected nodes.",
            "type": "number"
          },
          "indexed_vector_count": {
            "description": "For dense_vector field types, number of indexed vector types in selected nodes.",
            "type": "number"
          },
          "indexed_vector_dim_max": {
            "description": "For dense_vector field types, the maximum dimension of all indexed vector types in selected nodes.",
            "type": "number"
          },
          "indexed_vector_dim_min": {
            "description": "For dense_vector field types, the minimum dimension of all indexed vector types in selected nodes.",
            "type": "number"
          },
          "script_count": {
            "description": "The number of fields that declare a script.",
            "type": "number"
          }
        },
        "required": [
          "name",
          "count",
          "index_count"
        ]
      },
      "_types:CompletionStats": {
        "type": "object",
        "properties": {
          "size_in_bytes": {
            "description": "Total amount, in bytes, of memory used for completion across all shards assigned to selected nodes.",
            "type": "number"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:FieldSizeUsage"
            }
          }
        },
        "required": [
          "size_in_bytes"
        ]
      },
      "_types:FieldSizeUsage": {
        "type": "object",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "size_in_bytes"
        ]
      },
      "_types:DocStats": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of non-deleted documents across all primary shards assigned to selected nodes.\nThis number is based on documents in Lucene segments and may include documents from nested fields.",
            "type": "number"
          },
          "deleted": {
            "description": "Total number of deleted documents across all primary shards assigned to selected nodes.\nThis number is based on documents in Lucene segments.\nElasticsearch reclaims the disk space of deleted Lucene documents when a segment is merged.",
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "_types:FielddataStats": {
        "type": "object",
        "properties": {
          "evictions": {
            "type": "number"
          },
          "memory_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_size_in_bytes": {
            "type": "number"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:FieldMemoryUsage"
            }
          }
        },
        "required": [
          "memory_size_in_bytes"
        ]
      },
      "_types:FieldMemoryUsage": {
        "type": "object",
        "properties": {
          "memory_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "memory_size_in_bytes"
        ]
      },
      "_types:QueryCacheStats": {
        "type": "object",
        "properties": {
          "cache_count": {
            "description": "Total number of entries added to the query cache across all shards assigned to selected nodes.\nThis number includes current and evicted entries.",
            "type": "number"
          },
          "cache_size": {
            "description": "Total number of entries currently in the query cache across all shards assigned to selected nodes.",
            "type": "number"
          },
          "evictions": {
            "description": "Total number of query cache evictions across all shards assigned to selected nodes.",
            "type": "number"
          },
          "hit_count": {
            "description": "Total count of query cache hits across all shards assigned to selected nodes.",
            "type": "number"
          },
          "memory_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_size_in_bytes": {
            "description": "Total amount, in bytes, of memory used for the query cache across all shards assigned to selected nodes.",
            "type": "number"
          },
          "miss_count": {
            "description": "Total count of query cache misses across all shards assigned to selected nodes.",
            "type": "number"
          },
          "total_count": {
            "description": "Total count of hits and misses in the query cache across all shards assigned to selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "cache_count",
          "cache_size",
          "evictions",
          "hit_count",
          "memory_size_in_bytes",
          "miss_count",
          "total_count"
        ]
      },
      "_types:SegmentsStats": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of segments across all shards assigned to selected nodes.",
            "type": "number"
          },
          "doc_values_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "doc_values_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for doc values across all shards assigned to selected nodes.",
            "type": "number"
          },
          "file_sizes": {
            "description": "This object is not populated by the cluster stats API.\nTo get information on segment files, use the node stats API.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices.stats:ShardFileSizeInfo"
            }
          },
          "fixed_bit_set": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "fixed_bit_set_memory_in_bytes": {
            "description": "Total amount of memory, in bytes, used by fixed bit sets across all shards assigned to selected nodes.",
            "type": "number"
          },
          "index_writer_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "index_writer_max_memory_in_bytes": {
            "type": "number"
          },
          "index_writer_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used by all index writers across all shards assigned to selected nodes.",
            "type": "number"
          },
          "max_unsafe_auto_id_timestamp": {
            "description": "Unix timestamp, in milliseconds, of the most recently retried indexing request.",
            "type": "number"
          },
          "memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for segments across all shards assigned to selected nodes.",
            "type": "number"
          },
          "norms_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "norms_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for normalization factors across all shards assigned to selected nodes.",
            "type": "number"
          },
          "points_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "points_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for points across all shards assigned to selected nodes.",
            "type": "number"
          },
          "stored_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "stored_fields_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for stored fields across all shards assigned to selected nodes.",
            "type": "number"
          },
          "terms_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for terms across all shards assigned to selected nodes.",
            "type": "number"
          },
          "terms_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "term_vectory_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "term_vectors_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for term vectors across all shards assigned to selected nodes.",
            "type": "number"
          },
          "version_map_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "version_map_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used by all version maps across all shards assigned to selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "count",
          "doc_values_memory_in_bytes",
          "file_sizes",
          "fixed_bit_set_memory_in_bytes",
          "index_writer_memory_in_bytes",
          "max_unsafe_auto_id_timestamp",
          "memory_in_bytes",
          "norms_memory_in_bytes",
          "points_memory_in_bytes",
          "stored_fields_memory_in_bytes",
          "terms_memory_in_bytes",
          "term_vectors_memory_in_bytes",
          "version_map_memory_in_bytes"
        ]
      },
      "indices.stats:ShardFileSizeInfo": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "size_in_bytes": {
            "type": "number"
          },
          "min_size_in_bytes": {
            "type": "number"
          },
          "max_size_in_bytes": {
            "type": "number"
          },
          "average_size_in_bytes": {
            "type": "number"
          },
          "count": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "size_in_bytes"
        ]
      },
      "cluster.stats:ClusterIndicesShards": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/cluster.stats:ClusterIndicesShardsIndex"
          },
          "primaries": {
            "description": "Number of primary shards assigned to selected nodes.",
            "type": "number"
          },
          "replication": {
            "description": "Ratio of replica shards to primary shards across all selected nodes.",
            "type": "number"
          },
          "total": {
            "description": "Total number of shards assigned to selected nodes.",
            "type": "number"
          }
        }
      },
      "cluster.stats:ClusterIndicesShardsIndex": {
        "type": "object",
        "properties": {
          "primaries": {
            "$ref": "#/components/schemas/cluster.stats:ClusterShardMetrics"
          },
          "replication": {
            "$ref": "#/components/schemas/cluster.stats:ClusterShardMetrics"
          },
          "shards": {
            "$ref": "#/components/schemas/cluster.stats:ClusterShardMetrics"
          }
        },
        "required": [
          "primaries",
          "replication",
          "shards"
        ]
      },
      "cluster.stats:ClusterShardMetrics": {
        "type": "object",
        "properties": {
          "avg": {
            "description": "Mean number of shards in an index, counting only shards assigned to selected nodes.",
            "type": "number"
          },
          "max": {
            "description": "Maximum number of shards in an index, counting only shards assigned to selected nodes.",
            "type": "number"
          },
          "min": {
            "description": "Minimum number of shards in an index, counting only shards assigned to selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "avg",
          "max",
          "min"
        ]
      },
      "_types:StoreStats": {
        "type": "object",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size_in_bytes": {
            "description": "Total size, in bytes, of all shards assigned to selected nodes.",
            "type": "number"
          },
          "reserved": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "reserved_in_bytes": {
            "description": "A prediction, in bytes, of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities.",
            "type": "number"
          },
          "total_data_set_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_data_set_size_in_bytes": {
            "description": "Total data set size, in bytes, of all shards assigned to selected nodes.\nThis includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices.",
            "type": "number"
          }
        },
        "required": [
          "size_in_bytes",
          "reserved_in_bytes"
        ]
      },
      "cluster.stats:FieldTypesMappings": {
        "type": "object",
        "properties": {
          "field_types": {
            "description": "Contains statistics about field data types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "runtime_field_types": {
            "description": "Contains statistics about runtime field data types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:RuntimeFieldTypes"
            }
          },
          "total_field_count": {
            "description": "Total number of fields in all non-system indices.",
            "type": "number"
          },
          "total_deduplicated_field_count": {
            "description": "Total number of fields in all non-system indices, accounting for mapping deduplication.",
            "type": "number"
          },
          "total_deduplicated_mapping_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_deduplicated_mapping_size_in_bytes": {
            "description": "Total size of all mappings, in bytes, after deduplication and compression.",
            "type": "number"
          }
        },
        "required": [
          "field_types"
        ]
      },
      "cluster.stats:RuntimeFieldTypes": {
        "type": "object",
        "properties": {
          "chars_max": {
            "description": "Maximum number of characters for a single runtime field script.",
            "type": "number"
          },
          "chars_total": {
            "description": "Total number of characters for the scripts that define the current runtime field data type.",
            "type": "number"
          },
          "count": {
            "description": "Number of runtime fields mapped to the field data type in selected nodes.",
            "type": "number"
          },
          "doc_max": {
            "description": "Maximum number of accesses to doc_values for a single runtime field script",
            "type": "number"
          },
          "doc_total": {
            "description": "Total number of accesses to doc_values for the scripts that define the current runtime field data type.",
            "type": "number"
          },
          "index_count": {
            "description": "Number of indices containing a mapping of the runtime field data type in selected nodes.",
            "type": "number"
          },
          "lang": {
            "description": "Script languages used for the runtime fields scripts.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "lines_max": {
            "description": "Maximum number of lines for a single runtime field script.",
            "type": "number"
          },
          "lines_total": {
            "description": "Total number of lines for the scripts that define the current runtime field data type.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "scriptless_count": {
            "description": "Number of runtime fields that donâ€™t declare a script.",
            "type": "number"
          },
          "shadowed_count": {
            "description": "Number of runtime fields that shadow an indexed field.",
            "type": "number"
          },
          "source_max": {
            "description": "Maximum number of accesses to _source for a single runtime field script.",
            "type": "number"
          },
          "source_total": {
            "description": "Total number of accesses to _source for the scripts that define the current runtime field data type.",
            "type": "number"
          }
        },
        "required": [
          "chars_max",
          "chars_total",
          "count",
          "doc_max",
          "doc_total",
          "index_count",
          "lang",
          "lines_max",
          "lines_total",
          "name",
          "scriptless_count",
          "shadowed_count",
          "source_max",
          "source_total"
        ]
      },
      "cluster.stats:IndicesVersions": {
        "type": "object",
        "properties": {
          "index_count": {
            "type": "number"
          },
          "primary_shard_count": {
            "type": "number"
          },
          "total_primary_bytes": {
            "type": "number"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "index_count",
          "primary_shard_count",
          "total_primary_bytes",
          "version"
        ]
      },
      "cluster.stats:ClusterNodes": {
        "type": "object",
        "properties": {
          "count": {
            "$ref": "#/components/schemas/cluster.stats:ClusterNodeCount"
          },
          "discovery_types": {
            "description": "Contains statistics about the discovery types used by selected nodes.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "fs": {
            "$ref": "#/components/schemas/cluster.stats:ClusterFileSystem"
          },
          "indexing_pressure": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressure"
          },
          "ingest": {
            "$ref": "#/components/schemas/cluster.stats:ClusterIngest"
          },
          "jvm": {
            "$ref": "#/components/schemas/cluster.stats:ClusterJvm"
          },
          "network_types": {
            "$ref": "#/components/schemas/cluster.stats:ClusterNetworkTypes"
          },
          "os": {
            "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystem"
          },
          "packaging_types": {
            "description": "Contains statistics about Elasticsearch distributions installed on selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:NodePackagingType"
            }
          },
          "plugins": {
            "description": "Contains statistics about installed plugins and modules by selected nodes.\nIf no plugins or modules are installed, this array is empty.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:PluginStats"
            }
          },
          "process": {
            "$ref": "#/components/schemas/cluster.stats:ClusterProcess"
          },
          "versions": {
            "description": "Array of Elasticsearch versions used on selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:VersionString"
            }
          }
        },
        "required": [
          "count",
          "discovery_types",
          "fs",
          "indexing_pressure",
          "ingest",
          "jvm",
          "network_types",
          "os",
          "packaging_types",
          "plugins",
          "process",
          "versions"
        ]
      },
      "cluster.stats:ClusterNodeCount": {
        "type": "object",
        "properties": {
          "coordinating_only": {
            "type": "number"
          },
          "data": {
            "type": "number"
          },
          "data_cold": {
            "type": "number"
          },
          "data_content": {
            "type": "number"
          },
          "data_frozen": {
            "type": "number"
          },
          "data_hot": {
            "type": "number"
          },
          "data_warm": {
            "type": "number"
          },
          "ingest": {
            "type": "number"
          },
          "master": {
            "type": "number"
          },
          "ml": {
            "type": "number"
          },
          "remote_cluster_client": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "transform": {
            "type": "number"
          },
          "voting_only": {
            "type": "number"
          }
        },
        "required": [
          "coordinating_only",
          "data",
          "data_cold",
          "data_content",
          "data_hot",
          "data_warm",
          "ingest",
          "master",
          "ml",
          "remote_cluster_client",
          "total",
          "transform",
          "voting_only"
        ]
      },
      "cluster.stats:ClusterFileSystem": {
        "type": "object",
        "properties": {
          "available_in_bytes": {
            "description": "Total number of bytes available to JVM in file stores across all selected nodes.\nDepending on operating system or process-level restrictions, this number may be less than `nodes.fs.free_in_byes`.\nThis is the actual amount of free disk space the selected Elasticsearch nodes can use.",
            "type": "number"
          },
          "free_in_bytes": {
            "description": "Total number of unallocated bytes in file stores across all selected nodes.",
            "type": "number"
          },
          "total_in_bytes": {
            "description": "Total size, in bytes, of all file stores across all selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "available_in_bytes",
          "free_in_bytes",
          "total_in_bytes"
        ]
      },
      "cluster.stats:IndexingPressure": {
        "type": "object",
        "properties": {
          "memory": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressureMemory"
          }
        },
        "required": [
          "memory"
        ]
      },
      "cluster.stats:IndexingPressureMemory": {
        "type": "object",
        "properties": {
          "current": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressureMemorySummary"
          },
          "limit_in_bytes": {
            "type": "number"
          },
          "total": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressureMemorySummary"
          }
        },
        "required": [
          "current",
          "limit_in_bytes",
          "total"
        ]
      },
      "cluster.stats:IndexingPressureMemorySummary": {
        "type": "object",
        "properties": {
          "all_in_bytes": {
            "type": "number"
          },
          "combined_coordinating_and_primary_in_bytes": {
            "type": "number"
          },
          "coordinating_in_bytes": {
            "type": "number"
          },
          "coordinating_rejections": {
            "type": "number"
          },
          "primary_in_bytes": {
            "type": "number"
          },
          "primary_rejections": {
            "type": "number"
          },
          "replica_in_bytes": {
            "type": "number"
          },
          "replica_rejections": {
            "type": "number"
          }
        },
        "required": [
          "all_in_bytes",
          "combined_coordinating_and_primary_in_bytes",
          "coordinating_in_bytes",
          "primary_in_bytes",
          "replica_in_bytes"
        ]
      },
      "cluster.stats:ClusterIngest": {
        "type": "object",
        "properties": {
          "number_of_pipelines": {
            "type": "number"
          },
          "processor_stats": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.stats:ClusterProcessor"
            }
          }
        },
        "required": [
          "number_of_pipelines",
          "processor_stats"
        ]
      },
      "cluster.stats:ClusterProcessor": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "current": {
            "type": "number"
          },
          "failed": {
            "type": "number"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "count",
          "current",
          "failed",
          "time_in_millis"
        ]
      },
      "cluster.stats:ClusterJvm": {
        "type": "object",
        "properties": {
          "max_uptime_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "mem": {
            "$ref": "#/components/schemas/cluster.stats:ClusterJvmMemory"
          },
          "threads": {
            "description": "Number of active threads in use by JVM across all selected nodes.",
            "type": "number"
          },
          "versions": {
            "description": "Contains statistics about the JVM versions used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterJvmVersion"
            }
          }
        },
        "required": [
          "max_uptime_in_millis",
          "mem",
          "threads",
          "versions"
        ]
      },
      "cluster.stats:ClusterJvmMemory": {
        "type": "object",
        "properties": {
          "heap_max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap across all selected nodes.",
            "type": "number"
          },
          "heap_used_in_bytes": {
            "description": "Memory, in bytes, currently in use by the heap across all selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "heap_max_in_bytes",
          "heap_used_in_bytes"
        ]
      },
      "cluster.stats:ClusterJvmVersion": {
        "type": "object",
        "properties": {
          "bundled_jdk": {
            "description": "Always `true`. All distributions come with a bundled Java Development Kit (JDK).",
            "type": "boolean"
          },
          "count": {
            "description": "Total number of selected nodes using JVM.",
            "type": "number"
          },
          "using_bundled_jdk": {
            "description": "If `true`, a bundled JDK is in use by JVM.",
            "type": "boolean"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "vm_name": {
            "description": "Name of the JVM.",
            "type": "string"
          },
          "vm_vendor": {
            "description": "Vendor of the JVM.",
            "type": "string"
          },
          "vm_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "bundled_jdk",
          "count",
          "using_bundled_jdk",
          "version",
          "vm_name",
          "vm_vendor",
          "vm_version"
        ]
      },
      "cluster.stats:ClusterNetworkTypes": {
        "type": "object",
        "properties": {
          "http_types": {
            "description": "Contains statistics about the HTTP network types used by selected nodes.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "transport_types": {
            "description": "Contains statistics about the transport network types used by selected nodes.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "http_types",
          "transport_types"
        ]
      },
      "cluster.stats:ClusterOperatingSystem": {
        "type": "object",
        "properties": {
          "allocated_processors": {
            "description": "Number of processors used to calculate thread pool size across all selected nodes.\nThis number can be set with the processors setting of a node and defaults to the number of processors reported by the operating system.\nIn both cases, this number will never be larger than 32.",
            "type": "number"
          },
          "architectures": {
            "description": "Contains statistics about processor architectures (for example, x86_64 or aarch64) used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystemArchitecture"
            }
          },
          "available_processors": {
            "description": "Number of processors available to JVM across all selected nodes.",
            "type": "number"
          },
          "mem": {
            "$ref": "#/components/schemas/cluster.stats:OperatingSystemMemoryInfo"
          },
          "names": {
            "description": "Contains statistics about operating systems used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystemName"
            }
          },
          "pretty_names": {
            "description": "Contains statistics about operating systems used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystemPrettyName"
            }
          }
        },
        "required": [
          "allocated_processors",
          "available_processors",
          "mem",
          "names",
          "pretty_names"
        ]
      },
      "cluster.stats:ClusterOperatingSystemArchitecture": {
        "type": "object",
        "properties": {
          "arch": {
            "description": "Name of an architecture used by one or more selected nodes.",
            "type": "string"
          },
          "count": {
            "description": "Number of selected nodes using the architecture.",
            "type": "number"
          }
        },
        "required": [
          "arch",
          "count"
        ]
      },
      "cluster.stats:OperatingSystemMemoryInfo": {
        "type": "object",
        "properties": {
          "adjusted_total_in_bytes": {
            "description": "Total amount, in bytes, of memory across all selected nodes, but using the value specified using the `es.total_memory_bytes` system property instead of measured total memory for those nodes where that system property was set.",
            "type": "number"
          },
          "free_in_bytes": {
            "description": "Amount, in bytes, of free physical memory across all selected nodes.",
            "type": "number"
          },
          "free_percent": {
            "description": "Percentage of free physical memory across all selected nodes.",
            "type": "number"
          },
          "total_in_bytes": {
            "description": "Total amount, in bytes, of physical memory across all selected nodes.",
            "type": "number"
          },
          "used_in_bytes": {
            "description": "Amount, in bytes, of physical memory in use across all selected nodes.",
            "type": "number"
          },
          "used_percent": {
            "description": "Percentage of physical memory in use across all selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "free_in_bytes",
          "free_percent",
          "total_in_bytes",
          "used_in_bytes",
          "used_percent"
        ]
      },
      "cluster.stats:ClusterOperatingSystemName": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of selected nodes using the operating system.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "count",
          "name"
        ]
      },
      "cluster.stats:ClusterOperatingSystemPrettyName": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of selected nodes using the operating system.",
            "type": "number"
          },
          "pretty_name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "count",
          "pretty_name"
        ]
      },
      "cluster.stats:NodePackagingType": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of selected nodes using the distribution flavor and file type.",
            "type": "number"
          },
          "flavor": {
            "description": "Type of Elasticsearch distribution. This is always `default`.",
            "type": "string"
          },
          "type": {
            "description": "File type (such as `tar` or `zip`) used for the distribution package.",
            "type": "string"
          }
        },
        "required": [
          "count",
          "flavor",
          "type"
        ]
      },
      "_types:PluginStats": {
        "type": "object",
        "properties": {
          "classname": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "elasticsearch_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "extended_plugins": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "has_native_controller": {
            "type": "boolean"
          },
          "java_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "licensed": {
            "type": "boolean"
          }
        },
        "required": [
          "classname",
          "description",
          "elasticsearch_version",
          "extended_plugins",
          "has_native_controller",
          "java_version",
          "name",
          "version",
          "licensed"
        ]
      },
      "cluster.stats:ClusterProcess": {
        "type": "object",
        "properties": {
          "cpu": {
            "$ref": "#/components/schemas/cluster.stats:ClusterProcessCpu"
          },
          "open_file_descriptors": {
            "$ref": "#/components/schemas/cluster.stats:ClusterProcessOpenFileDescriptors"
          }
        },
        "required": [
          "cpu",
          "open_file_descriptors"
        ]
      },
      "cluster.stats:ClusterProcessCpu": {
        "type": "object",
        "properties": {
          "percent": {
            "description": "Percentage of CPU used across all selected nodes.\nReturns `-1` if not supported.",
            "type": "number"
          }
        },
        "required": [
          "percent"
        ]
      },
      "cluster.stats:ClusterProcessOpenFileDescriptors": {
        "type": "object",
        "properties": {
          "avg": {
            "description": "Average number of concurrently open file descriptors.\nReturns `-1` if not supported.",
            "type": "number"
          },
          "max": {
            "description": "Maximum number of concurrently open file descriptors allowed across all selected nodes.\nReturns `-1` if not supported.",
            "type": "number"
          },
          "min": {
            "description": "Minimum number of concurrently open file descriptors across all selected nodes.\nReturns -1 if not supported.",
            "type": "number"
          }
        },
        "required": [
          "avg",
          "max",
          "min"
        ]
      },
      "nodes._types:NodesResponseBase": {
        "type": "object",
        "properties": {
          "_nodes": {
            "$ref": "#/components/schemas/_types:NodeStatistics"
          }
        }
      },
      "_types:NodeStatistics": {
        "type": "object",
        "properties": {
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          },
          "total": {
            "description": "Total number of nodes selected by the request.",
            "type": "number"
          },
          "successful": {
            "description": "Number of nodes that responded successfully to the request.",
            "type": "number"
          },
          "failed": {
            "description": "Number of nodes that rejected the request or failed to respond. If this value is not 0, a reason for the rejection or failure is included in the response.",
            "type": "number"
          }
        },
        "required": [
          "total",
          "successful",
          "failed"
        ]
      },
      "_types:Result": {
        "type": "string",
        "enum": [
          "created",
          "updated",
          "deleted",
          "not_found",
          "noop"
        ]
      },
      "connector._types:Connector": {
        "type": "object",
        "properties": {
          "api_key_id": {
            "type": "string"
          },
          "api_key_secret_id": {
            "type": "string"
          },
          "configuration": {
            "$ref": "#/components/schemas/connector._types:ConnectorConfiguration"
          },
          "custom_scheduling": {
            "$ref": "#/components/schemas/connector._types:ConnectorCustomScheduling"
          },
          "description": {
            "type": "string"
          },
          "error": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "features": {
            "$ref": "#/components/schemas/connector._types:ConnectorFeatures"
          },
          "filtering": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/connector._types:FilteringConfig"
            }
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index_name": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "is_native": {
            "type": "boolean"
          },
          "language": {
            "type": "string"
          },
          "last_access_control_sync_error": {
            "type": "string"
          },
          "last_access_control_sync_scheduled_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_access_control_sync_status": {
            "$ref": "#/components/schemas/connector._types:SyncStatus"
          },
          "last_deleted_document_count": {
            "type": "number"
          },
          "last_incremental_sync_scheduled_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_indexed_document_count": {
            "type": "number"
          },
          "last_seen": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_sync_error": {
            "type": "string"
          },
          "last_sync_scheduled_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_sync_status": {
            "$ref": "#/components/schemas/connector._types:SyncStatus"
          },
          "last_synced": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "name": {
            "type": "string"
          },
          "pipeline": {
            "$ref": "#/components/schemas/connector._types:IngestPipelineParams"
          },
          "scheduling": {
            "$ref": "#/components/schemas/connector._types:SchedulingConfiguration"
          },
          "service_type": {
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/connector._types:ConnectorStatus"
          },
          "sync_cursor": {
            "type": "object"
          },
          "sync_now": {
            "type": "boolean"
          }
        },
        "required": [
          "configuration",
          "custom_scheduling",
          "filtering",
          "is_native",
          "scheduling",
          "status",
          "sync_now"
        ]
      },
      "connector._types:ConnectorConfiguration": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/connector._types:ConnectorConfigProperties"
        }
      },
      "connector._types:ConnectorConfigProperties": {
        "type": "object",
        "properties": {
          "category": {
            "type": "string"
          },
          "default_value": {
            "$ref": "#/components/schemas/_types:ScalarValue"
          },
          "depends_on": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/connector._types:Dependency"
            }
          },
          "display": {
            "$ref": "#/components/schemas/connector._types:DisplayType"
          },
          "label": {
            "type": "string"
          },
          "options": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/connector._types:SelectOption"
            }
          },
          "order": {
            "type": "number"
          },
          "placeholder": {
            "type": "string"
          },
          "required": {
            "type": "boolean"
          },
          "sensitive": {
            "type": "boolean"
          },
          "tooltip": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "type": {
            "$ref": "#/components/schemas/connector._types:ConnectorFieldType"
          },
          "ui_restrictions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "validations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/connector._types:Validation"
            }
          },
          "value": {
            "type": "object"
          }
        },
        "required": [
          "default_value",
          "depends_on",
          "display",
          "label",
          "options",
          "required",
          "sensitive",
          "value"
        ]
      },
      "_types:ScalarValue": {
        "description": "A scalar value.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "number"
          },
          {
            "type": "string"
          },
          {
            "type": "boolean"
          },
          {
            "nullable": true,
            "type": "string"
          }
        ]
      },
      "connector._types:Dependency": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/_types:ScalarValue"
          }
        },
        "required": [
          "field",
          "value"
        ]
      },
      "connector._types:DisplayType": {
        "type": "string",
        "enum": [
          "textbox",
          "textarea",
          "numeric",
          "toggle",
          "dropdown"
        ]
      },
      "connector._types:SelectOption": {
        "type": "object",
        "properties": {
          "label": {
            "type": "string"
          },
          "value": {
            "$ref": "#/components/schemas/_types:ScalarValue"
          }
        },
        "required": [
          "label",
          "value"
        ]
      },
      "connector._types:ConnectorFieldType": {
        "type": "string",
        "enum": [
          "str",
          "int",
          "list",
          "bool"
        ]
      },
      "connector._types:Validation": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/connector._types:LessThanValidation"
          },
          {
            "$ref": "#/components/schemas/connector._types:GreaterThanValidation"
          },
          {
            "$ref": "#/components/schemas/connector._types:ListTypeValidation"
          },
          {
            "$ref": "#/components/schemas/connector._types:IncludedInValidation"
          },
          {
            "$ref": "#/components/schemas/connector._types:RegexValidation"
          }
        ]
      },
      "connector._types:LessThanValidation": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "less_than"
            ]
          },
          "constraint": {
            "type": "number"
          }
        },
        "required": [
          "type",
          "constraint"
        ]
      },
      "connector._types:GreaterThanValidation": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "greater_than"
            ]
          },
          "constraint": {
            "type": "number"
          }
        },
        "required": [
          "type",
          "constraint"
        ]
      },
      "connector._types:ListTypeValidation": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "list_type"
            ]
          },
          "constraint": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "constraint"
        ]
      },
      "connector._types:IncludedInValidation": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "included_in"
            ]
          },
          "constraint": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ScalarValue"
            }
          }
        },
        "required": [
          "type",
          "constraint"
        ]
      },
      "connector._types:RegexValidation": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "regex"
            ]
          },
          "constraint": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "constraint"
        ]
      },
      "connector._types:ConnectorCustomScheduling": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/connector._types:CustomScheduling"
        }
      },
      "connector._types:CustomScheduling": {
        "type": "object",
        "properties": {
          "configuration_overrides": {
            "$ref": "#/components/schemas/connector._types:CustomSchedulingConfigurationOverrides"
          },
          "enabled": {
            "type": "boolean"
          },
          "interval": {
            "type": "string"
          },
          "last_synced": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "configuration_overrides",
          "enabled",
          "interval",
          "name"
        ]
      },
      "connector._types:CustomSchedulingConfigurationOverrides": {
        "type": "object",
        "properties": {
          "max_crawl_depth": {
            "type": "number"
          },
          "sitemap_discovery_disabled": {
            "type": "boolean"
          },
          "domain_allowlist": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "sitemap_urls": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "seed_urls": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "connector._types:ConnectorFeatures": {
        "type": "object",
        "properties": {
          "document_level_security": {
            "$ref": "#/components/schemas/connector._types:FeatureEnabled"
          },
          "incremental_sync": {
            "$ref": "#/components/schemas/connector._types:FeatureEnabled"
          },
          "native_connector_api_keys": {
            "$ref": "#/components/schemas/connector._types:FeatureEnabled"
          },
          "sync_rules": {
            "$ref": "#/components/schemas/connector._types:SyncRulesFeature"
          }
        }
      },
      "connector._types:FeatureEnabled": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "connector._types:SyncRulesFeature": {
        "type": "object",
        "properties": {
          "advanced": {
            "$ref": "#/components/schemas/connector._types:FeatureEnabled"
          },
          "basic": {
            "$ref": "#/components/schemas/connector._types:FeatureEnabled"
          }
        }
      },
      "connector._types:FilteringConfig": {
        "type": "object",
        "properties": {
          "active": {
            "$ref": "#/components/schemas/connector._types:FilteringRules"
          },
          "domain": {
            "type": "string"
          },
          "draft": {
            "$ref": "#/components/schemas/connector._types:FilteringRules"
          }
        },
        "required": [
          "active",
          "draft"
        ]
      },
      "connector._types:FilteringRules": {
        "type": "object",
        "properties": {
          "advanced_snippet": {
            "$ref": "#/components/schemas/connector._types:FilteringAdvancedSnippet"
          },
          "rules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/connector._types:FilteringRule"
            }
          },
          "validation": {
            "$ref": "#/components/schemas/connector._types:FilteringRulesValidation"
          }
        },
        "required": [
          "advanced_snippet",
          "rules",
          "validation"
        ]
      },
      "connector._types:FilteringAdvancedSnippet": {
        "type": "object",
        "properties": {
          "created_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "updated_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "value": {
            "type": "object"
          }
        },
        "required": [
          "value"
        ]
      },
      "connector._types:FilteringRule": {
        "type": "object",
        "properties": {
          "created_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "order": {
            "type": "number"
          },
          "policy": {
            "$ref": "#/components/schemas/connector._types:FilteringPolicy"
          },
          "rule": {
            "$ref": "#/components/schemas/connector._types:FilteringRuleRule"
          },
          "updated_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "field",
          "id",
          "order",
          "policy",
          "rule",
          "value"
        ]
      },
      "connector._types:FilteringPolicy": {
        "type": "string",
        "enum": [
          "exclude",
          "include"
        ]
      },
      "connector._types:FilteringRuleRule": {
        "type": "string",
        "enum": [
          "contains",
          "ends_with",
          "equals",
          "regex",
          "starts_with",
          ">",
          "<"
        ]
      },
      "connector._types:FilteringRulesValidation": {
        "type": "object",
        "properties": {
          "errors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/connector._types:FilteringValidation"
            }
          },
          "state": {
            "$ref": "#/components/schemas/connector._types:FilteringValidationState"
          }
        },
        "required": [
          "errors",
          "state"
        ]
      },
      "connector._types:FilteringValidation": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "messages": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "ids",
          "messages"
        ]
      },
      "connector._types:FilteringValidationState": {
        "type": "string",
        "enum": [
          "edited",
          "invalid",
          "valid"
        ]
      },
      "connector._types:SyncStatus": {
        "type": "string",
        "enum": [
          "canceling",
          "canceled",
          "completed",
          "error",
          "in_progress",
          "pending",
          "suspended"
        ]
      },
      "connector._types:IngestPipelineParams": {
        "type": "object",
        "properties": {
          "extract_binary_content": {
            "type": "boolean"
          },
          "name": {
            "type": "string"
          },
          "reduce_whitespace": {
            "type": "boolean"
          },
          "run_ml_inference": {
            "type": "boolean"
          }
        },
        "required": [
          "extract_binary_content",
          "name",
          "reduce_whitespace",
          "run_ml_inference"
        ]
      },
      "connector._types:SchedulingConfiguration": {
        "type": "object",
        "properties": {
          "access_control": {
            "$ref": "#/components/schemas/connector._types:ConnectorScheduling"
          },
          "full": {
            "$ref": "#/components/schemas/connector._types:ConnectorScheduling"
          },
          "incremental": {
            "$ref": "#/components/schemas/connector._types:ConnectorScheduling"
          }
        }
      },
      "connector._types:ConnectorScheduling": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "interval": {
            "description": "The interval is expressed using the crontab syntax",
            "type": "string"
          }
        },
        "required": [
          "enabled",
          "interval"
        ]
      },
      "connector._types:ConnectorStatus": {
        "type": "string",
        "enum": [
          "created",
          "needs_configuration",
          "configured",
          "connected",
          "error"
        ]
      },
      "connector._types:ConnectorSyncJob": {
        "type": "object",
        "properties": {
          "cancelation_requested_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "canceled_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "completed_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "connector": {
            "$ref": "#/components/schemas/connector._types:SyncJobConnectorReference"
          },
          "created_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "deleted_document_count": {
            "type": "number"
          },
          "error": {
            "type": "string"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "indexed_document_count": {
            "type": "number"
          },
          "indexed_document_volume": {
            "type": "number"
          },
          "job_type": {
            "$ref": "#/components/schemas/connector._types:SyncJobType"
          },
          "last_seen": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "started_at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "status": {
            "$ref": "#/components/schemas/connector._types:SyncStatus"
          },
          "total_document_count": {
            "type": "number"
          },
          "trigger_method": {
            "$ref": "#/components/schemas/connector._types:SyncJobTriggerMethod"
          },
          "worker_hostname": {
            "type": "string"
          }
        },
        "required": [
          "connector",
          "created_at",
          "deleted_document_count",
          "id",
          "indexed_document_count",
          "indexed_document_volume",
          "job_type",
          "metadata",
          "status",
          "total_document_count",
          "trigger_method"
        ]
      },
      "connector._types:SyncJobConnectorReference": {
        "type": "object",
        "properties": {
          "configuration": {
            "$ref": "#/components/schemas/connector._types:ConnectorConfiguration"
          },
          "filtering": {
            "$ref": "#/components/schemas/connector._types:FilteringRules"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index_name": {
            "type": "string"
          },
          "language": {
            "type": "string"
          },
          "pipeline": {
            "$ref": "#/components/schemas/connector._types:IngestPipelineParams"
          },
          "service_type": {
            "type": "string"
          },
          "sync_cursor": {
            "type": "object"
          }
        },
        "required": [
          "configuration",
          "filtering",
          "id",
          "index_name",
          "service_type"
        ]
      },
      "connector._types:SyncJobType": {
        "type": "string",
        "enum": [
          "full",
          "incremental",
          "access_control"
        ]
      },
      "connector._types:SyncJobTriggerMethod": {
        "type": "string",
        "enum": [
          "on_demand",
          "scheduled"
        ]
      },
      "_types:WriteResponseBase": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_primary_term": {
            "description": "The primary term assigned to the document for the indexing operation.",
            "type": "number"
          },
          "result": {
            "$ref": "#/components/schemas/_types:Result"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "forced_refresh": {
            "type": "boolean"
          }
        },
        "required": [
          "_id",
          "_index",
          "result",
          "_shards",
          "_version"
        ]
      },
      "dangling_indices.list_dangling_indices:DanglingIndex": {
        "type": "object",
        "properties": {
          "index_name": {
            "type": "string"
          },
          "index_uuid": {
            "type": "string"
          },
          "creation_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "node_ids": {
            "$ref": "#/components/schemas/_types:Ids"
          }
        },
        "required": [
          "index_name",
          "index_uuid",
          "creation_date_millis",
          "node_ids"
        ]
      },
      "_types:Conflicts": {
        "type": "string",
        "enum": [
          "abort",
          "proceed"
        ]
      },
      "_types:Slices": {
        "description": "Slices configuration used to parallelize a process.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "$ref": "#/components/schemas/_types:SlicesCalculation"
          }
        ]
      },
      "_types:SlicesCalculation": {
        "type": "string",
        "enum": [
          "auto"
        ]
      },
      "_types:BulkIndexByScrollFailure": {
        "type": "object",
        "properties": {
          "cause": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "status": {
            "type": "number"
          }
        },
        "required": [
          "cause",
          "id",
          "index",
          "status"
        ]
      },
      "_types:Retries": {
        "type": "object",
        "properties": {
          "bulk": {
            "description": "The number of bulk actions retried.",
            "type": "number"
          },
          "search": {
            "description": "The number of search actions retried.",
            "type": "number"
          }
        },
        "required": [
          "bulk",
          "search"
        ]
      },
      "_types:TaskId": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "tasks._types:TaskListResponseBase": {
        "type": "object",
        "properties": {
          "node_failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          },
          "task_failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:TaskFailure"
            }
          },
          "nodes": {
            "description": "Task information grouped by node, if `group_by` was set to `node` (the default).",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/tasks._types:NodeTasks"
            }
          },
          "tasks": {
            "$ref": "#/components/schemas/tasks._types:TaskInfos"
          }
        }
      },
      "_types:TaskFailure": {
        "type": "object",
        "properties": {
          "task_id": {
            "type": "number"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "status": {
            "type": "string"
          },
          "reason": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "task_id",
          "node_id",
          "status",
          "reason"
        ]
      },
      "tasks._types:NodeTasks": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "ip": {
            "$ref": "#/components/schemas/_types:Ip"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "tasks": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/tasks._types:TaskInfo"
            }
          }
        },
        "required": [
          "tasks"
        ]
      },
      "tasks._types:TaskInfo": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string"
          },
          "cancelled": {
            "type": "boolean"
          },
          "cancellable": {
            "type": "boolean"
          },
          "description": {
            "description": "Human readable text that identifies the particular request that the task is performing.\nFor example, it might identify the search request being performed by a search task.\nOther kinds of tasks have different descriptions, like `_reindex` which has the source and the destination, or `_bulk` which just has the number of requests and the destination indices.\nMany requests will have only an empty description because more detailed information about the request is not easily available or particularly helpful in identifying the request.",
            "type": "string"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "id": {
            "type": "number"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "running_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "running_time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "status": {
            "description": "The internal status of the task, which varies from task to task.\nThe format also varies.\nWhile the goal is to keep the status for a particular task consistent from version to version, this is not always possible because sometimes the implementation changes.\nFields might be removed from the status for a particular request so any parsing you do of the status might break in minor releases.",
            "type": "object"
          },
          "type": {
            "type": "string"
          },
          "parent_task_id": {
            "$ref": "#/components/schemas/_types:TaskId"
          }
        },
        "required": [
          "action",
          "cancellable",
          "headers",
          "id",
          "node",
          "running_time_in_nanos",
          "start_time_in_millis",
          "type"
        ]
      },
      "tasks._types:TaskInfos": {
        "oneOf": [
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/tasks._types:TaskInfo"
            }
          },
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/tasks._types:ParentTaskInfo"
            }
          }
        ]
      },
      "tasks._types:ParentTaskInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/tasks._types:TaskInfo"
          },
          {
            "type": "object",
            "properties": {
              "children": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/tasks._types:TaskInfo"
                }
              }
            }
          }
        ]
      },
      "enrich.execute_policy:ExecuteEnrichPolicyStatus": {
        "type": "object",
        "properties": {
          "phase": {
            "$ref": "#/components/schemas/enrich.execute_policy:EnrichPolicyPhase"
          },
          "step": {
            "type": "string"
          }
        },
        "required": [
          "phase"
        ]
      },
      "enrich.execute_policy:EnrichPolicyPhase": {
        "type": "string",
        "enum": [
          "SCHEDULED",
          "RUNNING",
          "COMPLETE",
          "FAILED",
          "CANCELLED"
        ]
      },
      "enrich._types:Summary": {
        "type": "object",
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/enrich._types:Policy"
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        },
        "required": [
          "config"
        ]
      },
      "enrich._types:Policy": {
        "type": "object",
        "properties": {
          "enrich_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "match_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "elasticsearch_version": {
            "type": "string"
          }
        },
        "required": [
          "enrich_fields",
          "indices",
          "match_field"
        ]
      },
      "enrich.stats:CoordinatorStats": {
        "type": "object",
        "properties": {
          "executed_searches_total": {
            "type": "number"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "queue_size": {
            "type": "number"
          },
          "remote_requests_current": {
            "type": "number"
          },
          "remote_requests_total": {
            "type": "number"
          }
        },
        "required": [
          "executed_searches_total",
          "node_id",
          "queue_size",
          "remote_requests_current",
          "remote_requests_total"
        ]
      },
      "enrich.stats:ExecutingPolicy": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "task": {
            "$ref": "#/components/schemas/tasks._types:TaskInfo"
          }
        },
        "required": [
          "name",
          "task"
        ]
      },
      "enrich.stats:CacheStats": {
        "type": "object",
        "properties": {
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "count": {
            "type": "number"
          },
          "hits": {
            "type": "number"
          },
          "hits_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "misses": {
            "type": "number"
          },
          "misses_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "evictions": {
            "type": "number"
          },
          "size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "node_id",
          "count",
          "hits",
          "hits_time_in_millis",
          "misses",
          "misses_time_in_millis",
          "evictions",
          "size_in_bytes"
        ]
      },
      "eql._types:EqlSearchResponseBase": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "is_partial": {
            "description": "If true, the response does not contain complete search results.",
            "type": "boolean"
          },
          "is_running": {
            "description": "If true, the search request is still executing.",
            "type": "boolean"
          },
          "took": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "timed_out": {
            "description": "If true, the request timed out before completion.",
            "type": "boolean"
          },
          "hits": {
            "$ref": "#/components/schemas/eql._types:EqlHits"
          }
        },
        "required": [
          "hits"
        ]
      },
      "eql._types:EqlHits": {
        "type": "object",
        "properties": {
          "total": {
            "$ref": "#/components/schemas/_global.search._types:TotalHits"
          },
          "events": {
            "description": "Contains events matching the query. Each object represents a matching event.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/eql._types:HitsEvent"
            }
          },
          "sequences": {
            "description": "Contains event sequences matching the query. Each object represents a matching sequence. This parameter is only returned for EQL queries containing a sequence.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/eql._types:HitsSequence"
            }
          }
        }
      },
      "eql._types:HitsEvent": {
        "type": "object",
        "properties": {
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_source": {
            "description": "Original JSON body passed for the event at index time.",
            "type": "object"
          },
          "missing": {
            "description": "Set to `true` for events in a timespan-constrained sequence that do not meet a given condition.",
            "type": "boolean"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          }
        },
        "required": [
          "_index",
          "_id",
          "_source"
        ]
      },
      "eql._types:HitsSequence": {
        "type": "object",
        "properties": {
          "events": {
            "description": "Contains events matching the query. Each object represents a matching event.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/eql._types:HitsEvent"
            }
          },
          "join_keys": {
            "description": "Shared field values used to constrain matches in the sequence. These are defined using the by keyword in the EQL query syntax.",
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "required": [
          "events"
        ]
      },
      "eql.search:ResultPosition": {
        "type": "string",
        "enum": [
          "tail",
          "head"
        ]
      },
      "esql.query:EsqlFormat": {
        "type": "string",
        "enum": [
          "csv",
          "json",
          "tsv",
          "txt",
          "yaml",
          "cbor",
          "smile",
          "arrow"
        ]
      },
      "esql._types:TableValuesContainer": {
        "type": "object",
        "properties": {
          "integer": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/esql._types:TableValuesIntegerValue"
            }
          },
          "keyword": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/esql._types:TableValuesKeywordValue"
            }
          },
          "long": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/esql._types:TableValuesLongValue"
            }
          },
          "double": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/esql._types:TableValuesLongDouble"
            }
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "esql._types:TableValuesIntegerValue": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        ]
      },
      "esql._types:TableValuesKeywordValue": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "esql._types:TableValuesLongValue": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        ]
      },
      "esql._types:TableValuesLongDouble": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        ]
      },
      "_types:EsqlResult": {
        "type": "object"
      },
      "_types:InlineGet": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "found": {
            "type": "boolean"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_primary_term": {
            "type": "number"
          },
          "_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_source": {
            "type": "object"
          }
        },
        "required": [
          "found"
        ]
      },
      "features._types:Feature": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "description": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "description"
        ]
      },
      "_global.field_caps:FieldCapability": {
        "type": "object",
        "properties": {
          "aggregatable": {
            "description": "Whether this field can be aggregated on all indices.",
            "type": "boolean"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "non_aggregatable_indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "non_searchable_indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "searchable": {
            "description": "Whether this field is indexed for search on all indices.",
            "type": "boolean"
          },
          "type": {
            "type": "string"
          },
          "metadata_field": {
            "description": "Whether this field is registered as a metadata field.",
            "type": "boolean"
          },
          "time_series_dimension": {
            "description": "Whether this field is used as a time series dimension.",
            "x-state": "Technical preview",
            "type": "boolean"
          },
          "time_series_metric": {
            "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
          },
          "non_dimension_indices": {
            "description": "If this list is present in response then some indices have the\nfield marked as a dimension and other indices, the ones in this list, do not.",
            "x-state": "Technical preview",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "metric_conflicts_indices": {
            "description": "The list of indices where this field is present if these indices\ndonâ€™t have the same `time_series_metric` value for this field.",
            "x-state": "Technical preview",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          }
        },
        "required": [
          "aggregatable",
          "searchable",
          "type"
        ]
      },
      "_types:IndexAlias": {
        "type": "string"
      },
      "fleet._types:Checkpoint": {
        "type": "number"
      },
      "_global.msearch:RequestItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.msearch:MultisearchHeader"
          },
          {
            "$ref": "#/components/schemas/_global.msearch:MultisearchBody"
          }
        ]
      },
      "_global.msearch:MultisearchHeader": {
        "type": "object",
        "properties": {
          "allow_no_indices": {
            "type": "boolean"
          },
          "expand_wildcards": {
            "$ref": "#/components/schemas/_types:ExpandWildcards"
          },
          "ignore_unavailable": {
            "type": "boolean"
          },
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "preference": {
            "type": "string"
          },
          "request_cache": {
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "search_type": {
            "$ref": "#/components/schemas/_types:SearchType"
          },
          "ccs_minimize_roundtrips": {
            "type": "boolean"
          },
          "allow_partial_search_results": {
            "type": "boolean"
          },
          "ignore_throttled": {
            "type": "boolean"
          }
        }
      },
      "_global.msearch:MultisearchBody": {
        "type": "object",
        "properties": {
          "aggregations": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations.html"
            },
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "collapse": {
            "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "explain": {
            "description": "If true, returns detailed information about score computation as part of a hit.",
            "type": "boolean"
          },
          "ext": {
            "description": "Configuration of search extensions defined by Elasticsearch plugins.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "stored_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "docvalue_fields": {
            "description": "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
            }
          },
          "knn": {
            "description": "Defines the approximate kNN search to run.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:KnnSearch"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:KnnSearch"
                }
              }
            ]
          },
          "from": {
            "description": "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.",
            "type": "number"
          },
          "highlight": {
            "$ref": "#/components/schemas/_global.search._types:Highlight"
          },
          "indices_boost": {
            "description": "Boosts the _score of documents from specified indices.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            }
          },
          "min_score": {
            "description": "Minimum _score for matching documents. Documents with a lower _score are\nnot included in the search results.",
            "type": "number"
          },
          "post_filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "profile": {
            "type": "boolean"
          },
          "rescore": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_global.search._types:Rescore"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_global.search._types:Rescore"
                }
              }
            ]
          },
          "script_fields": {
            "description": "Retrieve a script evaluation (based on different fields) for each hit.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "search_after": {
            "$ref": "#/components/schemas/_types:SortResults"
          },
          "size": {
            "description": "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.",
            "type": "number"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:Sort"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "fields": {
            "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
            }
          },
          "terminate_after": {
            "description": "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.",
            "type": "number"
          },
          "stats": {
            "description": "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "timeout": {
            "description": "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
            "type": "string"
          },
          "track_scores": {
            "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
            "type": "boolean"
          },
          "track_total_hits": {
            "$ref": "#/components/schemas/_global.search._types:TrackHits"
          },
          "version": {
            "description": "If true, returns document version as part of a hit.",
            "type": "boolean"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "seq_no_primary_term": {
            "description": "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.",
            "type": "boolean"
          },
          "pit": {
            "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
          },
          "suggest": {
            "$ref": "#/components/schemas/_global.search._types:Suggester"
          }
        }
      },
      "_global.msearch:ResponseItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.msearch:MultiSearchItem"
          },
          {
            "$ref": "#/components/schemas/_types:ErrorResponseBase"
          }
        ]
      },
      "_global.msearch:MultiSearchItem": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search:ResponseBody"
          },
          {
            "type": "object",
            "properties": {
              "status": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_global.search:ResponseBody": {
        "type": "object",
        "properties": {
          "took": {
            "description": "The number of milliseconds it took Elasticsearch to run the request.\nThis value is calculated by measuring the time elapsed between receipt of a request on the coordinating node and the time at which the coordinating node is ready to send the response.\nIt includes:\n\n* Communication time between the coordinating node and data nodes\n* Time the request spends in the search thread pool, queued for execution\n* Actual run time\n\nIt does not include:\n\n* Time needed to send the request to Elasticsearch\n* Time needed to serialize the JSON response\n* Time needed to send the response to a client",
            "type": "number"
          },
          "timed_out": {
            "description": "If `true`, the request timed out before completion; returned results may be partial or empty.",
            "type": "boolean"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "hits": {
            "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
          },
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:Aggregate"
            }
          },
          "_clusters": {
            "$ref": "#/components/schemas/_types:ClusterStatistics"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "max_score": {
            "type": "number"
          },
          "num_reduce_phases": {
            "type": "number"
          },
          "profile": {
            "$ref": "#/components/schemas/_global.search._types:Profile"
          },
          "pit_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_scroll_id": {
            "$ref": "#/components/schemas/_types:ScrollId"
          },
          "suggest": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.search._types:Suggest"
              }
            }
          },
          "terminated_early": {
            "type": "boolean"
          }
        },
        "required": [
          "took",
          "timed_out",
          "_shards",
          "hits"
        ]
      },
      "_types:ErrorResponseBase": {
        "type": "object",
        "properties": {
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "status": {
            "type": "number"
          }
        },
        "required": [
          "error",
          "status"
        ]
      },
      "_global.get:GetResult": {
        "type": "object",
        "properties": {
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "fields": {
            "description": "If the `stored_fields` parameter is set to `true` and `found` is `true`, it contains the document fields stored in the index.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "_ignored": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "found": {
            "description": "Indicates whether the document exists.",
            "type": "boolean"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_primary_term": {
            "description": "The primary term assigned to the document for the indexing operation.",
            "type": "number"
          },
          "_routing": {
            "description": "The explicit routing, if set.",
            "type": "string"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_source": {
            "description": "If `found` is `true`, it contains the document data formatted in JSON.\nIf the `_source` parameter is set to `false` or the `stored_fields` parameter is set to `true`, it is excluded.",
            "type": "object"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "_index",
          "found",
          "_id"
        ]
      },
      "_types:StoredScript": {
        "type": "object",
        "properties": {
          "lang": {
            "$ref": "#/components/schemas/_types:ScriptLanguage"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "source": {
            "description": "The script source.\nFor search templates, an object containing the search template.",
            "type": "string"
          }
        },
        "required": [
          "lang",
          "source"
        ]
      },
      "_global.get_script_context:Context": {
        "type": "object",
        "properties": {
          "methods": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.get_script_context:ContextMethod"
            }
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "methods",
          "name"
        ]
      },
      "_global.get_script_context:ContextMethod": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "return_type": {
            "type": "string"
          },
          "params": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.get_script_context:ContextMethodParam"
            }
          }
        },
        "required": [
          "name",
          "return_type",
          "params"
        ]
      },
      "_global.get_script_context:ContextMethodParam": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "_global.get_script_languages:LanguageContext": {
        "type": "object",
        "properties": {
          "contexts": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "language": {
            "$ref": "#/components/schemas/_types:ScriptLanguage"
          }
        },
        "required": [
          "contexts",
          "language"
        ]
      },
      "graph._types:Hop": {
        "type": "object",
        "properties": {
          "connections": {
            "$ref": "#/components/schemas/graph._types:Hop"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "vertices": {
            "description": "Contains the fields you are interested in.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/graph._types:VertexDefinition"
            }
          }
        },
        "required": [
          "query",
          "vertices"
        ]
      },
      "graph._types:VertexDefinition": {
        "type": "object",
        "properties": {
          "exclude": {
            "description": "Prevents the specified terms from being included in the results.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "include": {
            "description": "Identifies the terms of interest that form the starting points from which you want to spider out.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/graph._types:VertexInclude"
            }
          },
          "min_doc_count": {
            "description": "Specifies how many documents must contain a pair of terms before it is considered to be a useful connection.\nThis setting acts as a certainty threshold.",
            "type": "number"
          },
          "shard_min_doc_count": {
            "description": "Controls how many documents on a particular shard have to contain a pair of terms before the connection is returned for global consideration.",
            "type": "number"
          },
          "size": {
            "description": "Specifies the maximum number of vertex terms returned for each field.",
            "type": "number"
          }
        },
        "required": [
          "field"
        ]
      },
      "graph._types:VertexInclude": {
        "type": "object",
        "properties": {
          "boost": {
            "type": "number"
          },
          "term": {
            "type": "string"
          }
        },
        "required": [
          "boost",
          "term"
        ]
      },
      "graph._types:ExploreControls": {
        "type": "object",
        "properties": {
          "sample_diversity": {
            "$ref": "#/components/schemas/graph._types:SampleDiversity"
          },
          "sample_size": {
            "description": "Each hop considers a sample of the best-matching documents on each shard.\nUsing samples improves the speed of execution and keeps exploration focused on meaningfully-connected terms.\nVery small values (less than 50) might not provide sufficient weight-of-evidence to identify significant connections between terms.\nVery large sample sizes can dilute the quality of the results and increase execution times.",
            "type": "number"
          },
          "timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "use_significance": {
            "description": "Filters associated terms so only those that are significantly associated with your query are included.",
            "type": "boolean"
          }
        },
        "required": [
          "use_significance"
        ]
      },
      "graph._types:SampleDiversity": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "max_docs_per_value": {
            "type": "number"
          }
        },
        "required": [
          "field",
          "max_docs_per_value"
        ]
      },
      "graph._types:Connection": {
        "type": "object",
        "properties": {
          "doc_count": {
            "type": "number"
          },
          "source": {
            "type": "number"
          },
          "target": {
            "type": "number"
          },
          "weight": {
            "type": "number"
          }
        },
        "required": [
          "doc_count",
          "source",
          "target",
          "weight"
        ]
      },
      "graph._types:Vertex": {
        "type": "object",
        "properties": {
          "depth": {
            "type": "number"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "term": {
            "type": "string"
          },
          "weight": {
            "type": "number"
          }
        },
        "required": [
          "depth",
          "field",
          "term",
          "weight"
        ]
      },
      "_global.health_report:Indicators": {
        "type": "object",
        "properties": {
          "master_is_stable": {
            "$ref": "#/components/schemas/_global.health_report:MasterIsStableIndicator"
          },
          "shards_availability": {
            "$ref": "#/components/schemas/_global.health_report:ShardsAvailabilityIndicator"
          },
          "disk": {
            "$ref": "#/components/schemas/_global.health_report:DiskIndicator"
          },
          "repository_integrity": {
            "$ref": "#/components/schemas/_global.health_report:RepositoryIntegrityIndicator"
          },
          "data_stream_lifecycle": {
            "$ref": "#/components/schemas/_global.health_report:DataStreamLifecycleIndicator"
          },
          "ilm": {
            "$ref": "#/components/schemas/_global.health_report:IlmIndicator"
          },
          "slm": {
            "$ref": "#/components/schemas/_global.health_report:SlmIndicator"
          },
          "shards_capacity": {
            "$ref": "#/components/schemas/_global.health_report:ShardsCapacityIndicator"
          }
        }
      },
      "_global.health_report:MasterIsStableIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:MasterIsStableIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:MasterIsStableIndicatorDetails": {
        "type": "object",
        "properties": {
          "current_master": {
            "$ref": "#/components/schemas/_global.health_report:IndicatorNode"
          },
          "recent_masters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:IndicatorNode"
            }
          },
          "exception_fetching_history": {
            "$ref": "#/components/schemas/_global.health_report:MasterIsStableIndicatorExceptionFetchingHistory"
          },
          "cluster_formation": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:MasterIsStableIndicatorClusterFormationNode"
            }
          }
        },
        "required": [
          "current_master",
          "recent_masters"
        ]
      },
      "_global.health_report:IndicatorNode": {
        "type": "object",
        "properties": {
          "name": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "node_id": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "name",
          "node_id"
        ]
      },
      "_global.health_report:MasterIsStableIndicatorExceptionFetchingHistory": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string"
          },
          "stack_trace": {
            "type": "string"
          }
        },
        "required": [
          "message",
          "stack_trace"
        ]
      },
      "_global.health_report:MasterIsStableIndicatorClusterFormationNode": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "node_id": {
            "type": "string"
          },
          "cluster_formation_message": {
            "type": "string"
          }
        },
        "required": [
          "node_id",
          "cluster_formation_message"
        ]
      },
      "_global.health_report:BaseIndicator": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/_global.health_report:IndicatorHealthStatus"
          },
          "symptom": {
            "type": "string"
          },
          "impacts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:Impact"
            }
          },
          "diagnosis": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:Diagnosis"
            }
          }
        },
        "required": [
          "status",
          "symptom"
        ]
      },
      "_global.health_report:IndicatorHealthStatus": {
        "type": "string",
        "enum": [
          "green",
          "yellow",
          "red",
          "unknown"
        ]
      },
      "_global.health_report:Impact": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "id": {
            "type": "string"
          },
          "impact_areas": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:ImpactArea"
            }
          },
          "severity": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "id",
          "impact_areas",
          "severity"
        ]
      },
      "_global.health_report:ImpactArea": {
        "type": "string",
        "enum": [
          "search",
          "ingest",
          "backup",
          "deployment_management"
        ]
      },
      "_global.health_report:Diagnosis": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string"
          },
          "action": {
            "type": "string"
          },
          "affected_resources": {
            "$ref": "#/components/schemas/_global.health_report:DiagnosisAffectedResources"
          },
          "cause": {
            "type": "string"
          },
          "help_url": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "action",
          "affected_resources",
          "cause",
          "help_url"
        ]
      },
      "_global.health_report:DiagnosisAffectedResources": {
        "type": "object",
        "properties": {
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "nodes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:IndicatorNode"
            }
          },
          "slm_policies": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_states": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "snapshot_repositories": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "_global.health_report:ShardsAvailabilityIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:ShardsAvailabilityIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:ShardsAvailabilityIndicatorDetails": {
        "type": "object",
        "properties": {
          "creating_primaries": {
            "type": "number"
          },
          "creating_replicas": {
            "type": "number"
          },
          "initializing_primaries": {
            "type": "number"
          },
          "initializing_replicas": {
            "type": "number"
          },
          "restarting_primaries": {
            "type": "number"
          },
          "restarting_replicas": {
            "type": "number"
          },
          "started_primaries": {
            "type": "number"
          },
          "started_replicas": {
            "type": "number"
          },
          "unassigned_primaries": {
            "type": "number"
          },
          "unassigned_replicas": {
            "type": "number"
          }
        },
        "required": [
          "creating_primaries",
          "creating_replicas",
          "initializing_primaries",
          "initializing_replicas",
          "restarting_primaries",
          "restarting_replicas",
          "started_primaries",
          "started_replicas",
          "unassigned_primaries",
          "unassigned_replicas"
        ]
      },
      "_global.health_report:DiskIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:DiskIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:DiskIndicatorDetails": {
        "type": "object",
        "properties": {
          "indices_with_readonly_block": {
            "type": "number"
          },
          "nodes_with_enough_disk_space": {
            "type": "number"
          },
          "nodes_over_high_watermark": {
            "type": "number"
          },
          "nodes_over_flood_stage_watermark": {
            "type": "number"
          },
          "nodes_with_unknown_disk_status": {
            "type": "number"
          }
        },
        "required": [
          "indices_with_readonly_block",
          "nodes_with_enough_disk_space",
          "nodes_over_high_watermark",
          "nodes_over_flood_stage_watermark",
          "nodes_with_unknown_disk_status"
        ]
      },
      "_global.health_report:RepositoryIntegrityIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:RepositoryIntegrityIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:RepositoryIntegrityIndicatorDetails": {
        "type": "object",
        "properties": {
          "total_repositories": {
            "type": "number"
          },
          "corrupted_repositories": {
            "type": "number"
          },
          "corrupted": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "_global.health_report:DataStreamLifecycleIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:DataStreamLifecycleDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:DataStreamLifecycleDetails": {
        "type": "object",
        "properties": {
          "stagnating_backing_indices_count": {
            "type": "number"
          },
          "total_backing_indices_in_error": {
            "type": "number"
          },
          "stagnating_backing_indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.health_report:StagnatingBackingIndices"
            }
          }
        },
        "required": [
          "stagnating_backing_indices_count",
          "total_backing_indices_in_error"
        ]
      },
      "_global.health_report:StagnatingBackingIndices": {
        "type": "object",
        "properties": {
          "index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "first_occurrence_timestamp": {
            "type": "number"
          },
          "retry_count": {
            "type": "number"
          }
        },
        "required": [
          "index_name",
          "first_occurrence_timestamp",
          "retry_count"
        ]
      },
      "_global.health_report:IlmIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:IlmIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:IlmIndicatorDetails": {
        "type": "object",
        "properties": {
          "ilm_status": {
            "$ref": "#/components/schemas/_types:LifecycleOperationMode"
          },
          "policies": {
            "type": "number"
          },
          "stagnating_indices": {
            "type": "number"
          }
        },
        "required": [
          "ilm_status",
          "policies",
          "stagnating_indices"
        ]
      },
      "_types:LifecycleOperationMode": {
        "type": "string",
        "enum": [
          "RUNNING",
          "STOPPING",
          "STOPPED"
        ]
      },
      "_global.health_report:SlmIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:SlmIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:SlmIndicatorDetails": {
        "type": "object",
        "properties": {
          "slm_status": {
            "$ref": "#/components/schemas/_types:LifecycleOperationMode"
          },
          "policies": {
            "type": "number"
          },
          "unhealthy_policies": {
            "$ref": "#/components/schemas/_global.health_report:SlmIndicatorUnhealthyPolicies"
          }
        },
        "required": [
          "slm_status",
          "policies"
        ]
      },
      "_global.health_report:SlmIndicatorUnhealthyPolicies": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "invocations_since_last_success": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "count"
        ]
      },
      "_global.health_report:ShardsCapacityIndicator": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.health_report:BaseIndicator"
          },
          {
            "type": "object",
            "properties": {
              "details": {
                "$ref": "#/components/schemas/_global.health_report:ShardsCapacityIndicatorDetails"
              }
            }
          }
        ]
      },
      "_global.health_report:ShardsCapacityIndicatorDetails": {
        "type": "object",
        "properties": {
          "data": {
            "$ref": "#/components/schemas/_global.health_report:ShardsCapacityIndicatorTierDetail"
          },
          "frozen": {
            "$ref": "#/components/schemas/_global.health_report:ShardsCapacityIndicatorTierDetail"
          }
        },
        "required": [
          "data",
          "frozen"
        ]
      },
      "_global.health_report:ShardsCapacityIndicatorTierDetail": {
        "type": "object",
        "properties": {
          "max_shards_in_cluster": {
            "type": "number"
          },
          "current_used_shards": {
            "type": "number"
          }
        },
        "required": [
          "max_shards_in_cluster"
        ]
      },
      "ilm.explain_lifecycle:LifecycleExplain": {
        "discriminator": {
          "propertyName": "managed"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/ilm.explain_lifecycle:LifecycleExplainManaged"
          },
          {
            "$ref": "#/components/schemas/ilm.explain_lifecycle:LifecycleExplainUnmanaged"
          }
        ]
      },
      "ilm.explain_lifecycle:LifecycleExplainManaged": {
        "type": "object",
        "properties": {
          "action": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "action_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "action_time_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "failed_step": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "failed_step_retry_count": {
            "type": "number"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "index_creation_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "index_creation_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "is_auto_retryable_error": {
            "type": "boolean"
          },
          "lifecycle_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "lifecycle_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "managed": {
            "type": "string",
            "enum": [
              "true"
            ]
          },
          "phase": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "phase_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "phase_time_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "policy": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "previous_step_info": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "repository_name": {
            "type": "string"
          },
          "snapshot_name": {
            "type": "string"
          },
          "shrink_index_name": {
            "type": "string"
          },
          "step": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "step_info": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "step_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "step_time_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "phase_execution": {
            "$ref": "#/components/schemas/ilm.explain_lifecycle:LifecycleExplainPhaseExecution"
          },
          "time_since_index_creation": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "index",
          "managed"
        ]
      },
      "ilm.explain_lifecycle:LifecycleExplainPhaseExecution": {
        "type": "object",
        "properties": {
          "phase_definition": {
            "$ref": "#/components/schemas/ilm._types:Phase"
          },
          "policy": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "modified_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "policy",
          "version",
          "modified_date_in_millis"
        ]
      },
      "ilm._types:Phase": {
        "type": "object",
        "properties": {
          "actions": {
            "$ref": "#/components/schemas/ilm._types:Actions"
          },
          "min_age": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "ilm._types:Actions": {
        "type": "object",
        "properties": {
          "allocate": {
            "$ref": "#/components/schemas/ilm._types:AllocateAction"
          },
          "delete": {
            "$ref": "#/components/schemas/ilm._types:DeleteAction"
          },
          "downsample": {
            "$ref": "#/components/schemas/ilm._types:DownsampleAction"
          },
          "freeze": {
            "$ref": "#/components/schemas/_types:EmptyObject"
          },
          "forcemerge": {
            "$ref": "#/components/schemas/ilm._types:ForceMergeAction"
          },
          "migrate": {
            "$ref": "#/components/schemas/ilm._types:MigrateAction"
          },
          "readonly": {
            "$ref": "#/components/schemas/_types:EmptyObject"
          },
          "rollover": {
            "$ref": "#/components/schemas/ilm._types:RolloverAction"
          },
          "set_priority": {
            "$ref": "#/components/schemas/ilm._types:SetPriorityAction"
          },
          "searchable_snapshot": {
            "$ref": "#/components/schemas/ilm._types:SearchableSnapshotAction"
          },
          "shrink": {
            "$ref": "#/components/schemas/ilm._types:ShrinkAction"
          },
          "unfollow": {
            "$ref": "#/components/schemas/_types:EmptyObject"
          },
          "wait_for_snapshot": {
            "$ref": "#/components/schemas/ilm._types:WaitForSnapshotAction"
          }
        }
      },
      "ilm._types:AllocateAction": {
        "type": "object",
        "properties": {
          "number_of_replicas": {
            "type": "number"
          },
          "total_shards_per_node": {
            "type": "number"
          },
          "include": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "exclude": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "require": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "ilm._types:DeleteAction": {
        "type": "object",
        "properties": {
          "delete_searchable_snapshot": {
            "type": "boolean"
          }
        }
      },
      "ilm._types:DownsampleAction": {
        "type": "object",
        "properties": {
          "fixed_interval": {
            "$ref": "#/components/schemas/_types:DurationLarge"
          },
          "wait_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "fixed_interval"
        ]
      },
      "ilm._types:ForceMergeAction": {
        "type": "object",
        "properties": {
          "max_num_segments": {
            "type": "number"
          },
          "index_codec": {
            "type": "string"
          }
        },
        "required": [
          "max_num_segments"
        ]
      },
      "ilm._types:MigrateAction": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        }
      },
      "ilm._types:RolloverAction": {
        "type": "object",
        "properties": {
          "max_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_docs": {
            "type": "number"
          },
          "max_primary_shard_docs": {
            "type": "number"
          },
          "min_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "min_docs": {
            "type": "number"
          },
          "min_primary_shard_docs": {
            "type": "number"
          }
        }
      },
      "ilm._types:SetPriorityAction": {
        "type": "object",
        "properties": {
          "priority": {
            "type": "number"
          }
        }
      },
      "ilm._types:SearchableSnapshotAction": {
        "type": "object",
        "properties": {
          "snapshot_repository": {
            "type": "string"
          },
          "force_merge_index": {
            "type": "boolean"
          }
        },
        "required": [
          "snapshot_repository"
        ]
      },
      "ilm._types:ShrinkAction": {
        "type": "object",
        "properties": {
          "number_of_shards": {
            "type": "number"
          },
          "max_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "allow_write_after_shrink": {
            "type": "boolean"
          }
        }
      },
      "ilm._types:WaitForSnapshotAction": {
        "type": "object",
        "properties": {
          "policy": {
            "type": "string"
          }
        },
        "required": [
          "policy"
        ]
      },
      "ilm.explain_lifecycle:LifecycleExplainUnmanaged": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "managed": {
            "type": "string",
            "enum": [
              "false"
            ]
          }
        },
        "required": [
          "index",
          "managed"
        ]
      },
      "ilm.get_lifecycle:Lifecycle": {
        "type": "object",
        "properties": {
          "modified_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "policy": {
            "$ref": "#/components/schemas/ilm._types:Policy"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "modified_date",
          "policy",
          "version"
        ]
      },
      "ilm._types:Policy": {
        "type": "object",
        "properties": {
          "phases": {
            "$ref": "#/components/schemas/ilm._types:Phases"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "phases"
        ]
      },
      "ilm._types:Phases": {
        "type": "object",
        "properties": {
          "cold": {
            "$ref": "#/components/schemas/ilm._types:Phase"
          },
          "delete": {
            "$ref": "#/components/schemas/ilm._types:Phase"
          },
          "frozen": {
            "$ref": "#/components/schemas/ilm._types:Phase"
          },
          "hot": {
            "$ref": "#/components/schemas/ilm._types:Phase"
          },
          "warm": {
            "$ref": "#/components/schemas/ilm._types:Phase"
          }
        }
      },
      "ilm.move_to_step:StepKey": {
        "type": "object",
        "properties": {
          "action": {
            "description": "The optional action to which the index will be moved.",
            "type": "string"
          },
          "name": {
            "description": "The optional step name to which the index will be moved.",
            "type": "string"
          },
          "phase": {
            "type": "string"
          }
        },
        "required": [
          "phase"
        ]
      },
      "_types:OpType": {
        "type": "string",
        "enum": [
          "index",
          "create"
        ]
      },
      "indices.add_block:IndicesBlockOptions": {
        "type": "string",
        "enum": [
          "metadata",
          "read",
          "read_only",
          "write"
        ]
      },
      "indices.add_block:IndicesBlockStatus": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "blocked": {
            "type": "boolean"
          }
        },
        "required": [
          "name",
          "blocked"
        ]
      },
      "indices.analyze:TextToAnalyze": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "indices.analyze:AnalyzeDetail": {
        "type": "object",
        "properties": {
          "analyzer": {
            "$ref": "#/components/schemas/indices.analyze:AnalyzerDetail"
          },
          "charfilters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:CharFilterDetail"
            }
          },
          "custom_analyzer": {
            "type": "boolean"
          },
          "tokenfilters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:TokenDetail"
            }
          },
          "tokenizer": {
            "$ref": "#/components/schemas/indices.analyze:TokenDetail"
          }
        },
        "required": [
          "custom_analyzer"
        ]
      },
      "indices.analyze:AnalyzerDetail": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:ExplainAnalyzeToken"
            }
          }
        },
        "required": [
          "name",
          "tokens"
        ]
      },
      "indices.analyze:ExplainAnalyzeToken": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "string"
          },
          "end_offset": {
            "type": "number"
          },
          "keyword": {
            "type": "boolean"
          },
          "position": {
            "type": "number"
          },
          "positionLength": {
            "type": "number"
          },
          "start_offset": {
            "type": "number"
          },
          "termFrequency": {
            "type": "number"
          },
          "token": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "bytes",
          "end_offset",
          "position",
          "positionLength",
          "start_offset",
          "termFrequency",
          "token",
          "type"
        ]
      },
      "indices.analyze:CharFilterDetail": {
        "type": "object",
        "properties": {
          "filtered_text": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "filtered_text",
          "name"
        ]
      },
      "indices.analyze:TokenDetail": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:ExplainAnalyzeToken"
            }
          }
        },
        "required": [
          "name",
          "tokens"
        ]
      },
      "indices.analyze:AnalyzeToken": {
        "type": "object",
        "properties": {
          "end_offset": {
            "type": "number"
          },
          "position": {
            "type": "number"
          },
          "positionLength": {
            "type": "number"
          },
          "start_offset": {
            "type": "number"
          },
          "token": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "end_offset",
          "position",
          "start_offset",
          "token",
          "type"
        ]
      },
      "_types:ShardsOperationResponseBase": {
        "type": "object",
        "properties": {
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          }
        }
      },
      "indices.close:CloseIndexResult": {
        "type": "object",
        "properties": {
          "closed": {
            "type": "boolean"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices.close:CloseShardResult"
            }
          }
        },
        "required": [
          "closed"
        ]
      },
      "indices.close:CloseShardResult": {
        "type": "object",
        "properties": {
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ShardFailure"
            }
          }
        },
        "required": [
          "failures"
        ]
      },
      "indices.data_streams_stats:DataStreamsStatsItem": {
        "type": "object",
        "properties": {
          "backing_indices": {
            "description": "Current number of backing indices for the data stream.",
            "type": "number"
          },
          "data_stream": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "maximum_timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "store_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "store_size_bytes": {
            "description": "Total size, in bytes, of all shards for the data streamâ€™s backing indices.",
            "type": "number"
          }
        },
        "required": [
          "backing_indices",
          "data_stream",
          "maximum_timestamp",
          "store_size_bytes"
        ]
      },
      "_types:IndicesResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "_shards": {
                "$ref": "#/components/schemas/_types:ShardStatistics"
              }
            }
          }
        ]
      },
      "_types:DataStreamNames": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:DataStreamName"
            }
          }
        ]
      },
      "indices.explain_data_lifecycle:DataStreamLifecycleExplain": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "managed_by_lifecycle": {
            "type": "boolean"
          },
          "index_creation_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time_since_index_creation": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "rollover_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time_since_rollover": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          },
          "generation_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "error": {
            "type": "string"
          }
        },
        "required": [
          "index",
          "managed_by_lifecycle"
        ]
      },
      "indices.field_usage_stats:FieldsUsageBody": {
        "type": "object",
        "properties": {
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          }
        },
        "required": [
          "_shards"
        ]
      },
      "indices.forcemerge._types:ForceMergeResponseBody": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:ShardsOperationResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "task": {
                "description": "task contains a task id returned when wait_for_completion=false,\nyou can use the task_id to get the status of the task at _tasks/<task_id>",
                "type": "string"
              }
            }
          }
        ]
      },
      "indices.get:Features": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/indices.get:Feature"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.get:Feature"
            }
          }
        ]
      },
      "indices.get:Feature": {
        "type": "string",
        "enum": [
          "aliases",
          "mappings",
          "settings"
        ]
      },
      "indices.get_alias:IndexAliases": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:AliasDefinition"
            }
          }
        },
        "required": [
          "aliases"
        ]
      },
      "indices.get_data_lifecycle:DataStreamWithLifecycle": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycle"
          }
        },
        "required": [
          "name"
        ]
      },
      "indices.get_data_lifecycle_stats:DataStreamStats": {
        "type": "object",
        "properties": {
          "backing_indices_in_error": {
            "description": "The count of the backing indices for the data stream.",
            "type": "number"
          },
          "backing_indices_in_total": {
            "description": "The count of the backing indices for the data stream that have encountered an error.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          }
        },
        "required": [
          "backing_indices_in_error",
          "backing_indices_in_total",
          "name"
        ]
      },
      "indices._types:DataStream": {
        "type": "object",
        "properties": {
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "allow_custom_routing": {
            "description": "If `true`, the data stream allows custom routing on write request.",
            "type": "boolean"
          },
          "failure_store": {
            "$ref": "#/components/schemas/indices._types:FailureStore"
          },
          "generation": {
            "description": "Current generation for the data stream. This number acts as a cumulative count of the streamâ€™s rollovers, starting at 1.",
            "type": "number"
          },
          "hidden": {
            "description": "If `true`, the data stream is hidden.",
            "type": "boolean"
          },
          "ilm_policy": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "next_generation_managed_by": {
            "$ref": "#/components/schemas/indices._types:ManagedBy"
          },
          "prefer_ilm": {
            "description": "Indicates if ILM should take precedence over DSL in case both are configured to managed this data stream.",
            "type": "boolean"
          },
          "indices": {
            "description": "Array of objects containing information about the data streamâ€™s backing indices.\nThe last item in this array contains information about the streamâ€™s current write index.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices._types:DataStreamIndex"
            }
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          },
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "replicated": {
            "description": "If `true`, the data stream is created and managed by cross-cluster replication and the local cluster can not write into this data stream or change its mappings.",
            "type": "boolean"
          },
          "rollover_on_write": {
            "description": "If `true`, the next write to this data stream will trigger a rollover first and the document will be indexed in the new backing index. If the rollover fails the indexing request will fail too.",
            "type": "boolean"
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "system": {
            "description": "If `true`, the data stream is created and managed by an Elastic stack component and cannot be modified through normal user interaction.",
            "type": "boolean"
          },
          "template": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "timestamp_field": {
            "$ref": "#/components/schemas/indices._types:DataStreamTimestampField"
          }
        },
        "required": [
          "generation",
          "hidden",
          "next_generation_managed_by",
          "prefer_ilm",
          "indices",
          "name",
          "rollover_on_write",
          "status",
          "template",
          "timestamp_field"
        ]
      },
      "indices._types:FailureStore": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices._types:DataStreamIndex"
            }
          },
          "rollover_on_write": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled",
          "indices",
          "rollover_on_write"
        ]
      },
      "indices._types:DataStreamIndex": {
        "type": "object",
        "properties": {
          "index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "index_uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "ilm_policy": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "managed_by": {
            "$ref": "#/components/schemas/indices._types:ManagedBy"
          },
          "prefer_ilm": {
            "description": "Indicates if ILM should take precedence over DSL in case both are configured to manage this index.",
            "type": "boolean"
          }
        },
        "required": [
          "index_name",
          "index_uuid"
        ]
      },
      "indices._types:ManagedBy": {
        "type": "string",
        "enum": [
          "Index Lifecycle Management",
          "Data stream lifecycle",
          "Unmanaged"
        ]
      },
      "indices._types:DataStreamTimestampField": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "name"
        ]
      },
      "indices.get_field_mapping:TypeFieldMappings": {
        "type": "object",
        "properties": {
          "mappings": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:FieldMapping"
            }
          }
        },
        "required": [
          "mappings"
        ]
      },
      "_types.mapping:FieldMapping": {
        "type": "object",
        "properties": {
          "full_name": {
            "type": "string"
          },
          "mapping": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        },
        "required": [
          "full_name",
          "mapping"
        ]
      },
      "indices.get_index_template:IndexTemplateItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "index_template": {
            "$ref": "#/components/schemas/indices._types:IndexTemplate"
          }
        },
        "required": [
          "name",
          "index_template"
        ]
      },
      "indices._types:IndexTemplate": {
        "type": "object",
        "properties": {
          "index_patterns": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "composed_of": {
            "description": "An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          },
          "template": {
            "$ref": "#/components/schemas/indices._types:IndexTemplateSummary"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "priority": {
            "description": "Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
            "type": "number"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "allow_auto_create": {
            "type": "boolean"
          },
          "data_stream": {
            "$ref": "#/components/schemas/indices._types:IndexTemplateDataStreamConfiguration"
          },
          "deprecated": {
            "description": "Marks this index template as deprecated.\nWhen creating or updating a non-deprecated index template that uses deprecated components,\nElasticsearch will emit a deprecation warning.",
            "type": "boolean"
          },
          "ignore_missing_component_templates": {
            "$ref": "#/components/schemas/_types:Names"
          }
        },
        "required": [
          "index_patterns",
          "composed_of"
        ]
      },
      "indices._types:IndexTemplateSummary": {
        "type": "object",
        "properties": {
          "aliases": {
            "description": "Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          }
        }
      },
      "indices._types:IndexTemplateDataStreamConfiguration": {
        "type": "object",
        "properties": {
          "hidden": {
            "description": "If true, the data stream is hidden.",
            "type": "boolean"
          },
          "allow_custom_routing": {
            "description": "If true, the data stream supports custom routing.",
            "type": "boolean"
          }
        }
      },
      "indices.get_mapping:IndexMappingRecord": {
        "type": "object",
        "properties": {
          "item": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          }
        },
        "required": [
          "mappings"
        ]
      },
      "indices._types:TemplateMapping": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "index_patterns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "order": {
            "type": "number"
          },
          "settings": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "aliases",
          "index_patterns",
          "mappings",
          "order",
          "settings"
        ]
      },
      "indices.modify_data_stream:Action": {
        "type": "object",
        "properties": {
          "add_backing_index": {
            "$ref": "#/components/schemas/indices.modify_data_stream:IndexAndDataStreamAction"
          },
          "remove_backing_index": {
            "$ref": "#/components/schemas/indices.modify_data_stream:IndexAndDataStreamAction"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "indices.modify_data_stream:IndexAndDataStreamAction": {
        "type": "object",
        "properties": {
          "data_stream": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "data_stream",
          "index"
        ]
      },
      "indices.put_index_template:IndexTemplateMapping": {
        "type": "object",
        "properties": {
          "aliases": {
            "description": "Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycle"
          }
        }
      },
      "indices._types:DataStreamVisibility": {
        "type": "object",
        "properties": {
          "hidden": {
            "type": "boolean"
          },
          "allow_custom_routing": {
            "type": "boolean"
          }
        }
      },
      "indices.recovery:RecoveryStatus": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.recovery:ShardRecovery"
            }
          }
        },
        "required": [
          "shards"
        ]
      },
      "indices.recovery:ShardRecovery": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "index": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryIndexStatus"
          },
          "primary": {
            "type": "boolean"
          },
          "source": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryOrigin"
          },
          "stage": {
            "type": "string"
          },
          "start": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryStartStatus"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "stop_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "stop_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "target": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryOrigin"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "translog": {
            "$ref": "#/components/schemas/indices.recovery:TranslogStatus"
          },
          "type": {
            "type": "string"
          },
          "verify_index": {
            "$ref": "#/components/schemas/indices.recovery:VerifyIndex"
          }
        },
        "required": [
          "id",
          "index",
          "primary",
          "source",
          "stage",
          "start_time_in_millis",
          "target",
          "total_time_in_millis",
          "translog",
          "type",
          "verify_index"
        ]
      },
      "indices.recovery:RecoveryIndexStatus": {
        "type": "object",
        "properties": {
          "bytes": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryBytes"
          },
          "files": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryFiles"
          },
          "size": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryBytes"
          },
          "source_throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "source_throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "target_throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "target_throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "files",
          "size",
          "source_throttle_time_in_millis",
          "target_throttle_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "indices.recovery:RecoveryBytes": {
        "type": "object",
        "properties": {
          "percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "recovered": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "recovered_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "recovered_from_snapshot": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "recovered_from_snapshot_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "reused": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "reused_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        },
        "required": [
          "percent",
          "recovered_in_bytes",
          "reused_in_bytes",
          "total_in_bytes"
        ]
      },
      "indices.recovery:RecoveryFiles": {
        "type": "object",
        "properties": {
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.recovery:FileDetails"
            }
          },
          "percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "recovered": {
            "type": "number"
          },
          "reused": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "percent",
          "recovered",
          "reused",
          "total"
        ]
      },
      "indices.recovery:FileDetails": {
        "type": "object",
        "properties": {
          "length": {
            "type": "number"
          },
          "name": {
            "type": "string"
          },
          "recovered": {
            "type": "number"
          }
        },
        "required": [
          "length",
          "name",
          "recovered"
        ]
      },
      "indices.recovery:RecoveryOrigin": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "ip": {
            "$ref": "#/components/schemas/_types:Ip"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "bootstrap_new_history_uuid": {
            "type": "boolean"
          },
          "repository": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "snapshot": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "restoreUUID": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        }
      },
      "indices.recovery:RecoveryStartStatus": {
        "type": "object",
        "properties": {
          "check_index_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "check_index_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "check_index_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "indices.recovery:TranslogStatus": {
        "type": "object",
        "properties": {
          "percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "recovered": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_on_start": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "percent",
          "recovered",
          "total",
          "total_on_start",
          "total_time_in_millis"
        ]
      },
      "indices.recovery:VerifyIndex": {
        "type": "object",
        "properties": {
          "check_index_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "check_index_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "check_index_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "indices.reload_search_analyzers:ReloadResult": {
        "type": "object",
        "properties": {
          "reload_details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadDetails"
            }
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          }
        },
        "required": [
          "reload_details",
          "_shards"
        ]
      },
      "indices.reload_search_analyzers:ReloadDetails": {
        "type": "object",
        "properties": {
          "index": {
            "type": "string"
          },
          "reloaded_analyzers": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "reloaded_node_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "index",
          "reloaded_analyzers",
          "reloaded_node_ids"
        ]
      },
      "indices.resolve_cluster:ResolveClusterInfo": {
        "type": "object",
        "properties": {
          "connected": {
            "description": "Whether the remote cluster is connected to the local (querying) cluster.",
            "type": "boolean"
          },
          "skip_unavailable": {
            "description": "The `skip_unavailable` setting for a remote cluster.",
            "type": "boolean"
          },
          "matching_indices": {
            "description": "Whether the index expression provided in the request matches any indices, aliases or data streams\non the cluster.",
            "type": "boolean"
          },
          "error": {
            "description": "Provides error messages that are likely to occur if you do a search with this index expression\non the specified cluster (for example, lack of security privileges to query an index).",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:ElasticsearchVersionMinInfo"
          }
        },
        "required": [
          "connected",
          "skip_unavailable"
        ]
      },
      "_types:ElasticsearchVersionMinInfo": {
        "type": "object",
        "properties": {
          "build_flavor": {
            "type": "string"
          },
          "minimum_index_compatibility_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "minimum_wire_compatibility_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "number": {
            "type": "string"
          }
        },
        "required": [
          "build_flavor",
          "minimum_index_compatibility_version",
          "minimum_wire_compatibility_version",
          "number"
        ]
      },
      "indices.resolve_index:ResolveIndexItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "aliases": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "attributes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "data_stream": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          }
        },
        "required": [
          "name",
          "attributes"
        ]
      },
      "indices.resolve_index:ResolveIndexAliasItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          }
        },
        "required": [
          "name",
          "indices"
        ]
      },
      "indices.resolve_index:ResolveIndexDataStreamsItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "timestamp_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "backing_indices": {
            "$ref": "#/components/schemas/_types:Indices"
          }
        },
        "required": [
          "name",
          "timestamp_field",
          "backing_indices"
        ]
      },
      "indices.rollover:RolloverConditions": {
        "type": "object",
        "properties": {
          "min_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_age_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "min_docs": {
            "type": "number"
          },
          "max_docs": {
            "type": "number"
          },
          "max_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_size_bytes": {
            "type": "number"
          },
          "min_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_size_bytes": {
            "type": "number"
          },
          "max_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_primary_shard_size_bytes": {
            "type": "number"
          },
          "min_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_size_bytes": {
            "type": "number"
          },
          "max_primary_shard_docs": {
            "type": "number"
          },
          "min_primary_shard_docs": {
            "type": "number"
          }
        }
      },
      "indices.segments:IndexSegment": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/indices.segments:ShardsSegment"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.segments:ShardsSegment"
                  }
                }
              ]
            }
          }
        },
        "required": [
          "shards"
        ]
      },
      "indices.segments:ShardsSegment": {
        "type": "object",
        "properties": {
          "num_committed_segments": {
            "type": "number"
          },
          "routing": {
            "$ref": "#/components/schemas/indices.segments:ShardSegmentRouting"
          },
          "num_search_segments": {
            "type": "number"
          },
          "segments": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices.segments:Segment"
            }
          }
        },
        "required": [
          "num_committed_segments",
          "routing",
          "num_search_segments",
          "segments"
        ]
      },
      "indices.segments:ShardSegmentRouting": {
        "type": "object",
        "properties": {
          "node": {
            "type": "string"
          },
          "primary": {
            "type": "boolean"
          },
          "state": {
            "type": "string"
          }
        },
        "required": [
          "node",
          "primary",
          "state"
        ]
      },
      "indices.segments:Segment": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "committed": {
            "type": "boolean"
          },
          "compound": {
            "type": "boolean"
          },
          "deleted_docs": {
            "type": "number"
          },
          "generation": {
            "type": "number"
          },
          "search": {
            "type": "boolean"
          },
          "size_in_bytes": {
            "type": "number"
          },
          "num_docs": {
            "type": "number"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "attributes",
          "committed",
          "compound",
          "deleted_docs",
          "generation",
          "search",
          "size_in_bytes",
          "num_docs",
          "version"
        ]
      },
      "indices.shard_stores:ShardStoreStatus": {
        "type": "string",
        "enum": [
          "green",
          "yellow",
          "red",
          "all"
        ]
      },
      "indices.shard_stores:IndicesShardStores": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices.shard_stores:ShardStoreWrapper"
            }
          }
        },
        "required": [
          "shards"
        ]
      },
      "indices.shard_stores:ShardStoreWrapper": {
        "type": "object",
        "properties": {
          "stores": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.shard_stores:ShardStore"
            }
          }
        },
        "required": [
          "stores"
        ]
      },
      "indices.shard_stores:ShardStore": {
        "type": "object",
        "properties": {
          "allocation": {
            "$ref": "#/components/schemas/indices.shard_stores:ShardStoreAllocation"
          },
          "allocation_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "store_exception": {
            "$ref": "#/components/schemas/indices.shard_stores:ShardStoreException"
          }
        },
        "required": [
          "allocation"
        ]
      },
      "indices.shard_stores:ShardStoreAllocation": {
        "type": "string",
        "enum": [
          "primary",
          "replica",
          "unused"
        ]
      },
      "indices.shard_stores:ShardStoreException": {
        "type": "object",
        "properties": {
          "reason": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "reason",
          "type"
        ]
      },
      "indices.simulate_template:Overlapping": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "index_patterns": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "name",
          "index_patterns"
        ]
      },
      "indices.simulate_template:Template": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          }
        },
        "required": [
          "aliases",
          "mappings",
          "settings"
        ]
      },
      "indices.stats:IndicesStats": {
        "type": "object",
        "properties": {
          "primaries": {
            "$ref": "#/components/schemas/indices.stats:IndexStats"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/indices.stats:ShardStats"
              }
            }
          },
          "total": {
            "$ref": "#/components/schemas/indices.stats:IndexStats"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "health": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "status": {
            "$ref": "#/components/schemas/indices.stats:IndexMetadataState"
          }
        }
      },
      "indices.stats:IndexStats": {
        "type": "object",
        "properties": {
          "completion": {
            "$ref": "#/components/schemas/_types:CompletionStats"
          },
          "docs": {
            "$ref": "#/components/schemas/_types:DocStats"
          },
          "fielddata": {
            "$ref": "#/components/schemas/_types:FielddataStats"
          },
          "flush": {
            "$ref": "#/components/schemas/_types:FlushStats"
          },
          "get": {
            "$ref": "#/components/schemas/_types:GetStats"
          },
          "indexing": {
            "$ref": "#/components/schemas/_types:IndexingStats"
          },
          "indices": {
            "$ref": "#/components/schemas/indices.stats:IndicesStats"
          },
          "merges": {
            "$ref": "#/components/schemas/_types:MergesStats"
          },
          "query_cache": {
            "$ref": "#/components/schemas/_types:QueryCacheStats"
          },
          "recovery": {
            "$ref": "#/components/schemas/_types:RecoveryStats"
          },
          "refresh": {
            "$ref": "#/components/schemas/_types:RefreshStats"
          },
          "request_cache": {
            "$ref": "#/components/schemas/_types:RequestCacheStats"
          },
          "search": {
            "$ref": "#/components/schemas/_types:SearchStats"
          },
          "segments": {
            "$ref": "#/components/schemas/_types:SegmentsStats"
          },
          "store": {
            "$ref": "#/components/schemas/_types:StoreStats"
          },
          "translog": {
            "$ref": "#/components/schemas/_types:TranslogStats"
          },
          "warmer": {
            "$ref": "#/components/schemas/_types:WarmerStats"
          },
          "bulk": {
            "$ref": "#/components/schemas/_types:BulkStats"
          },
          "shard_stats": {
            "$ref": "#/components/schemas/indices.stats:ShardsTotalStats"
          }
        }
      },
      "_types:FlushStats": {
        "type": "object",
        "properties": {
          "periodic": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "periodic",
          "total",
          "total_time_in_millis"
        ]
      },
      "_types:GetStats": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number"
          },
          "exists_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "exists_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "exists_total": {
            "type": "number"
          },
          "missing_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "missing_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "missing_total": {
            "type": "number"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "current",
          "exists_time_in_millis",
          "exists_total",
          "missing_time_in_millis",
          "missing_total",
          "time_in_millis",
          "total"
        ]
      },
      "_types:IndexingStats": {
        "type": "object",
        "properties": {
          "index_current": {
            "type": "number"
          },
          "delete_current": {
            "type": "number"
          },
          "delete_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "delete_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "delete_total": {
            "type": "number"
          },
          "is_throttled": {
            "type": "boolean"
          },
          "noop_update_total": {
            "type": "number"
          },
          "throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "index_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_total": {
            "type": "number"
          },
          "index_failed": {
            "type": "number"
          },
          "types": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:IndexingStats"
            }
          },
          "write_load": {
            "type": "number"
          }
        },
        "required": [
          "index_current",
          "delete_current",
          "delete_time_in_millis",
          "delete_total",
          "is_throttled",
          "noop_update_total",
          "throttle_time_in_millis",
          "index_time_in_millis",
          "index_total",
          "index_failed"
        ]
      },
      "_types:MergesStats": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number"
          },
          "current_docs": {
            "type": "number"
          },
          "current_size": {
            "type": "string"
          },
          "current_size_in_bytes": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_auto_throttle": {
            "type": "string"
          },
          "total_auto_throttle_in_bytes": {
            "type": "number"
          },
          "total_docs": {
            "type": "number"
          },
          "total_size": {
            "type": "string"
          },
          "total_size_in_bytes": {
            "type": "number"
          },
          "total_stopped_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_stopped_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_throttled_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_throttled_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "current",
          "current_docs",
          "current_size_in_bytes",
          "total",
          "total_auto_throttle_in_bytes",
          "total_docs",
          "total_size_in_bytes",
          "total_stopped_time_in_millis",
          "total_throttled_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "_types:RecoveryStats": {
        "type": "object",
        "properties": {
          "current_as_source": {
            "type": "number"
          },
          "current_as_target": {
            "type": "number"
          },
          "throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "current_as_source",
          "current_as_target",
          "throttle_time_in_millis"
        ]
      },
      "_types:RefreshStats": {
        "type": "object",
        "properties": {
          "external_total": {
            "type": "number"
          },
          "external_total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "listeners": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "external_total",
          "external_total_time_in_millis",
          "listeners",
          "total",
          "total_time_in_millis"
        ]
      },
      "_types:RequestCacheStats": {
        "type": "object",
        "properties": {
          "evictions": {
            "type": "number"
          },
          "hit_count": {
            "type": "number"
          },
          "memory_size": {
            "type": "string"
          },
          "memory_size_in_bytes": {
            "type": "number"
          },
          "miss_count": {
            "type": "number"
          }
        },
        "required": [
          "evictions",
          "hit_count",
          "memory_size_in_bytes",
          "miss_count"
        ]
      },
      "_types:SearchStats": {
        "type": "object",
        "properties": {
          "fetch_current": {
            "type": "number"
          },
          "fetch_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "fetch_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "fetch_total": {
            "type": "number"
          },
          "open_contexts": {
            "type": "number"
          },
          "query_current": {
            "type": "number"
          },
          "query_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "query_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "query_total": {
            "type": "number"
          },
          "scroll_current": {
            "type": "number"
          },
          "scroll_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "scroll_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "scroll_total": {
            "type": "number"
          },
          "suggest_current": {
            "type": "number"
          },
          "suggest_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "suggest_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "suggest_total": {
            "type": "number"
          },
          "groups": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:SearchStats"
            }
          }
        },
        "required": [
          "fetch_current",
          "fetch_time_in_millis",
          "fetch_total",
          "query_current",
          "query_time_in_millis",
          "query_total",
          "scroll_current",
          "scroll_time_in_millis",
          "scroll_total",
          "suggest_current",
          "suggest_time_in_millis",
          "suggest_total"
        ]
      },
      "_types:TranslogStats": {
        "type": "object",
        "properties": {
          "earliest_last_modified_age": {
            "type": "number"
          },
          "operations": {
            "type": "number"
          },
          "size": {
            "type": "string"
          },
          "size_in_bytes": {
            "type": "number"
          },
          "uncommitted_operations": {
            "type": "number"
          },
          "uncommitted_size": {
            "type": "string"
          },
          "uncommitted_size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "earliest_last_modified_age",
          "operations",
          "size_in_bytes",
          "uncommitted_operations",
          "uncommitted_size_in_bytes"
        ]
      },
      "_types:WarmerStats": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "current",
          "total",
          "total_time_in_millis"
        ]
      },
      "_types:BulkStats": {
        "type": "object",
        "properties": {
          "total_operations": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_size_in_bytes": {
            "type": "number"
          },
          "avg_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "avg_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "avg_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "avg_size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "total_operations",
          "total_time_in_millis",
          "total_size_in_bytes",
          "avg_time_in_millis",
          "avg_size_in_bytes"
        ]
      },
      "indices.stats:ShardsTotalStats": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "number"
          }
        },
        "required": [
          "total_count"
        ]
      },
      "indices.stats:ShardStats": {
        "type": "object",
        "properties": {
          "commit": {
            "$ref": "#/components/schemas/indices.stats:ShardCommit"
          },
          "completion": {
            "$ref": "#/components/schemas/_types:CompletionStats"
          },
          "docs": {
            "$ref": "#/components/schemas/_types:DocStats"
          },
          "fielddata": {
            "$ref": "#/components/schemas/_types:FielddataStats"
          },
          "flush": {
            "$ref": "#/components/schemas/_types:FlushStats"
          },
          "get": {
            "$ref": "#/components/schemas/_types:GetStats"
          },
          "indexing": {
            "$ref": "#/components/schemas/_types:IndexingStats"
          },
          "mappings": {
            "$ref": "#/components/schemas/indices.stats:MappingStats"
          },
          "merges": {
            "$ref": "#/components/schemas/_types:MergesStats"
          },
          "shard_path": {
            "$ref": "#/components/schemas/indices.stats:ShardPath"
          },
          "query_cache": {
            "$ref": "#/components/schemas/indices.stats:ShardQueryCache"
          },
          "recovery": {
            "$ref": "#/components/schemas/_types:RecoveryStats"
          },
          "refresh": {
            "$ref": "#/components/schemas/_types:RefreshStats"
          },
          "request_cache": {
            "$ref": "#/components/schemas/_types:RequestCacheStats"
          },
          "retention_leases": {
            "$ref": "#/components/schemas/indices.stats:ShardRetentionLeases"
          },
          "routing": {
            "$ref": "#/components/schemas/indices.stats:ShardRouting"
          },
          "search": {
            "$ref": "#/components/schemas/_types:SearchStats"
          },
          "segments": {
            "$ref": "#/components/schemas/_types:SegmentsStats"
          },
          "seq_no": {
            "$ref": "#/components/schemas/indices.stats:ShardSequenceNumber"
          },
          "store": {
            "$ref": "#/components/schemas/_types:StoreStats"
          },
          "translog": {
            "$ref": "#/components/schemas/_types:TranslogStats"
          },
          "warmer": {
            "$ref": "#/components/schemas/_types:WarmerStats"
          },
          "bulk": {
            "$ref": "#/components/schemas/_types:BulkStats"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "shard_stats": {
            "$ref": "#/components/schemas/indices.stats:ShardsTotalStats"
          },
          "indices": {
            "$ref": "#/components/schemas/indices.stats:IndicesStats"
          }
        }
      },
      "indices.stats:ShardCommit": {
        "type": "object",
        "properties": {
          "generation": {
            "type": "number"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "num_docs": {
            "type": "number"
          },
          "user_data": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "generation",
          "id",
          "num_docs",
          "user_data"
        ]
      },
      "indices.stats:MappingStats": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "number"
          },
          "total_estimated_overhead": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_estimated_overhead_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "total_count",
          "total_estimated_overhead_in_bytes"
        ]
      },
      "indices.stats:ShardPath": {
        "type": "object",
        "properties": {
          "data_path": {
            "type": "string"
          },
          "is_custom_data_path": {
            "type": "boolean"
          },
          "state_path": {
            "type": "string"
          }
        },
        "required": [
          "data_path",
          "is_custom_data_path",
          "state_path"
        ]
      },
      "indices.stats:ShardQueryCache": {
        "type": "object",
        "properties": {
          "cache_count": {
            "type": "number"
          },
          "cache_size": {
            "type": "number"
          },
          "evictions": {
            "type": "number"
          },
          "hit_count": {
            "type": "number"
          },
          "memory_size_in_bytes": {
            "type": "number"
          },
          "miss_count": {
            "type": "number"
          },
          "total_count": {
            "type": "number"
          }
        },
        "required": [
          "cache_count",
          "cache_size",
          "evictions",
          "hit_count",
          "memory_size_in_bytes",
          "miss_count",
          "total_count"
        ]
      },
      "indices.stats:ShardRetentionLeases": {
        "type": "object",
        "properties": {
          "primary_term": {
            "type": "number"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "leases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.stats:ShardLease"
            }
          }
        },
        "required": [
          "primary_term",
          "version",
          "leases"
        ]
      },
      "indices.stats:ShardLease": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "retaining_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "timestamp": {
            "type": "number"
          },
          "source": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "retaining_seq_no",
          "timestamp",
          "source"
        ]
      },
      "indices.stats:ShardRouting": {
        "type": "object",
        "properties": {
          "node": {
            "type": "string"
          },
          "primary": {
            "type": "boolean"
          },
          "relocating_node": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "state": {
            "$ref": "#/components/schemas/indices.stats:ShardRoutingState"
          }
        },
        "required": [
          "node",
          "primary",
          "state"
        ]
      },
      "indices.stats:ShardRoutingState": {
        "type": "string",
        "enum": [
          "UNASSIGNED",
          "INITIALIZING",
          "STARTED",
          "RELOCATING"
        ]
      },
      "indices.stats:ShardSequenceNumber": {
        "type": "object",
        "properties": {
          "global_checkpoint": {
            "type": "number"
          },
          "local_checkpoint": {
            "type": "number"
          },
          "max_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          }
        },
        "required": [
          "global_checkpoint",
          "local_checkpoint",
          "max_seq_no"
        ]
      },
      "indices.stats:IndexMetadataState": {
        "type": "string",
        "enum": [
          "open",
          "close"
        ]
      },
      "indices.update_aliases:Action": {
        "type": "object",
        "properties": {
          "add": {
            "$ref": "#/components/schemas/indices.update_aliases:AddAction"
          },
          "remove": {
            "$ref": "#/components/schemas/indices.update_aliases:RemoveAction"
          },
          "remove_index": {
            "$ref": "#/components/schemas/indices.update_aliases:RemoveIndexAction"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "indices.update_aliases:AddAction": {
        "type": "object",
        "properties": {
          "alias": {
            "$ref": "#/components/schemas/_types:IndexAlias"
          },
          "aliases": {
            "description": "Aliases for the action.\nIndex alias names support date math.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexAlias"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexAlias"
                }
              }
            ]
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "index_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "is_hidden": {
            "description": "If `true`, the alias is hidden.",
            "type": "boolean"
          },
          "is_write_index": {
            "description": "If `true`, sets the write index or data stream for the alias.",
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "search_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "must_exist": {
            "description": "If `true`, the alias must exist to perform the action.",
            "type": "boolean"
          }
        }
      },
      "indices.update_aliases:RemoveAction": {
        "type": "object",
        "properties": {
          "alias": {
            "$ref": "#/components/schemas/_types:IndexAlias"
          },
          "aliases": {
            "description": "Aliases for the action.\nIndex alias names support date math.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexAlias"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexAlias"
                }
              }
            ]
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "must_exist": {
            "description": "If `true`, the alias must exist to perform the action.",
            "type": "boolean"
          }
        }
      },
      "indices.update_aliases:RemoveIndexAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "must_exist": {
            "description": "If `true`, the alias must exist to perform the action.",
            "type": "boolean"
          }
        }
      },
      "indices.validate_query:IndicesValidationExplanation": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string"
          },
          "explanation": {
            "type": "string"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "valid": {
            "type": "boolean"
          }
        },
        "required": [
          "index",
          "valid"
        ]
      },
      "inference._types:TaskType": {
        "type": "string",
        "enum": [
          "sparse_embedding",
          "text_embedding",
          "rerank",
          "completion"
        ]
      },
      "inference._types:DeleteInferenceEndpointResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "pipelines": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "pipelines"
            ]
          }
        ]
      },
      "inference._types:InferenceEndpointInfo": {
        "allOf": [
          {
            "$ref": "#/components/schemas/inference._types:InferenceEndpoint"
          },
          {
            "type": "object",
            "properties": {
              "inference_id": {
                "description": "The inference Id",
                "type": "string"
              },
              "task_type": {
                "$ref": "#/components/schemas/inference._types:TaskType"
              }
            },
            "required": [
              "inference_id",
              "task_type"
            ]
          }
        ]
      },
      "inference._types:InferenceEndpoint": {
        "type": "object",
        "properties": {
          "chunking_settings": {
            "$ref": "#/components/schemas/inference._types:InferenceChunkingSettings"
          },
          "service": {
            "description": "The service type",
            "type": "string"
          },
          "service_settings": {
            "$ref": "#/components/schemas/inference._types:ServiceSettings"
          },
          "task_settings": {
            "$ref": "#/components/schemas/inference._types:TaskSettings"
          }
        },
        "required": [
          "service",
          "service_settings"
        ]
      },
      "inference._types:InferenceChunkingSettings": {
        "type": "object",
        "properties": {
          "max_chunk_size": {
            "description": "Specifies the maximum size of a chunk in words\nThis value cannot be higher than `300` or lower than `20` (for `sentence` strategy) or `10` (for `word` strategy)",
            "type": "number"
          },
          "overlap": {
            "description": "Specifies the number of overlapping words for chunks\nOnly for `word` chunking strategy\nThis value cannot be higher than the half of `max_chunk_size`",
            "type": "number"
          },
          "sentence_overlap": {
            "description": "Specifies the number of overlapping sentences for chunks\nOnly for `sentence` chunking strategy\nIt can be either `1` or `0`",
            "type": "number"
          },
          "strategy": {
            "description": "Specifies the chunking strategy\nIt could be either `sentence` or `word`",
            "type": "string"
          }
        }
      },
      "inference._types:ServiceSettings": {
        "type": "object"
      },
      "inference._types:TaskSettings": {
        "type": "object"
      },
      "inference._types:InferenceResult": {
        "description": "InferenceResult is an aggregation of mutually exclusive variants",
        "type": "object",
        "properties": {
          "text_embedding_bytes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/inference._types:TextEmbeddingByteResult"
            }
          },
          "text_embedding": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/inference._types:TextEmbeddingResult"
            }
          },
          "sparse_embedding": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/inference._types:SparseEmbeddingResult"
            }
          },
          "completion": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/inference._types:CompletionResult"
            }
          },
          "rerank": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/inference._types:RankedDocument"
            }
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "inference._types:TextEmbeddingByteResult": {
        "type": "object",
        "properties": {
          "embedding": {
            "$ref": "#/components/schemas/inference._types:DenseByteVector"
          }
        },
        "required": [
          "embedding"
        ]
      },
      "inference._types:DenseByteVector": {
        "description": "Text Embedding results containing bytes are represented as Dense\nVectors of bytes.",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/_types:byte"
        }
      },
      "inference._types:TextEmbeddingResult": {
        "type": "object",
        "properties": {
          "embedding": {
            "$ref": "#/components/schemas/inference._types:DenseVector"
          }
        },
        "required": [
          "embedding"
        ]
      },
      "inference._types:DenseVector": {
        "description": "Text Embedding results are represented as Dense Vectors\nof floats.",
        "type": "array",
        "items": {
          "type": "number"
        }
      },
      "inference._types:SparseEmbeddingResult": {
        "type": "object",
        "properties": {
          "embedding": {
            "$ref": "#/components/schemas/inference._types:SparseVector"
          }
        },
        "required": [
          "embedding"
        ]
      },
      "inference._types:SparseVector": {
        "description": "Sparse Embedding tokens are represented as a dictionary\nof string to double.",
        "type": "object",
        "additionalProperties": {
          "type": "number"
        }
      },
      "inference._types:CompletionResult": {
        "type": "object",
        "properties": {
          "result": {
            "type": "string"
          }
        },
        "required": [
          "result"
        ]
      },
      "inference._types:RankedDocument": {
        "type": "object",
        "properties": {
          "index": {
            "type": "number"
          },
          "relevance_score": {
            "type": "number"
          },
          "text": {
            "type": "string"
          }
        },
        "required": [
          "index",
          "relevance_score"
        ]
      },
      "_types:StreamResult": {
        "type": "object"
      },
      "_types:ElasticsearchVersionInfo": {
        "type": "object",
        "properties": {
          "build_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "build_flavor": {
            "description": "The build flavor. For example, `default`.",
            "type": "string"
          },
          "build_hash": {
            "description": "The Elasticsearch Git commit's SHA hash.",
            "type": "string"
          },
          "build_snapshot": {
            "description": "Indicates whether the Elasticsearch build was a snapshot.",
            "type": "boolean"
          },
          "build_type": {
            "description": "The build type that corresponds to how Elasticsearch was installed.\nFor example, `docker`, `rpm`, or `tar`.",
            "type": "string"
          },
          "lucene_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "minimum_index_compatibility_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "minimum_wire_compatibility_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "number": {
            "description": "The Elasticsearch version number.",
            "type": "string"
          }
        },
        "required": [
          "build_date",
          "build_flavor",
          "build_hash",
          "build_snapshot",
          "build_type",
          "lucene_version",
          "minimum_index_compatibility_version",
          "minimum_wire_compatibility_version",
          "number"
        ]
      },
      "ingest.geo_ip_stats:GeoIpDownloadStatistics": {
        "type": "object",
        "properties": {
          "successful_downloads": {
            "description": "Total number of successful database downloads.",
            "type": "number"
          },
          "failed_downloads": {
            "description": "Total number of failed database downloads.",
            "type": "number"
          },
          "total_download_time": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "databases_count": {
            "description": "Current number of databases available for use.",
            "type": "number"
          },
          "skipped_updates": {
            "description": "Total number of database updates skipped.",
            "type": "number"
          },
          "expired_databases": {
            "description": "Total number of databases not updated after 30 days",
            "type": "number"
          }
        },
        "required": [
          "successful_downloads",
          "failed_downloads",
          "total_download_time",
          "databases_count",
          "skipped_updates",
          "expired_databases"
        ]
      },
      "ingest.geo_ip_stats:GeoIpNodeDatabases": {
        "type": "object",
        "properties": {
          "databases": {
            "description": "Downloaded databases for the node.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest.geo_ip_stats:GeoIpNodeDatabaseName"
            }
          },
          "files_in_temp": {
            "description": "Downloaded database files, including related license files. Elasticsearch stores these files in the nodeâ€™s temporary directory: $ES_TMPDIR/geoip-databases/<node_id>.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "databases",
          "files_in_temp"
        ]
      },
      "ingest.geo_ip_stats:GeoIpNodeDatabaseName": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name"
        ]
      },
      "ingest.get_geoip_database:DatabaseConfigurationMetadata": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "version": {
            "type": "number"
          },
          "modified_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "database": {
            "$ref": "#/components/schemas/ingest._types:DatabaseConfiguration"
          }
        },
        "required": [
          "id",
          "version",
          "modified_date_millis",
          "database"
        ]
      },
      "ingest._types:DatabaseConfiguration": {
        "description": "The configuration necessary to identify which IP geolocation provider to use to download a database, as well as any provider-specific configuration necessary for such downloading.\nAt present, the only supported providers are `maxmind` and `ipinfo`, and the `maxmind` provider requires that an `account_id` (string) is configured.\nA provider (either `maxmind` or `ipinfo`) must be specified. The web and local providers can be returned as read only configurations.",
        "allOf": [
          {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/_types:Name"
              }
            },
            "required": [
              "name"
            ]
          },
          {
            "type": "object",
            "properties": {
              "maxmind": {
                "$ref": "#/components/schemas/ingest._types:Maxmind"
              },
              "ipinfo": {
                "$ref": "#/components/schemas/ingest._types:Ipinfo"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "ingest._types:Maxmind": {
        "type": "object",
        "properties": {
          "account_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "required": [
          "account_id"
        ]
      },
      "ingest._types:Ipinfo": {
        "type": "object"
      },
      "ingest.get_ip_location_database:DatabaseConfigurationMetadata": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "modified_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "modified_date": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "database": {
            "$ref": "#/components/schemas/ingest._types:DatabaseConfigurationFull"
          }
        },
        "required": [
          "id",
          "version",
          "database"
        ]
      },
      "ingest._types:DatabaseConfigurationFull": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/_types:Name"
              }
            },
            "required": [
              "name"
            ]
          },
          {
            "type": "object",
            "properties": {
              "web": {
                "$ref": "#/components/schemas/ingest._types:Web"
              },
              "local": {
                "$ref": "#/components/schemas/ingest._types:Local"
              },
              "maxmind": {
                "$ref": "#/components/schemas/ingest._types:Maxmind"
              },
              "ipinfo": {
                "$ref": "#/components/schemas/ingest._types:Ipinfo"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "ingest._types:Web": {
        "type": "object"
      },
      "ingest._types:Local": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "ingest._types:Pipeline": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the ingest pipeline.",
            "type": "string"
          },
          "on_failure": {
            "description": "Processors to run immediately after a processor failure.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          },
          "processors": {
            "description": "Processors used to perform transformations on documents before indexing.\nProcessors run sequentially in the order specified.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "deprecated": {
            "description": "Marks this ingest pipeline as deprecated.\nWhen a deprecated ingest pipeline is referenced as the default or final pipeline when creating or updating a non-deprecated index template, Elasticsearch will emit a deprecation warning.",
            "type": "boolean"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        }
      },
      "ingest._types:ProcessorContainer": {
        "type": "object",
        "properties": {
          "append": {
            "$ref": "#/components/schemas/ingest._types:AppendProcessor"
          },
          "attachment": {
            "$ref": "#/components/schemas/ingest._types:AttachmentProcessor"
          },
          "bytes": {
            "$ref": "#/components/schemas/ingest._types:BytesProcessor"
          },
          "circle": {
            "$ref": "#/components/schemas/ingest._types:CircleProcessor"
          },
          "community_id": {
            "$ref": "#/components/schemas/ingest._types:CommunityIDProcessor"
          },
          "convert": {
            "$ref": "#/components/schemas/ingest._types:ConvertProcessor"
          },
          "csv": {
            "$ref": "#/components/schemas/ingest._types:CsvProcessor"
          },
          "date": {
            "$ref": "#/components/schemas/ingest._types:DateProcessor"
          },
          "date_index_name": {
            "$ref": "#/components/schemas/ingest._types:DateIndexNameProcessor"
          },
          "dissect": {
            "$ref": "#/components/schemas/ingest._types:DissectProcessor"
          },
          "dot_expander": {
            "$ref": "#/components/schemas/ingest._types:DotExpanderProcessor"
          },
          "drop": {
            "$ref": "#/components/schemas/ingest._types:DropProcessor"
          },
          "enrich": {
            "$ref": "#/components/schemas/ingest._types:EnrichProcessor"
          },
          "fail": {
            "$ref": "#/components/schemas/ingest._types:FailProcessor"
          },
          "fingerprint": {
            "$ref": "#/components/schemas/ingest._types:FingerprintProcessor"
          },
          "foreach": {
            "$ref": "#/components/schemas/ingest._types:ForeachProcessor"
          },
          "ip_location": {
            "$ref": "#/components/schemas/ingest._types:IpLocationProcessor"
          },
          "geo_grid": {
            "$ref": "#/components/schemas/ingest._types:GeoGridProcessor"
          },
          "geoip": {
            "$ref": "#/components/schemas/ingest._types:GeoIpProcessor"
          },
          "grok": {
            "$ref": "#/components/schemas/ingest._types:GrokProcessor"
          },
          "gsub": {
            "$ref": "#/components/schemas/ingest._types:GsubProcessor"
          },
          "html_strip": {
            "$ref": "#/components/schemas/ingest._types:HtmlStripProcessor"
          },
          "inference": {
            "$ref": "#/components/schemas/ingest._types:InferenceProcessor"
          },
          "join": {
            "$ref": "#/components/schemas/ingest._types:JoinProcessor"
          },
          "json": {
            "$ref": "#/components/schemas/ingest._types:JsonProcessor"
          },
          "kv": {
            "$ref": "#/components/schemas/ingest._types:KeyValueProcessor"
          },
          "lowercase": {
            "$ref": "#/components/schemas/ingest._types:LowercaseProcessor"
          },
          "network_direction": {
            "$ref": "#/components/schemas/ingest._types:NetworkDirectionProcessor"
          },
          "pipeline": {
            "$ref": "#/components/schemas/ingest._types:PipelineProcessor"
          },
          "redact": {
            "$ref": "#/components/schemas/ingest._types:RedactProcessor"
          },
          "registered_domain": {
            "$ref": "#/components/schemas/ingest._types:RegisteredDomainProcessor"
          },
          "remove": {
            "$ref": "#/components/schemas/ingest._types:RemoveProcessor"
          },
          "rename": {
            "$ref": "#/components/schemas/ingest._types:RenameProcessor"
          },
          "reroute": {
            "$ref": "#/components/schemas/ingest._types:RerouteProcessor"
          },
          "script": {
            "$ref": "#/components/schemas/ingest._types:ScriptProcessor"
          },
          "set": {
            "$ref": "#/components/schemas/ingest._types:SetProcessor"
          },
          "set_security_user": {
            "$ref": "#/components/schemas/ingest._types:SetSecurityUserProcessor"
          },
          "sort": {
            "$ref": "#/components/schemas/ingest._types:SortProcessor"
          },
          "split": {
            "$ref": "#/components/schemas/ingest._types:SplitProcessor"
          },
          "terminate": {
            "$ref": "#/components/schemas/ingest._types:TerminateProcessor"
          },
          "trim": {
            "$ref": "#/components/schemas/ingest._types:TrimProcessor"
          },
          "uppercase": {
            "$ref": "#/components/schemas/ingest._types:UppercaseProcessor"
          },
          "urldecode": {
            "$ref": "#/components/schemas/ingest._types:UrlDecodeProcessor"
          },
          "uri_parts": {
            "$ref": "#/components/schemas/ingest._types:UriPartsProcessor"
          },
          "user_agent": {
            "$ref": "#/components/schemas/ingest._types:UserAgentProcessor"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ingest._types:AppendProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "value": {
                "description": "The value to be appended. Supports template snippets.",
                "oneOf": [
                  {
                    "type": "object"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "object"
                    }
                  }
                ]
              },
              "allow_duplicates": {
                "description": "If `false`, the processor does not append values already present in the field.",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "value"
            ]
          }
        ]
      },
      "ingest._types:ProcessorBase": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the processor.\nUseful for describing the purpose of the processor or its configuration.",
            "type": "string"
          },
          "if": {
            "description": "Conditionally execute the processor.",
            "type": "string"
          },
          "ignore_failure": {
            "description": "Ignore failures for the processor.",
            "type": "boolean"
          },
          "on_failure": {
            "description": "Handle failures for the processor.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          },
          "tag": {
            "description": "Identifier for the processor.\nUseful for debugging and metrics.",
            "type": "string"
          }
        }
      },
      "ingest._types:AttachmentProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and field does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "indexed_chars": {
                "description": "The number of chars being used for extraction to prevent huge fields.\nUse `-1` for no limit.",
                "type": "number"
              },
              "indexed_chars_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "properties": {
                "description": "Array of properties to select to be stored.\nCan be `content`, `title`, `name`, `author`, `keywords`, `date`, `content_type`, `content_length`, `language`.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "remove_binary": {
                "description": "If true, the binary field will be removed from the document",
                "type": "boolean"
              },
              "resource_name": {
                "description": "Field containing the name of the resource to decode.\nIf specified, the processor passes this resource name to the underlying Tika library to enable Resource Name Based Detection.",
                "type": "string"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:BytesProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:CircleProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "error_distance": {
                "description": "The difference between the resulting inscribed distance from center to side and the circleâ€™s radius (measured in meters for `geo_shape`, unit-less for `shape`).",
                "type": "number"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "shape_type": {
                "$ref": "#/components/schemas/ingest._types:ShapeType"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "error_distance",
              "field",
              "shape_type"
            ]
          }
        ]
      },
      "ingest._types:ShapeType": {
        "type": "string",
        "enum": [
          "geo_shape",
          "shape"
        ]
      },
      "ingest._types:CommunityIDProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "source_ip": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "source_port": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "destination_ip": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "destination_port": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "iana_number": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "icmp_type": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "icmp_code": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "transport": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "seed": {
                "description": "Seed for the community ID hash. Must be between 0 and 65535 (inclusive). The\nseed can prevent hash collisions between network domains, such as a staging\nand production network that use the same addressing scheme.",
                "type": "number"
              },
              "ignore_missing": {
                "description": "If true and any required fields are missing, the processor quietly exits\nwithout modifying the document.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "ingest._types:ConvertProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "type": {
                "$ref": "#/components/schemas/ingest._types:ConvertType"
              }
            },
            "required": [
              "field",
              "type"
            ]
          }
        ]
      },
      "ingest._types:ConvertType": {
        "type": "string",
        "enum": [
          "integer",
          "long",
          "double",
          "float",
          "boolean",
          "ip",
          "string",
          "auto"
        ]
      },
      "ingest._types:CsvProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "empty_value": {
                "description": "Value used to fill empty fields.\nEmpty fields are skipped if this is not provided.\nAn empty field is one with no value (2 consecutive separators) or empty quotes (`\"\"`).",
                "type": "object"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "quote": {
                "description": "Quote used in CSV, has to be single character string.",
                "type": "string"
              },
              "separator": {
                "description": "Separator used in CSV, has to be single character string.",
                "type": "string"
              },
              "target_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "trim": {
                "description": "Trim whitespaces in unquoted fields.",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "target_fields"
            ]
          }
        ]
      },
      "ingest._types:DateProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "formats": {
                "description": "An array of the expected date formats.\nCan be a java time pattern or one of the following formats: ISO8601, UNIX, UNIX_MS, or TAI64N.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "locale": {
                "description": "The locale to use when parsing the date, relevant when parsing month names or week days.\nSupports template snippets.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "timezone": {
                "description": "The timezone to use when parsing the date.\nSupports template snippets.",
                "type": "string"
              },
              "output_format": {
                "description": "The format to use when writing the date to target_field. Must be a valid\njava time pattern.",
                "type": "string"
              }
            },
            "required": [
              "field",
              "formats"
            ]
          }
        ]
      },
      "ingest._types:DateIndexNameProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "date_formats": {
                "description": "An array of the expected date formats for parsing dates / timestamps in the document being preprocessed.\nCan be a java time pattern or one of the following formats: ISO8601, UNIX, UNIX_MS, or TAI64N.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "date_rounding": {
                "description": "How to round the date when formatting the date into the index name. Valid values are:\n`y` (year), `M` (month), `w` (week), `d` (day), `h` (hour), `m` (minute) and `s` (second).\nSupports template snippets.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "index_name_format": {
                "description": "The format to be used when printing the parsed date into the index name.\nA valid java time pattern is expected here.\nSupports template snippets.",
                "type": "string"
              },
              "index_name_prefix": {
                "description": "A prefix of the index name to be prepended before the printed date.\nSupports template snippets.",
                "type": "string"
              },
              "locale": {
                "description": "The locale to use when parsing the date from the document being preprocessed, relevant when parsing month names or week days.",
                "type": "string"
              },
              "timezone": {
                "description": "The timezone to use when parsing the date and when date math index supports resolves expressions into concrete index names.",
                "type": "string"
              }
            },
            "required": [
              "date_formats",
              "date_rounding",
              "field"
            ]
          }
        ]
      },
      "ingest._types:DissectProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "append_separator": {
                "description": "The character(s) that separate the appended fields.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "pattern": {
                "description": "The pattern to apply to the field.",
                "type": "string"
              }
            },
            "required": [
              "field",
              "pattern"
            ]
          }
        ]
      },
      "ingest._types:DotExpanderProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "override": {
                "description": "Controls the behavior when there is already an existing nested object that conflicts with the expanded field.\nWhen `false`, the processor will merge conflicts by combining the old and the new values into an array.\nWhen `true`, the value from the expanded field will overwrite the existing value.",
                "type": "boolean"
              },
              "path": {
                "description": "The field that contains the field to expand.\nOnly required if the field to expand is part another object field, because the `field` option can only understand leaf fields.",
                "type": "string"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:DropProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "ingest._types:EnrichProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "max_matches": {
                "description": "The maximum number of matched documents to include under the configured target field.\nThe `target_field` will be turned into a json array if `max_matches` is higher than 1, otherwise `target_field` will become a json object.\nIn order to avoid documents getting too large, the maximum allowed value is 128.",
                "type": "number"
              },
              "override": {
                "description": "If processor will update fields with pre-existing non-null-valued field.\nWhen set to `false`, such fields will not be touched.",
                "type": "boolean"
              },
              "policy_name": {
                "description": "The name of the enrich policy to use.",
                "type": "string"
              },
              "shape_relation": {
                "$ref": "#/components/schemas/_types:GeoShapeRelation"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "policy_name",
              "target_field"
            ]
          }
        ]
      },
      "_types:GeoShapeRelation": {
        "type": "string",
        "enum": [
          "intersects",
          "disjoint",
          "within",
          "contains"
        ]
      },
      "ingest._types:FailProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "message": {
                "description": "The error message thrown by the processor.\nSupports template snippets.",
                "type": "string"
              }
            },
            "required": [
              "message"
            ]
          }
        ]
      },
      "ingest._types:FingerprintProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "salt": {
                "description": "Salt value for the hash function.",
                "type": "string"
              },
              "method": {
                "$ref": "#/components/schemas/ingest._types:FingerprintDigest"
              },
              "ignore_missing": {
                "description": "If true, the processor ignores any missing fields. If all fields are\nmissing, the processor silently exits without modifying the document.",
                "type": "boolean"
              }
            },
            "required": [
              "fields"
            ]
          }
        ]
      },
      "ingest._types:FingerprintDigest": {
        "type": "string",
        "enum": [
          "MD5",
          "SHA-1",
          "SHA-256",
          "SHA-512",
          "MurmurHash3"
        ]
      },
      "ingest._types:ForeachProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true`, the processor silently exits without changing the document if the `field` is `null` or missing.",
                "type": "boolean"
              },
              "processor": {
                "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
              }
            },
            "required": [
              "field",
              "processor"
            ]
          }
        ]
      },
      "ingest._types:IpLocationProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "database_file": {
                "description": "The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the ingest-geoip config directory.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "first_only": {
                "description": "If `true`, only the first found IP location data will be returned, even if the field contains an array.",
                "type": "boolean"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "properties": {
                "description": "Controls what properties are added to the `target_field` based on the IP location lookup.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "download_database_on_pipeline_creation": {
                "description": "If `true` (and if `ingest.geoip.downloader.eager.download` is `false`), the missing database is downloaded when the pipeline is created.\nElse, the download is triggered by when the pipeline is used as the `default_pipeline` or `final_pipeline` in an index.",
                "type": "boolean"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:GeoGridProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "description": "The field to interpret as a geo-tile.=\nThe field format is determined by the `tile_type`.",
                "type": "string"
              },
              "tile_type": {
                "$ref": "#/components/schemas/ingest._types:GeoGridTileType"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "parent_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "children_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "non_children_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_format": {
                "$ref": "#/components/schemas/ingest._types:GeoGridTargetFormat"
              }
            },
            "required": [
              "field",
              "tile_type"
            ]
          }
        ]
      },
      "ingest._types:GeoGridTileType": {
        "type": "string",
        "enum": [
          "geotile",
          "geohex",
          "geohash"
        ]
      },
      "ingest._types:GeoGridTargetFormat": {
        "type": "string",
        "enum": [
          "geojson",
          "wkt"
        ]
      },
      "ingest._types:GeoIpProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "database_file": {
                "description": "The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the ingest-geoip config directory.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "first_only": {
                "description": "If `true`, only the first found geoip data will be returned, even if the field contains an array.",
                "type": "boolean"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "properties": {
                "description": "Controls what properties are added to the `target_field` based on the geoip lookup.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "download_database_on_pipeline_creation": {
                "description": "If `true` (and if `ingest.geoip.downloader.eager.download` is `false`), the missing database is downloaded when the pipeline is created.\nElse, the download is triggered by when the pipeline is used as the `default_pipeline` or `final_pipeline` in an index.",
                "type": "boolean"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:GrokProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "ecs_compatibility": {
                "description": "Must be disabled or v1. If v1, the processor uses patterns with Elastic\nCommon Schema (ECS) field names.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "pattern_definitions": {
                "description": "A map of pattern-name and pattern tuples defining custom patterns to be used by the current processor.\nPatterns matching existing names will override the pre-existing definition.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "patterns": {
                "description": "An ordered list of grok expression to match and extract named captures with.\nReturns on the first expression in the list that matches.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:GrokPattern"
                }
              },
              "trace_match": {
                "description": "When `true`, `_ingest._grok_match_index` will be inserted into your matched documentâ€™s metadata with the index into the pattern found in `patterns` that matched.",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "patterns"
            ]
          }
        ]
      },
      "_types:GrokPattern": {
        "type": "string"
      },
      "ingest._types:GsubProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "pattern": {
                "description": "The pattern to be replaced.",
                "type": "string"
              },
              "replacement": {
                "description": "The string to replace the matching patterns with.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "pattern",
              "replacement"
            ]
          }
        ]
      },
      "ingest._types:HtmlStripProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document,",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:InferenceProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "field_map": {
                "description": "Maps the document field names to the known field names of the model.\nThis mapping takes precedence over any default mappings provided in the model configuration.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "inference_config": {
                "$ref": "#/components/schemas/ingest._types:InferenceConfig"
              },
              "input_output": {
                "description": "Input fields for inference and output (destination) fields for the inference results.\nThis option is incompatible with the target_field and field_map options.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ingest._types:InputConfig"
                }
              },
              "ignore_missing": {
                "description": "If true and any of the input fields defined in input_ouput are missing\nthen those missing fields are quietly ignored, otherwise a missing field causes a failure.\nOnly applies when using input_output configurations to explicitly list the input fields.",
                "type": "boolean"
              }
            },
            "required": [
              "model_id"
            ]
          }
        ]
      },
      "ingest._types:InferenceConfig": {
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ingest._types:InferenceConfigRegression"
          },
          "classification": {
            "$ref": "#/components/schemas/ingest._types:InferenceConfigClassification"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ingest._types:InferenceConfigRegression": {
        "type": "object",
        "properties": {
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "num_top_feature_importance_values": {
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          }
        }
      },
      "ingest._types:InferenceConfigClassification": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return.",
            "type": "number"
          },
          "num_top_feature_importance_values": {
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          },
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "top_classes_results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "prediction_field_type": {
            "description": "Specifies the type of the predicted field to write.\nValid values are: `string`, `number`, `boolean`.",
            "type": "string"
          }
        }
      },
      "ingest._types:InputConfig": {
        "type": "object",
        "properties": {
          "input_field": {
            "type": "string"
          },
          "output_field": {
            "type": "string"
          }
        },
        "required": [
          "input_field",
          "output_field"
        ]
      },
      "ingest._types:JoinProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "separator": {
                "description": "The separator character.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "separator"
            ]
          }
        ]
      },
      "ingest._types:JsonProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "add_to_root": {
                "description": "Flag that forces the parsed JSON to be added at the top level of the document.\n`target_field` must not be set when this option is chosen.",
                "type": "boolean"
              },
              "add_to_root_conflict_strategy": {
                "$ref": "#/components/schemas/ingest._types:JsonProcessorConflictStrategy"
              },
              "allow_duplicate_keys": {
                "description": "When set to `true`, the JSON parser will not fail if the JSON contains duplicate keys.\nInstead, the last encountered value for any duplicate key wins.",
                "type": "boolean"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:JsonProcessorConflictStrategy": {
        "type": "string",
        "enum": [
          "replace",
          "merge"
        ]
      },
      "ingest._types:KeyValueProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "exclude_keys": {
                "description": "List of keys to exclude from document.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "field_split": {
                "description": "Regex pattern to use for splitting key-value pairs.",
                "type": "string"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "include_keys": {
                "description": "List of keys to filter and insert into document.\nDefaults to including all keys.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "prefix": {
                "description": "Prefix to be added to extracted keys.",
                "type": "string"
              },
              "strip_brackets": {
                "description": "If `true`. strip brackets `()`, `<>`, `[]` as well as quotes `'` and `\"` from extracted values.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "trim_key": {
                "description": "String of characters to trim from extracted keys.",
                "type": "string"
              },
              "trim_value": {
                "description": "String of characters to trim from extracted values.",
                "type": "string"
              },
              "value_split": {
                "description": "Regex pattern to use for splitting the key from the value within a key-value pair.",
                "type": "string"
              }
            },
            "required": [
              "field",
              "field_split",
              "value_split"
            ]
          }
        ]
      },
      "ingest._types:LowercaseProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:NetworkDirectionProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "source_ip": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "destination_ip": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "internal_networks": {
                "description": "List of internal networks. Supports IPv4 and IPv6 addresses and ranges in\nCIDR notation. Also supports the named ranges listed below. These may be\nconstructed with template snippets. Must specify only one of\ninternal_networks or internal_networks_field.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "internal_networks_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If true and any required fields are missing, the processor quietly exits\nwithout modifying the document.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "ingest._types:PipelineProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "ignore_missing_pipeline": {
                "description": "Whether to ignore missing pipelines instead of failing.",
                "type": "boolean"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      },
      "ingest._types:RedactProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "patterns": {
                "description": "A list of grok expressions to match and redact named captures with",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:GrokPattern"
                }
              },
              "pattern_definitions": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "prefix": {
                "description": "Start a redacted section with this token",
                "type": "string"
              },
              "suffix": {
                "description": "End a redacted section with this token",
                "type": "string"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "skip_if_unlicensed": {
                "description": "If `true` and the current license does not support running redact processors, then the processor quietly exits without modifying the document",
                "type": "boolean"
              },
              "trace_redact": {
                "description": "If `true` then ingest metadata `_ingest._redact._is_redacted` is set to `true` if the document has been redacted",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "patterns"
            ]
          }
        ]
      },
      "ingest._types:RegisteredDomainProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If true and any required fields are missing, the processor quietly exits\nwithout modifying the document.",
                "type": "boolean"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:RemoveProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "keep": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:RenameProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "target_field"
            ]
          }
        ]
      },
      "ingest._types:RerouteProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "destination": {
                "description": "A static value for the target. Canâ€™t be set when the dataset or namespace option is set.",
                "type": "string"
              },
              "dataset": {
                "description": "Field references or a static value for the dataset part of the data stream name.\nIn addition to the criteria for index names, cannot contain - and must be no longer than 100 characters.\nExample values are nginx.access and nginx.error.\n\nSupports field references with a mustache-like syntax (denoted as {{double}} or {{{triple}}} curly braces).\nWhen resolving field references, the processor replaces invalid characters with _. Uses the <dataset> part\nof the index name as a fallback if all field references resolve to a null, missing, or non-string value.\n\ndefault {{data_stream.dataset}}",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "namespace": {
                "description": "Field references or a static value for the namespace part of the data stream name. See the criteria for\nindex names for allowed characters. Must be no longer than 100 characters.\n\nSupports field references with a mustache-like syntax (denoted as {{double}} or {{{triple}}} curly braces).\nWhen resolving field references, the processor replaces invalid characters with _. Uses the <namespace> part\nof the index name as a fallback if all field references resolve to a null, missing, or non-string value.\n\ndefault {{data_stream.namespace}}",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "ingest._types:ScriptProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "lang": {
                "description": "Script language.",
                "type": "string"
              },
              "params": {
                "description": "Object containing parameters for the script.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "source": {
                "description": "Inline script.\nIf no `id` is specified, this parameter is required.",
                "type": "string"
              }
            }
          }
        ]
      },
      "ingest._types:SetProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "copy_from": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_empty_value": {
                "description": "If `true` and `value` is a template snippet that evaluates to `null` or the empty string, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "media_type": {
                "description": "The media type for encoding `value`.\nApplies only when value is a template snippet.\nMust be one of `application/json`, `text/plain`, or `application/x-www-form-urlencoded`.",
                "type": "string"
              },
              "override": {
                "description": "If `true` processor will update fields with pre-existing non-null-valued field.\nWhen set to `false`, such fields will not be touched.",
                "type": "boolean"
              },
              "value": {
                "description": "The value to be set for the field.\nSupports template snippets.\nMay specify only one of `value` or `copy_from`.",
                "type": "object"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:SetSecurityUserProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "properties": {
                "description": "Controls what user related properties are added to the field.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:SortProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "order": {
                "$ref": "#/components/schemas/_types:SortOrder"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:SplitProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "preserve_trailing": {
                "description": "Preserves empty trailing fields, if any.",
                "type": "boolean"
              },
              "separator": {
                "description": "A regex which matches the separator, for example, `,` or `\\s+`.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "separator"
            ]
          }
        ]
      },
      "ingest._types:TerminateProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "ingest._types:TrimProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UppercaseProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UrlDecodeProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UriPartsProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "keep_original": {
                "description": "If `true`, the processor copies the unparsed URI to `<target_field>.original`.",
                "type": "boolean"
              },
              "remove_if_successful": {
                "description": "If `true`, the processor removes the `field` after parsing the URI string.\nIf parsing fails, the processor does not remove the `field`.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UserAgentProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "regex_file": {
                "description": "The name of the file in the `config/ingest-user-agent` directory containing the regular expressions for parsing the user agent string. Both the directory and the file have to be created before starting Elasticsearch. If not specified, ingest-user-agent will use the `regexes.yaml` from uap-core it ships with.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "properties": {
                "description": "Controls what properties are added to `target_field`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ingest._types:UserAgentProperty"
                }
              },
              "extract_device_type": {
                "description": "Extracts device type from the user agent string on a best-effort basis.",
                "x-beta": true,
                "type": "boolean"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UserAgentProperty": {
        "type": "string",
        "enum": [
          "name",
          "os",
          "device",
          "original",
          "version"
        ]
      },
      "ingest._types:Document": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_source": {
            "description": "JSON body for the document.",
            "type": "object"
          }
        },
        "required": [
          "_source"
        ]
      },
      "ingest._types:SimulateDocumentResult": {
        "type": "object",
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/ingest._types:DocumentSimulation"
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "processor_results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:PipelineSimulation"
            }
          }
        }
      },
      "ingest._types:DocumentSimulation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_ingest": {
            "$ref": "#/components/schemas/ingest._types:Ingest"
          },
          "_routing": {
            "description": "Value used to send the document to a specific primary shard.",
            "type": "string"
          },
          "_source": {
            "description": "JSON body for the document.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "_version": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedVersionNumber"
          },
          "_version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "_id",
          "_index",
          "_ingest",
          "_source"
        ]
      },
      "ingest._types:Ingest": {
        "type": "object",
        "properties": {
          "_redact": {
            "$ref": "#/components/schemas/ingest._types:Redact"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "pipeline": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "timestamp"
        ]
      },
      "ingest._types:Redact": {
        "type": "object",
        "properties": {
          "_is_redacted": {
            "description": "indicates if document has been redacted",
            "type": "boolean"
          }
        },
        "required": [
          "_is_redacted"
        ]
      },
      "_spec_utils:StringifiedVersionNumber": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          {
            "type": "string"
          }
        ]
      },
      "ingest._types:PipelineSimulation": {
        "type": "object",
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/ingest._types:DocumentSimulation"
          },
          "tag": {
            "type": "string"
          },
          "processor_type": {
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:ActionStatusOptions"
          },
          "description": {
            "type": "string"
          },
          "ignored_error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        }
      },
      "watcher._types:ActionStatusOptions": {
        "type": "string",
        "enum": [
          "success",
          "failure",
          "simulated",
          "throttled"
        ]
      },
      "_global.knn_search._types:Query": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "query_vector": {
            "$ref": "#/components/schemas/_types:QueryVector"
          },
          "k": {
            "description": "The final number of nearest neighbors to return as top hits",
            "type": "number"
          },
          "num_candidates": {
            "description": "The number of nearest neighbor candidates to consider per shard",
            "type": "number"
          }
        },
        "required": [
          "field",
          "query_vector",
          "k",
          "num_candidates"
        ]
      },
      "license.get:LicenseInformation": {
        "type": "object",
        "properties": {
          "expiry_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "expiry_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "issue_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "issue_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "issued_to": {
            "type": "string"
          },
          "issuer": {
            "type": "string"
          },
          "max_nodes": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "max_resource_units": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "status": {
            "$ref": "#/components/schemas/license._types:LicenseStatus"
          },
          "type": {
            "$ref": "#/components/schemas/license._types:LicenseType"
          },
          "uid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "start_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "issue_date",
          "issue_date_in_millis",
          "issued_to",
          "issuer",
          "max_nodes",
          "status",
          "type",
          "uid",
          "start_date_in_millis"
        ]
      },
      "license._types:LicenseStatus": {
        "type": "string",
        "enum": [
          "active",
          "valid",
          "invalid",
          "expired"
        ]
      },
      "license._types:LicenseType": {
        "type": "string",
        "enum": [
          "missing",
          "trial",
          "basic",
          "standard",
          "dev",
          "silver",
          "gold",
          "platinum",
          "enterprise"
        ]
      },
      "license._types:License": {
        "type": "object",
        "properties": {
          "expiry_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "issue_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "start_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "issued_to": {
            "type": "string"
          },
          "issuer": {
            "type": "string"
          },
          "max_nodes": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "max_resource_units": {
            "type": "number"
          },
          "signature": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/license._types:LicenseType"
          },
          "uid": {
            "type": "string"
          }
        },
        "required": [
          "expiry_date_in_millis",
          "issue_date_in_millis",
          "issued_to",
          "issuer",
          "signature",
          "type",
          "uid"
        ]
      },
      "license.post:Acknowledgement": {
        "type": "object",
        "properties": {
          "license": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "message": {
            "type": "string"
          }
        },
        "required": [
          "license",
          "message"
        ]
      },
      "logstash._types:Pipeline": {
        "type": "object",
        "properties": {
          "description": {
            "description": "A description of the pipeline.\nThis description is not used by Elasticsearch or Logstash.",
            "type": "string"
          },
          "last_modified": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "pipeline": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html"
            },
            "description": "The configuration for the pipeline.",
            "type": "string"
          },
          "pipeline_metadata": {
            "$ref": "#/components/schemas/logstash._types:PipelineMetadata"
          },
          "pipeline_settings": {
            "$ref": "#/components/schemas/logstash._types:PipelineSettings"
          },
          "username": {
            "description": "The user who last updated the pipeline.",
            "type": "string"
          }
        },
        "required": [
          "description",
          "last_modified",
          "pipeline",
          "pipeline_metadata",
          "pipeline_settings",
          "username"
        ]
      },
      "logstash._types:PipelineMetadata": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "version"
        ]
      },
      "logstash._types:PipelineSettings": {
        "type": "object",
        "properties": {
          "pipeline.workers": {
            "description": "The number of workers that will, in parallel, execute the filter and output stages of the pipeline.",
            "type": "number"
          },
          "pipeline.batch.size": {
            "description": "The maximum number of events an individual worker thread will collect from inputs before attempting to execute its filters and outputs.",
            "type": "number"
          },
          "pipeline.batch.delay": {
            "description": "When creating pipeline event batches, how long in milliseconds to wait for each event before dispatching an undersized batch to pipeline workers.",
            "type": "number"
          },
          "queue.type": {
            "description": "The internal queuing model to use for event buffering.",
            "type": "string"
          },
          "queue.max_bytes.number": {
            "description": "The total capacity of the queue (`queue.type: persisted`) in number of bytes.",
            "type": "number"
          },
          "queue.max_bytes.units": {
            "description": "The total capacity of the queue (`queue.type: persisted`) in terms of units of bytes.",
            "type": "string"
          },
          "queue.checkpoint.writes": {
            "description": "The maximum number of written events before forcing a checkpoint when persistent queues are enabled (`queue.type: persisted`).",
            "type": "number"
          }
        },
        "required": [
          "pipeline.workers",
          "pipeline.batch.size",
          "pipeline.batch.delay",
          "queue.type",
          "queue.max_bytes.number",
          "queue.max_bytes.units",
          "queue.checkpoint.writes"
        ]
      },
      "_global.mget:Operation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "stored_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "_id"
        ]
      },
      "_global.mget:ResponseItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.get:GetResult"
          },
          {
            "$ref": "#/components/schemas/_global.mget:MultiGetError"
          }
        ]
      },
      "_global.mget:MultiGetError": {
        "type": "object",
        "properties": {
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "error",
          "_id",
          "_index"
        ]
      },
      "migration.deprecations:Deprecation": {
        "type": "object",
        "properties": {
          "details": {
            "description": "Optional details about the deprecation warning.",
            "type": "string"
          },
          "level": {
            "$ref": "#/components/schemas/migration.deprecations:DeprecationLevel"
          },
          "message": {
            "description": "Descriptive information about the deprecation warning.",
            "type": "string"
          },
          "url": {
            "description": "A link to the breaking change documentation, where you can find more information about this change.",
            "type": "string"
          },
          "resolve_during_rolling_upgrade": {
            "type": "boolean"
          },
          "_meta": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "level",
          "message",
          "url",
          "resolve_during_rolling_upgrade"
        ]
      },
      "migration.deprecations:DeprecationLevel": {
        "type": "string",
        "enum": [
          "none",
          "info",
          "warning",
          "critical"
        ]
      },
      "migration.get_feature_upgrade_status:MigrationFeature": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "minimum_index_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "migration_status": {
            "$ref": "#/components/schemas/migration.get_feature_upgrade_status:MigrationStatus"
          },
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/migration.get_feature_upgrade_status:MigrationFeatureIndexInfo"
            }
          }
        },
        "required": [
          "feature_name",
          "minimum_index_version",
          "migration_status",
          "indices"
        ]
      },
      "migration.get_feature_upgrade_status:MigrationStatus": {
        "type": "string",
        "enum": [
          "NO_MIGRATION_NEEDED",
          "MIGRATION_NEEDED",
          "IN_PROGRESS",
          "ERROR"
        ]
      },
      "migration.get_feature_upgrade_status:MigrationFeatureIndexInfo": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "failure_cause": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "index",
          "version"
        ]
      },
      "migration.post_feature_upgrade:MigrationFeature": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          }
        },
        "required": [
          "feature_name"
        ]
      },
      "ml._types:AnalysisConfig": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "categorization_analyzer": {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzer"
          },
          "categorization_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "categorization_filters": {
            "description": "If `categorization_field_name` is specified, you can also define optional filters. This property expects an array of regular expressions. The expressions are used to filter out matching sequences from the categorization field values. You can use this functionality to fine tune the categorization by excluding sequences from consideration when categories are defined. For example, you can exclude SQL statements that appear in your log files. This property cannot be used at the same time as `categorization_analyzer`. If you only want to define simple regular expression filters that are applied prior to tokenization, setting this property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering, use the `categorization_analyzer` property instead and include the filters as pattern_replace character filters. The effect is exactly the same.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "detectors": {
            "description": "Detector configuration objects specify which data fields a job analyzes. They also specify which analytical functions are used. You can specify multiple detectors for a job. If the detectors array does not contain at least one detector, no analysis can occur and an error is returned.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Detector"
            }
          },
          "influencers": {
            "description": "A comma separated list of influencer field names. Typically these can be the by, over, or partition fields that are used in the detector configuration. You might also want to use a field name that is not specifically named in a detector, but is available as part of the input data. When you use multiple detectors, the use of influencers is recommended as it aggregates results for each influencer entity.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          },
          "latency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "model_prune_window": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "multivariate_by_fields": {
            "description": "This functionality is reserved for internal use. It is not supported for use in customer environments and is not subject to the support SLA of official GA features. If set to `true`, the analysis will automatically find correlations between metrics for a given by field value and report anomalies when those correlations cease to hold. For example, suppose CPU and memory usage on host A is usually highly correlated with the same metrics on host B. Perhaps this correlation occurs because they are running a load-balanced application. If you enable this property, anomalies will be reported when, for example, CPU usage on host A is high and the value of CPU usage on host B is low. That is to say, youâ€™ll see an anomaly when the CPU of host A is unusual given the CPU of host B. To use the `multivariate_by_fields` property, you must also specify `by_field_name` in your detector.",
            "type": "boolean"
          },
          "per_partition_categorization": {
            "$ref": "#/components/schemas/ml._types:PerPartitionCategorization"
          },
          "summary_count_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "detectors"
        ]
      },
      "ml._types:CategorizationAnalyzer": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzerDefinition"
          }
        ]
      },
      "ml._types:CategorizationAnalyzerDefinition": {
        "type": "object",
        "properties": {
          "char_filter": {
            "description": "One or more character filters. In addition to the built-in character filters, other plugins can provide more character filters. If this property is not specified, no character filters are applied prior to categorization. If you are customizing some other aspect of the analyzer and you need to achieve the equivalent of `categorization_filters` (which are not permitted when some other aspect of the analyzer is customized), add them here as pattern replace character filters.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.analysis:CharFilter"
            }
          },
          "filter": {
            "description": "One or more token filters. In addition to the built-in token filters, other plugins can provide more token filters. If this property is not specified, no token filters are applied prior to categorization.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.analysis:TokenFilter"
            }
          },
          "tokenizer": {
            "$ref": "#/components/schemas/_types.analysis:Tokenizer"
          }
        }
      },
      "ml._types:Detector": {
        "type": "object",
        "properties": {
          "by_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "custom_rules": {
            "description": "Custom rules enable you to customize the way detectors operate. For example, a rule may dictate conditions under which results should be skipped. Kibana refers to custom rules as job rules.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectionRule"
            }
          },
          "detector_description": {
            "description": "A description of the detector.",
            "type": "string"
          },
          "detector_index": {
            "description": "A unique identifier for the detector. This identifier is based on the order of the detectors in the `analysis_config`, starting at zero. If you specify a value for this property, it is ignored.",
            "type": "number"
          },
          "exclude_frequent": {
            "$ref": "#/components/schemas/ml._types:ExcludeFrequent"
          },
          "field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "function": {
            "description": "The analysis function that is used. For example, `count`, `rare`, `mean`, `min`, `max`, or `sum`.",
            "type": "string"
          },
          "over_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "partition_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "use_null": {
            "description": "Defines whether a new series is used as the null series when there is no value for the by or partition fields.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DetectionRule": {
        "type": "object",
        "properties": {
          "actions": {
            "description": "The set of actions to be triggered when the rule applies. If more than one action is specified the effects of all actions are combined.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:RuleAction"
            }
          },
          "conditions": {
            "description": "An array of numeric conditions when the rule applies. A rule must either have a non-empty scope or at least one condition. Multiple conditions are combined together with a logical AND.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:RuleCondition"
            }
          },
          "scope": {
            "description": "A scope of series where the rule applies. A rule must either have a non-empty scope or at least one condition. By default, the scope includes all series. Scoping is allowed for any of the fields that are also specified in `by_field_name`, `over_field_name`, or `partition_field_name`.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ml._types:FilterRef"
            }
          }
        }
      },
      "ml._types:RuleAction": {
        "type": "string",
        "enum": [
          "skip_result",
          "skip_model_update"
        ]
      },
      "ml._types:RuleCondition": {
        "type": "object",
        "properties": {
          "applies_to": {
            "$ref": "#/components/schemas/ml._types:AppliesTo"
          },
          "operator": {
            "$ref": "#/components/schemas/ml._types:ConditionOperator"
          },
          "value": {
            "description": "The value that is compared against the `applies_to` field using the operator.",
            "type": "number"
          }
        },
        "required": [
          "applies_to",
          "operator",
          "value"
        ]
      },
      "ml._types:AppliesTo": {
        "type": "string",
        "enum": [
          "actual",
          "typical",
          "diff_from_typical",
          "time"
        ]
      },
      "ml._types:ConditionOperator": {
        "type": "string",
        "enum": [
          "gt",
          "gte",
          "lt",
          "lte"
        ]
      },
      "ml._types:FilterRef": {
        "type": "object",
        "properties": {
          "filter_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "filter_type": {
            "$ref": "#/components/schemas/ml._types:FilterType"
          }
        },
        "required": [
          "filter_id"
        ]
      },
      "ml._types:FilterType": {
        "type": "string",
        "enum": [
          "include",
          "exclude"
        ]
      },
      "ml._types:ExcludeFrequent": {
        "type": "string",
        "enum": [
          "all",
          "none",
          "by",
          "over"
        ]
      },
      "ml._types:PerPartitionCategorization": {
        "type": "object",
        "properties": {
          "enabled": {
            "description": "To enable this setting, you must also set the `partition_field_name` property to the same value in every detector that uses the keyword `mlcategory`. Otherwise, job creation fails.",
            "type": "boolean"
          },
          "stop_on_warn": {
            "description": "This setting can be set to true only if per-partition categorization is enabled. If true, both categorization and subsequent anomaly detection stops for partitions where the categorization status changes to warn. This setting makes it viable to have a job where it is expected that categorization works well for some partitions but not others; you do not pay the cost of bad categorization forever in the partitions where it works badly.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeEvaluationContainer": {
        "type": "object",
        "properties": {
          "classification": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationClassification"
          },
          "outlier_detection": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationOutlierDetection"
          },
          "regression": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegression"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeEvaluationClassification": {
        "type": "object",
        "properties": {
          "actual_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "predicted_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "top_classes_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationClassificationMetrics"
          }
        },
        "required": [
          "actual_field"
        ]
      },
      "ml._types:DataframeEvaluationClassificationMetrics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationMetrics"
          },
          {
            "type": "object",
            "properties": {
              "accuracy": {
                "description": "Accuracy of predictions (per-class and overall).",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "multiclass_confusion_matrix": {
                "description": "Multiclass confusion matrix.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              }
            }
          }
        ]
      },
      "ml._types:DataframeEvaluationMetrics": {
        "type": "object",
        "properties": {
          "auc_roc": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationClassificationMetricsAucRoc"
          },
          "precision": {
            "description": "Precision of predictions (per-class and average).",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "recall": {
            "description": "Recall of predictions (per-class and average).",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        }
      },
      "ml._types:DataframeEvaluationClassificationMetricsAucRoc": {
        "type": "object",
        "properties": {
          "class_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "include_curve": {
            "description": "Whether or not the curve should be returned in addition to the score. Default value is false.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeEvaluationOutlierDetection": {
        "type": "object",
        "properties": {
          "actual_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "predicted_probability_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationOutlierDetectionMetrics"
          }
        },
        "required": [
          "actual_field",
          "predicted_probability_field"
        ]
      },
      "ml._types:DataframeEvaluationOutlierDetectionMetrics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationMetrics"
          },
          {
            "type": "object",
            "properties": {
              "confusion_matrix": {
                "description": "Accuracy of predictions (per-class and overall).",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              }
            }
          }
        ]
      },
      "ml._types:DataframeEvaluationRegression": {
        "type": "object",
        "properties": {
          "actual_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "predicted_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegressionMetrics"
          }
        },
        "required": [
          "actual_field",
          "predicted_field"
        ]
      },
      "ml._types:DataframeEvaluationRegressionMetrics": {
        "type": "object",
        "properties": {
          "mse": {
            "description": "Average squared difference between the predicted values and the actual (ground truth) value. For more information, read this wiki article.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "msle": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegressionMetricsMsle"
          },
          "huber": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegressionMetricsHuber"
          },
          "r_squared": {
            "description": "Proportion of the variance in the dependent variable that is predictable from the independent variables.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        }
      },
      "ml._types:DataframeEvaluationRegressionMetricsMsle": {
        "type": "object",
        "properties": {
          "offset": {
            "description": "Defines the transition point at which you switch from minimizing quadratic error to minimizing quadratic log error. Defaults to 1.",
            "type": "number"
          }
        }
      },
      "ml._types:DataframeEvaluationRegressionMetricsHuber": {
        "type": "object",
        "properties": {
          "delta": {
            "description": "Approximates 1/2 (prediction - actual)2 for values much less than delta and approximates a straight line with slope delta for values much larger than delta. Defaults to 1. Delta needs to be greater than 0.",
            "type": "number"
          }
        }
      },
      "ml.evaluate_data_frame:DataframeClassificationSummary": {
        "type": "object",
        "properties": {
          "auc_roc": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationSummaryAucRoc"
          },
          "accuracy": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryAccuracy"
          },
          "multiclass_confusion_matrix": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryMulticlassConfusionMatrix"
          },
          "precision": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryPrecision"
          },
          "recall": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryRecall"
          }
        }
      },
      "ml.evaluate_data_frame:DataframeEvaluationSummaryAucRoc": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          {
            "type": "object",
            "properties": {
              "curve": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationSummaryAucRocCurveItem"
                }
              }
            }
          }
        ]
      },
      "ml.evaluate_data_frame:DataframeEvaluationSummaryAucRocCurveItem": {
        "type": "object",
        "properties": {
          "tpr": {
            "type": "number"
          },
          "fpr": {
            "type": "number"
          },
          "threshold": {
            "type": "number"
          }
        },
        "required": [
          "tpr",
          "fpr",
          "threshold"
        ]
      },
      "ml.evaluate_data_frame:DataframeEvaluationValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number"
          }
        },
        "required": [
          "value"
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryAccuracy": {
        "type": "object",
        "properties": {
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationClass"
            }
          },
          "overall_accuracy": {
            "type": "number"
          }
        },
        "required": [
          "classes",
          "overall_accuracy"
        ]
      },
      "ml.evaluate_data_frame:DataframeEvaluationClass": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          {
            "type": "object",
            "properties": {
              "class_name": {
                "$ref": "#/components/schemas/_types:Name"
              }
            },
            "required": [
              "class_name"
            ]
          }
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryMulticlassConfusionMatrix": {
        "type": "object",
        "properties": {
          "confusion_matrix": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:ConfusionMatrixItem"
            }
          },
          "other_actual_class_count": {
            "type": "number"
          }
        },
        "required": [
          "confusion_matrix",
          "other_actual_class_count"
        ]
      },
      "ml.evaluate_data_frame:ConfusionMatrixItem": {
        "type": "object",
        "properties": {
          "actual_class": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "actual_class_doc_count": {
            "type": "number"
          },
          "predicted_classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:ConfusionMatrixPrediction"
            }
          },
          "other_predicted_class_doc_count": {
            "type": "number"
          }
        },
        "required": [
          "actual_class",
          "actual_class_doc_count",
          "predicted_classes",
          "other_predicted_class_doc_count"
        ]
      },
      "ml.evaluate_data_frame:ConfusionMatrixPrediction": {
        "type": "object",
        "properties": {
          "predicted_class": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "count": {
            "type": "number"
          }
        },
        "required": [
          "predicted_class",
          "count"
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryPrecision": {
        "type": "object",
        "properties": {
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationClass"
            }
          },
          "avg_precision": {
            "type": "number"
          }
        },
        "required": [
          "classes",
          "avg_precision"
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryRecall": {
        "type": "object",
        "properties": {
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationClass"
            }
          },
          "avg_recall": {
            "type": "number"
          }
        },
        "required": [
          "classes",
          "avg_recall"
        ]
      },
      "ml.evaluate_data_frame:DataframeOutlierDetectionSummary": {
        "type": "object",
        "properties": {
          "auc_roc": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationSummaryAucRoc"
          },
          "precision": {
            "description": "Set the different thresholds of the outlier score at where the metric is calculated.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "recall": {
            "description": "Set the different thresholds of the outlier score at where the metric is calculated.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "confusion_matrix": {
            "description": "Set the different thresholds of the outlier score at where the metrics (`tp` - true positive, `fp` - false positive, `tn` - true negative, `fn` - false negative) are calculated.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:ConfusionMatrixThreshold"
            }
          }
        }
      },
      "ml.evaluate_data_frame:ConfusionMatrixThreshold": {
        "type": "object",
        "properties": {
          "tp": {
            "description": "True Positive",
            "type": "number"
          },
          "fp": {
            "description": "False Positive",
            "type": "number"
          },
          "tn": {
            "description": "True Negative",
            "type": "number"
          },
          "fn": {
            "description": "False Negative",
            "type": "number"
          }
        },
        "required": [
          "tp",
          "fp",
          "tn",
          "fn"
        ]
      },
      "ml.evaluate_data_frame:DataframeRegressionSummary": {
        "type": "object",
        "properties": {
          "huber": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          "mse": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          "msle": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          "r_squared": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          }
        }
      },
      "ml._types:DataframeAnalyticsSource": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "_source": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:DataframeAnalysisAnalyzedFields": {
        "type": "object",
        "properties": {
          "includes": {
            "description": "An array of strings that defines the fields that will be excluded from the analysis. You do not need to add fields with unsupported data types to excludes, these fields are excluded from the analysis automatically.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "excludes": {
            "description": "An array of strings that defines the fields that will be included in the analysis.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "includes",
          "excludes"
        ]
      },
      "ml._types:DataframeAnalyticsDestination": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:DataframeAnalysisContainer": {
        "type": "object",
        "properties": {
          "classification": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisClassification"
          },
          "outlier_detection": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisOutlierDetection"
          },
          "regression": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisRegression"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeAnalysisClassification": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysis"
          },
          {
            "type": "object",
            "properties": {
              "class_assignment_objective": {
                "type": "string"
              },
              "num_top_classes": {
                "description": "Defines the number of categories for which the predicted probabilities are reported. It must be non-negative or -1. If it is -1 or greater than the total number of categories, probabilities are reported for all categories; if you have a large number of categories, there could be a significant effect on the size of your destination index. NOTE: To use the AUC ROC evaluation method, `num_top_classes` must be set to -1 or a value greater than or equal to the total number of categories.",
                "type": "number"
              }
            }
          }
        ]
      },
      "ml._types:DataframeAnalysis": {
        "type": "object",
        "properties": {
          "alpha": {
            "description": "Advanced configuration option. Machine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly. This parameter affects loss calculations by acting as a multiplier of the tree depth. Higher alpha values result in shallower trees and faster training times. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to zero.",
            "type": "number"
          },
          "dependent_variable": {
            "description": "Defines which field of the document is to be predicted. It must match one of the fields in the index being used to train. If this field is missing from a document, then that document will not be used for training, but a prediction with the trained model will be generated for it. It is also known as continuous target variable.\nFor classification analysis, the data type of the field must be numeric (`integer`, `short`, `long`, `byte`), categorical (`ip` or `keyword`), or `boolean`. There must be no more than 30 different values in this field.\nFor regression analysis, the data type of the field must be numeric.",
            "type": "string"
          },
          "downsample_factor": {
            "description": "Advanced configuration option. Controls the fraction of data that is used to compute the derivatives of the loss function for tree training. A small value results in the use of a small fraction of the data. If this value is set to be less than 1, accuracy typically improves. However, too small a value may result in poor convergence for the ensemble and so require more trees. By default, this value is calculated during hyperparameter optimization. It must be greater than zero and less than or equal to 1.",
            "type": "number"
          },
          "early_stopping_enabled": {
            "description": "Advanced configuration option. Specifies whether the training process should finish if it is not finding any better performing models. If disabled, the training process can take significantly longer and the chance of finding a better performing model is unremarkable.",
            "type": "boolean"
          },
          "eta": {
            "description": "Advanced configuration option. The shrinkage applied to the weights. Smaller values result in larger forests which have a better generalization error. However, larger forests cause slower training. By default, this value is calculated during hyperparameter optimization. It must be a value between 0.001 and 1.",
            "type": "number"
          },
          "eta_growth_rate_per_tree": {
            "description": "Advanced configuration option. Specifies the rate at which `eta` increases for each new tree that is added to the forest. For example, a rate of 1.05 increases `eta` by 5% for each extra tree. By default, this value is calculated during hyperparameter optimization. It must be between 0.5 and 2.",
            "type": "number"
          },
          "feature_bag_fraction": {
            "description": "Advanced configuration option. Defines the fraction of features that will be used when selecting a random bag for each candidate split. By default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "feature_processors": {
            "description": "Advanced configuration option. A collection of feature preprocessors that modify one or more included fields. The analysis uses the resulting one or more features instead of the original document field. However, these features are ephemeral; they are not stored in the destination index. Multiple `feature_processors` entries can refer to the same document fields. Automatic categorical feature encoding still occurs for the fields that are unprocessed by a custom processor or that have categorical values. Use this property only if you want to override the automatic feature encoding of the specified fields.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessor"
            }
          },
          "gamma": {
            "description": "Advanced configuration option. Regularization parameter to prevent overfitting on the training data set. Multiplies a linear penalty associated with the size of individual trees in the forest. A high gamma value causes training to prefer small trees. A small gamma value results in larger individual trees and slower training. By default, this value is calculated during hyperparameter optimization. It must be a nonnegative value.",
            "type": "number"
          },
          "lambda": {
            "description": "Advanced configuration option. Regularization parameter to prevent overfitting on the training data set. Multiplies an L2 regularization term which applies to leaf weights of the individual trees in the forest. A high lambda value causes training to favor small leaf weights. This behavior makes the prediction function smoother at the expense of potentially not being able to capture relevant relationships between the features and the dependent variable. A small lambda value results in large individual trees and slower training. By default, this value is calculated during hyperparameter optimization. It must be a nonnegative value.",
            "type": "number"
          },
          "max_optimization_rounds_per_hyperparameter": {
            "description": "Advanced configuration option. A multiplier responsible for determining the maximum number of hyperparameter optimization steps in the Bayesian optimization procedure. The maximum number of steps is determined based on the number of undefined hyperparameters times the maximum optimization rounds per hyperparameter. By default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "max_trees": {
            "description": "Advanced configuration option. Defines the maximum number of decision trees in the forest. The maximum value is 2000. By default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "num_top_feature_importance_values": {
            "description": "Advanced configuration option. Specifies the maximum number of feature importance values per document to return. By default, no feature importance calculation occurs.",
            "type": "number"
          },
          "prediction_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "randomize_seed": {
            "description": "Defines the seed for the random generator that is used to pick training data. By default, it is randomly generated. Set it to a specific value to use the same training data each time you start a job (assuming other related parameters such as `source` and `analyzed_fields` are the same).",
            "type": "number"
          },
          "soft_tree_depth_limit": {
            "description": "Advanced configuration option. Machine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly. This soft limit combines with the `soft_tree_depth_tolerance` to penalize trees that exceed the specified depth; the regularized loss increases quickly beyond this depth. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to 0.",
            "type": "number"
          },
          "soft_tree_depth_tolerance": {
            "description": "Advanced configuration option. This option controls how quickly the regularized loss increases when the tree depth exceeds `soft_tree_depth_limit`. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to 0.01.",
            "type": "number"
          },
          "training_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          }
        },
        "required": [
          "dependent_variable"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessor": {
        "type": "object",
        "properties": {
          "frequency_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorFrequencyEncoding"
          },
          "multi_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorMultiEncoding"
          },
          "n_gram_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorNGramEncoding"
          },
          "one_hot_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorOneHotEncoding"
          },
          "target_mean_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorTargetMeanEncoding"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeAnalysisFeatureProcessorFrequencyEncoding": {
        "type": "object",
        "properties": {
          "feature_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "frequency_map": {
            "description": "The resulting frequency map for the field value. If the field value is missing from the frequency_map, the resulting value is 0.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "feature_name",
          "field",
          "frequency_map"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorMultiEncoding": {
        "type": "object",
        "properties": {
          "processors": {
            "description": "The ordered array of custom processors to execute. Must be more than 1.",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "processors"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorNGramEncoding": {
        "type": "object",
        "properties": {
          "feature_prefix": {
            "description": "The feature name prefix. Defaults to ngram_<start>_<length>.",
            "type": "string"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "length": {
            "description": "Specifies the length of the n-gram substring. Defaults to 50. Must be greater than 0.",
            "type": "number"
          },
          "n_grams": {
            "description": "Specifies which n-grams to gather. Itâ€™s an array of integer values where the minimum value is 1, and a maximum value is 5.",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "start": {
            "description": "Specifies the zero-indexed start of the n-gram substring. Negative values are allowed for encoding n-grams of string suffixes. Defaults to 0.",
            "type": "number"
          },
          "custom": {
            "type": "boolean"
          }
        },
        "required": [
          "field",
          "n_grams"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorOneHotEncoding": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "hot_map": {
            "description": "The one hot map mapping the field value with the column name.",
            "type": "string"
          }
        },
        "required": [
          "field",
          "hot_map"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorTargetMeanEncoding": {
        "type": "object",
        "properties": {
          "default_value": {
            "description": "The default value if field value is not found in the target_map.",
            "type": "number"
          },
          "feature_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "target_map": {
            "description": "The field value to target mean transition map.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "default_value",
          "feature_name",
          "field",
          "target_map"
        ]
      },
      "ml._types:DataframeAnalysisOutlierDetection": {
        "type": "object",
        "properties": {
          "compute_feature_influence": {
            "description": "Specifies whether the feature influence calculation is enabled.",
            "type": "boolean"
          },
          "feature_influence_threshold": {
            "description": "The minimum outlier score that a document needs to have in order to calculate its feature influence score. Value range: 0-1.",
            "type": "number"
          },
          "method": {
            "description": "The method that outlier detection uses. Available methods are `lof`, `ldof`, `distance_kth_nn`, `distance_knn`, and `ensemble`. The default value is ensemble, which means that outlier detection uses an ensemble of different methods and normalises and combines their individual outlier scores to obtain the overall outlier score.",
            "type": "string"
          },
          "n_neighbors": {
            "description": "Defines the value for how many nearest neighbors each method of outlier detection uses to calculate its outlier score. When the value is not set, different values are used for different ensemble members. This default behavior helps improve the diversity in the ensemble; only override it if you are confident that the value you choose is appropriate for the data set.",
            "type": "number"
          },
          "outlier_fraction": {
            "description": "The proportion of the data set that is assumed to be outlying prior to outlier detection. For example, 0.05 means it is assumed that 5% of values are real outliers and 95% are inliers.",
            "type": "number"
          },
          "standardization_enabled": {
            "description": "If true, the following operation is performed on the columns before computing outlier scores: `(x_i - mean(x_i)) / sd(x_i)`.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeAnalysisRegression": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysis"
          },
          {
            "type": "object",
            "properties": {
              "loss_function": {
                "description": "The loss function used during regression. Available options are `mse` (mean squared error), `msle` (mean squared logarithmic error), `huber` (Pseudo-Huber loss).",
                "type": "string"
              },
              "loss_function_parameter": {
                "description": "A positive number that is used as a parameter to the `loss_function`.",
                "type": "number"
              }
            }
          }
        ]
      },
      "ml._types:DataframeAnalyticsFieldSelection": {
        "type": "object",
        "properties": {
          "is_included": {
            "description": "Whether the field is selected to be included in the analysis.",
            "type": "boolean"
          },
          "is_required": {
            "description": "Whether the field is required.",
            "type": "boolean"
          },
          "feature_type": {
            "description": "The feature type of this field for the analysis. May be categorical or numerical.",
            "type": "string"
          },
          "mapping_types": {
            "description": "The mapping types of the field.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "reason": {
            "description": "The reason a field is not selected to be included in the analysis.",
            "type": "string"
          }
        },
        "required": [
          "is_included",
          "is_required",
          "mapping_types",
          "name"
        ]
      },
      "ml._types:DataframeAnalyticsMemoryEstimation": {
        "type": "object",
        "properties": {
          "expected_memory_with_disk": {
            "description": "Estimated memory usage under the assumption that overflowing to disk is allowed during data frame analytics. expected_memory_with_disk is usually smaller than expected_memory_without_disk as using disk allows to limit the main memory needed to perform data frame analytics.",
            "type": "string"
          },
          "expected_memory_without_disk": {
            "description": "Estimated memory usage under the assumption that the whole data frame analytics should happen in memory (i.e. without overflowing to disk).",
            "type": "string"
          }
        },
        "required": [
          "expected_memory_with_disk",
          "expected_memory_without_disk"
        ]
      },
      "ml._types:Page": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Skips the specified number of items.",
            "type": "number"
          },
          "size": {
            "description": "Specifies the maximum number of items to obtain.",
            "type": "number"
          }
        }
      },
      "ml._types:BucketSummary": {
        "type": "object",
        "properties": {
          "anomaly_score": {
            "description": "The maximum anomaly score, between 0-100, for any of the bucket influencers. This is an overall, rate-limited\nscore for the job. All the anomaly records in the bucket contribute to this score. This value might be updated as\nnew data is analyzed.",
            "type": "number"
          },
          "bucket_influencers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:BucketInfluencer"
            }
          },
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "event_count": {
            "description": "The number of input data records processed in this bucket.",
            "type": "number"
          },
          "initial_anomaly_score": {
            "description": "The maximum anomaly score for any of the bucket influencers. This is the initial value that was calculated at the\ntime the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "result_type": {
            "description": "Internal. This value is always set to bucket.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "anomaly_score",
          "bucket_influencers",
          "bucket_span",
          "event_count",
          "initial_anomaly_score",
          "is_interim",
          "job_id",
          "processing_time_ms",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:BucketInfluencer": {
        "type": "object",
        "properties": {
          "anomaly_score": {
            "description": "A normalized score between 0-100, which is calculated for each bucket influencer. This score might be updated as\nnewer data is analyzed.",
            "type": "number"
          },
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "influencer_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "initial_anomaly_score": {
            "description": "The score between 0-100 for each bucket influencer. This score is the initial value that was calculated at the\ntime the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "probability": {
            "description": "The probability that the bucket has this behavior, in the range 0 to 1. This value can be held to a high precision\nof over 300 decimal places, so the `anomaly_score` is provided as a human-readable and friendly interpretation of\nthis.",
            "type": "number"
          },
          "raw_anomaly_score": {
            "description": "Internal.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This value is always set to `bucket_influencer`.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "anomaly_score",
          "bucket_span",
          "influencer_field_name",
          "initial_anomaly_score",
          "is_interim",
          "job_id",
          "probability",
          "raw_anomaly_score",
          "result_type",
          "timestamp"
        ]
      },
      "_types:DurationValueUnitSeconds": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitSeconds"
          }
        ]
      },
      "ml._types:CalendarEvent": {
        "type": "object",
        "properties": {
          "calendar_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "event_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "description": {
            "description": "A description of the scheduled event.",
            "type": "string"
          },
          "end_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "description",
          "end_time",
          "start_time"
        ]
      },
      "ml.get_calendars:Calendar": {
        "type": "object",
        "properties": {
          "calendar_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "description": {
            "description": "A description of the calendar.",
            "type": "string"
          },
          "job_ids": {
            "description": "An array of anomaly detection job identifiers.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          }
        },
        "required": [
          "calendar_id",
          "job_ids"
        ]
      },
      "_types:CategoryId": {
        "type": "string"
      },
      "ml._types:Category": {
        "type": "object",
        "properties": {
          "category_id": {
            "$ref": "#/components/schemas/_types:ulong"
          },
          "examples": {
            "description": "A list of examples of actual values that matched the category.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "grok_pattern": {
            "$ref": "#/components/schemas/_types:GrokPattern"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_matching_length": {
            "$ref": "#/components/schemas/_types:ulong"
          },
          "partition_field_name": {
            "description": "If per-partition categorization is enabled, this property identifies the field used to segment the categorization. It is not present when per-partition categorization is disabled.",
            "type": "string"
          },
          "partition_field_value": {
            "description": "If per-partition categorization is enabled, this property identifies the value of the partition_field_name for the category. It is not present when per-partition categorization is disabled.",
            "type": "string"
          },
          "regex": {
            "description": "A regular expression that is used to search for values that match the category.",
            "type": "string"
          },
          "terms": {
            "description": "A space separated list of the common tokens that are matched in values of the category.",
            "type": "string"
          },
          "num_matches": {
            "description": "The number of messages that have been matched by this category. This is only guaranteed to have the latest accurate count after a job _flush or _close",
            "type": "number"
          },
          "preferred_to_categories": {
            "description": "A list of category_id entries that this current category encompasses. Any new message that is processed by the categorizer will match against this category and not any of the categories in this list. This is only guaranteed to have the latest accurate list of categories after a job _flush or _close",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "p": {
            "type": "string"
          },
          "result_type": {
            "type": "string"
          },
          "mlcategory": {
            "type": "string"
          }
        },
        "required": [
          "category_id",
          "examples",
          "job_id",
          "max_matching_length",
          "regex",
          "terms",
          "result_type",
          "mlcategory"
        ]
      },
      "ml._types:DataframeAnalyticsSummary": {
        "type": "object",
        "properties": {
          "allow_lazy_start": {
            "type": "boolean"
          },
          "analysis": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
          },
          "analyzed_fields": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
          },
          "authorization": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsAuthorization"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "description": {
            "type": "string"
          },
          "dest": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_num_threads": {
            "type": "number"
          },
          "model_memory_limit": {
            "type": "string"
          },
          "source": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "analysis",
          "dest",
          "id",
          "source"
        ]
      },
      "ml._types:DataframeAnalyticsAuthorization": {
        "type": "object",
        "properties": {
          "api_key": {
            "$ref": "#/components/schemas/ml._types:ApiKeyAuthorization"
          },
          "roles": {
            "description": "If a user ID was used for the most recent update to the job, its roles at the time of the update are listed in the response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "service_account": {
            "description": "If a service account was used for the most recent update to the job, the account name is listed in the response.",
            "type": "string"
          }
        }
      },
      "ml._types:ApiKeyAuthorization": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The identifier for the API key.",
            "type": "string"
          },
          "name": {
            "description": "The name of the API key.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "ml._types:DataframeAnalytics": {
        "type": "object",
        "properties": {
          "analysis_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsContainer"
          },
          "assignment_explanation": {
            "description": "For running jobs only, contains messages relating to the selection of a node to run the job.",
            "type": "string"
          },
          "data_counts": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsDataCounts"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "memory_usage": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsMemoryUsage"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeAttributes"
          },
          "progress": {
            "description": "The progress report of the data frame analytics job by phase.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsProgress"
            }
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DataframeState"
          }
        },
        "required": [
          "data_counts",
          "id",
          "memory_usage",
          "progress",
          "state"
        ]
      },
      "ml._types:DataframeAnalyticsStatsContainer": {
        "type": "object",
        "properties": {
          "classification_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsHyperparameters"
          },
          "outlier_detection_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsOutlierDetection"
          },
          "regression_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsHyperparameters"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeAnalyticsStatsHyperparameters": {
        "type": "object",
        "properties": {
          "hyperparameters": {
            "$ref": "#/components/schemas/ml._types:Hyperparameters"
          },
          "iteration": {
            "description": "The number of iterations on the analysis.",
            "type": "number"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:TimingStats"
          },
          "validation_loss": {
            "$ref": "#/components/schemas/ml._types:ValidationLoss"
          }
        },
        "required": [
          "hyperparameters",
          "iteration",
          "timestamp",
          "timing_stats",
          "validation_loss"
        ]
      },
      "ml._types:Hyperparameters": {
        "type": "object",
        "properties": {
          "alpha": {
            "description": "Advanced configuration option.\nMachine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly.\nThis parameter affects loss calculations by acting as a multiplier of the tree depth.\nHigher alpha values result in shallower trees and faster training times.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to zero.",
            "type": "number"
          },
          "lambda": {
            "description": "Advanced configuration option.\nRegularization parameter to prevent overfitting on the training data set.\nMultiplies an L2 regularization term which applies to leaf weights of the individual trees in the forest.\nA high lambda value causes training to favor small leaf weights.\nThis behavior makes the prediction function smoother at the expense of potentially not being able to capture relevant relationships between the features and the dependent variable.\nA small lambda value results in large individual trees and slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a nonnegative value.",
            "type": "number"
          },
          "gamma": {
            "description": "Advanced configuration option.\nRegularization parameter to prevent overfitting on the training data set.\nMultiplies a linear penalty associated with the size of individual trees in the forest.\nA high gamma value causes training to prefer small trees.\nA small gamma value results in larger individual trees and slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a nonnegative value.",
            "type": "number"
          },
          "eta": {
            "description": "Advanced configuration option.\nThe shrinkage applied to the weights.\nSmaller values result in larger forests which have a better generalization error.\nHowever, larger forests cause slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a value between `0.001` and `1`.",
            "type": "number"
          },
          "eta_growth_rate_per_tree": {
            "description": "Advanced configuration option.\nSpecifies the rate at which `eta` increases for each new tree that is added to the forest.\nFor example, a rate of 1.05 increases `eta` by 5% for each extra tree.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be between `0.5` and `2`.",
            "type": "number"
          },
          "feature_bag_fraction": {
            "description": "Advanced configuration option.\nDefines the fraction of features that will be used when selecting a random bag for each candidate split.\nBy default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "downsample_factor": {
            "description": "Advanced configuration option.\nControls the fraction of data that is used to compute the derivatives of the loss function for tree training.\nA small value results in the use of a small fraction of the data.\nIf this value is set to be less than 1, accuracy typically improves.\nHowever, too small a value may result in poor convergence for the ensemble and so require more trees.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than zero and less than or equal to 1.",
            "type": "number"
          },
          "max_attempts_to_add_tree": {
            "description": "If the algorithm fails to determine a non-trivial tree (more than a single leaf), this parameter determines how many of such consecutive failures are tolerated.\nOnce the number of attempts exceeds the threshold, the forest training stops.",
            "type": "number"
          },
          "max_optimization_rounds_per_hyperparameter": {
            "description": "Advanced configuration option.\nA multiplier responsible for determining the maximum number of hyperparameter optimization steps in the Bayesian optimization procedure.\nThe maximum number of steps is determined based on the number of undefined hyperparameters times the maximum optimization rounds per hyperparameter.\nBy default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "max_trees": {
            "description": "Advanced configuration option.\nDefines the maximum number of decision trees in the forest.\nThe maximum value is 2000.\nBy default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "num_folds": {
            "description": "The maximum number of folds for the cross-validation procedure.",
            "type": "number"
          },
          "num_splits_per_feature": {
            "description": "Determines the maximum number of splits for every feature that can occur in a decision tree when the tree is trained.",
            "type": "number"
          },
          "soft_tree_depth_limit": {
            "description": "Advanced configuration option.\nMachine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly.\nThis soft limit combines with the `soft_tree_depth_tolerance` to penalize trees that exceed the specified depth; the regularized loss increases quickly beyond this depth.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to 0.",
            "type": "number"
          },
          "soft_tree_depth_tolerance": {
            "description": "Advanced configuration option.\nThis option controls how quickly the regularized loss increases when the tree depth exceeds `soft_tree_depth_limit`.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to 0.01.",
            "type": "number"
          }
        }
      },
      "ml._types:TimingStats": {
        "type": "object",
        "properties": {
          "elapsed_time": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "iteration_time": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "elapsed_time"
        ]
      },
      "ml._types:ValidationLoss": {
        "type": "object",
        "properties": {
          "fold_values": {
            "description": "Validation loss values for every added decision tree during the forest growing procedure.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "loss_type": {
            "description": "The type of the loss metric. For example, binomial_logistic.",
            "type": "string"
          }
        },
        "required": [
          "fold_values",
          "loss_type"
        ]
      },
      "ml._types:DataframeAnalyticsStatsOutlierDetection": {
        "type": "object",
        "properties": {
          "parameters": {
            "$ref": "#/components/schemas/ml._types:OutlierDetectionParameters"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:TimingStats"
          }
        },
        "required": [
          "parameters",
          "timestamp",
          "timing_stats"
        ]
      },
      "ml._types:OutlierDetectionParameters": {
        "type": "object",
        "properties": {
          "compute_feature_influence": {
            "description": "Specifies whether the feature influence calculation is enabled.",
            "type": "boolean"
          },
          "feature_influence_threshold": {
            "description": "The minimum outlier score that a document needs to have in order to calculate its feature influence score.\nValue range: 0-1",
            "type": "number"
          },
          "method": {
            "description": "The method that outlier detection uses.\nAvailable methods are `lof`, `ldof`, `distance_kth_nn`, `distance_knn`, and `ensemble`.\nThe default value is ensemble, which means that outlier detection uses an ensemble of different methods and normalises and combines their individual outlier scores to obtain the overall outlier score.",
            "type": "string"
          },
          "n_neighbors": {
            "description": "Defines the value for how many nearest neighbors each method of outlier detection uses to calculate its outlier score.\nWhen the value is not set, different values are used for different ensemble members.\nThis default behavior helps improve the diversity in the ensemble; only override it if you are confident that the value you choose is appropriate for the data set.",
            "type": "number"
          },
          "outlier_fraction": {
            "description": "The proportion of the data set that is assumed to be outlying prior to outlier detection.\nFor example, 0.05 means it is assumed that 5% of values are real outliers and 95% are inliers.",
            "type": "number"
          },
          "standardization_enabled": {
            "description": "If `true`, the following operation is performed on the columns before computing outlier scores: (x_i - mean(x_i)) / sd(x_i).",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeAnalyticsStatsDataCounts": {
        "type": "object",
        "properties": {
          "skipped_docs_count": {
            "description": "The number of documents that are skipped during the analysis because they contained values that are not supported by the analysis. For example, outlier detection does not support missing fields so it skips documents with missing fields. Likewise, all types of analysis skip documents that contain arrays with more than one element.",
            "type": "number"
          },
          "test_docs_count": {
            "description": "The number of documents that are not used for training the model and can be used for testing.",
            "type": "number"
          },
          "training_docs_count": {
            "description": "The number of documents that are used for training the model.",
            "type": "number"
          }
        },
        "required": [
          "skipped_docs_count",
          "test_docs_count",
          "training_docs_count"
        ]
      },
      "ml._types:DataframeAnalyticsStatsMemoryUsage": {
        "type": "object",
        "properties": {
          "memory_reestimate_bytes": {
            "description": "This value is present when the status is hard_limit and it is a new estimate of how much memory the job needs.",
            "type": "number"
          },
          "peak_usage_bytes": {
            "description": "The number of bytes used at the highest peak of memory usage.",
            "type": "number"
          },
          "status": {
            "description": "The memory usage status.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "peak_usage_bytes",
          "status"
        ]
      },
      "_types:NodeAttributes": {
        "type": "object",
        "properties": {
          "attributes": {
            "description": "Lists node attributes.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "name": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          }
        },
        "required": [
          "attributes",
          "ephemeral_id",
          "name",
          "transport_address"
        ]
      },
      "ml._types:DataframeAnalyticsStatsProgress": {
        "type": "object",
        "properties": {
          "phase": {
            "description": "Defines the phase of the data frame analytics job.",
            "type": "string"
          },
          "progress_percent": {
            "description": "The progress that the data frame analytics job has made expressed in percentage.",
            "type": "number"
          }
        },
        "required": [
          "phase",
          "progress_percent"
        ]
      },
      "ml._types:DataframeState": {
        "type": "string",
        "enum": [
          "started",
          "stopped",
          "starting",
          "stopping",
          "failed"
        ]
      },
      "ml._types:DatafeedStats": {
        "type": "object",
        "properties": {
          "assignment_explanation": {
            "description": "For started datafeeds only, contains messages relating to the selection of a node.",
            "type": "string"
          },
          "datafeed_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node": {
            "$ref": "#/components/schemas/ml._types:DiscoveryNodeCompact"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DatafeedState"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:DatafeedTimingStats"
          },
          "running_state": {
            "$ref": "#/components/schemas/ml._types:DatafeedRunningState"
          }
        },
        "required": [
          "datafeed_id",
          "state"
        ]
      },
      "ml._types:DiscoveryNodeCompact": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "name",
          "ephemeral_id",
          "id",
          "transport_address",
          "attributes"
        ]
      },
      "ml._types:DatafeedTimingStats": {
        "type": "object",
        "properties": {
          "bucket_count": {
            "description": "The number of buckets processed.",
            "type": "number"
          },
          "exponential_average_search_time_per_hour_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "exponential_average_calculation_context": {
            "$ref": "#/components/schemas/ml._types:ExponentialAverageCalculationContext"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "search_count": {
            "description": "The number of searches run by the datafeed.",
            "type": "number"
          },
          "total_search_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "average_search_time_per_bucket_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          }
        },
        "required": [
          "bucket_count",
          "exponential_average_search_time_per_hour_ms",
          "job_id",
          "search_count",
          "total_search_time_ms"
        ]
      },
      "_types:DurationValueUnitFloatMillis": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitFloatMillis"
          }
        ]
      },
      "_types:UnitFloatMillis": {
        "description": "Time unit for fractional milliseconds",
        "type": "number"
      },
      "ml._types:ExponentialAverageCalculationContext": {
        "type": "object",
        "properties": {
          "incremental_metric_value_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "latest_timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "previous_exponential_average_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          }
        },
        "required": [
          "incremental_metric_value_ms"
        ]
      },
      "ml._types:DatafeedRunningState": {
        "type": "object",
        "properties": {
          "real_time_configured": {
            "description": "Indicates if the datafeed is \"real-time\"; meaning that the datafeed has no configured `end` time.",
            "type": "boolean"
          },
          "real_time_running": {
            "description": "Indicates whether the datafeed has finished running on the available past data.\nFor datafeeds without a configured `end` time, this means that the datafeed is now running on \"real-time\" data.",
            "type": "boolean"
          },
          "search_interval": {
            "$ref": "#/components/schemas/ml._types:RunningStateSearchInterval"
          }
        },
        "required": [
          "real_time_configured",
          "real_time_running"
        ]
      },
      "ml._types:RunningStateSearchInterval": {
        "type": "object",
        "properties": {
          "end": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "end_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "start": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "start_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "end_ms",
          "start_ms"
        ]
      },
      "ml._types:Datafeed": {
        "type": "object",
        "properties": {
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "authorization": {
            "$ref": "#/components/schemas/ml._types:DatafeedAuthorization"
          },
          "chunking_config": {
            "$ref": "#/components/schemas/ml._types:ChunkingConfig"
          },
          "datafeed_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "frequency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "indices": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_empty_searches": {
            "type": "number"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "query_delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "script_fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "scroll_size": {
            "type": "number"
          },
          "delayed_data_check_config": {
            "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "indices_options": {
            "$ref": "#/components/schemas/_types:IndicesOptions"
          }
        },
        "required": [
          "datafeed_id",
          "indices",
          "job_id",
          "query",
          "delayed_data_check_config"
        ]
      },
      "ml._types:DatafeedAuthorization": {
        "type": "object",
        "properties": {
          "api_key": {
            "$ref": "#/components/schemas/ml._types:ApiKeyAuthorization"
          },
          "roles": {
            "description": "If a user ID was used for the most recent update to the datafeed, its roles at the time of the update are listed in the response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "service_account": {
            "description": "If a service account was used for the most recent update to the datafeed, the account name is listed in the response.",
            "type": "string"
          }
        }
      },
      "ml._types:ChunkingConfig": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/ml._types:ChunkingMode"
          },
          "time_span": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "mode"
        ]
      },
      "ml._types:ChunkingMode": {
        "type": "string",
        "enum": [
          "auto",
          "manual",
          "off"
        ]
      },
      "ml._types:DelayedDataCheckConfig": {
        "type": "object",
        "properties": {
          "check_window": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "enabled": {
            "description": "Specifies whether the datafeed periodically checks for delayed data.",
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types:IndicesOptions": {
        "type": "object",
        "properties": {
          "allow_no_indices": {
            "description": "If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "type": "boolean"
          },
          "expand_wildcards": {
            "$ref": "#/components/schemas/_types:ExpandWildcards"
          },
          "ignore_unavailable": {
            "description": "If true, missing or closed indices are not included in the response.",
            "type": "boolean"
          },
          "ignore_throttled": {
            "description": "If true, concrete, expanded or aliased indices are ignored when frozen.",
            "type": "boolean"
          }
        }
      },
      "ml._types:Filter": {
        "type": "object",
        "properties": {
          "description": {
            "description": "A description of the filter.",
            "type": "string"
          },
          "filter_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "items": {
            "description": "An array of strings which is the filter item list.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "filter_id",
          "items"
        ]
      },
      "ml._types:Influencer": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "influencer_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the influencer in this bucket aggregated\nacross detectors. Unlike `initial_influencer_score`, this value is updated by a re-normalization process as new\ndata is analyzed.",
            "type": "number"
          },
          "influencer_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "influencer_field_value": {
            "description": "The entity that influenced, contributed to, or was to blame for the anomaly.",
            "type": "string"
          },
          "initial_influencer_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the influencer aggregated across detectors.\nThis is the initial value that was calculated at the time the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "probability": {
            "description": "The probability that the influencer has this behavior, in the range 0 to 1. This value can be held to a high\nprecision of over 300 decimal places, so the `influencer_score` is provided as a human-readable and friendly\ninterpretation of this value.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This value is always set to `influencer`.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "foo": {
            "description": "Additional influencer properties are added, depending on the fields being analyzed. For example, if itâ€™s\nanalyzing `user_name` as an influencer, a field `user_name` is added to the result document. This\ninformation enables you to filter the anomaly results more easily.",
            "type": "string"
          }
        },
        "required": [
          "bucket_span",
          "influencer_score",
          "influencer_field_name",
          "influencer_field_value",
          "initial_influencer_score",
          "is_interim",
          "job_id",
          "probability",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:JobStats": {
        "type": "object",
        "properties": {
          "assignment_explanation": {
            "description": "For open anomaly detection jobs only, contains messages relating to the selection of a node to run the job.",
            "type": "string"
          },
          "data_counts": {
            "$ref": "#/components/schemas/ml._types:DataCounts"
          },
          "forecasts_stats": {
            "$ref": "#/components/schemas/ml._types:JobForecastStatistics"
          },
          "job_id": {
            "description": "Identifier for the anomaly detection job.",
            "type": "string"
          },
          "model_size_stats": {
            "$ref": "#/components/schemas/ml._types:ModelSizeStats"
          },
          "node": {
            "$ref": "#/components/schemas/ml._types:DiscoveryNodeCompact"
          },
          "open_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:JobState"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:JobTimingStats"
          },
          "deleting": {
            "description": "Indicates that the process of deleting the job is in progress but not yet completed. It is only reported when `true`.",
            "type": "boolean"
          }
        },
        "required": [
          "data_counts",
          "forecasts_stats",
          "job_id",
          "model_size_stats",
          "state",
          "timing_stats"
        ]
      },
      "ml._types:DataCounts": {
        "type": "object",
        "properties": {
          "bucket_count": {
            "type": "number"
          },
          "earliest_record_timestamp": {
            "type": "number"
          },
          "empty_bucket_count": {
            "type": "number"
          },
          "input_bytes": {
            "type": "number"
          },
          "input_field_count": {
            "type": "number"
          },
          "input_record_count": {
            "type": "number"
          },
          "invalid_date_count": {
            "type": "number"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "last_data_time": {
            "type": "number"
          },
          "latest_empty_bucket_timestamp": {
            "type": "number"
          },
          "latest_record_timestamp": {
            "type": "number"
          },
          "latest_sparse_bucket_timestamp": {
            "type": "number"
          },
          "latest_bucket_timestamp": {
            "type": "number"
          },
          "log_time": {
            "type": "number"
          },
          "missing_field_count": {
            "type": "number"
          },
          "out_of_order_timestamp_count": {
            "type": "number"
          },
          "processed_field_count": {
            "type": "number"
          },
          "processed_record_count": {
            "type": "number"
          },
          "sparse_bucket_count": {
            "type": "number"
          }
        },
        "required": [
          "bucket_count",
          "empty_bucket_count",
          "input_bytes",
          "input_field_count",
          "input_record_count",
          "invalid_date_count",
          "job_id",
          "missing_field_count",
          "out_of_order_timestamp_count",
          "processed_field_count",
          "processed_record_count",
          "sparse_bucket_count"
        ]
      },
      "ml._types:JobForecastStatistics": {
        "type": "object",
        "properties": {
          "memory_bytes": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "processing_time_ms": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "records": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "status": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "total": {
            "type": "number"
          },
          "forecasted_jobs": {
            "type": "number"
          }
        },
        "required": [
          "total",
          "forecasted_jobs"
        ]
      },
      "ml._types:JobStatistics": {
        "type": "object",
        "properties": {
          "avg": {
            "type": "number"
          },
          "max": {
            "type": "number"
          },
          "min": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "avg",
          "max",
          "min",
          "total"
        ]
      },
      "ml._types:ModelSizeStats": {
        "type": "object",
        "properties": {
          "bucket_allocation_failures_count": {
            "type": "number"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "log_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "memory_status": {
            "$ref": "#/components/schemas/ml._types:MemoryStatus"
          },
          "model_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model_bytes_exceeded": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model_bytes_memory_limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "output_memory_allocator_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "peak_model_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "assignment_memory_basis": {
            "type": "string"
          },
          "result_type": {
            "type": "string"
          },
          "total_by_field_count": {
            "type": "number"
          },
          "total_over_field_count": {
            "type": "number"
          },
          "total_partition_field_count": {
            "type": "number"
          },
          "categorization_status": {
            "$ref": "#/components/schemas/ml._types:CategorizationStatus"
          },
          "categorized_doc_count": {
            "type": "number"
          },
          "dead_category_count": {
            "type": "number"
          },
          "failed_category_count": {
            "type": "number"
          },
          "frequent_category_count": {
            "type": "number"
          },
          "rare_category_count": {
            "type": "number"
          },
          "total_category_count": {
            "type": "number"
          },
          "timestamp": {
            "type": "number"
          }
        },
        "required": [
          "bucket_allocation_failures_count",
          "job_id",
          "log_time",
          "memory_status",
          "model_bytes",
          "result_type",
          "total_by_field_count",
          "total_over_field_count",
          "total_partition_field_count",
          "categorization_status",
          "categorized_doc_count",
          "dead_category_count",
          "failed_category_count",
          "frequent_category_count",
          "rare_category_count",
          "total_category_count"
        ]
      },
      "ml._types:JobTimingStats": {
        "type": "object",
        "properties": {
          "average_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "bucket_count": {
            "type": "number"
          },
          "exponential_average_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "exponential_average_bucket_processing_time_per_hour_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "total_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "maximum_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "minimum_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          }
        },
        "required": [
          "bucket_count",
          "exponential_average_bucket_processing_time_per_hour_ms",
          "job_id",
          "total_bucket_processing_time_ms"
        ]
      },
      "ml._types:Job": {
        "type": "object",
        "properties": {
          "allow_lazy_open": {
            "description": "Advanced configuration option.\nSpecifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node.",
            "type": "boolean"
          },
          "analysis_config": {
            "$ref": "#/components/schemas/ml._types:AnalysisConfig"
          },
          "analysis_limits": {
            "$ref": "#/components/schemas/ml._types:AnalysisLimits"
          },
          "background_persist_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "blocked": {
            "$ref": "#/components/schemas/ml._types:JobBlocked"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "custom_settings": {
            "$ref": "#/components/schemas/ml._types:CustomSettings"
          },
          "daily_model_snapshot_retention_after_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies a period of time (in days) after which only the first snapshot per day is retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nValid values range from 0 to `model_snapshot_retention_days`.",
            "type": "number"
          },
          "data_description": {
            "$ref": "#/components/schemas/ml._types:DataDescription"
          },
          "datafeed_config": {
            "$ref": "#/components/schemas/ml._types:Datafeed"
          },
          "deleting": {
            "description": "Indicates that the process of deleting the job is in progress but not yet completed.\nIt is only reported when `true`.",
            "type": "boolean"
          },
          "description": {
            "description": "A description of the job.",
            "type": "string"
          },
          "finished_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "groups": {
            "description": "A list of job groups.\nA job can belong to no groups or many.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "job_type": {
            "description": "Reserved for future use, currently set to `anomaly_detector`.",
            "type": "string"
          },
          "job_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "model_plot_config": {
            "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
          },
          "model_snapshot_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "model_snapshot_retention_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies the maximum period of time (in days) that snapshots are retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nBy default, snapshots ten days older than the newest snapshot are deleted.",
            "type": "number"
          },
          "renormalization_window_days": {
            "description": "Advanced configuration option.\nThe period over which adjustments to the score are applied, as new data is seen.\nThe default value is the longer of 30 days or 100 `bucket_spans`.",
            "type": "number"
          },
          "results_index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "results_retention_days": {
            "description": "Advanced configuration option.\nThe period of time (in days) that results are retained.\nAge is calculated relative to the timestamp of the latest bucket result.\nIf this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch.\nThe default value is null, which means all results are retained.\nAnnotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results.\nAnnotations added by users are retained forever.",
            "type": "number"
          }
        },
        "required": [
          "allow_lazy_open",
          "analysis_config",
          "data_description",
          "job_id",
          "model_snapshot_retention_days",
          "results_index_name"
        ]
      },
      "ml._types:AnalysisLimits": {
        "type": "object",
        "properties": {
          "categorization_examples_limit": {
            "description": "The maximum number of examples stored per category in memory and in the results data store. If you increase this value, more examples are available, however it requires that you have more storage available. If you set this value to 0, no examples are stored. NOTE: The `categorization_examples_limit` applies only to analysis that uses categorization.",
            "type": "number"
          },
          "model_memory_limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        }
      },
      "ml._types:JobBlocked": {
        "type": "object",
        "properties": {
          "reason": {
            "$ref": "#/components/schemas/ml._types:JobBlockedReason"
          },
          "task_id": {
            "$ref": "#/components/schemas/_types:TaskId"
          }
        },
        "required": [
          "reason"
        ]
      },
      "ml._types:JobBlockedReason": {
        "type": "string",
        "enum": [
          "delete",
          "reset",
          "revert"
        ]
      },
      "ml._types:CustomSettings": {
        "description": "Custom metadata about the job",
        "type": "object"
      },
      "ml._types:DataDescription": {
        "type": "object",
        "properties": {
          "format": {
            "description": "Only JSON format is supported at this time.",
            "type": "string"
          },
          "time_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "time_format": {
            "description": "The time format, which can be `epoch`, `epoch_ms`, or a custom pattern. The value `epoch` refers to UNIX or Epoch time (the number of seconds since 1 Jan 1970). The value `epoch_ms` indicates that time is measured in milliseconds since the epoch. The `epoch` and `epoch_ms` time formats accept either integer or real values. Custom patterns must conform to the Java DateTimeFormatter class. When you use date-time formatting patterns, it is recommended that you provide the full date, time and time zone. For example: `yyyy-MM-dd'T'HH:mm:ssX`. If the pattern that you specify is not sufficient to produce a complete timestamp, job creation fails.",
            "type": "string"
          },
          "field_delimiter": {
            "type": "string"
          }
        }
      },
      "ml._types:ModelPlotConfig": {
        "type": "object",
        "properties": {
          "annotations_enabled": {
            "description": "If true, enables calculation and storage of the model change annotations for each entity that is being analyzed.",
            "type": "boolean"
          },
          "enabled": {
            "description": "If true, enables calculation and storage of the model bounds for each entity that is being analyzed.",
            "type": "boolean"
          },
          "terms": {
            "$ref": "#/components/schemas/_types:Field"
          }
        }
      },
      "ml.get_memory_stats:Memory": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "jvm": {
            "$ref": "#/components/schemas/ml.get_memory_stats:JvmStats"
          },
          "mem": {
            "$ref": "#/components/schemas/ml.get_memory_stats:MemStats"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "description": "Roles assigned to the node.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "required": [
          "attributes",
          "jvm",
          "mem",
          "name",
          "roles",
          "transport_address",
          "ephemeral_id"
        ]
      },
      "ml.get_memory_stats:JvmStats": {
        "type": "object",
        "properties": {
          "heap_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "heap_max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "java_inference": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "java_inference_in_bytes": {
            "description": "Amount of Java heap, in bytes, currently being used for caching inference models.",
            "type": "number"
          },
          "java_inference_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "java_inference_max_in_bytes": {
            "description": "Maximum amount of Java heap, in bytes, to be used for caching inference models.",
            "type": "number"
          }
        },
        "required": [
          "heap_max_in_bytes",
          "java_inference_in_bytes",
          "java_inference_max_in_bytes"
        ]
      },
      "ml.get_memory_stats:MemStats": {
        "type": "object",
        "properties": {
          "adjusted_total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "adjusted_total_in_bytes": {
            "description": "If the amount of physical memory has been overridden using the `es.total_memory_bytes` system property\nthen this reports the overridden value in bytes. Otherwise it reports the same value as `total_in_bytes`.",
            "type": "number"
          },
          "total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_in_bytes": {
            "description": "Total amount of physical memory in bytes.",
            "type": "number"
          },
          "ml": {
            "$ref": "#/components/schemas/ml.get_memory_stats:MemMlStats"
          }
        },
        "required": [
          "adjusted_total_in_bytes",
          "total_in_bytes",
          "ml"
        ]
      },
      "ml.get_memory_stats:MemMlStats": {
        "type": "object",
        "properties": {
          "anomaly_detectors": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "anomaly_detectors_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for anomaly detection jobs.",
            "type": "number"
          },
          "data_frame_analytics": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "data_frame_analytics_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for data frame analytics jobs.",
            "type": "number"
          },
          "max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_in_bytes": {
            "description": "Maximum amount of native memory (separate to the JVM heap), in bytes, that may be used by machine learning native processes.",
            "type": "number"
          },
          "native_code_overhead": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "native_code_overhead_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for loading machine learning native code shared libraries.",
            "type": "number"
          },
          "native_inference": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "native_inference_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for trained models that have a PyTorch model_type.",
            "type": "number"
          }
        },
        "required": [
          "anomaly_detectors_in_bytes",
          "data_frame_analytics_in_bytes",
          "max_in_bytes",
          "native_code_overhead_in_bytes",
          "native_inference_in_bytes"
        ]
      },
      "ml._types:ModelSnapshotUpgrade": {
        "type": "object",
        "properties": {
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "snapshot_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:SnapshotUpgradeState"
          },
          "node": {
            "$ref": "#/components/schemas/ml._types:DiscoveryNode"
          },
          "assignment_explanation": {
            "type": "string"
          }
        },
        "required": [
          "job_id",
          "snapshot_id",
          "state",
          "node",
          "assignment_explanation"
        ]
      },
      "ml._types:SnapshotUpgradeState": {
        "type": "string",
        "enum": [
          "loading_old_state",
          "saving_new_state",
          "stopped",
          "failed"
        ]
      },
      "ml._types:DiscoveryNode": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/ml._types:DiscoveryNodeContent"
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DiscoveryNodeContent": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "external_id": {
            "type": "string"
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "min_index_version": {
            "type": "number"
          },
          "max_index_version": {
            "type": "number"
          }
        },
        "required": [
          "ephemeral_id",
          "transport_address",
          "external_id",
          "attributes",
          "roles",
          "version",
          "min_index_version",
          "max_index_version"
        ]
      },
      "ml._types:ModelSnapshot": {
        "type": "object",
        "properties": {
          "description": {
            "description": "An optional description of the job.",
            "type": "string"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "latest_record_time_stamp": {
            "description": "The timestamp of the latest processed record.",
            "type": "number"
          },
          "latest_result_time_stamp": {
            "description": "The timestamp of the latest bucket result.",
            "type": "number"
          },
          "min_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "model_size_stats": {
            "$ref": "#/components/schemas/ml._types:ModelSizeStats"
          },
          "retain": {
            "description": "If true, this snapshot will not be deleted during automatic cleanup of snapshots older than model_snapshot_retention_days. However, this snapshot will be deleted when the job is deleted. The default value is false.",
            "type": "boolean"
          },
          "snapshot_doc_count": {
            "description": "For internal use only.",
            "type": "number"
          },
          "snapshot_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "timestamp": {
            "description": "The creation timestamp for the snapshot.",
            "type": "number"
          }
        },
        "required": [
          "job_id",
          "min_version",
          "retain",
          "snapshot_doc_count",
          "snapshot_id",
          "timestamp"
        ]
      },
      "ml._types:OverallBucket": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "jobs": {
            "description": "An array of objects that contain the max_anomaly_score per job_id.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:OverallBucketJob"
            }
          },
          "overall_score": {
            "description": "The top_n average of the maximum bucket anomaly_score per job.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This is always set to overall_bucket.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "bucket_span",
          "is_interim",
          "jobs",
          "overall_score",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:OverallBucketJob": {
        "type": "object",
        "properties": {
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_anomaly_score": {
            "type": "number"
          }
        },
        "required": [
          "job_id",
          "max_anomaly_score"
        ]
      },
      "ml._types:Anomaly": {
        "type": "object",
        "properties": {
          "actual": {
            "description": "The actual value for the bucket.",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "anomaly_score_explanation": {
            "$ref": "#/components/schemas/ml._types:AnomalyExplanation"
          },
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "by_field_name": {
            "description": "The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.",
            "type": "string"
          },
          "by_field_value": {
            "description": "The value of `by_field_name`.",
            "type": "string"
          },
          "causes": {
            "description": "For population analysis, an over field must be specified in the detector. This property contains an array of anomaly records that are the causes for the anomaly that has been identified for the over field. This sub-resource contains the most anomalous records for the `over_field_name`. For scalability reasons, a maximum of the 10 most significant causes of the anomaly are returned. As part of the core analytical modeling, these low-level anomaly records are aggregated for their parent over field record. The `causes` resource contains similar elements to the record resource, namely `actual`, `typical`, `geo_results.actual_point`, `geo_results.typical_point`, `*_field_name` and `*_field_value`. Probability and scores are not applicable to causes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:AnomalyCause"
            }
          },
          "detector_index": {
            "description": "A unique identifier for the detector.",
            "type": "number"
          },
          "field_name": {
            "description": "Certain functions require a field to operate on, for example, `sum()`. For those functions, this value is the name of the field to be analyzed.",
            "type": "string"
          },
          "function": {
            "description": "The function in which the anomaly occurs, as specified in the detector configuration. For example, `max`.",
            "type": "string"
          },
          "function_description": {
            "description": "The description of the function in which the anomaly occurs, as specified in the detector configuration.",
            "type": "string"
          },
          "geo_results": {
            "$ref": "#/components/schemas/ml._types:GeoResults"
          },
          "influencers": {
            "description": "If influencers were specified in the detector configuration, this array contains influencers that contributed to or were to blame for an anomaly.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Influence"
            }
          },
          "initial_record_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the anomalousness of this record. This is the initial value that was calculated at the time the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "description": "Identifier for the anomaly detection job.",
            "type": "string"
          },
          "over_field_name": {
            "description": "The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.",
            "type": "string"
          },
          "over_field_value": {
            "description": "The value of `over_field_name`.",
            "type": "string"
          },
          "partition_field_name": {
            "description": "The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.",
            "type": "string"
          },
          "partition_field_value": {
            "description": "The value of `partition_field_name`.",
            "type": "string"
          },
          "probability": {
            "description": "The probability of the individual anomaly occurring, in the range 0 to 1. For example, `0.0000772031`. This value can be held to a high precision of over 300 decimal places, so the `record_score` is provided as a human-readable and friendly interpretation of this.",
            "type": "number"
          },
          "record_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the anomalousness of this record. Unlike `initial_record_score`, this value will be updated by a re-normalization process as new data is analyzed.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This is always set to `record`.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "typical": {
            "description": "The typical value for the bucket, according to analytical modeling.",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "bucket_span",
          "detector_index",
          "initial_record_score",
          "is_interim",
          "job_id",
          "probability",
          "record_score",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:AnomalyExplanation": {
        "type": "object",
        "properties": {
          "anomaly_characteristics_impact": {
            "description": "Impact from the duration and magnitude of the detected anomaly relative to the historical average.",
            "type": "number"
          },
          "anomaly_length": {
            "description": "Length of the detected anomaly in the number of buckets.",
            "type": "number"
          },
          "anomaly_type": {
            "description": "Type of the detected anomaly: `spike` or `dip`.",
            "type": "string"
          },
          "high_variance_penalty": {
            "description": "Indicates reduction of anomaly score for the bucket with large confidence intervals. If a bucket has large confidence intervals, the score is reduced.",
            "type": "boolean"
          },
          "incomplete_bucket_penalty": {
            "description": "If the bucket contains fewer samples than expected, the score is reduced.",
            "type": "boolean"
          },
          "lower_confidence_bound": {
            "description": "Lower bound of the 95% confidence interval.",
            "type": "number"
          },
          "multi_bucket_impact": {
            "description": "Impact of the deviation between actual and typical values in the past 12 buckets.",
            "type": "number"
          },
          "single_bucket_impact": {
            "description": "Impact of the deviation between actual and typical values in the current bucket.",
            "type": "number"
          },
          "typical_value": {
            "description": "Typical (expected) value for this bucket.",
            "type": "number"
          },
          "upper_confidence_bound": {
            "description": "Upper bound of the 95% confidence interval.",
            "type": "number"
          }
        }
      },
      "ml._types:AnomalyCause": {
        "type": "object",
        "properties": {
          "actual": {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "by_field_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "by_field_value": {
            "type": "string"
          },
          "correlated_by_field_value": {
            "type": "string"
          },
          "field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "function": {
            "type": "string"
          },
          "function_description": {
            "type": "string"
          },
          "geo_results": {
            "$ref": "#/components/schemas/ml._types:GeoResults"
          },
          "influencers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Influence"
            }
          },
          "over_field_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "over_field_value": {
            "type": "string"
          },
          "partition_field_name": {
            "type": "string"
          },
          "partition_field_value": {
            "type": "string"
          },
          "probability": {
            "type": "number"
          },
          "typical": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "probability"
        ]
      },
      "ml._types:GeoResults": {
        "type": "object",
        "properties": {
          "actual_point": {
            "description": "The actual value for the bucket formatted as a `geo_point`.",
            "type": "string"
          },
          "typical_point": {
            "description": "The typical value for the bucket formatted as a `geo_point`.",
            "type": "string"
          }
        }
      },
      "ml._types:Influence": {
        "type": "object",
        "properties": {
          "influencer_field_name": {
            "type": "string"
          },
          "influencer_field_values": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "influencer_field_name",
          "influencer_field_values"
        ]
      },
      "ml._types:Include": {
        "type": "string",
        "enum": [
          "definition",
          "feature_importance_baseline",
          "hyperparameters",
          "total_feature_importance",
          "definition_status"
        ]
      },
      "ml._types:TrainedModelConfig": {
        "type": "object",
        "properties": {
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "model_type": {
            "$ref": "#/components/schemas/ml._types:TrainedModelType"
          },
          "tags": {
            "description": "A comma delimited string of tags. A trained model can have many tags, or none.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "compressed_definition": {
            "type": "string"
          },
          "created_by": {
            "description": "Information on the creator of the trained model.",
            "type": "string"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "default_field_map": {
            "description": "Any field map described in the inference configuration takes precedence.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "description": {
            "description": "The free-text description of the trained model.",
            "type": "string"
          },
          "estimated_heap_memory_usage_bytes": {
            "description": "The estimated heap usage in bytes to keep the trained model in memory.",
            "type": "number"
          },
          "estimated_operations": {
            "description": "The estimated number of operations to use the trained model.",
            "type": "number"
          },
          "fully_defined": {
            "description": "True if the full model definition is present.",
            "type": "boolean"
          },
          "inference_config": {
            "$ref": "#/components/schemas/ml._types:InferenceConfigCreateContainer"
          },
          "input": {
            "$ref": "#/components/schemas/ml._types:TrainedModelConfigInput"
          },
          "license_level": {
            "description": "The license level of the trained model.",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/ml._types:TrainedModelConfigMetadata"
          },
          "model_size_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model_package": {
            "$ref": "#/components/schemas/ml._types:ModelPackageConfig"
          },
          "location": {
            "$ref": "#/components/schemas/ml._types:TrainedModelLocation"
          },
          "platform_architecture": {
            "type": "string"
          },
          "prefix_strings": {
            "$ref": "#/components/schemas/ml._types:TrainedModelPrefixStrings"
          }
        },
        "required": [
          "model_id",
          "tags",
          "input"
        ]
      },
      "ml._types:TrainedModelType": {
        "type": "string",
        "enum": [
          "tree_ensemble",
          "lang_ident",
          "pytorch"
        ]
      },
      "ml._types:InferenceConfigCreateContainer": {
        "description": "Inference configuration provided when storing the model config",
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ml._types:RegressionInferenceOptions"
          },
          "classification": {
            "$ref": "#/components/schemas/ml._types:ClassificationInferenceOptions"
          },
          "text_classification": {
            "$ref": "#/components/schemas/ml._types:TextClassificationInferenceOptions"
          },
          "zero_shot_classification": {
            "$ref": "#/components/schemas/ml._types:ZeroShotClassificationInferenceOptions"
          },
          "fill_mask": {
            "$ref": "#/components/schemas/ml._types:FillMaskInferenceOptions"
          },
          "learning_to_rank": {
            "$ref": "#/components/schemas/ml._types:LearningToRankConfig"
          },
          "ner": {
            "$ref": "#/components/schemas/ml._types:NerInferenceOptions"
          },
          "pass_through": {
            "$ref": "#/components/schemas/ml._types:PassThroughInferenceOptions"
          },
          "text_embedding": {
            "$ref": "#/components/schemas/ml._types:TextEmbeddingInferenceOptions"
          },
          "text_expansion": {
            "$ref": "#/components/schemas/ml._types:TextExpansionInferenceOptions"
          },
          "question_answering": {
            "$ref": "#/components/schemas/ml._types:QuestionAnsweringInferenceOptions"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:TextClassificationInferenceOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "classification_labels": {
            "description": "Classification labels to apply other than the stored labels. Must have the same deminsions as the default configured labels",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        }
      },
      "ml._types:TokenizationConfigContainer": {
        "description": "Tokenization options stored in inference configuration",
        "type": "object",
        "properties": {
          "bert": {
            "$ref": "#/components/schemas/ml._types:NlpBertTokenizationConfig"
          },
          "bert_ja": {
            "$ref": "#/components/schemas/ml._types:NlpBertTokenizationConfig"
          },
          "mpnet": {
            "$ref": "#/components/schemas/ml._types:NlpBertTokenizationConfig"
          },
          "roberta": {
            "$ref": "#/components/schemas/ml._types:NlpRobertaTokenizationConfig"
          },
          "xlm_roberta": {
            "$ref": "#/components/schemas/ml._types:XlmRobertaTokenizationConfig"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:NlpBertTokenizationConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:CommonTokenizationConfig"
          },
          {
            "type": "object"
          }
        ]
      },
      "ml._types:CommonTokenizationConfig": {
        "type": "object",
        "properties": {
          "do_lower_case": {
            "description": "Should the tokenizer lower case the text",
            "type": "boolean"
          },
          "max_sequence_length": {
            "description": "Maximum input sequence length for the model",
            "type": "number"
          },
          "span": {
            "description": "Tokenization spanning options. Special value of -1 indicates no spanning takes place",
            "type": "number"
          },
          "truncate": {
            "$ref": "#/components/schemas/ml._types:TokenizationTruncate"
          },
          "with_special_tokens": {
            "description": "Is tokenization completed with special tokens",
            "type": "boolean"
          }
        }
      },
      "ml._types:TokenizationTruncate": {
        "type": "string",
        "enum": [
          "first",
          "second",
          "none"
        ]
      },
      "ml._types:NlpRobertaTokenizationConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:CommonTokenizationConfig"
          },
          {
            "type": "object",
            "properties": {
              "add_prefix_space": {
                "description": "Should the tokenizer prefix input with a space character",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "ml._types:XlmRobertaTokenizationConfig": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:CommonTokenizationConfig"
          },
          {
            "type": "object"
          }
        ]
      },
      "ml._types:Vocabulary": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:ZeroShotClassificationInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "hypothesis_template": {
            "description": "Hypothesis template used when tokenizing labels for prediction",
            "type": "string"
          },
          "classification_labels": {
            "description": "The zero shot classification labels indicating entailment, neutral, and contradiction\nMust contain exactly and only entailment, neutral, and contradiction",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "multi_label": {
            "description": "Indicates if more than one true label exists.",
            "type": "boolean"
          },
          "labels": {
            "description": "The labels to predict.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "classification_labels"
        ]
      },
      "ml._types:FillMaskInferenceOptions": {
        "type": "object",
        "properties": {
          "mask_token": {
            "description": "The string/token which will be removed from incoming documents and replaced with the inference prediction(s).\nIn a response, this field contains the mask token for the specified model/tokenizer. Each model and tokenizer\nhas a predefined mask token which cannot be changed. Thus, it is recommended not to set this value in requests.\nHowever, if this field is present in a request, its value must match the predefined value for that model/tokenizer,\notherwise the request will fail.",
            "type": "string"
          },
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        },
        "required": [
          "vocabulary"
        ]
      },
      "ml._types:LearningToRankConfig": {
        "type": "object",
        "properties": {
          "default_params": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "feature_extractors": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ml._types:FeatureExtractor"
              }
            }
          },
          "num_top_feature_importance_values": {
            "type": "number"
          }
        },
        "required": [
          "num_top_feature_importance_values"
        ]
      },
      "ml._types:FeatureExtractor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:QueryFeatureExtractor"
          }
        ]
      },
      "ml._types:QueryFeatureExtractor": {
        "type": "object",
        "properties": {
          "default_score": {
            "type": "number"
          },
          "feature_name": {
            "type": "string"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "feature_name",
          "query"
        ]
      },
      "ml._types:NerInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "classification_labels": {
            "description": "The token classification labels. Must be IOB formatted tags",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        }
      },
      "ml._types:PassThroughInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        }
      },
      "ml._types:TextEmbeddingInferenceOptions": {
        "type": "object",
        "properties": {
          "embedding_size": {
            "description": "The number of dimensions in the embedding output",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        },
        "required": [
          "vocabulary"
        ]
      },
      "ml._types:TextExpansionInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        },
        "required": [
          "vocabulary"
        ]
      },
      "ml._types:QuestionAnsweringInferenceOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "max_answer_length": {
            "description": "The maximum answer length to consider",
            "type": "number"
          }
        }
      },
      "ml._types:TrainedModelConfigInput": {
        "type": "object",
        "properties": {
          "field_names": {
            "description": "An array of input field names for the model.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          }
        },
        "required": [
          "field_names"
        ]
      },
      "ml._types:TrainedModelConfigMetadata": {
        "type": "object",
        "properties": {
          "model_aliases": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_importance_baseline": {
            "description": "An object that contains the baseline for feature importance values. For regression analysis, it is a single value. For classification analysis, there is a value for each class.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "hyperparameters": {
            "description": "List of the available hyperparameters optimized during the fine_parameter_tuning phase as well as specified by the user.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Hyperparameter"
            }
          },
          "total_feature_importance": {
            "description": "An array of the total feature importance for each feature used from the training data set. This array of objects is returned if data frame analytics trained the model and the request includes total_feature_importance in the include request parameter.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportance"
            }
          }
        }
      },
      "ml._types:Hyperparameter": {
        "type": "object",
        "properties": {
          "absolute_importance": {
            "description": "A positive number showing how much the parameter influences the variation of the loss function. For hyperparameters with values that are not specified by the user but tuned during hyperparameter optimization.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "relative_importance": {
            "description": "A number between 0 and 1 showing the proportion of influence on the variation of the loss function among all tuned hyperparameters. For hyperparameters with values that are not specified by the user but tuned during hyperparameter optimization.",
            "type": "number"
          },
          "supplied": {
            "description": "Indicates if the hyperparameter is specified by the user (true) or optimized (false).",
            "type": "boolean"
          },
          "value": {
            "description": "The value of the hyperparameter, either optimized or specified by the user.",
            "type": "number"
          }
        },
        "required": [
          "name",
          "supplied",
          "value"
        ]
      },
      "ml._types:TotalFeatureImportance": {
        "type": "object",
        "properties": {
          "feature_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "importance": {
            "description": "A collection of feature importance statistics related to the training data set for this particular feature.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportanceStatistics"
            }
          },
          "classes": {
            "description": "If the trained model is a classification model, feature importance statistics are gathered per target class value.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportanceClass"
            }
          }
        },
        "required": [
          "feature_name",
          "importance",
          "classes"
        ]
      },
      "ml._types:TotalFeatureImportanceStatistics": {
        "type": "object",
        "properties": {
          "mean_magnitude": {
            "description": "The average magnitude of this feature across all the training data. This value is the average of the absolute values of the importance for this feature.",
            "type": "number"
          },
          "max": {
            "description": "The maximum importance value across all the training data for this feature.",
            "type": "number"
          },
          "min": {
            "description": "The minimum importance value across all the training data for this feature.",
            "type": "number"
          }
        },
        "required": [
          "mean_magnitude",
          "max",
          "min"
        ]
      },
      "ml._types:TotalFeatureImportanceClass": {
        "type": "object",
        "properties": {
          "class_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "importance": {
            "description": "A collection of feature importance statistics related to the training data set for this particular feature.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportanceStatistics"
            }
          }
        },
        "required": [
          "class_name",
          "importance"
        ]
      },
      "ml._types:ModelPackageConfig": {
        "type": "object",
        "properties": {
          "create_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "description": {
            "type": "string"
          },
          "inference_config": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "minimum_version": {
            "type": "string"
          },
          "model_repository": {
            "type": "string"
          },
          "model_type": {
            "type": "string"
          },
          "packaged_model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "platform_architecture": {
            "type": "string"
          },
          "prefix_strings": {
            "$ref": "#/components/schemas/ml._types:TrainedModelPrefixStrings"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "sha256": {
            "type": "string"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "vocabulary_file": {
            "type": "string"
          }
        },
        "required": [
          "packaged_model_id"
        ]
      },
      "ml._types:TrainedModelPrefixStrings": {
        "type": "object",
        "properties": {
          "ingest": {
            "description": "String prepended to input at ingest",
            "type": "string"
          },
          "search": {
            "description": "String prepended to input at search",
            "type": "string"
          }
        }
      },
      "ml._types:TrainedModelLocation": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/ml._types:TrainedModelLocationIndex"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:TrainedModelLocationIndex": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "name"
        ]
      },
      "ml._types:TrainedModelStats": {
        "type": "object",
        "properties": {
          "deployment_stats": {
            "$ref": "#/components/schemas/ml._types:TrainedModelDeploymentStats"
          },
          "inference_stats": {
            "$ref": "#/components/schemas/ml._types:TrainedModelInferenceStats"
          },
          "ingest": {
            "description": "A collection of ingest stats for the model across all nodes.\nThe values are summations of the individual node statistics.\nThe format matches the ingest section in the nodes stats API.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "model_size_stats": {
            "$ref": "#/components/schemas/ml._types:TrainedModelSizeStats"
          },
          "pipeline_count": {
            "description": "The number of ingest pipelines that currently refer to the model.",
            "type": "number"
          }
        },
        "required": [
          "model_id",
          "model_size_stats",
          "pipeline_count"
        ]
      },
      "ml._types:TrainedModelDeploymentStats": {
        "type": "object",
        "properties": {
          "adaptive_allocations": {
            "$ref": "#/components/schemas/ml._types:AdaptiveAllocationsSettings"
          },
          "allocation_status": {
            "$ref": "#/components/schemas/ml._types:TrainedModelDeploymentAllocationStatus"
          },
          "cache_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "deployment_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "error_count": {
            "description": "The sum of `error_count` for all nodes in the deployment.",
            "type": "number"
          },
          "inference_count": {
            "description": "The sum of `inference_count` for all nodes in the deployment.",
            "type": "number"
          },
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "nodes": {
            "description": "The deployment stats for each node that currently has the model allocated.\nIn serverless, stats are reported for a single unnamed virtual node.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelDeploymentNodesStats"
            }
          },
          "number_of_allocations": {
            "description": "The number of allocations requested.",
            "type": "number"
          },
          "peak_throughput_per_minute": {
            "type": "number"
          },
          "priority": {
            "$ref": "#/components/schemas/ml._types:TrainingPriority"
          },
          "queue_capacity": {
            "description": "The number of inference requests that can be queued before new requests are rejected.",
            "type": "number"
          },
          "rejected_execution_count": {
            "description": "The sum of `rejected_execution_count` for all nodes in the deployment.\nIndividual nodes reject an inference request if the inference queue is full.\nThe queue size is controlled by the `queue_capacity` setting in the start\ntrained model deployment API.",
            "type": "number"
          },
          "reason": {
            "description": "The reason for the current deployment state. Usually only populated when\nthe model is not deployed to a node.",
            "type": "string"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DeploymentAssignmentState"
          },
          "threads_per_allocation": {
            "description": "The number of threads used be each allocation during inference.",
            "type": "number"
          },
          "timeout_count": {
            "description": "The sum of `timeout_count` for all nodes in the deployment.",
            "type": "number"
          }
        },
        "required": [
          "deployment_id",
          "model_id",
          "nodes",
          "peak_throughput_per_minute",
          "priority",
          "start_time"
        ]
      },
      "ml._types:AdaptiveAllocationsSettings": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "min_number_of_allocations": {
            "type": "number"
          },
          "max_number_of_allocations": {
            "type": "number"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "ml._types:TrainedModelDeploymentAllocationStatus": {
        "type": "object",
        "properties": {
          "allocation_count": {
            "description": "The current number of nodes where the model is allocated.",
            "type": "number"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DeploymentAllocationState"
          },
          "target_allocation_count": {
            "description": "The desired number of nodes for model allocation.",
            "type": "number"
          }
        },
        "required": [
          "allocation_count",
          "state",
          "target_allocation_count"
        ]
      },
      "ml._types:DeploymentAllocationState": {
        "type": "string",
        "enum": [
          "started",
          "starting",
          "fully_allocated"
        ]
      },
      "ml._types:TrainedModelDeploymentNodesStats": {
        "type": "object",
        "properties": {
          "average_inference_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "average_inference_time_ms_last_minute": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "average_inference_time_ms_excluding_cache_hits": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "error_count": {
            "description": "The number of errors when evaluating the trained model.",
            "type": "number"
          },
          "inference_count": {
            "description": "The total number of inference calls made against this node for this model.",
            "type": "number"
          },
          "inference_cache_hit_count": {
            "type": "number"
          },
          "inference_cache_hit_count_last_minute": {
            "type": "number"
          },
          "last_access": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "node": {
            "$ref": "#/components/schemas/ml._types:DiscoveryNode"
          },
          "number_of_allocations": {
            "description": "The number of allocations assigned to this node.",
            "type": "number"
          },
          "number_of_pending_requests": {
            "description": "The number of inference requests queued to be processed.",
            "type": "number"
          },
          "peak_throughput_per_minute": {
            "type": "number"
          },
          "rejection_execution_count": {
            "description": "The number of inference requests that were not processed because the queue was full.",
            "type": "number"
          },
          "routing_state": {
            "$ref": "#/components/schemas/ml._types:TrainedModelAssignmentRoutingTable"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "threads_per_allocation": {
            "description": "The number of threads used by each allocation during inference.",
            "type": "number"
          },
          "throughput_last_minute": {
            "type": "number"
          },
          "timeout_count": {
            "description": "The number of inference requests that timed out before being processed.",
            "type": "number"
          }
        },
        "required": [
          "peak_throughput_per_minute",
          "routing_state",
          "throughput_last_minute"
        ]
      },
      "ml._types:TrainedModelAssignmentRoutingTable": {
        "type": "object",
        "properties": {
          "reason": {
            "description": "The reason for the current state. It is usually populated only when the\n`routing_state` is `failed`.",
            "type": "string"
          },
          "routing_state": {
            "$ref": "#/components/schemas/ml._types:RoutingState"
          },
          "current_allocations": {
            "description": "Current number of allocations.",
            "type": "number"
          },
          "target_allocations": {
            "description": "Target number of allocations.",
            "type": "number"
          }
        },
        "required": [
          "routing_state",
          "current_allocations",
          "target_allocations"
        ]
      },
      "ml._types:RoutingState": {
        "type": "string",
        "enum": [
          "failed",
          "started",
          "starting",
          "stopped",
          "stopping"
        ]
      },
      "ml._types:TrainingPriority": {
        "type": "string",
        "enum": [
          "normal",
          "low"
        ]
      },
      "ml._types:DeploymentAssignmentState": {
        "type": "string",
        "enum": [
          "started",
          "starting",
          "stopping",
          "failed"
        ]
      },
      "ml._types:TrainedModelInferenceStats": {
        "type": "object",
        "properties": {
          "cache_miss_count": {
            "description": "The number of times the model was loaded for inference and was not retrieved from the cache.\nIf this number is close to the `inference_count`, the cache is not being appropriately used.\nThis can be solved by increasing the cache size or its time-to-live (TTL).\nRefer to general machine learning settings for the appropriate settings.",
            "type": "number"
          },
          "failure_count": {
            "description": "The number of failures when using the model for inference.",
            "type": "number"
          },
          "inference_count": {
            "description": "The total number of times the model has been called for inference.\nThis is across all inference contexts, including all pipelines.",
            "type": "number"
          },
          "missing_all_fields_count": {
            "description": "The number of inference calls where all the training features for the model were missing.",
            "type": "number"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "cache_miss_count",
          "failure_count",
          "inference_count",
          "missing_all_fields_count",
          "timestamp"
        ]
      },
      "ml._types:TrainedModelSizeStats": {
        "type": "object",
        "properties": {
          "model_size_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "required_native_memory_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        },
        "required": [
          "model_size_bytes",
          "required_native_memory_bytes"
        ]
      },
      "ml._types:InferenceConfigUpdateContainer": {
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ml._types:RegressionInferenceOptions"
          },
          "classification": {
            "$ref": "#/components/schemas/ml._types:ClassificationInferenceOptions"
          },
          "text_classification": {
            "$ref": "#/components/schemas/ml._types:TextClassificationInferenceUpdateOptions"
          },
          "zero_shot_classification": {
            "$ref": "#/components/schemas/ml._types:ZeroShotClassificationInferenceUpdateOptions"
          },
          "fill_mask": {
            "$ref": "#/components/schemas/ml._types:FillMaskInferenceUpdateOptions"
          },
          "ner": {
            "$ref": "#/components/schemas/ml._types:NerInferenceUpdateOptions"
          },
          "pass_through": {
            "$ref": "#/components/schemas/ml._types:PassThroughInferenceUpdateOptions"
          },
          "text_embedding": {
            "$ref": "#/components/schemas/ml._types:TextEmbeddingInferenceUpdateOptions"
          },
          "text_expansion": {
            "$ref": "#/components/schemas/ml._types:TextExpansionInferenceUpdateOptions"
          },
          "question_answering": {
            "$ref": "#/components/schemas/ml._types:QuestionAnsweringInferenceUpdateOptions"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:TextClassificationInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "classification_labels": {
            "description": "Classification labels to apply other than the stored labels. Must have the same deminsions as the default configured labels",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ml._types:NlpTokenizationUpdateOptions": {
        "type": "object",
        "properties": {
          "truncate": {
            "$ref": "#/components/schemas/ml._types:TokenizationTruncate"
          },
          "span": {
            "description": "Span options to apply",
            "type": "number"
          }
        }
      },
      "ml._types:ZeroShotClassificationInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "multi_label": {
            "description": "Update the configured multi label option. Indicates if more than one true label exists. Defaults to the configured value.",
            "type": "boolean"
          },
          "labels": {
            "description": "The labels to predict.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "labels"
        ]
      },
      "ml._types:FillMaskInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:NerInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:PassThroughInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:TextEmbeddingInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:TextExpansionInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:QuestionAnsweringInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "question": {
            "description": "The question to answer given the inference context",
            "type": "string"
          },
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "max_answer_length": {
            "description": "The maximum answer length to consider for extraction",
            "type": "number"
          }
        },
        "required": [
          "question"
        ]
      },
      "ml._types:InferenceResponseResult": {
        "type": "object",
        "properties": {
          "entities": {
            "description": "If the model is trained for named entity recognition (NER) tasks, the response contains the recognized entities.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelEntities"
            }
          },
          "is_truncated": {
            "description": "Indicates whether the input text was truncated to meet the model's maximum sequence length limit. This property\nis present only when it is true.",
            "type": "boolean"
          },
          "predicted_value": {
            "description": "If the model is trained for a text classification or zero shot classification task, the response is the\npredicted class.\nFor named entity recognition (NER) tasks, it contains the annotated text output.\nFor fill mask tasks, it contains the top prediction for replacing the mask token.\nFor text embedding tasks, it contains the raw numerical text embedding values.\nFor regression models, its a numerical value\nFor classification models, it may be an integer, double, boolean or string depending on prediction type",
            "oneOf": [
              {
                "$ref": "#/components/schemas/ml._types:PredictedValue"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ml._types:PredictedValue"
                }
              }
            ]
          },
          "predicted_value_sequence": {
            "description": "For fill mask tasks, the response contains the input text sequence with the mask token replaced by the predicted\nvalue.\nAdditionally",
            "type": "string"
          },
          "prediction_probability": {
            "description": "Specifies a probability for the predicted value.",
            "type": "number"
          },
          "prediction_score": {
            "description": "Specifies a confidence score for the predicted value.",
            "type": "number"
          },
          "top_classes": {
            "description": "For fill mask, text classification, and zero shot classification tasks, the response contains a list of top\nclass entries.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TopClassEntry"
            }
          },
          "warning": {
            "description": "If the request failed, the response contains the reason for the failure.",
            "type": "string"
          },
          "feature_importance": {
            "description": "The feature importance for the inference results. Relevant only for classification or regression models",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelInferenceFeatureImportance"
            }
          }
        }
      },
      "ml._types:TrainedModelEntities": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "class_probability": {
            "type": "number"
          },
          "entity": {
            "type": "string"
          },
          "start_pos": {
            "type": "number"
          },
          "end_pos": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "class_probability",
          "entity",
          "start_pos",
          "end_pos"
        ]
      },
      "ml._types:PredictedValue": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ScalarValue"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ScalarValue"
            }
          }
        ]
      },
      "ml._types:TopClassEntry": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "class_probability": {
            "type": "number"
          },
          "class_score": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "class_probability",
          "class_score"
        ]
      },
      "ml._types:TrainedModelInferenceFeatureImportance": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          },
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelInferenceClassImportance"
            }
          }
        },
        "required": [
          "feature_name"
        ]
      },
      "ml._types:TrainedModelInferenceClassImportance": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "importance"
        ]
      },
      "ml.info:Defaults": {
        "type": "object",
        "properties": {
          "anomaly_detectors": {
            "$ref": "#/components/schemas/ml.info:AnomalyDetectors"
          },
          "datafeeds": {
            "$ref": "#/components/schemas/ml.info:Datafeeds"
          }
        },
        "required": [
          "anomaly_detectors",
          "datafeeds"
        ]
      },
      "ml.info:AnomalyDetectors": {
        "type": "object",
        "properties": {
          "categorization_analyzer": {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzer"
          },
          "categorization_examples_limit": {
            "type": "number"
          },
          "model_memory_limit": {
            "type": "string"
          },
          "model_snapshot_retention_days": {
            "type": "number"
          },
          "daily_model_snapshot_retention_after_days": {
            "type": "number"
          }
        },
        "required": [
          "categorization_analyzer",
          "categorization_examples_limit",
          "model_memory_limit",
          "model_snapshot_retention_days",
          "daily_model_snapshot_retention_after_days"
        ]
      },
      "ml.info:Datafeeds": {
        "type": "object",
        "properties": {
          "scroll_size": {
            "type": "number"
          }
        },
        "required": [
          "scroll_size"
        ]
      },
      "ml.info:Limits": {
        "type": "object",
        "properties": {
          "max_single_ml_node_processors": {
            "type": "number"
          },
          "total_ml_processors": {
            "type": "number"
          },
          "max_model_memory_limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "effective_max_model_memory_limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_ml_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        },
        "required": [
          "total_ml_memory"
        ]
      },
      "ml.info:NativeCode": {
        "type": "object",
        "properties": {
          "build_hash": {
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "build_hash",
          "version"
        ]
      },
      "ml.preview_data_frame_analytics:DataframePreviewConfig": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
          },
          "analysis": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
          },
          "model_memory_limit": {
            "type": "string"
          },
          "max_num_threads": {
            "type": "number"
          },
          "analyzed_fields": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
          }
        },
        "required": [
          "source",
          "analysis"
        ]
      },
      "ml._types:DatafeedConfig": {
        "type": "object",
        "properties": {
          "aggregations": {
            "description": "If set, the datafeed performs aggregation searches. Support for aggregations is limited and should be used only with low cardinality data.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "chunking_config": {
            "$ref": "#/components/schemas/ml._types:ChunkingConfig"
          },
          "datafeed_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "delayed_data_check_config": {
            "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
          },
          "frequency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "indices_options": {
            "$ref": "#/components/schemas/_types:IndicesOptions"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_empty_searches": {
            "description": "If a real-time datafeed has never seen any data (including during any initial training period) then it will automatically stop itself and close its associated job after this many real-time searches that return no documents. In other words, it will stop after `frequency` times `max_empty_searches` of real-time operation. If not set then a datafeed with no end time that sees no data will remain started until it is explicitly stopped.",
            "type": "number"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "query_delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "script_fields": {
            "description": "Specifies scripts that evaluate custom expressions and returns script fields to the datafeed. The detector configuration objects in a job can contain functions that use these script fields.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "scroll_size": {
            "description": "The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations. The maximum value is the value of `index.max_result_window`, which is 10,000 by default.",
            "type": "number"
          }
        }
      },
      "ml._types:JobConfig": {
        "type": "object",
        "properties": {
          "allow_lazy_open": {
            "description": "Advanced configuration option. Specifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node.",
            "type": "boolean"
          },
          "analysis_config": {
            "$ref": "#/components/schemas/ml._types:AnalysisConfig"
          },
          "analysis_limits": {
            "$ref": "#/components/schemas/ml._types:AnalysisLimits"
          },
          "background_persist_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "custom_settings": {
            "$ref": "#/components/schemas/ml._types:CustomSettings"
          },
          "daily_model_snapshot_retention_after_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies a period of time (in days) after which only the first snapshot per day is retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.",
            "type": "number"
          },
          "data_description": {
            "$ref": "#/components/schemas/ml._types:DataDescription"
          },
          "datafeed_config": {
            "$ref": "#/components/schemas/ml._types:DatafeedConfig"
          },
          "description": {
            "description": "A description of the job.",
            "type": "string"
          },
          "groups": {
            "description": "A list of job groups. A job can belong to no groups or many.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "job_type": {
            "description": "Reserved for future use, currently set to `anomaly_detector`.",
            "type": "string"
          },
          "model_plot_config": {
            "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
          },
          "model_snapshot_retention_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies the maximum period of time (in days) that snapshots are retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nThe default value is `10`, which means snapshots ten days older than the newest snapshot are deleted.",
            "type": "number"
          },
          "renormalization_window_days": {
            "description": "Advanced configuration option.\nThe period over which adjustments to the score are applied, as new data is seen.\nThe default value is the longer of 30 days or 100 `bucket_spans`.",
            "type": "number"
          },
          "results_index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "results_retention_days": {
            "description": "Advanced configuration option.\nThe period of time (in days) that results are retained.\nAge is calculated relative to the timestamp of the latest bucket result.\nIf this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch.\nThe default value is null, which means all results are retained.\nAnnotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results.\nAnnotations added by users are retained forever.",
            "type": "number"
          }
        },
        "required": [
          "analysis_config",
          "data_description"
        ]
      },
      "_types:HttpHeaders": {
        "type": "object",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        }
      },
      "ml._types:AnalysisConfigRead": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "categorization_analyzer": {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzer"
          },
          "categorization_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "categorization_filters": {
            "description": "If `categorization_field_name` is specified, you can also define optional filters.\nThis property expects an array of regular expressions.\nThe expressions are used to filter out matching sequences from the categorization field values.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "detectors": {
            "description": "An array of detector configuration objects.\nDetector configuration objects specify which data fields a job analyzes.\nThey also specify which analytical functions are used.\nYou can specify multiple detectors for a job.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectorRead"
            }
          },
          "influencers": {
            "description": "A comma separated list of influencer field names.\nTypically these can be the by, over, or partition fields that are used in the detector configuration.\nYou might also want to use a field name that is not specifically named in a detector, but is available as part of the input data.\nWhen you use multiple detectors, the use of influencers is recommended as it aggregates results for each influencer entity.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          },
          "model_prune_window": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "latency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "multivariate_by_fields": {
            "description": "This functionality is reserved for internal use.\nIt is not supported for use in customer environments and is not subject to the support SLA of official GA features.\nIf set to `true`, the analysis will automatically find correlations between metrics for a given by field value and report anomalies when those correlations cease to hold.",
            "type": "boolean"
          },
          "per_partition_categorization": {
            "$ref": "#/components/schemas/ml._types:PerPartitionCategorization"
          },
          "summary_count_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "bucket_span",
          "detectors",
          "influencers"
        ]
      },
      "ml._types:DetectorRead": {
        "type": "object",
        "properties": {
          "by_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "custom_rules": {
            "description": "An array of custom rule objects, which enable you to customize the way detectors operate.\nFor example, a rule may dictate to the detector conditions under which results should be skipped.\nKibana refers to custom rules as job rules.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectionRule"
            }
          },
          "detector_description": {
            "description": "A description of the detector.",
            "type": "string"
          },
          "detector_index": {
            "description": "A unique identifier for the detector.\nThis identifier is based on the order of the detectors in the `analysis_config`, starting at zero.",
            "type": "number"
          },
          "exclude_frequent": {
            "$ref": "#/components/schemas/ml._types:ExcludeFrequent"
          },
          "field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "function": {
            "description": "The analysis function that is used.\nFor example, `count`, `rare`, `mean`, `min`, `max`, and `sum`.",
            "type": "string"
          },
          "over_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "partition_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "use_null": {
            "description": "Defines whether a new series is used as the null series when there is no value for the by or partition fields.",
            "type": "boolean"
          }
        },
        "required": [
          "function"
        ]
      },
      "ml.put_trained_model:Definition": {
        "type": "object",
        "properties": {
          "preprocessors": {
            "description": "Collection of preprocessors",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.put_trained_model:Preprocessor"
            }
          },
          "trained_model": {
            "$ref": "#/components/schemas/ml.put_trained_model:TrainedModel"
          }
        },
        "required": [
          "trained_model"
        ]
      },
      "ml.put_trained_model:Preprocessor": {
        "type": "object",
        "properties": {
          "frequency_encoding": {
            "$ref": "#/components/schemas/ml.put_trained_model:FrequencyEncodingPreprocessor"
          },
          "one_hot_encoding": {
            "$ref": "#/components/schemas/ml.put_trained_model:OneHotEncodingPreprocessor"
          },
          "target_mean_encoding": {
            "$ref": "#/components/schemas/ml.put_trained_model:TargetMeanEncodingPreprocessor"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml.put_trained_model:FrequencyEncodingPreprocessor": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "feature_name": {
            "type": "string"
          },
          "frequency_map": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "field",
          "feature_name",
          "frequency_map"
        ]
      },
      "ml.put_trained_model:OneHotEncodingPreprocessor": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "hot_map": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "field",
          "hot_map"
        ]
      },
      "ml.put_trained_model:TargetMeanEncodingPreprocessor": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "feature_name": {
            "type": "string"
          },
          "target_map": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "default_value": {
            "type": "number"
          }
        },
        "required": [
          "field",
          "feature_name",
          "target_map",
          "default_value"
        ]
      },
      "ml.put_trained_model:TrainedModel": {
        "type": "object",
        "properties": {
          "tree": {
            "$ref": "#/components/schemas/ml.put_trained_model:TrainedModelTree"
          },
          "tree_node": {
            "$ref": "#/components/schemas/ml.put_trained_model:TrainedModelTreeNode"
          },
          "ensemble": {
            "$ref": "#/components/schemas/ml.put_trained_model:Ensemble"
          }
        }
      },
      "ml.put_trained_model:TrainedModelTree": {
        "type": "object",
        "properties": {
          "classification_labels": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "target_type": {
            "type": "string"
          },
          "tree_structure": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.put_trained_model:TrainedModelTreeNode"
            }
          }
        },
        "required": [
          "feature_names",
          "tree_structure"
        ]
      },
      "ml.put_trained_model:TrainedModelTreeNode": {
        "type": "object",
        "properties": {
          "decision_type": {
            "type": "string"
          },
          "default_left": {
            "type": "boolean"
          },
          "leaf_value": {
            "type": "number"
          },
          "left_child": {
            "type": "number"
          },
          "node_index": {
            "type": "number"
          },
          "right_child": {
            "type": "number"
          },
          "split_feature": {
            "type": "number"
          },
          "split_gain": {
            "type": "number"
          },
          "threshold": {
            "type": "number"
          }
        },
        "required": [
          "node_index"
        ]
      },
      "ml.put_trained_model:Ensemble": {
        "type": "object",
        "properties": {
          "aggregate_output": {
            "$ref": "#/components/schemas/ml.put_trained_model:AggregateOutput"
          },
          "classification_labels": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "target_type": {
            "type": "string"
          },
          "trained_models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.put_trained_model:TrainedModel"
            }
          }
        },
        "required": [
          "trained_models"
        ]
      },
      "ml.put_trained_model:AggregateOutput": {
        "type": "object",
        "properties": {
          "logistic_regression": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          },
          "weighted_sum": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          },
          "weighted_mode": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          },
          "exponent": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          }
        }
      },
      "ml.put_trained_model:Weights": {
        "type": "object",
        "properties": {
          "weights": {
            "type": "number"
          }
        },
        "required": [
          "weights"
        ]
      },
      "ml.put_trained_model:Input": {
        "type": "object",
        "properties": {
          "field_names": {
            "$ref": "#/components/schemas/_types:Names"
          }
        },
        "required": [
          "field_names"
        ]
      },
      "ml._types:TrainedModelAssignment": {
        "type": "object",
        "properties": {
          "adaptive_allocations": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/ml._types:AdaptiveAllocationsSettings"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "assignment_state": {
            "$ref": "#/components/schemas/ml._types:DeploymentAssignmentState"
          },
          "max_assigned_allocations": {
            "type": "number"
          },
          "reason": {
            "type": "string"
          },
          "routing_table": {
            "description": "The allocation state for each node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ml._types:TrainedModelAssignmentRoutingTable"
            }
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "task_parameters": {
            "$ref": "#/components/schemas/ml._types:TrainedModelAssignmentTaskParameters"
          }
        },
        "required": [
          "assignment_state",
          "routing_table",
          "start_time",
          "task_parameters"
        ]
      },
      "ml._types:TrainedModelAssignmentTaskParameters": {
        "type": "object",
        "properties": {
          "model_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "deployment_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "cache_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "number_of_allocations": {
            "description": "The total number of allocations this model is assigned across ML nodes.",
            "type": "number"
          },
          "priority": {
            "$ref": "#/components/schemas/ml._types:TrainingPriority"
          },
          "per_deployment_memory_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "per_allocation_memory_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "queue_capacity": {
            "description": "Number of inference requests are allowed in the queue at a time.",
            "type": "number"
          },
          "threads_per_allocation": {
            "description": "Number of threads per allocation.",
            "type": "number"
          }
        },
        "required": [
          "model_bytes",
          "model_id",
          "deployment_id",
          "number_of_allocations",
          "priority",
          "per_deployment_memory_bytes",
          "per_allocation_memory_bytes",
          "queue_capacity",
          "threads_per_allocation"
        ]
      },
      "ml._types:AnalysisMemoryLimit": {
        "type": "object",
        "properties": {
          "model_memory_limit": {
            "description": "Limits can be applied for the resources required to hold the mathematical models in memory. These limits are approximate and can be set per job. They do not control the memory used by other processes, for example the Elasticsearch Java processes.",
            "type": "string"
          }
        },
        "required": [
          "model_memory_limit"
        ]
      },
      "ml._types:DetectorUpdate": {
        "type": "object",
        "properties": {
          "detector_index": {
            "description": "A unique identifier for the detector.\nThis identifier is based on the order of the detectors in the `analysis_config`, starting at zero.",
            "type": "number"
          },
          "description": {
            "description": "A description of the detector.",
            "type": "string"
          },
          "custom_rules": {
            "description": "An array of custom rule objects, which enable you to customize the way detectors operate.\nFor example, a rule may dictate to the detector conditions under which results should be skipped.\nKibana refers to custom rules as job rules.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectionRule"
            }
          }
        },
        "required": [
          "detector_index"
        ]
      },
      "_global.msearch:MultiSearchResult": {
        "type": "object",
        "properties": {
          "took": {
            "type": "number"
          },
          "responses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.msearch:ResponseItem"
            }
          }
        },
        "required": [
          "took",
          "responses"
        ]
      },
      "_global.msearch_template:RequestItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.msearch:MultisearchHeader"
          },
          {
            "$ref": "#/components/schemas/_global.msearch_template:TemplateConfig"
          }
        ]
      },
      "_global.msearch_template:TemplateConfig": {
        "type": "object",
        "properties": {
          "explain": {
            "description": "If `true`, returns detailed information about score calculation as part of each hit.",
            "type": "boolean"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "description": "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "profile": {
            "description": "If `true`, the query execution is profiled.",
            "type": "boolean"
          },
          "source": {
            "description": "An inline search template. Supports the same parameters as the search API's\nrequest body. It also supports Mustache variables. If no `id` is specified, this\nparameter is required.",
            "type": "string"
          }
        }
      },
      "_global.mtermvectors:Operation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "doc": {
            "description": "An artificial document (a document not present in the index) for which you want to retrieve term vectors.",
            "type": "object"
          },
          "fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "field_statistics": {
            "description": "If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.",
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/_global.termvectors:Filter"
          },
          "offsets": {
            "description": "If `true`, the response includes term offsets.",
            "type": "boolean"
          },
          "payloads": {
            "description": "If `true`, the response includes term payloads.",
            "type": "boolean"
          },
          "positions": {
            "description": "If `true`, the response includes term positions.",
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "term_statistics": {
            "description": "If true, the response includes term frequency and document frequency.",
            "type": "boolean"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        }
      },
      "_global.termvectors:Filter": {
        "type": "object",
        "properties": {
          "max_doc_freq": {
            "description": "Ignore words which occur in more than this many docs.\nDefaults to unbounded.",
            "type": "number"
          },
          "max_num_terms": {
            "description": "The maximum number of terms that must be returned per field.",
            "type": "number"
          },
          "max_term_freq": {
            "description": "Ignore words with more than this frequency in the source doc.\nIt defaults to unbounded.",
            "type": "number"
          },
          "max_word_length": {
            "description": "The maximum word length above which words will be ignored.\nDefaults to unbounded.",
            "type": "number"
          },
          "min_doc_freq": {
            "description": "Ignore terms which do not occur in at least this many docs.",
            "type": "number"
          },
          "min_term_freq": {
            "description": "Ignore words with less than this frequency in the source doc.",
            "type": "number"
          },
          "min_word_length": {
            "description": "The minimum word length below which words will be ignored.",
            "type": "number"
          }
        }
      },
      "_global.mtermvectors:TermVectorsResult": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "took": {
            "type": "number"
          },
          "found": {
            "type": "boolean"
          },
          "term_vectors": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_global.termvectors:TermVector"
            }
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "_index"
        ]
      },
      "_global.termvectors:TermVector": {
        "type": "object",
        "properties": {
          "field_statistics": {
            "$ref": "#/components/schemas/_global.termvectors:FieldStatistics"
          },
          "terms": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_global.termvectors:Term"
            }
          }
        },
        "required": [
          "terms"
        ]
      },
      "_global.termvectors:FieldStatistics": {
        "type": "object",
        "properties": {
          "doc_count": {
            "type": "number"
          },
          "sum_doc_freq": {
            "type": "number"
          },
          "sum_ttf": {
            "type": "number"
          }
        },
        "required": [
          "doc_count",
          "sum_doc_freq",
          "sum_ttf"
        ]
      },
      "_global.termvectors:Term": {
        "type": "object",
        "properties": {
          "doc_freq": {
            "type": "number"
          },
          "score": {
            "type": "number"
          },
          "term_freq": {
            "type": "number"
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.termvectors:Token"
            }
          },
          "ttf": {
            "type": "number"
          }
        },
        "required": [
          "term_freq"
        ]
      },
      "_global.termvectors:Token": {
        "type": "object",
        "properties": {
          "end_offset": {
            "type": "number"
          },
          "payload": {
            "type": "string"
          },
          "position": {
            "type": "number"
          },
          "start_offset": {
            "type": "number"
          }
        },
        "required": [
          "position"
        ]
      },
      "nodes.clear_repositories_metering_archive:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "description": "Contains repositories metering information for the nodes selected by the request.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes._types:RepositoryMeteringInformation"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "nodes._types:RepositoryMeteringInformation": {
        "type": "object",
        "properties": {
          "repository_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "repository_type": {
            "description": "Repository type.",
            "type": "string"
          },
          "repository_location": {
            "$ref": "#/components/schemas/nodes._types:RepositoryLocation"
          },
          "repository_ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "repository_started_at": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "repository_stopped_at": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "archived": {
            "description": "A flag that tells whether or not this object has been archived. When a repository is closed or updated the\nrepository metering information is archived and kept for a certain period of time. This allows retrieving the\nrepository metering information of previous repository instantiations.",
            "type": "boolean"
          },
          "cluster_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "request_counts": {
            "$ref": "#/components/schemas/nodes._types:RequestCounts"
          }
        },
        "required": [
          "repository_name",
          "repository_type",
          "repository_location",
          "repository_ephemeral_id",
          "repository_started_at",
          "archived",
          "request_counts"
        ]
      },
      "nodes._types:RepositoryLocation": {
        "type": "object",
        "properties": {
          "base_path": {
            "type": "string"
          },
          "container": {
            "description": "Container name (Azure)",
            "type": "string"
          },
          "bucket": {
            "description": "Bucket name (GCP, S3)",
            "type": "string"
          }
        },
        "required": [
          "base_path"
        ]
      },
      "nodes._types:RequestCounts": {
        "type": "object",
        "properties": {
          "GetBlobProperties": {
            "description": "Number of Get Blob Properties requests (Azure)",
            "type": "number"
          },
          "GetBlob": {
            "description": "Number of Get Blob requests (Azure)",
            "type": "number"
          },
          "ListBlobs": {
            "description": "Number of List Blobs requests (Azure)",
            "type": "number"
          },
          "PutBlob": {
            "description": "Number of Put Blob requests (Azure)",
            "type": "number"
          },
          "PutBlock": {
            "description": "Number of Put Block (Azure)",
            "type": "number"
          },
          "PutBlockList": {
            "description": "Number of Put Block List requests",
            "type": "number"
          },
          "GetObject": {
            "description": "Number of get object requests (GCP, S3)",
            "type": "number"
          },
          "ListObjects": {
            "description": "Number of list objects requests (GCP, S3)",
            "type": "number"
          },
          "InsertObject": {
            "description": "Number of insert object requests, including simple, multipart and resumable uploads. Resumable uploads\ncan perform multiple http requests to insert a single object but they are considered as a single request\nsince they are billed as an individual operation. (GCP)",
            "type": "number"
          },
          "PutObject": {
            "description": "Number of PutObject requests (S3)",
            "type": "number"
          },
          "PutMultipartObject": {
            "description": "Number of Multipart requests, including CreateMultipartUpload, UploadPart and CompleteMultipartUpload requests (S3)",
            "type": "number"
          }
        }
      },
      "nodes.get_repositories_metering_info:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "description": "Contains repositories metering information for the nodes selected by the request.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes._types:RepositoryMeteringInformation"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "_types:ThreadType": {
        "type": "string",
        "enum": [
          "cpu",
          "wait",
          "block",
          "gpu",
          "mem"
        ]
      },
      "nodes.info:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes.info:NodeInfo"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "nodes.info:NodeInfo": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "build_flavor": {
            "type": "string"
          },
          "build_hash": {
            "description": "Short hash of the last git commit in this release.",
            "type": "string"
          },
          "build_type": {
            "type": "string"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "http": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoHttp"
          },
          "ip": {
            "$ref": "#/components/schemas/_types:Ip"
          },
          "jvm": {
            "$ref": "#/components/schemas/nodes.info:NodeJvmInfo"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "network": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoNetwork"
          },
          "os": {
            "$ref": "#/components/schemas/nodes.info:NodeOperatingSystemInfo"
          },
          "plugins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:PluginStats"
            }
          },
          "process": {
            "$ref": "#/components/schemas/nodes.info:NodeProcessInfo"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "settings": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettings"
          },
          "thread_pool": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeThreadPoolInfo"
            }
          },
          "total_indexing_buffer": {
            "description": "Total heap allowed to be used to hold recently indexed documents before they must be written to disk. This size is a shared pool across all shards on this node, and is controlled by Indexing Buffer settings.",
            "type": "number"
          },
          "total_indexing_buffer_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoTransport"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "modules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:PluginStats"
            }
          },
          "ingest": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngest"
          },
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoAggregation"
            }
          }
        },
        "required": [
          "attributes",
          "build_flavor",
          "build_hash",
          "build_type",
          "host",
          "ip",
          "name",
          "roles",
          "transport_address",
          "version"
        ]
      },
      "nodes.info:NodeInfoHttp": {
        "type": "object",
        "properties": {
          "bound_address": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "max_content_length": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_content_length_in_bytes": {
            "type": "number"
          },
          "publish_address": {
            "type": "string"
          }
        },
        "required": [
          "bound_address",
          "max_content_length_in_bytes",
          "publish_address"
        ]
      },
      "nodes.info:NodeJvmInfo": {
        "type": "object",
        "properties": {
          "gc_collectors": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mem": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoJvmMemory"
          },
          "memory_pools": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "pid": {
            "type": "number"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "vm_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "vm_vendor": {
            "type": "string"
          },
          "vm_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "using_bundled_jdk": {
            "type": "boolean"
          },
          "using_compressed_ordinary_object_pointers": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "input_arguments": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "gc_collectors",
          "mem",
          "memory_pools",
          "pid",
          "start_time_in_millis",
          "version",
          "vm_name",
          "vm_vendor",
          "vm_version",
          "using_bundled_jdk",
          "input_arguments"
        ]
      },
      "nodes.info:NodeInfoJvmMemory": {
        "type": "object",
        "properties": {
          "direct_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "direct_max_in_bytes": {
            "type": "number"
          },
          "heap_init": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "heap_init_in_bytes": {
            "type": "number"
          },
          "heap_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "heap_max_in_bytes": {
            "type": "number"
          },
          "non_heap_init": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "non_heap_init_in_bytes": {
            "type": "number"
          },
          "non_heap_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "non_heap_max_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "direct_max_in_bytes",
          "heap_init_in_bytes",
          "heap_max_in_bytes",
          "non_heap_init_in_bytes",
          "non_heap_max_in_bytes"
        ]
      },
      "nodes.info:NodeInfoNetwork": {
        "type": "object",
        "properties": {
          "primary_interface": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoNetworkInterface"
          },
          "refresh_interval": {
            "type": "number"
          }
        },
        "required": [
          "primary_interface",
          "refresh_interval"
        ]
      },
      "nodes.info:NodeInfoNetworkInterface": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "mac_address": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "address",
          "mac_address",
          "name"
        ]
      },
      "nodes.info:NodeOperatingSystemInfo": {
        "type": "object",
        "properties": {
          "arch": {
            "description": "Name of the JVM architecture (ex: amd64, x86)",
            "type": "string"
          },
          "available_processors": {
            "description": "Number of processors available to the Java virtual machine",
            "type": "number"
          },
          "allocated_processors": {
            "description": "The number of processors actually used to calculate thread pool size. This number can be set with the node.processors setting of a node and defaults to the number of processors reported by the OS.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "pretty_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "refresh_interval_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "cpu": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoOSCPU"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoMemory"
          },
          "swap": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoMemory"
          }
        },
        "required": [
          "arch",
          "available_processors",
          "name",
          "pretty_name",
          "refresh_interval_in_millis",
          "version"
        ]
      },
      "nodes.info:NodeInfoOSCPU": {
        "type": "object",
        "properties": {
          "cache_size": {
            "type": "string"
          },
          "cache_size_in_bytes": {
            "type": "number"
          },
          "cores_per_socket": {
            "type": "number"
          },
          "mhz": {
            "type": "number"
          },
          "model": {
            "type": "string"
          },
          "total_cores": {
            "type": "number"
          },
          "total_sockets": {
            "type": "number"
          },
          "vendor": {
            "type": "string"
          }
        },
        "required": [
          "cache_size",
          "cache_size_in_bytes",
          "cores_per_socket",
          "mhz",
          "model",
          "total_cores",
          "total_sockets",
          "vendor"
        ]
      },
      "nodes.info:NodeInfoMemory": {
        "type": "object",
        "properties": {
          "total": {
            "type": "string"
          },
          "total_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "total",
          "total_in_bytes"
        ]
      },
      "nodes.info:NodeProcessInfo": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Process identifier (PID)",
            "type": "number"
          },
          "mlockall": {
            "description": "Indicates if the process address space has been successfully locked in memory",
            "type": "boolean"
          },
          "refresh_interval_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "id",
          "mlockall",
          "refresh_interval_in_millis"
        ]
      },
      "nodes.info:NodeInfoSettings": {
        "type": "object",
        "properties": {
          "cluster": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsCluster"
          },
          "node": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsNode"
          },
          "path": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoPath"
          },
          "repositories": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoRepositories"
          },
          "discovery": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoDiscover"
          },
          "action": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoAction"
          },
          "client": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoClient"
          },
          "http": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsHttp"
          },
          "bootstrap": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoBootstrap"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsTransport"
          },
          "network": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsNetwork"
          },
          "xpack": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpack"
          },
          "script": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoScript"
          },
          "search": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSearch"
          },
          "ingest": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsIngest"
          }
        },
        "required": [
          "cluster",
          "node",
          "http",
          "transport"
        ]
      },
      "nodes.info:NodeInfoSettingsCluster": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "routing": {
            "$ref": "#/components/schemas/indices._types:IndexRouting"
          },
          "election": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsClusterElection"
          },
          "initial_master_nodes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "deprecation_indexing": {
            "$ref": "#/components/schemas/nodes.info:DeprecationIndexing"
          }
        },
        "required": [
          "name",
          "election"
        ]
      },
      "nodes.info:NodeInfoSettingsClusterElection": {
        "type": "object",
        "properties": {
          "strategy": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "strategy"
        ]
      },
      "nodes.info:DeprecationIndexing": {
        "type": "object",
        "properties": {
          "enabled": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeInfoSettingsNode": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "attr": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "max_local_storage_nodes": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "attr"
        ]
      },
      "nodes.info:NodeInfoPath": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "string"
          },
          "home": {
            "type": "string"
          },
          "repo": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "data": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          }
        }
      },
      "nodes.info:NodeInfoRepositories": {
        "type": "object",
        "properties": {
          "url": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoRepositoriesUrl"
          }
        },
        "required": [
          "url"
        ]
      },
      "nodes.info:NodeInfoRepositoriesUrl": {
        "type": "object",
        "properties": {
          "allowed_urls": {
            "type": "string"
          }
        },
        "required": [
          "allowed_urls"
        ]
      },
      "nodes.info:NodeInfoDiscover": {
        "type": "object",
        "properties": {
          "seed_hosts": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "type": {
            "type": "string"
          },
          "seed_providers": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "nodes.info:NodeInfoAction": {
        "type": "object",
        "properties": {
          "destructive_requires_name": {
            "type": "string"
          }
        },
        "required": [
          "destructive_requires_name"
        ]
      },
      "nodes.info:NodeInfoClient": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoSettingsHttp": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsHttpType"
          },
          "type.default": {
            "type": "string"
          },
          "compression": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "port": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoSettingsHttpType": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string"
          }
        },
        "required": [
          "default"
        ]
      },
      "nodes.info:NodeInfoBootstrap": {
        "type": "object",
        "properties": {
          "memory_lock": {
            "type": "string"
          }
        },
        "required": [
          "memory_lock"
        ]
      },
      "nodes.info:NodeInfoSettingsTransport": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsTransportType"
          },
          "type.default": {
            "type": "string"
          },
          "features": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsTransportFeatures"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoSettingsTransportType": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string"
          }
        },
        "required": [
          "default"
        ]
      },
      "nodes.info:NodeInfoSettingsTransportFeatures": {
        "type": "object",
        "properties": {
          "x-pack": {
            "type": "string"
          }
        },
        "required": [
          "x-pack"
        ]
      },
      "nodes.info:NodeInfoSettingsNetwork": {
        "type": "object",
        "properties": {
          "host": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Host"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Host"
                }
              }
            ]
          }
        }
      },
      "nodes.info:NodeInfoXpack": {
        "type": "object",
        "properties": {
          "license": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackLicense"
          },
          "security": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurity"
          },
          "notification": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "ml": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackMl"
          }
        },
        "required": [
          "security"
        ]
      },
      "nodes.info:NodeInfoXpackLicense": {
        "type": "object",
        "properties": {
          "self_generated": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackLicenseType"
          }
        },
        "required": [
          "self_generated"
        ]
      },
      "nodes.info:NodeInfoXpackLicenseType": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoXpackSecurity": {
        "type": "object",
        "properties": {
          "http": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecuritySsl"
          },
          "enabled": {
            "type": "string"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecuritySsl"
          },
          "authc": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthc"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeInfoXpackSecuritySsl": {
        "type": "object",
        "properties": {
          "ssl": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "ssl"
        ]
      },
      "nodes.info:NodeInfoXpackSecurityAuthc": {
        "type": "object",
        "properties": {
          "realms": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealms"
          },
          "token": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcToken"
          }
        }
      },
      "nodes.info:NodeInfoXpackSecurityAuthcRealms": {
        "type": "object",
        "properties": {
          "file": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus"
            }
          },
          "native": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus"
            }
          },
          "pki": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus"
            }
          }
        }
      },
      "nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "string"
          },
          "order": {
            "type": "string"
          }
        },
        "required": [
          "order"
        ]
      },
      "nodes.info:NodeInfoXpackSecurityAuthcToken": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "string"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeInfoXpackMl": {
        "type": "object",
        "properties": {
          "use_auto_machine_memory_percent": {
            "type": "boolean"
          }
        }
      },
      "nodes.info:NodeInfoScript": {
        "type": "object",
        "properties": {
          "allowed_types": {
            "type": "string"
          },
          "disable_max_compilations_rate": {
            "type": "string"
          }
        },
        "required": [
          "allowed_types"
        ]
      },
      "nodes.info:NodeInfoSearch": {
        "type": "object",
        "properties": {
          "remote": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSearchRemote"
          }
        },
        "required": [
          "remote"
        ]
      },
      "nodes.info:NodeInfoSearchRemote": {
        "type": "object",
        "properties": {
          "connect": {
            "type": "string"
          }
        },
        "required": [
          "connect"
        ]
      },
      "nodes.info:NodeInfoSettingsIngest": {
        "type": "object",
        "properties": {
          "attachment": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "append": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "csv": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "convert": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "date": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "date_index_name": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "dot_expander": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "enrich": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "fail": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "foreach": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "json": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "user_agent": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "kv": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "geoip": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "grok": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "gsub": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "join": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "lowercase": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "remove": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "rename": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "script": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "set": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "sort": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "split": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "trim": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "uppercase": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "urldecode": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "bytes": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "dissect": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "set_security_user": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "pipeline": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "drop": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "circle": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "inference": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          }
        }
      },
      "nodes.info:NodeInfoIngestInfo": {
        "type": "object",
        "properties": {
          "downloader": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestDownloader"
          }
        },
        "required": [
          "downloader"
        ]
      },
      "nodes.info:NodeInfoIngestDownloader": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "string"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeThreadPoolInfo": {
        "type": "object",
        "properties": {
          "core": {
            "type": "number"
          },
          "keep_alive": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max": {
            "type": "number"
          },
          "queue_size": {
            "type": "number"
          },
          "size": {
            "type": "number"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "queue_size",
          "type"
        ]
      },
      "nodes.info:NodeInfoTransport": {
        "type": "object",
        "properties": {
          "bound_address": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "publish_address": {
            "type": "string"
          },
          "profiles": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "bound_address",
          "publish_address",
          "profiles"
        ]
      },
      "nodes.info:NodeInfoIngest": {
        "type": "object",
        "properties": {
          "processors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoIngestProcessor"
            }
          }
        },
        "required": [
          "processors"
        ]
      },
      "nodes.info:NodeInfoIngestProcessor": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoAggregation": {
        "type": "object",
        "properties": {
          "types": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "types"
        ]
      },
      "_types:Password": {
        "type": "string"
      },
      "nodes.reload_secure_settings:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes._types:NodeReloadResult"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "nodes._types:NodeReloadResult": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "reload_exception": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "name"
        ]
      },
      "nodes.stats:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes._types:Stats"
                }
              }
            },
            "required": [
              "nodes"
            ]
          }
        ]
      },
      "nodes._types:Stats": {
        "type": "object",
        "properties": {
          "adaptive_selection": {
            "description": "Statistics about adaptive replica selection.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:AdaptiveSelection"
            }
          },
          "breakers": {
            "description": "Statistics about the field data circuit breaker.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:Breaker"
            }
          },
          "fs": {
            "$ref": "#/components/schemas/nodes._types:FileSystem"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "http": {
            "$ref": "#/components/schemas/nodes._types:Http"
          },
          "ingest": {
            "$ref": "#/components/schemas/nodes._types:Ingest"
          },
          "ip": {
            "description": "IP address and port for the node.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Ip"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Ip"
                }
              }
            ]
          },
          "jvm": {
            "$ref": "#/components/schemas/nodes._types:Jvm"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "os": {
            "$ref": "#/components/schemas/nodes._types:OperatingSystem"
          },
          "process": {
            "$ref": "#/components/schemas/nodes._types:Process"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "script": {
            "$ref": "#/components/schemas/nodes._types:Scripting"
          },
          "script_cache": {
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/nodes._types:ScriptCache"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/nodes._types:ScriptCache"
                  }
                }
              ]
            }
          },
          "thread_pool": {
            "description": "Statistics about each thread pool, including current size, queue and rejected tasks.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:ThreadCount"
            }
          },
          "timestamp": {
            "type": "number"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes._types:Transport"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "attributes": {
            "description": "Contains a list of attributes for the node.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "discovery": {
            "$ref": "#/components/schemas/nodes._types:Discovery"
          },
          "indexing_pressure": {
            "$ref": "#/components/schemas/nodes._types:IndexingPressure"
          },
          "indices": {
            "$ref": "#/components/schemas/indices.stats:ShardStats"
          }
        }
      },
      "nodes._types:AdaptiveSelection": {
        "type": "object",
        "properties": {
          "avg_queue_size": {
            "description": "The exponentially weighted moving average queue size of search requests on the keyed node.",
            "type": "number"
          },
          "avg_response_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "avg_response_time_ns": {
            "description": "The exponentially weighted moving average response time, in nanoseconds, of search requests on the keyed node.",
            "type": "number"
          },
          "avg_service_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "avg_service_time_ns": {
            "description": "The exponentially weighted moving average service time, in nanoseconds, of search requests on the keyed node.",
            "type": "number"
          },
          "outgoing_searches": {
            "description": "The number of outstanding search requests to the keyed node from the node these stats are for.",
            "type": "number"
          },
          "rank": {
            "description": "The rank of this node; used for shard selection when routing search requests.",
            "type": "string"
          }
        }
      },
      "nodes._types:Breaker": {
        "type": "object",
        "properties": {
          "estimated_size": {
            "description": "Estimated memory used for the operation.",
            "type": "string"
          },
          "estimated_size_in_bytes": {
            "description": "Estimated memory used, in bytes, for the operation.",
            "type": "number"
          },
          "limit_size": {
            "description": "Memory limit for the circuit breaker.",
            "type": "string"
          },
          "limit_size_in_bytes": {
            "description": "Memory limit, in bytes, for the circuit breaker.",
            "type": "number"
          },
          "overhead": {
            "description": "A constant that all estimates for the circuit breaker are multiplied with to calculate a final estimate.",
            "type": "number"
          },
          "tripped": {
            "description": "Total number of times the circuit breaker has been triggered and prevented an out of memory error.",
            "type": "number"
          }
        }
      },
      "nodes._types:FileSystem": {
        "type": "object",
        "properties": {
          "data": {
            "description": "List of all file stores.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:DataPathStats"
            }
          },
          "timestamp": {
            "description": "Last time the file stores statistics were refreshed.\nRecorded in milliseconds since the Unix Epoch.",
            "type": "number"
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:FileSystemTotal"
          },
          "io_stats": {
            "$ref": "#/components/schemas/nodes._types:IoStats"
          }
        }
      },
      "nodes._types:DataPathStats": {
        "type": "object",
        "properties": {
          "available": {
            "description": "Total amount of disk space available to this Java virtual machine on this file store.",
            "type": "string"
          },
          "available_in_bytes": {
            "description": "Total number of bytes available to this Java virtual machine on this file store.",
            "type": "number"
          },
          "disk_queue": {
            "type": "string"
          },
          "disk_reads": {
            "type": "number"
          },
          "disk_read_size": {
            "type": "string"
          },
          "disk_read_size_in_bytes": {
            "type": "number"
          },
          "disk_writes": {
            "type": "number"
          },
          "disk_write_size": {
            "type": "string"
          },
          "disk_write_size_in_bytes": {
            "type": "number"
          },
          "free": {
            "description": "Total amount of unallocated disk space in the file store.",
            "type": "string"
          },
          "free_in_bytes": {
            "description": "Total number of unallocated bytes in the file store.",
            "type": "number"
          },
          "mount": {
            "description": "Mount point of the file store (for example: `/dev/sda2`).",
            "type": "string"
          },
          "path": {
            "description": "Path to the file store.",
            "type": "string"
          },
          "total": {
            "description": "Total size of the file store.",
            "type": "string"
          },
          "total_in_bytes": {
            "description": "Total size of the file store in bytes.",
            "type": "number"
          },
          "type": {
            "description": "Type of the file store (ex: ext4).",
            "type": "string"
          }
        }
      },
      "nodes._types:FileSystemTotal": {
        "type": "object",
        "properties": {
          "available": {
            "description": "Total disk space available to this Java virtual machine on all file stores.\nDepending on OS or process level restrictions, this might appear less than `free`.\nThis is the actual amount of free disk space the Elasticsearch node can utilise.",
            "type": "string"
          },
          "available_in_bytes": {
            "description": "Total number of bytes available to this Java virtual machine on all file stores.\nDepending on OS or process level restrictions, this might appear less than `free_in_bytes`.\nThis is the actual amount of free disk space the Elasticsearch node can utilise.",
            "type": "number"
          },
          "free": {
            "description": "Total unallocated disk space in all file stores.",
            "type": "string"
          },
          "free_in_bytes": {
            "description": "Total number of unallocated bytes in all file stores.",
            "type": "number"
          },
          "total": {
            "description": "Total size of all file stores.",
            "type": "string"
          },
          "total_in_bytes": {
            "description": "Total size of all file stores in bytes.",
            "type": "number"
          }
        }
      },
      "nodes._types:IoStats": {
        "type": "object",
        "properties": {
          "devices": {
            "description": "Array of disk metrics for each device that is backing an Elasticsearch data path.\nThese disk metrics are probed periodically and averages between the last probe and the current probe are computed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:IoStatDevice"
            }
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:IoStatDevice"
          }
        }
      },
      "nodes._types:IoStatDevice": {
        "type": "object",
        "properties": {
          "device_name": {
            "description": "The Linux device name.",
            "type": "string"
          },
          "operations": {
            "description": "The total number of read and write operations for the device completed since starting Elasticsearch.",
            "type": "number"
          },
          "read_kilobytes": {
            "description": "The total number of kilobytes read for the device since starting Elasticsearch.",
            "type": "number"
          },
          "read_operations": {
            "description": "The total number of read operations for the device completed since starting Elasticsearch.",
            "type": "number"
          },
          "write_kilobytes": {
            "description": "The total number of kilobytes written for the device since starting Elasticsearch.",
            "type": "number"
          },
          "write_operations": {
            "description": "The total number of write operations for the device completed since starting Elasticsearch.",
            "type": "number"
          }
        }
      },
      "nodes._types:Jvm": {
        "type": "object",
        "properties": {
          "buffer_pools": {
            "description": "Contains statistics about JVM buffer pools for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:NodeBufferPool"
            }
          },
          "classes": {
            "$ref": "#/components/schemas/nodes._types:JvmClasses"
          },
          "gc": {
            "$ref": "#/components/schemas/nodes._types:GarbageCollector"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes._types:JvmMemoryStats"
          },
          "threads": {
            "$ref": "#/components/schemas/nodes._types:JvmThreads"
          },
          "timestamp": {
            "description": "Last time JVM statistics were refreshed.",
            "type": "number"
          },
          "uptime": {
            "description": "Human-readable JVM uptime.\nOnly returned if the `human` query parameter is `true`.",
            "type": "string"
          },
          "uptime_in_millis": {
            "description": "JVM uptime in milliseconds.",
            "type": "number"
          }
        }
      },
      "nodes._types:NodeBufferPool": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of buffer pools.",
            "type": "number"
          },
          "total_capacity": {
            "description": "Total capacity of buffer pools.",
            "type": "string"
          },
          "total_capacity_in_bytes": {
            "description": "Total capacity of buffer pools in bytes.",
            "type": "number"
          },
          "used": {
            "description": "Size of buffer pools.",
            "type": "string"
          },
          "used_in_bytes": {
            "description": "Size of buffer pools in bytes.",
            "type": "number"
          }
        }
      },
      "nodes._types:JvmClasses": {
        "type": "object",
        "properties": {
          "current_loaded_count": {
            "description": "Number of classes currently loaded by JVM.",
            "type": "number"
          },
          "total_loaded_count": {
            "description": "Total number of classes loaded since the JVM started.",
            "type": "number"
          },
          "total_unloaded_count": {
            "description": "Total number of classes unloaded since the JVM started.",
            "type": "number"
          }
        }
      },
      "nodes._types:GarbageCollector": {
        "type": "object",
        "properties": {
          "collectors": {
            "description": "Contains statistics about JVM garbage collectors for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:GarbageCollectorTotal"
            }
          }
        }
      },
      "nodes._types:GarbageCollectorTotal": {
        "type": "object",
        "properties": {
          "collection_count": {
            "description": "Total number of JVM garbage collectors that collect objects.",
            "type": "number"
          },
          "collection_time": {
            "description": "Total time spent by JVM collecting objects.",
            "type": "string"
          },
          "collection_time_in_millis": {
            "description": "Total time, in milliseconds, spent by JVM collecting objects.",
            "type": "number"
          }
        }
      },
      "nodes._types:JvmMemoryStats": {
        "type": "object",
        "properties": {
          "heap_used_in_bytes": {
            "description": "Memory, in bytes, currently in use by the heap.",
            "type": "number"
          },
          "heap_used_percent": {
            "description": "Percentage of memory currently in use by the heap.",
            "type": "number"
          },
          "heap_committed_in_bytes": {
            "description": "Amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "heap_max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "non_heap_used_in_bytes": {
            "description": "Non-heap memory used, in bytes.",
            "type": "number"
          },
          "non_heap_committed_in_bytes": {
            "description": "Amount of non-heap memory available, in bytes.",
            "type": "number"
          },
          "pools": {
            "description": "Contains statistics about heap memory usage for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:Pool"
            }
          }
        }
      },
      "nodes._types:Pool": {
        "type": "object",
        "properties": {
          "used_in_bytes": {
            "description": "Memory, in bytes, used by the heap.",
            "type": "number"
          },
          "max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "peak_used_in_bytes": {
            "description": "Largest amount of memory, in bytes, historically used by the heap.",
            "type": "number"
          },
          "peak_max_in_bytes": {
            "description": "Largest amount of memory, in bytes, historically used by the heap.",
            "type": "number"
          }
        }
      },
      "nodes._types:JvmThreads": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of active threads in use by JVM.",
            "type": "number"
          },
          "peak_count": {
            "description": "Highest number of threads used by JVM.",
            "type": "number"
          }
        }
      },
      "nodes._types:OperatingSystem": {
        "type": "object",
        "properties": {
          "cpu": {
            "$ref": "#/components/schemas/nodes._types:Cpu"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes._types:ExtendedMemoryStats"
          },
          "swap": {
            "$ref": "#/components/schemas/nodes._types:MemoryStats"
          },
          "cgroup": {
            "$ref": "#/components/schemas/nodes._types:Cgroup"
          },
          "timestamp": {
            "type": "number"
          }
        }
      },
      "nodes._types:Cpu": {
        "type": "object",
        "properties": {
          "percent": {
            "type": "number"
          },
          "sys": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "sys_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "user": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "user_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "load_average": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        }
      },
      "nodes._types:ExtendedMemoryStats": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:MemoryStats"
          },
          {
            "type": "object",
            "properties": {
              "free_percent": {
                "description": "Percentage of free memory.",
                "type": "number"
              },
              "used_percent": {
                "description": "Percentage of used memory.",
                "type": "number"
              }
            }
          }
        ]
      },
      "nodes._types:MemoryStats": {
        "type": "object",
        "properties": {
          "adjusted_total_in_bytes": {
            "description": "If the amount of physical memory has been overridden using the `es`.`total_memory_bytes` system property then this reports the overridden value in bytes.\nOtherwise it reports the same value as `total_in_bytes`.",
            "type": "number"
          },
          "resident": {
            "type": "string"
          },
          "resident_in_bytes": {
            "type": "number"
          },
          "share": {
            "type": "string"
          },
          "share_in_bytes": {
            "type": "number"
          },
          "total_virtual": {
            "type": "string"
          },
          "total_virtual_in_bytes": {
            "type": "number"
          },
          "total_in_bytes": {
            "description": "Total amount of physical memory in bytes.",
            "type": "number"
          },
          "free_in_bytes": {
            "description": "Amount of free physical memory in bytes.",
            "type": "number"
          },
          "used_in_bytes": {
            "description": "Amount of used physical memory in bytes.",
            "type": "number"
          }
        }
      },
      "nodes._types:Cgroup": {
        "type": "object",
        "properties": {
          "cpuacct": {
            "$ref": "#/components/schemas/nodes._types:CpuAcct"
          },
          "cpu": {
            "$ref": "#/components/schemas/nodes._types:CgroupCpu"
          },
          "memory": {
            "$ref": "#/components/schemas/nodes._types:CgroupMemory"
          }
        }
      },
      "nodes._types:CpuAcct": {
        "type": "object",
        "properties": {
          "control_group": {
            "description": "The `cpuacct` control group to which the Elasticsearch process belongs.",
            "type": "string"
          },
          "usage_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          }
        }
      },
      "nodes._types:CgroupCpu": {
        "type": "object",
        "properties": {
          "control_group": {
            "description": "The `cpu` control group to which the Elasticsearch process belongs.",
            "type": "string"
          },
          "cfs_period_micros": {
            "description": "The period of time, in microseconds, for how regularly all tasks in the same cgroup as the Elasticsearch process should have their access to CPU resources reallocated.",
            "type": "number"
          },
          "cfs_quota_micros": {
            "description": "The total amount of time, in microseconds, for which all tasks in the same cgroup as the Elasticsearch process can run during one period `cfs_period_micros`.",
            "type": "number"
          },
          "stat": {
            "$ref": "#/components/schemas/nodes._types:CgroupCpuStat"
          }
        }
      },
      "nodes._types:CgroupCpuStat": {
        "type": "object",
        "properties": {
          "number_of_elapsed_periods": {
            "description": "The number of reporting periods (as specified by `cfs_period_micros`) that have elapsed.",
            "type": "number"
          },
          "number_of_times_throttled": {
            "description": "The number of times all tasks in the same cgroup as the Elasticsearch process have been throttled.",
            "type": "number"
          },
          "time_throttled_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          }
        }
      },
      "nodes._types:CgroupMemory": {
        "type": "object",
        "properties": {
          "control_group": {
            "description": "The `memory` control group to which the Elasticsearch process belongs.",
            "type": "string"
          },
          "limit_in_bytes": {
            "description": "The maximum amount of user memory (including file cache) allowed for all tasks in the same cgroup as the Elasticsearch process.\nThis value can be too big to store in a `long`, so is returned as a string so that the value returned can exactly match what the underlying operating system interface returns.\nAny value that is too large to parse into a `long` almost certainly means no limit has been set for the cgroup.",
            "type": "string"
          },
          "usage_in_bytes": {
            "description": "The total current memory usage by processes in the cgroup, in bytes, by all tasks in the same cgroup as the Elasticsearch process.\nThis value is stored as a string for consistency with `limit_in_bytes`.",
            "type": "string"
          }
        }
      },
      "nodes._types:Process": {
        "type": "object",
        "properties": {
          "cpu": {
            "$ref": "#/components/schemas/nodes._types:Cpu"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes._types:MemoryStats"
          },
          "open_file_descriptors": {
            "description": "Number of opened file descriptors associated with the current or `-1` if not supported.",
            "type": "number"
          },
          "max_file_descriptors": {
            "description": "Maximum number of file descriptors allowed on the system, or `-1` if not supported.",
            "type": "number"
          },
          "timestamp": {
            "description": "Last time the statistics were refreshed.\nRecorded in milliseconds since the Unix Epoch.",
            "type": "number"
          }
        }
      },
      "nodes._types:ScriptCache": {
        "type": "object",
        "properties": {
          "cache_evictions": {
            "description": "Total number of times the script cache has evicted old data.",
            "type": "number"
          },
          "compilation_limit_triggered": {
            "description": "Total number of times the script compilation circuit breaker has limited inline script compilations.",
            "type": "number"
          },
          "compilations": {
            "description": "Total number of inline script compilations performed by the node.",
            "type": "number"
          },
          "context": {
            "type": "string"
          }
        }
      },
      "nodes._types:Transport": {
        "type": "object",
        "properties": {
          "inbound_handling_time_histogram": {
            "description": "The distribution of the time spent handling each inbound message on a transport thread, represented as a histogram.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:TransportHistogram"
            }
          },
          "outbound_handling_time_histogram": {
            "description": "The distribution of the time spent sending each outbound transport message on a transport thread, represented as a histogram.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:TransportHistogram"
            }
          },
          "rx_count": {
            "description": "Total number of RX (receive) packets received by the node during internal cluster communication.",
            "type": "number"
          },
          "rx_size": {
            "description": "Size of RX packets received by the node during internal cluster communication.",
            "type": "string"
          },
          "rx_size_in_bytes": {
            "description": "Size, in bytes, of RX packets received by the node during internal cluster communication.",
            "type": "number"
          },
          "server_open": {
            "description": "Current number of inbound TCP connections used for internal communication between nodes.",
            "type": "number"
          },
          "tx_count": {
            "description": "Total number of TX (transmit) packets sent by the node during internal cluster communication.",
            "type": "number"
          },
          "tx_size": {
            "description": "Size of TX packets sent by the node during internal cluster communication.",
            "type": "string"
          },
          "tx_size_in_bytes": {
            "description": "Size, in bytes, of TX packets sent by the node during internal cluster communication.",
            "type": "number"
          },
          "total_outbound_connections": {
            "description": "The cumulative number of outbound transport connections that this node has opened since it started.\nEach transport connection may comprise multiple TCP connections but is only counted once in this statistic.\nTransport connections are typically long-lived so this statistic should remain constant in a stable cluster.",
            "type": "number"
          }
        }
      },
      "nodes._types:TransportHistogram": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of times a transport thread took a period of time within the bounds of this bucket to handle an inbound message.",
            "type": "number"
          },
          "lt_millis": {
            "description": "The exclusive upper bound of the bucket in milliseconds.\nMay be omitted on the last bucket if this bucket has no upper bound.",
            "type": "number"
          },
          "ge_millis": {
            "description": "The inclusive lower bound of the bucket in milliseconds. May be omitted on the first bucket if this bucket has no lower bound.",
            "type": "number"
          }
        }
      },
      "nodes._types:Discovery": {
        "type": "object",
        "properties": {
          "cluster_state_queue": {
            "$ref": "#/components/schemas/nodes._types:ClusterStateQueue"
          },
          "published_cluster_states": {
            "$ref": "#/components/schemas/nodes._types:PublishedClusterStates"
          },
          "cluster_state_update": {
            "description": "Contains low-level statistics about how long various activities took during cluster state updates while the node was the elected master.\nOmitted if the node is not master-eligible.\nEvery field whose name ends in `_time` within this object is also represented as a raw number of milliseconds in a field whose name ends in `_time_millis`.\nThe human-readable fields with a `_time` suffix are only returned if requested with the `?human=true` query parameter.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:ClusterStateUpdate"
            }
          },
          "serialized_cluster_states": {
            "$ref": "#/components/schemas/nodes._types:SerializedClusterState"
          },
          "cluster_applier_stats": {
            "$ref": "#/components/schemas/nodes._types:ClusterAppliedStats"
          }
        }
      },
      "nodes._types:ClusterStateQueue": {
        "type": "object",
        "properties": {
          "total": {
            "description": "Total number of cluster states in queue.",
            "type": "number"
          },
          "pending": {
            "description": "Number of pending cluster states in queue.",
            "type": "number"
          },
          "committed": {
            "description": "Number of committed cluster states in queue.",
            "type": "number"
          }
        }
      },
      "nodes._types:PublishedClusterStates": {
        "type": "object",
        "properties": {
          "full_states": {
            "description": "Number of published cluster states.",
            "type": "number"
          },
          "incompatible_diffs": {
            "description": "Number of incompatible differences between published cluster states.",
            "type": "number"
          },
          "compatible_diffs": {
            "description": "Number of compatible differences between published cluster states.",
            "type": "number"
          }
        }
      },
      "nodes._types:ClusterStateUpdate": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of cluster state update attempts that did not change the cluster state since the node started.",
            "type": "number"
          },
          "computation_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "computation_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "publication_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "publication_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "context_construction_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "context_construction_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "commit_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "commit_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "completion_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "completion_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "master_apply_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "master_apply_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "notification_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "notification_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "count"
        ]
      },
      "nodes._types:SerializedClusterState": {
        "type": "object",
        "properties": {
          "full_states": {
            "$ref": "#/components/schemas/nodes._types:SerializedClusterStateDetail"
          },
          "diffs": {
            "$ref": "#/components/schemas/nodes._types:SerializedClusterStateDetail"
          }
        }
      },
      "nodes._types:SerializedClusterStateDetail": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "uncompressed_size": {
            "type": "string"
          },
          "uncompressed_size_in_bytes": {
            "type": "number"
          },
          "compressed_size": {
            "type": "string"
          },
          "compressed_size_in_bytes": {
            "type": "number"
          }
        }
      },
      "nodes._types:ClusterAppliedStats": {
        "type": "object",
        "properties": {
          "recordings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:Recording"
            }
          }
        }
      },
      "nodes._types:Recording": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "cumulative_execution_count": {
            "type": "number"
          },
          "cumulative_execution_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "cumulative_execution_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        }
      },
      "nodes._types:IndexingPressure": {
        "type": "object",
        "properties": {
          "memory": {
            "$ref": "#/components/schemas/nodes._types:IndexingPressureMemory"
          }
        }
      },
      "nodes._types:IndexingPressureMemory": {
        "type": "object",
        "properties": {
          "limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "limit_in_bytes": {
            "description": "Configured memory limit, in bytes, for the indexing requests.\nReplica requests have an automatic limit that is 1.5x this value.",
            "type": "number"
          },
          "current": {
            "$ref": "#/components/schemas/nodes._types:PressureMemory"
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:PressureMemory"
          }
        }
      },
      "nodes._types:PressureMemory": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "all_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the coordinating, primary, or replica stage.",
            "type": "number"
          },
          "combined_coordinating_and_primary": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "combined_coordinating_and_primary_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the coordinating or primary stage.\nThis value is not the sum of coordinating and primary as a node can reuse the coordinating memory if the primary stage is executed locally.",
            "type": "number"
          },
          "coordinating": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "coordinating_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the coordinating stage.",
            "type": "number"
          },
          "primary": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "primary_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the primary stage.",
            "type": "number"
          },
          "replica": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "replica_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the replica stage.",
            "type": "number"
          },
          "coordinating_rejections": {
            "description": "Number of indexing requests rejected in the coordinating stage.",
            "type": "number"
          },
          "primary_rejections": {
            "description": "Number of indexing requests rejected in the primary stage.",
            "type": "number"
          },
          "replica_rejections": {
            "description": "Number of indexing requests rejected in the replica stage.",
            "type": "number"
          }
        }
      },
      "nodes.usage:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes.usage:NodeUsage"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "nodes.usage:NodeUsage": {
        "type": "object",
        "properties": {
          "rest_actions": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "since": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "rest_actions",
          "since",
          "timestamp",
          "aggregations"
        ]
      },
      "query_rules._types:QueryRule": {
        "type": "object",
        "properties": {
          "rule_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "type": {
            "$ref": "#/components/schemas/query_rules._types:QueryRuleType"
          },
          "criteria": {
            "description": "The criteria that must be met for the rule to be applied.\nIf multiple criteria are specified for a rule, all criteria must be met for the rule to be applied.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/query_rules._types:QueryRuleCriteria"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/query_rules._types:QueryRuleCriteria"
                }
              }
            ]
          },
          "actions": {
            "$ref": "#/components/schemas/query_rules._types:QueryRuleActions"
          },
          "priority": {
            "type": "number"
          }
        },
        "required": [
          "rule_id",
          "type",
          "criteria",
          "actions"
        ]
      },
      "query_rules._types:QueryRuleType": {
        "type": "string",
        "enum": [
          "pinned",
          "exclude"
        ]
      },
      "query_rules._types:QueryRuleCriteria": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/query_rules._types:QueryRuleCriteriaType"
          },
          "metadata": {
            "description": "The metadata field to match against.\nThis metadata will be used to match against `match_criteria` sent in the rule.\nIt is required for all criteria types except `always`.",
            "type": "string"
          },
          "values": {
            "description": "The values to match against the `metadata` field.\nOnly one value must match for the criteria to be met.\nIt is required for all criteria types except `always`.",
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "query_rules._types:QueryRuleCriteriaType": {
        "type": "string",
        "enum": [
          "global",
          "exact",
          "exact_fuzzy",
          "fuzzy",
          "prefix",
          "suffix",
          "contains",
          "lt",
          "lte",
          "gt",
          "gte",
          "always"
        ]
      },
      "query_rules._types:QueryRuleActions": {
        "type": "object",
        "properties": {
          "ids": {
            "description": "The unique document IDs of the documents to apply the rule to.\nOnly one of `ids` or `docs` may be specified and at least one must be specified.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "docs": {
            "description": "The documents to apply the rule to.\nOnly one of `ids` or `docs` may be specified and at least one must be specified.\nThere is a maximum value of 100 documents in a rule.\nYou can specify the following attributes for each document:\n\n* `_index`: The index of the document to pin.\n* `_id`: The unique document ID.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:PinnedDoc"
            }
          }
        }
      },
      "query_rules._types:QueryRuleset": {
        "type": "object",
        "properties": {
          "ruleset_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "rules": {
            "description": "Rules associated with the query ruleset.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/query_rules._types:QueryRule"
            }
          }
        },
        "required": [
          "ruleset_id",
          "rules"
        ]
      },
      "query_rules.list_rulesets:QueryRulesetListItem": {
        "type": "object",
        "properties": {
          "ruleset_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "rule_total_count": {
            "description": "The number of rules associated with the ruleset.",
            "type": "number"
          },
          "rule_criteria_types_counts": {
            "description": "A map of criteria type (for example, `exact`) to the number of rules of that type.\n\nNOTE: The counts in `rule_criteria_types_counts` may be larger than the value of `rule_total_count` because a rule may have multiple criteria.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "rule_type_counts": {
            "description": "A map of rule type (for example, `pinned`) to the number of rules of that type.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "ruleset_id",
          "rule_total_count",
          "rule_criteria_types_counts",
          "rule_type_counts"
        ]
      },
      "query_rules.test:QueryRulesetMatchedRule": {
        "type": "object",
        "properties": {
          "ruleset_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "rule_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "required": [
          "ruleset_id",
          "rule_id"
        ]
      },
      "_global.rank_eval:RankEvalRequestItem": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "request": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalQuery"
          },
          "ratings": {
            "description": "List of document ratings",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.rank_eval:DocumentRating"
            }
          },
          "template_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "description": "The search template parameters.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "id",
          "ratings"
        ]
      },
      "_global.rank_eval:RankEvalQuery": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "size": {
            "type": "number"
          }
        },
        "required": [
          "query"
        ]
      },
      "_global.rank_eval:DocumentRating": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "rating": {
            "description": "The documentâ€™s relevance with regard to this search request.",
            "type": "number"
          }
        },
        "required": [
          "_id",
          "_index",
          "rating"
        ]
      },
      "_global.rank_eval:RankEvalMetric": {
        "type": "object",
        "properties": {
          "precision": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricPrecision"
          },
          "recall": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRecall"
          },
          "mean_reciprocal_rank": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricMeanReciprocalRank"
          },
          "dcg": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricDiscountedCumulativeGain"
          },
          "expected_reciprocal_rank": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricExpectedReciprocalRank"
          }
        }
      },
      "_global.rank_eval:RankEvalMetricPrecision": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRatingTreshold"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unlabeled": {
                "description": "Controls how unlabeled documents in the search results are counted. If set to true, unlabeled documents are ignored and neither count as relevant or irrelevant. Set to false (the default), they are treated as irrelevant.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricRatingTreshold": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricBase"
          },
          {
            "type": "object",
            "properties": {
              "relevant_rating_threshold": {
                "description": "Sets the rating threshold above which documents are considered to be \"relevant\".",
                "type": "number"
              }
            }
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricBase": {
        "type": "object",
        "properties": {
          "k": {
            "description": "Sets the maximum number of documents retrieved per query. This value will act in place of the usual size parameter in the query.",
            "type": "number"
          }
        }
      },
      "_global.rank_eval:RankEvalMetricRecall": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRatingTreshold"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricMeanReciprocalRank": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRatingTreshold"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricDiscountedCumulativeGain": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricBase"
          },
          {
            "type": "object",
            "properties": {
              "normalize": {
                "description": "If set to true, this metric will calculate the Normalized DCG.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricExpectedReciprocalRank": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricBase"
          },
          {
            "type": "object",
            "properties": {
              "maximum_relevance": {
                "description": "The highest relevance grade used in the user-supplied relevance judgments.",
                "type": "number"
              }
            },
            "required": [
              "maximum_relevance"
            ]
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricDetail": {
        "type": "object",
        "properties": {
          "metric_score": {
            "description": "The metric_score in the details section shows the contribution of this query to the global quality metric score",
            "type": "number"
          },
          "unrated_docs": {
            "description": "The unrated_docs section contains an _index and _id entry for each document in the search result for this query that didnâ€™t have a ratings value. This can be used to ask the user to supply ratings for these documents",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.rank_eval:UnratedDocument"
            }
          },
          "hits": {
            "description": "The hits section shows a grouping of the search results with their supplied ratings",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.rank_eval:RankEvalHitItem"
            }
          },
          "metric_details": {
            "description": "The metric_details give additional information about the calculated quality metric (e.g. how many of the retrieved documents were relevant). The content varies for each metric but allows for better interpretation of the results",
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "object"
              }
            }
          }
        },
        "required": [
          "metric_score",
          "unrated_docs",
          "hits",
          "metric_details"
        ]
      },
      "_global.rank_eval:UnratedDocument": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "_id",
          "_index"
        ]
      },
      "_global.rank_eval:RankEvalHitItem": {
        "type": "object",
        "properties": {
          "hit": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalHit"
          },
          "rating": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "hit"
        ]
      },
      "_global.rank_eval:RankEvalHit": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_score": {
            "type": "number"
          }
        },
        "required": [
          "_id",
          "_index",
          "_score"
        ]
      },
      "_global.reindex:Destination": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "op_type": {
            "$ref": "#/components/schemas/_types:OpType"
          },
          "pipeline": {
            "description": "The name of the pipeline to use.",
            "type": "string"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "index"
        ]
      },
      "_global.reindex:Source": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "remote": {
            "$ref": "#/components/schemas/_global.reindex:RemoteSource"
          },
          "size": {
            "description": "The number of documents to index per batch.\nUse it when you are indexing from remote to ensure that the batches fit within the on-heap buffer, which defaults to a maximum size of 100 MB.",
            "type": "number"
          },
          "slice": {
            "$ref": "#/components/schemas/_types:SlicedScroll"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:Sort"
          },
          "_source": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          }
        },
        "required": [
          "index"
        ]
      },
      "_global.reindex:RemoteSource": {
        "type": "object",
        "properties": {
          "connect_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "headers": {
            "description": "An object containing the headers of the request.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "password": {
            "$ref": "#/components/schemas/_types:Password"
          },
          "socket_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "host"
        ]
      },
      "_types:Username": {
        "type": "string"
      },
      "_global.reindex_rethrottle:ReindexNode": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_spec_utils:BaseNode"
          },
          {
            "type": "object",
            "properties": {
              "tasks": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_global.reindex_rethrottle:ReindexTask"
                }
              }
            },
            "required": [
              "tasks"
            ]
          }
        ]
      },
      "_global.reindex_rethrottle:ReindexTask": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string"
          },
          "cancellable": {
            "type": "boolean"
          },
          "description": {
            "type": "string"
          },
          "id": {
            "type": "number"
          },
          "node": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "running_time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "status": {
            "$ref": "#/components/schemas/_global.reindex_rethrottle:ReindexStatus"
          },
          "type": {
            "type": "string"
          },
          "headers": {
            "$ref": "#/components/schemas/_types:HttpHeaders"
          }
        },
        "required": [
          "action",
          "cancellable",
          "description",
          "id",
          "node",
          "running_time_in_nanos",
          "start_time_in_millis",
          "status",
          "type",
          "headers"
        ]
      },
      "_global.reindex_rethrottle:ReindexStatus": {
        "type": "object",
        "properties": {
          "batches": {
            "description": "The number of scroll responses pulled back by the reindex.",
            "type": "number"
          },
          "created": {
            "description": "The number of documents that were successfully created.",
            "type": "number"
          },
          "deleted": {
            "description": "The number of documents that were successfully deleted.",
            "type": "number"
          },
          "noops": {
            "description": "The number of documents that were ignored because the script used for the reindex returned a `noop` value for `ctx.op`.",
            "type": "number"
          },
          "requests_per_second": {
            "description": "The number of requests per second effectively executed during the reindex.",
            "type": "number"
          },
          "retries": {
            "$ref": "#/components/schemas/_types:Retries"
          },
          "throttled": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttled_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "throttled_until": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttled_until_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total": {
            "description": "The number of documents that were successfully processed.",
            "type": "number"
          },
          "updated": {
            "description": "The number of documents that were successfully updated, for example, a document with same ID already existed prior to reindex updating it.",
            "type": "number"
          },
          "version_conflicts": {
            "description": "The number of version conflicts that reindex hits.",
            "type": "number"
          }
        },
        "required": [
          "batches",
          "created",
          "deleted",
          "noops",
          "requests_per_second",
          "retries",
          "throttled_millis",
          "throttled_until_millis",
          "total",
          "updated",
          "version_conflicts"
        ]
      },
      "_spec_utils:BaseNode": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "ip": {
            "$ref": "#/components/schemas/_types:Ip"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          }
        },
        "required": [
          "attributes",
          "host",
          "ip",
          "name",
          "transport_address"
        ]
      },
      "rollup.get_jobs:RollupJob": {
        "type": "object",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/rollup.get_jobs:RollupJobConfiguration"
          },
          "stats": {
            "$ref": "#/components/schemas/rollup.get_jobs:RollupJobStats"
          },
          "status": {
            "$ref": "#/components/schemas/rollup.get_jobs:RollupJobStatus"
          }
        },
        "required": [
          "config",
          "stats",
          "status"
        ]
      },
      "rollup.get_jobs:RollupJobConfiguration": {
        "type": "object",
        "properties": {
          "cron": {
            "type": "string"
          },
          "groups": {
            "$ref": "#/components/schemas/rollup._types:Groupings"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index_pattern": {
            "type": "string"
          },
          "metrics": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/rollup._types:FieldMetric"
            }
          },
          "page_size": {
            "type": "number"
          },
          "rollup_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "cron",
          "groups",
          "id",
          "index_pattern",
          "metrics",
          "page_size",
          "rollup_index",
          "timeout"
        ]
      },
      "rollup._types:Groupings": {
        "type": "object",
        "properties": {
          "date_histogram": {
            "$ref": "#/components/schemas/rollup._types:DateHistogramGrouping"
          },
          "histogram": {
            "$ref": "#/components/schemas/rollup._types:HistogramGrouping"
          },
          "terms": {
            "$ref": "#/components/schemas/rollup._types:TermsGrouping"
          }
        }
      },
      "rollup._types:DateHistogramGrouping": {
        "type": "object",
        "properties": {
          "delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "format": {
            "type": "string"
          },
          "interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "calendar_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "fixed_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_zone": {
            "$ref": "#/components/schemas/_types:TimeZone"
          }
        },
        "required": [
          "field"
        ]
      },
      "rollup._types:HistogramGrouping": {
        "type": "object",
        "properties": {
          "fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "interval": {
            "description": "The interval of histogram buckets to be generated when rolling up.\nFor example, a value of `5` creates buckets that are five units wide (`0-5`, `5-10`, etc).\nNote that only one interval can be specified in the histogram group, meaning that all fields being grouped via the histogram must share the same interval.",
            "type": "number"
          }
        },
        "required": [
          "fields",
          "interval"
        ]
      },
      "rollup._types:TermsGrouping": {
        "type": "object",
        "properties": {
          "fields": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        },
        "required": [
          "fields"
        ]
      },
      "rollup._types:FieldMetric": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "description": "An array of metrics to collect for the field. At least one metric must be configured.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/rollup._types:Metric"
            }
          }
        },
        "required": [
          "field",
          "metrics"
        ]
      },
      "rollup._types:Metric": {
        "type": "string",
        "enum": [
          "min",
          "max",
          "sum",
          "avg",
          "value_count"
        ]
      },
      "rollup.get_jobs:RollupJobStats": {
        "type": "object",
        "properties": {
          "documents_processed": {
            "type": "number"
          },
          "index_failures": {
            "type": "number"
          },
          "index_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_total": {
            "type": "number"
          },
          "pages_processed": {
            "type": "number"
          },
          "rollups_indexed": {
            "type": "number"
          },
          "search_failures": {
            "type": "number"
          },
          "search_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "search_total": {
            "type": "number"
          },
          "trigger_count": {
            "type": "number"
          },
          "processing_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "processing_total": {
            "type": "number"
          }
        },
        "required": [
          "documents_processed",
          "index_failures",
          "index_time_in_ms",
          "index_total",
          "pages_processed",
          "rollups_indexed",
          "search_failures",
          "search_time_in_ms",
          "search_total",
          "trigger_count",
          "processing_time_in_ms",
          "processing_total"
        ]
      },
      "rollup.get_jobs:RollupJobStatus": {
        "type": "object",
        "properties": {
          "current_position": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "job_state": {
            "$ref": "#/components/schemas/rollup.get_jobs:IndexingJobState"
          },
          "upgraded_doc_id": {
            "type": "boolean"
          }
        },
        "required": [
          "job_state"
        ]
      },
      "rollup.get_jobs:IndexingJobState": {
        "type": "string",
        "enum": [
          "started",
          "indexing",
          "stopping",
          "stopped",
          "aborting"
        ]
      },
      "rollup.get_rollup_caps:RollupCapabilities": {
        "type": "object",
        "properties": {
          "rollup_jobs": {
            "description": "There can be multiple, independent jobs configured for a single index or index pattern. Each of these jobs may have different configurations, so the API returns a list of all the various configurations available.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/rollup.get_rollup_caps:RollupCapabilitySummary"
            }
          }
        },
        "required": [
          "rollup_jobs"
        ]
      },
      "rollup.get_rollup_caps:RollupCapabilitySummary": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/rollup.get_rollup_caps:RollupFieldSummary"
              }
            }
          },
          "index_pattern": {
            "type": "string"
          },
          "job_id": {
            "type": "string"
          },
          "rollup_index": {
            "type": "string"
          }
        },
        "required": [
          "fields",
          "index_pattern",
          "job_id",
          "rollup_index"
        ]
      },
      "rollup.get_rollup_caps:RollupFieldSummary": {
        "type": "object",
        "properties": {
          "agg": {
            "type": "string"
          },
          "calendar_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_zone": {
            "$ref": "#/components/schemas/_types:TimeZone"
          }
        },
        "required": [
          "agg"
        ]
      },
      "rollup.get_rollup_index_caps:IndexCapabilities": {
        "type": "object",
        "properties": {
          "rollup_jobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/rollup.get_rollup_index_caps:RollupJobSummary"
            }
          }
        },
        "required": [
          "rollup_jobs"
        ]
      },
      "rollup.get_rollup_index_caps:RollupJobSummary": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/rollup.get_rollup_index_caps:RollupJobSummaryField"
              }
            }
          },
          "index_pattern": {
            "type": "string"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "rollup_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "fields",
          "index_pattern",
          "job_id",
          "rollup_index"
        ]
      },
      "rollup.get_rollup_index_caps:RollupJobSummaryField": {
        "type": "object",
        "properties": {
          "agg": {
            "type": "string"
          },
          "time_zone": {
            "$ref": "#/components/schemas/_types:TimeZone"
          },
          "calendar_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "agg"
        ]
      },
      "_global.scripts_painless_execute:PainlessContextSetup": {
        "type": "object",
        "properties": {
          "document": {
            "description": "Document thatâ€™s temporarily indexed in-memory and accessible from the script.",
            "type": "object"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "document",
          "index"
        ]
      },
      "_types:RankContainer": {
        "type": "object",
        "properties": {
          "rrf": {
            "$ref": "#/components/schemas/_types:RrfRank"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:RrfRank": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RankBase"
          },
          {
            "type": "object",
            "properties": {
              "rank_constant": {
                "description": "How much influence documents in individual result sets per query have over the final ranked result set",
                "type": "number"
              },
              "rank_window_size": {
                "description": "Size of the individual result sets per query",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types:RankBase": {
        "type": "object"
      },
      "_types:RetrieverContainer": {
        "type": "object",
        "properties": {
          "standard": {
            "$ref": "#/components/schemas/_types:StandardRetriever"
          },
          "knn": {
            "$ref": "#/components/schemas/_types:KnnRetriever"
          },
          "rrf": {
            "$ref": "#/components/schemas/_types:RRFRetriever"
          },
          "text_similarity_reranker": {
            "$ref": "#/components/schemas/_types:TextSimilarityReranker"
          },
          "rule": {
            "$ref": "#/components/schemas/_types:RuleRetriever"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:StandardRetriever": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RetrieverBase"
          },
          {
            "type": "object",
            "properties": {
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "search_after": {
                "$ref": "#/components/schemas/_types:SortResults"
              },
              "terminate_after": {
                "description": "Maximum number of documents to collect for each shard.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              },
              "collapse": {
                "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
              }
            }
          }
        ]
      },
      "_types:RetrieverBase": {
        "type": "object",
        "properties": {
          "filter": {
            "description": "Query to filter the documents that can match.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            ]
          },
          "min_score": {
            "description": "Minimum _score for matching documents. Documents with a lower _score are not included in the top documents.",
            "type": "number"
          }
        }
      },
      "_types:KnnRetriever": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RetrieverBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "description": "The name of the vector field to search against.",
                "type": "string"
              },
              "query_vector": {
                "$ref": "#/components/schemas/_types:QueryVector"
              },
              "query_vector_builder": {
                "$ref": "#/components/schemas/_types:QueryVectorBuilder"
              },
              "k": {
                "description": "Number of nearest neighbors to return as top hits.",
                "type": "number"
              },
              "num_candidates": {
                "description": "Number of nearest neighbor candidates to consider per shard.",
                "type": "number"
              },
              "similarity": {
                "description": "The minimum similarity required for a document to be considered a match.",
                "type": "number"
              }
            },
            "required": [
              "field",
              "k",
              "num_candidates"
            ]
          }
        ]
      },
      "_types:RRFRetriever": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RetrieverBase"
          },
          {
            "type": "object",
            "properties": {
              "retrievers": {
                "description": "A list of child retrievers to specify which sets of returned top documents will have the RRF formula applied to them.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:RetrieverContainer"
                }
              },
              "rank_constant": {
                "description": "This value determines how much influence documents in individual result sets per query have over the final ranked result set.",
                "type": "number"
              },
              "rank_window_size": {
                "description": "This value determines the size of the individual result sets per query.",
                "type": "number"
              }
            },
            "required": [
              "retrievers"
            ]
          }
        ]
      },
      "_types:TextSimilarityReranker": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RetrieverBase"
          },
          {
            "type": "object",
            "properties": {
              "retriever": {
                "$ref": "#/components/schemas/_types:RetrieverContainer"
              },
              "rank_window_size": {
                "description": "This value determines how many documents we will consider from the nested retriever.",
                "type": "number"
              },
              "inference_id": {
                "description": "Unique identifier of the inference endpoint created using the inference API.",
                "type": "string"
              },
              "inference_text": {
                "description": "The text snippet used as the basis for similarity comparison",
                "type": "string"
              },
              "field": {
                "description": "The document field to be used for text similarity comparisons. This field should contain the text that will be evaluated against the inference_text",
                "type": "string"
              }
            },
            "required": [
              "retriever"
            ]
          }
        ]
      },
      "_types:RuleRetriever": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RetrieverBase"
          },
          {
            "type": "object",
            "properties": {
              "ruleset_ids": {
                "description": "The ruleset IDs containing the rules this retriever is evaluating against.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Id"
                }
              },
              "match_criteria": {
                "description": "The match criteria that will determine if a rule in the provided rulesets should be applied.",
                "type": "object"
              },
              "retriever": {
                "$ref": "#/components/schemas/_types:RetrieverContainer"
              },
              "rank_window_size": {
                "description": "This value determines the size of the individual result set.",
                "type": "number"
              }
            },
            "required": [
              "ruleset_ids",
              "match_criteria",
              "retriever"
            ]
          }
        ]
      },
      "search_application._types:SearchApplication": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "description": "Indices that are part of the Search Application.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "updated_at_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "analytics_collection_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "template": {
            "$ref": "#/components/schemas/search_application._types:SearchApplicationTemplate"
          }
        },
        "required": [
          "name",
          "indices",
          "updated_at_millis"
        ]
      },
      "search_application._types:SearchApplicationTemplate": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "script"
        ]
      },
      "search_application._types:AnalyticsCollection": {
        "type": "object",
        "properties": {
          "event_data_stream": {
            "$ref": "#/components/schemas/search_application._types:EventDataStream"
          }
        },
        "required": [
          "event_data_stream"
        ]
      },
      "search_application._types:EventDataStream": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "name"
        ]
      },
      "search_application.list:SearchApplicationListItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "description": "Indices that are part of the Search Application",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "updated_at_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "analytics_collection_name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name",
          "indices",
          "updated_at_millis"
        ]
      },
      "search_application._types:EventType": {
        "type": "string",
        "enum": [
          "page_view",
          "search",
          "search_click"
        ]
      },
      "search_application.put_behavioral_analytics:AnalyticsAcknowledgeResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/_types:Name"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      },
      "_global.search_mvt._types:ZoomLevel": {
        "type": "number"
      },
      "_global.search_mvt._types:Coordinate": {
        "type": "number"
      },
      "_global.search_mvt._types:GridAggregationType": {
        "type": "string",
        "enum": [
          "geotile",
          "geohex"
        ]
      },
      "_global.search_mvt._types:GridType": {
        "type": "string",
        "enum": [
          "grid",
          "point",
          "centroid"
        ]
      },
      "_types:MapboxVectorTiles": {
        "type": "object"
      },
      "_global.search_shards:SearchShardsNodeAttributes": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "external_id": {
            "type": "string"
          },
          "attributes": {
            "description": "Lists node attributes.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "min_index_version": {
            "type": "number"
          },
          "max_index_version": {
            "type": "number"
          }
        },
        "required": [
          "name",
          "ephemeral_id",
          "transport_address",
          "external_id",
          "attributes",
          "roles",
          "version",
          "min_index_version",
          "max_index_version"
        ]
      },
      "_types:NodeShard": {
        "type": "object",
        "properties": {
          "state": {
            "$ref": "#/components/schemas/indices.stats:ShardRoutingState"
          },
          "primary": {
            "type": "boolean"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "shard": {
            "type": "number"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "allocation_id": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "recovery_source": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "unassigned_info": {
            "$ref": "#/components/schemas/cluster.allocation_explain:UnassignedInformation"
          },
          "relocating_node": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:NodeId"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "relocation_failure_info": {
            "$ref": "#/components/schemas/_types:RelocationFailureInfo"
          }
        },
        "required": [
          "state",
          "primary",
          "shard",
          "index"
        ]
      },
      "_types:RelocationFailureInfo": {
        "type": "object",
        "properties": {
          "failed_attempts": {
            "type": "number"
          }
        },
        "required": [
          "failed_attempts"
        ]
      },
      "_global.search_shards:ShardStoreIndex": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        }
      },
      "searchable_snapshots.cache_stats:Node": {
        "type": "object",
        "properties": {
          "shared_cache": {
            "$ref": "#/components/schemas/searchable_snapshots.cache_stats:Shared"
          }
        },
        "required": [
          "shared_cache"
        ]
      },
      "searchable_snapshots.cache_stats:Shared": {
        "type": "object",
        "properties": {
          "reads": {
            "type": "number"
          },
          "bytes_read_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "writes": {
            "type": "number"
          },
          "bytes_written_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "evictions": {
            "type": "number"
          },
          "num_regions": {
            "type": "number"
          },
          "size_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "region_size_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        },
        "required": [
          "reads",
          "bytes_read_in_bytes",
          "writes",
          "bytes_written_in_bytes",
          "evictions",
          "num_regions",
          "size_in_bytes",
          "region_size_in_bytes"
        ]
      },
      "searchable_snapshots.mount:MountedSnapshot": {
        "type": "object",
        "properties": {
          "snapshot": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          }
        },
        "required": [
          "snapshot",
          "indices",
          "shards"
        ]
      },
      "searchable_snapshots._types:StatsLevel": {
        "type": "string",
        "enum": [
          "cluster",
          "indices",
          "shards"
        ]
      },
      "security._types:GrantType": {
        "type": "string",
        "enum": [
          "password",
          "access_token"
        ]
      },
      "security._types:UserProfileWithMetadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/security._types:UserProfile"
          },
          {
            "type": "object",
            "properties": {
              "last_synchronized": {
                "type": "number"
              },
              "_doc": {
                "$ref": "#/components/schemas/security._types:UserProfileHitMetadata"
              }
            },
            "required": [
              "last_synchronized",
              "_doc"
            ]
          }
        ]
      },
      "security._types:UserProfileHitMetadata": {
        "type": "object",
        "properties": {
          "_primary_term": {
            "type": "number"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          }
        },
        "required": [
          "_primary_term",
          "_seq_no"
        ]
      },
      "security._types:UserProfile": {
        "type": "object",
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/security._types:UserProfileId"
          },
          "user": {
            "$ref": "#/components/schemas/security._types:UserProfileUser"
          },
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "uid",
          "user",
          "data",
          "labels"
        ]
      },
      "security._types:UserProfileId": {
        "type": "string"
      },
      "security._types:UserProfileUser": {
        "type": "object",
        "properties": {
          "email": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "full_name": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Name"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "realm_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "realm_domain": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          }
        },
        "required": [
          "realm_name",
          "roles",
          "username"
        ]
      },
      "security.authenticate:AuthenticateApiKey": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "id"
        ]
      },
      "security._types:RealmInfo": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "security.authenticate:Token": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "security._types:BulkError": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of errors",
            "type": "number"
          },
          "details": {
            "description": "Details about the errors, keyed by role name",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "count",
          "details"
        ]
      },
      "security._types:RoleDescriptor": {
        "type": "object",
        "properties": {
          "cluster": {
            "description": "A list of cluster privileges. These privileges define the cluster level actions that API keys are able to execute.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ClusterPrivilege"
            }
          },
          "indices": {
            "description": "A list of indices permissions entries.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivileges"
            }
          },
          "remote_indices": {
            "description": "A list of indices permissions for remote clusters.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteIndicesPrivileges"
            }
          },
          "remote_cluster": {
            "description": "A list of cluster permissions for remote clusters.\nNOTE: This is limited a subset of the cluster permissions.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteClusterPrivileges"
            }
          },
          "global": {
            "description": "An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.",
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/security._types:GlobalPrivilege"
                }
              },
              {
                "$ref": "#/components/schemas/security._types:GlobalPrivilege"
              }
            ]
          },
          "applications": {
            "description": "A list of application privilege entries",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "run_as": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/run-as-privilege.html"
            },
            "description": "A list of users that the API keys can impersonate.\nNOTE: In Elastic Cloud Serverless, the run-as feature is disabled.\nFor API compatibility, you can still specify an empty `run_as` field, but a non-empty list will be rejected.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "description": "Optional description of the role descriptor",
            "type": "string"
          },
          "restriction": {
            "$ref": "#/components/schemas/security._types:Restriction"
          },
          "transient_metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        }
      },
      "security._types:ClusterPrivilege": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "all",
              "cancel_task",
              "create_snapshot",
              "cross_cluster_replication",
              "cross_cluster_search",
              "delegate_pki",
              "grant_api_key",
              "manage",
              "manage_api_key",
              "manage_autoscaling",
              "manage_behavioral_analytics",
              "manage_ccr",
              "manage_data_frame_transforms",
              "manage_data_stream_global_retention",
              "manage_enrich",
              "manage_ilm",
              "manage_index_templates",
              "manage_inference",
              "manage_ingest_pipelines",
              "manage_logstash_pipelines",
              "manage_ml",
              "manage_oidc",
              "manage_own_api_key",
              "manage_pipeline",
              "manage_rollup",
              "manage_saml",
              "manage_search_application",
              "manage_search_query_rules",
              "manage_search_synonyms",
              "manage_security",
              "manage_service_account",
              "manage_slm",
              "manage_token",
              "manage_transform",
              "manage_user_profile",
              "manage_watcher",
              "monitor",
              "monitor_data_frame_transforms",
              "monitor_data_stream_global_retention",
              "monitor_enrich",
              "monitor_inference",
              "monitor_ml",
              "monitor_rollup",
              "monitor_snapshot",
              "monitor_stats",
              "monitor_text_structure",
              "monitor_transform",
              "monitor_watcher",
              "none",
              "post_behavioral_analytics_event",
              "read_ccr",
              "read_fleet_secrets",
              "read_ilm",
              "read_pipeline",
              "read_security",
              "read_slm",
              "transport_client",
              "write_connector_secrets",
              "write_fleet_secrets"
            ]
          },
          {
            "type": "string"
          }
        ]
      },
      "security._types:IndicesPrivileges": {
        "type": "object",
        "properties": {
          "field_security": {
            "$ref": "#/components/schemas/security._types:FieldSecurity"
          },
          "names": {
            "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              }
            ]
          },
          "privileges": {
            "description": "The index level privileges that owners of the role have on the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "query": {
            "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "names",
          "privileges"
        ]
      },
      "security._types:FieldSecurity": {
        "type": "object",
        "properties": {
          "except": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "grant": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        }
      },
      "security._types:IndexPrivilege": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "all",
              "auto_configure",
              "create",
              "create_doc",
              "create_index",
              "cross_cluster_replication",
              "cross_cluster_replication_internal",
              "delete",
              "delete_index",
              "index",
              "maintenance",
              "manage",
              "manage_data_stream_lifecycle",
              "manage_follow_index",
              "manage_ilm",
              "manage_leader_index",
              "monitor",
              "none",
              "read",
              "read_cross_cluster",
              "view_index_metadata",
              "write"
            ]
          },
          {
            "type": "string"
          }
        ]
      },
      "security._types:IndicesPrivilegesQuery": {
        "description": "While creating or updating a role you can provide either a JSON structure or a string to the API.\nHowever, the response provided by Elasticsearch will only be string with a json-as-text content.\n\nSince this is embedded in `IndicesPrivileges`, the same structure is used for clarity in both contexts.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          {
            "$ref": "#/components/schemas/security._types:RoleTemplateQuery"
          }
        ]
      },
      "security._types:RoleTemplateQuery": {
        "type": "object",
        "properties": {
          "template": {
            "$ref": "#/components/schemas/security._types:RoleTemplateScript"
          }
        }
      },
      "security._types:RoleTemplateScript": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/security._types:RoleTemplateInlineQuery"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "description": "Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "lang": {
            "$ref": "#/components/schemas/_types:ScriptLanguage"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        }
      },
      "security._types:RoleTemplateInlineQuery": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        ]
      },
      "security._types:RemoteIndicesPrivileges": {
        "type": "object",
        "properties": {
          "clusters": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "field_security": {
            "$ref": "#/components/schemas/security._types:FieldSecurity"
          },
          "names": {
            "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              }
            ]
          },
          "privileges": {
            "description": "The index level privileges that owners of the role have on the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "query": {
            "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "clusters",
          "names",
          "privileges"
        ]
      },
      "security._types:RemoteClusterPrivileges": {
        "type": "object",
        "properties": {
          "clusters": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "privileges": {
            "description": "The cluster level privileges that owners of the role have on the remote cluster.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteClusterPrivilege"
            }
          }
        },
        "required": [
          "clusters",
          "privileges"
        ]
      },
      "security._types:RemoteClusterPrivilege": {
        "type": "string",
        "enum": [
          "monitor_enrich",
          "monitor_stats"
        ]
      },
      "security._types:GlobalPrivilege": {
        "type": "object",
        "properties": {
          "application": {
            "$ref": "#/components/schemas/security._types:ApplicationGlobalUserPrivileges"
          }
        },
        "required": [
          "application"
        ]
      },
      "security._types:ApplicationGlobalUserPrivileges": {
        "type": "object",
        "properties": {
          "manage": {
            "$ref": "#/components/schemas/security._types:ManageUserPrivileges"
          }
        },
        "required": [
          "manage"
        ]
      },
      "security._types:ManageUserPrivileges": {
        "type": "object",
        "properties": {
          "applications": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "applications"
        ]
      },
      "security._types:ApplicationPrivileges": {
        "type": "object",
        "properties": {
          "application": {
            "description": "The name of the application to which this entry applies.",
            "type": "string"
          },
          "privileges": {
            "description": "A list of strings, where each element is the name of an application privilege or action.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "resources": {
            "description": "A list resources to which the privileges are applied.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "application",
          "privileges",
          "resources"
        ]
      },
      "security._types:Restriction": {
        "type": "object",
        "properties": {
          "workflows": {
            "description": "A list of workflows to which the API key is restricted.\nNOTE: In order to use a role restriction, an API key must be created with a single role descriptor.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RestrictionWorkflow"
            }
          }
        },
        "required": [
          "workflows"
        ]
      },
      "security._types:RestrictionWorkflow": {
        "anyOf": [
          {
            "type": "string",
            "enum": [
              "search_application_query"
            ]
          },
          {
            "type": "string"
          }
        ]
      },
      "security._types:ClusterNode": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name"
        ]
      },
      "_types:Namespace": {
        "type": "string"
      },
      "_types:Service": {
        "type": "string"
      },
      "security._types:Access": {
        "type": "object",
        "properties": {
          "replication": {
            "description": "A list of indices permission entries for cross-cluster replication.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ReplicationAccess"
            }
          },
          "search": {
            "description": "A list of indices permission entries for cross-cluster search.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:SearchAccess"
            }
          }
        }
      },
      "security._types:ReplicationAccess": {
        "type": "object",
        "properties": {
          "names": {
            "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              }
            ]
          },
          "allow_restricted_indices": {
            "description": "This needs to be set to true if the patterns in the names field should cover system indices.",
            "type": "boolean"
          }
        },
        "required": [
          "names"
        ]
      },
      "security._types:SearchAccess": {
        "type": "object",
        "properties": {
          "field_security": {
            "$ref": "#/components/schemas/security._types:FieldSecurity"
          },
          "names": {
            "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              }
            ]
          },
          "query": {
            "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "names"
        ]
      },
      "security.create_service_token:Token": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "security.delegate_pki:Authentication": {
        "type": "object",
        "properties": {
          "username": {
            "type": "string"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "full_name": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "email": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "token": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "enabled": {
            "type": "boolean"
          },
          "authentication_realm": {
            "$ref": "#/components/schemas/security.delegate_pki:AuthenticationRealm"
          },
          "lookup_realm": {
            "$ref": "#/components/schemas/security.delegate_pki:AuthenticationRealm"
          },
          "authentication_type": {
            "type": "string"
          },
          "api_key": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "username",
          "roles",
          "full_name",
          "email",
          "metadata",
          "enabled",
          "authentication_realm",
          "lookup_realm",
          "authentication_type"
        ]
      },
      "security.delegate_pki:AuthenticationRealm": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "type": {
            "type": "string"
          },
          "domain": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "security.delete_privileges:FoundStatus": {
        "type": "object",
        "properties": {
          "found": {
            "type": "boolean"
          }
        },
        "required": [
          "found"
        ]
      },
      "security.enroll_kibana:Token": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The name of the bearer token for the `elastic/kibana` service account.",
            "type": "string"
          },
          "value": {
            "description": "The value of the bearer token for the `elastic/kibana` service account.\nUse this value to authenticate the service account with Elasticsearch.",
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "security._types:ApiKey": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "$ref": "#/components/schemas/security._types:ApiKeyType"
          },
          "creation": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "expiration": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "invalidated": {
            "description": "Invalidation status for the API key.\nIf the key has been invalidated, it has a value of `true`. Otherwise, it is `false`.",
            "type": "boolean"
          },
          "invalidation": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "realm": {
            "description": "Realm name of the principal for which this API key was created.",
            "type": "string"
          },
          "realm_type": {
            "description": "Realm type of the principal for which this API key was created",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "role_descriptors": {
            "description": "The role descriptors assigned to this API key when it was created or last updated.\nAn empty role descriptor means the API key inherits the owner userâ€™s permissions.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/security._types:RoleDescriptor"
            }
          },
          "limited_by": {
            "description": "The owner userâ€™s permissions associated with the API key.\nIt is a point-in-time snapshot captured at creation and subsequent updates.\nAn API keyâ€™s effective permissions are an intersection of its assigned privileges and the owner userâ€™s permissions.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security._types:RoleDescriptor"
              }
            }
          },
          "access": {
            "$ref": "#/components/schemas/security._types:Access"
          },
          "profile_uid": {
            "description": "The profile uid for the API key owner principal, if requested and if it exists",
            "type": "string"
          },
          "_sort": {
            "$ref": "#/components/schemas/_types:SortResults"
          }
        },
        "required": [
          "id",
          "name",
          "type",
          "creation",
          "invalidated",
          "username",
          "realm",
          "metadata"
        ]
      },
      "security._types:ApiKeyType": {
        "type": "string",
        "enum": [
          "rest",
          "cross_cluster"
        ]
      },
      "security.put_privileges:Actions": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "application": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "actions"
        ]
      },
      "security.get_role:Role": {
        "type": "object",
        "properties": {
          "cluster": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ClusterPrivilege"
            }
          },
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivileges"
            }
          },
          "remote_indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteIndicesPrivileges"
            }
          },
          "remote_cluster": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteClusterPrivileges"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "description": {
            "type": "string"
          },
          "run_as": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transient_metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "applications": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
            }
          },
          "role_templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RoleTemplate"
            }
          },
          "global": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "required": [
          "cluster",
          "indices",
          "metadata",
          "applications"
        ]
      },
      "security._types:RoleTemplate": {
        "type": "object",
        "properties": {
          "format": {
            "$ref": "#/components/schemas/security._types:TemplateFormat"
          },
          "template": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "template"
        ]
      },
      "security._types:TemplateFormat": {
        "type": "string",
        "enum": [
          "string",
          "json"
        ]
      },
      "security._types:RoleMapping": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "role_templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RoleTemplate"
            }
          },
          "rules": {
            "$ref": "#/components/schemas/security._types:RoleMappingRule"
          }
        },
        "required": [
          "enabled",
          "metadata",
          "rules"
        ]
      },
      "security._types:RoleMappingRule": {
        "type": "object",
        "properties": {
          "any": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RoleMappingRule"
            }
          },
          "all": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RoleMappingRule"
            }
          },
          "field": {
            "$ref": "#/components/schemas/security._types:FieldRule"
          },
          "except": {
            "$ref": "#/components/schemas/security._types:RoleMappingRule"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security._types:FieldRule": {
        "type": "object",
        "properties": {
          "username": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "dn": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "groups": {
            "$ref": "#/components/schemas/_types:Names"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security.get_service_accounts:RoleDescriptorWrapper": {
        "type": "object",
        "properties": {
          "role_descriptor": {
            "$ref": "#/components/schemas/security._types:RoleDescriptorRead"
          }
        },
        "required": [
          "role_descriptor"
        ]
      },
      "security._types:RoleDescriptorRead": {
        "type": "object",
        "properties": {
          "cluster": {
            "description": "A list of cluster privileges. These privileges define the cluster level actions that API keys are able to execute.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ClusterPrivilege"
            }
          },
          "indices": {
            "description": "A list of indices permissions entries.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivileges"
            }
          },
          "remote_indices": {
            "description": "A list of indices permissions for remote clusters.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteIndicesPrivileges"
            }
          },
          "remote_cluster": {
            "description": "A list of cluster permissions for remote clusters.\nNOTE: This is limited a subset of the cluster permissions.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RemoteClusterPrivileges"
            }
          },
          "global": {
            "description": "An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.",
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/security._types:GlobalPrivilege"
                }
              },
              {
                "$ref": "#/components/schemas/security._types:GlobalPrivilege"
              }
            ]
          },
          "applications": {
            "description": "A list of application privilege entries",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "run_as": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/run-as-privilege.html"
            },
            "description": "A list of users that the API keys can impersonate.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "description": {
            "description": "An optional description of the role descriptor.",
            "type": "string"
          },
          "restriction": {
            "$ref": "#/components/schemas/security._types:Restriction"
          },
          "transient_metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "cluster",
          "indices"
        ]
      },
      "security.get_service_credentials:NodesCredentials": {
        "type": "object",
        "properties": {
          "_nodes": {
            "$ref": "#/components/schemas/_types:NodeStatistics"
          },
          "file_tokens": {
            "description": "File-backed tokens collected from all nodes",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/security.get_service_credentials:NodesCredentialsFileToken"
            }
          }
        },
        "required": [
          "_nodes",
          "file_tokens"
        ]
      },
      "security.get_service_credentials:NodesCredentialsFileToken": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "nodes"
        ]
      },
      "security._types:SecuritySettings": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          }
        }
      },
      "security.get_token:AccessTokenGrantType": {
        "type": "string",
        "enum": [
          "password",
          "client_credentials",
          "_kerberos",
          "refresh_token"
        ]
      },
      "security.get_token:AuthenticatedUser": {
        "allOf": [
          {
            "$ref": "#/components/schemas/security._types:User"
          },
          {
            "type": "object",
            "properties": {
              "authentication_realm": {
                "$ref": "#/components/schemas/security.get_token:UserRealm"
              },
              "lookup_realm": {
                "$ref": "#/components/schemas/security.get_token:UserRealm"
              },
              "authentication_provider": {
                "$ref": "#/components/schemas/security.get_token:AuthenticationProvider"
              },
              "authentication_type": {
                "type": "string"
              }
            },
            "required": [
              "authentication_realm",
              "lookup_realm",
              "authentication_type"
            ]
          }
        ]
      },
      "security.get_token:UserRealm": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "security.get_token:AuthenticationProvider": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "type",
          "name"
        ]
      },
      "security._types:User": {
        "type": "object",
        "properties": {
          "email": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "full_name": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Name"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "enabled": {
            "type": "boolean"
          },
          "profile_uid": {
            "$ref": "#/components/schemas/security._types:UserProfileId"
          }
        },
        "required": [
          "metadata",
          "roles",
          "username",
          "enabled"
        ]
      },
      "security._types:UserIndicesPrivileges": {
        "type": "object",
        "properties": {
          "field_security": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/field-and-document-access-control.html"
            },
            "description": "The document fields that the owners of the role have read access to.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:FieldSecurity"
            }
          },
          "names": {
            "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              }
            ]
          },
          "privileges": {
            "description": "The index level privileges that owners of the role have on the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "query": {
            "description": "Search queries that define the documents the user has access to. A document within the specified indices must match these queries for it to be accessible by the owners of the role.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
            }
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "names",
          "privileges",
          "allow_restricted_indices"
        ]
      },
      "security._types:RemoteUserIndicesPrivileges": {
        "type": "object",
        "properties": {
          "field_security": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/field-and-document-access-control.html"
            },
            "description": "The document fields that the owners of the role have read access to.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:FieldSecurity"
            }
          },
          "names": {
            "description": "A list of indices (or index name patterns) to which the permissions in this entry apply.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              }
            ]
          },
          "privileges": {
            "description": "The index level privileges that owners of the role have on the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "query": {
            "description": "Search queries that define the documents the user has access to. A document within the specified indices must match these queries for it to be accessible by the owners of the role.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
            }
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          },
          "clusters": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "names",
          "privileges",
          "allow_restricted_indices",
          "clusters"
        ]
      },
      "security.get_user_profile:GetUserProfileErrors": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "count",
          "details"
        ]
      },
      "security.grant_api_key:GrantApiKey": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "expiration": {
            "$ref": "#/components/schemas/_types:DurationLarge"
          },
          "role_descriptors": {
            "description": "The role descriptors for this API key.\nWhen it is not specified or is an empty array, the API key has a point in time snapshot of permissions of the specified user or access token.\nIf you supply role descriptors, the resultant permissions are an intersection of API keys permissions and the permissions of the user or access token.",
            "oneOf": [
              {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security._types:RoleDescriptor"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security._types:RoleDescriptor"
                  }
                }
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "name"
        ]
      },
      "security.grant_api_key:ApiKeyGrantType": {
        "type": "string",
        "enum": [
          "access_token",
          "password"
        ]
      },
      "security.has_privileges:ApplicationPrivilegesCheck": {
        "type": "object",
        "properties": {
          "application": {
            "description": "The name of the application.",
            "type": "string"
          },
          "privileges": {
            "description": "A list of the privileges that you want to check for the specified resources.\nIt may be either application privilege names or the names of actions that are granted by those privileges",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "resources": {
            "description": "A list of resource names against which the privileges should be checked.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "application",
          "privileges",
          "resources"
        ]
      },
      "security.has_privileges:IndexPrivilegesCheck": {
        "type": "object",
        "properties": {
          "names": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "privileges": {
            "description": "A list of the privileges that you want to check for the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "allow_restricted_indices": {
            "description": "This needs to be set to `true` (default is `false`) if using wildcards or regexps for patterns that cover restricted indices.\nImplicitly, restricted indices do not match index patterns because restricted indices usually have limited privileges and including them in pattern tests would render most such tests false.\nIf restricted indices are explicitly included in the names list, privileges will be checked against them regardless of the value of `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "names",
          "privileges"
        ]
      },
      "security.has_privileges:ApplicationsPrivileges": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/security.has_privileges:ResourcePrivileges"
        }
      },
      "security.has_privileges:ResourcePrivileges": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/security.has_privileges:Privileges"
        }
      },
      "security.has_privileges:Privileges": {
        "type": "object",
        "additionalProperties": {
          "type": "boolean"
        }
      },
      "security.has_privileges_user_profile:PrivilegesCheck": {
        "type": "object",
        "properties": {
          "application": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.has_privileges:ApplicationPrivilegesCheck"
            }
          },
          "cluster": {
            "description": "A list of the cluster privileges that you want to check.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ClusterPrivilege"
            }
          },
          "index": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.has_privileges:IndexPrivilegesCheck"
            }
          }
        }
      },
      "security.has_privileges_user_profile:HasPrivilegesUserProfileErrors": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "count",
          "details"
        ]
      },
      "security._types:CreatedStatus": {
        "type": "object",
        "properties": {
          "created": {
            "type": "boolean"
          }
        },
        "required": [
          "created"
        ]
      },
      "security.query_api_keys:ApiKeyAggregationContainer": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "aggregations": {
                "description": "Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security.query_api_keys:ApiKeyAggregationContainer"
                }
              },
              "meta": {
                "$ref": "#/components/schemas/_types:Metadata"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "cardinality": {
                "$ref": "#/components/schemas/_types.aggregations:CardinalityAggregation"
              },
              "composite": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregation"
              },
              "date_range": {
                "$ref": "#/components/schemas/_types.aggregations:DateRangeAggregation"
              },
              "filter": {
                "$ref": "#/components/schemas/security.query_api_keys:ApiKeyQueryContainer"
              },
              "filters": {
                "$ref": "#/components/schemas/security.query_api_keys:ApiKeyFiltersAggregation"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:MissingAggregation"
              },
              "range": {
                "$ref": "#/components/schemas/_types.aggregations:RangeAggregation"
              },
              "terms": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregation"
              },
              "value_count": {
                "$ref": "#/components/schemas/_types.aggregations:ValueCountAggregation"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "security.query_api_keys:ApiKeyQueryContainer": {
        "type": "object",
        "properties": {
          "bool": {
            "$ref": "#/components/schemas/_types.query_dsl:BoolQuery"
          },
          "exists": {
            "$ref": "#/components/schemas/_types.query_dsl:ExistsQuery"
          },
          "ids": {
            "$ref": "#/components/schemas/_types.query_dsl:IdsQuery"
          },
          "match": {
            "description": "Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_all": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchAllQuery"
          },
          "prefix": {
            "description": "Returns documents that contain a specific prefix in a provided field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:PrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "range": {
            "description": "Returns documents that contain terms within a provided range.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RangeQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "simple_query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringQuery"
          },
          "term": {
            "description": "Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "terms": {
            "$ref": "#/components/schemas/_types.query_dsl:TermsQuery"
          },
          "wildcard": {
            "description": "Returns documents that contain terms matching a wildcard pattern.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:WildcardQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security.query_api_keys:ApiKeyFiltersAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "filters": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsApiKeyQueryContainer"
              },
              "other_bucket": {
                "description": "Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters.",
                "type": "boolean"
              },
              "other_bucket_key": {
                "description": "The key with which the other bucket is returned.",
                "type": "string"
              },
              "keyed": {
                "description": "By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketsApiKeyQueryContainer": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/security.query_api_keys:ApiKeyQueryContainer"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.query_api_keys:ApiKeyQueryContainer"
            }
          }
        ]
      },
      "security.query_api_keys:ApiKeyAggregate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CardinalityAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ValueCountAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:LongTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DoubleTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MissingAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FilterAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FiltersAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DateRangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregate"
          }
        ]
      },
      "security.query_role:RoleQueryContainer": {
        "type": "object",
        "properties": {
          "bool": {
            "$ref": "#/components/schemas/_types.query_dsl:BoolQuery"
          },
          "exists": {
            "$ref": "#/components/schemas/_types.query_dsl:ExistsQuery"
          },
          "ids": {
            "$ref": "#/components/schemas/_types.query_dsl:IdsQuery"
          },
          "match": {
            "description": "Returns roles that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_all": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchAllQuery"
          },
          "prefix": {
            "description": "Returns roles that contain a specific prefix in a provided field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:PrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "range": {
            "description": "Returns roles that contain terms within a provided range.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RangeQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "simple_query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringQuery"
          },
          "term": {
            "description": "Returns roles that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "terms": {
            "$ref": "#/components/schemas/_types.query_dsl:TermsQuery"
          },
          "wildcard": {
            "description": "Returns roles that contain terms matching a wildcard pattern.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:WildcardQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security.query_role:QueryRole": {
        "allOf": [
          {
            "$ref": "#/components/schemas/security._types:RoleDescriptor"
          },
          {
            "type": "object",
            "properties": {
              "_sort": {
                "$ref": "#/components/schemas/_types:SortResults"
              },
              "name": {
                "description": "Name of the role.",
                "type": "string"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      },
      "security.query_user:UserQueryContainer": {
        "type": "object",
        "properties": {
          "ids": {
            "$ref": "#/components/schemas/_types.query_dsl:IdsQuery"
          },
          "bool": {
            "$ref": "#/components/schemas/_types.query_dsl:BoolQuery"
          },
          "exists": {
            "$ref": "#/components/schemas/_types.query_dsl:ExistsQuery"
          },
          "match": {
            "description": "Returns users that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_all": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchAllQuery"
          },
          "prefix": {
            "description": "Returns users that contain a specific prefix in a provided field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:PrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "range": {
            "description": "Returns users that contain terms within a provided range.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RangeQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "simple_query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringQuery"
          },
          "term": {
            "description": "Returns users that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "terms": {
            "$ref": "#/components/schemas/_types.query_dsl:TermsQuery"
          },
          "wildcard": {
            "description": "Returns users that contain terms matching a wildcard pattern.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:WildcardQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security.query_user:QueryUser": {
        "allOf": [
          {
            "$ref": "#/components/schemas/security._types:User"
          },
          {
            "type": "object",
            "properties": {
              "_sort": {
                "$ref": "#/components/schemas/_types:SortResults"
              }
            }
          }
        ]
      },
      "security.suggest_user_profiles:Hint": {
        "type": "object",
        "properties": {
          "uids": {
            "description": "A list of profile UIDs to match against.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:UserProfileId"
            }
          },
          "labels": {
            "description": "A single key-value pair to match against the labels section\nof a profile. A profile is considered matching if it matches\nat least one of the strings.",
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            }
          }
        }
      },
      "security.suggest_user_profiles:TotalUserProfiles": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number"
          },
          "relation": {
            "$ref": "#/components/schemas/_types:RelationName"
          }
        },
        "required": [
          "value",
          "relation"
        ]
      },
      "shutdown.get_node:NodeShutdownStatus": {
        "type": "object",
        "properties": {
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "type": {
            "$ref": "#/components/schemas/shutdown.get_node:ShutdownType"
          },
          "reason": {
            "type": "string"
          },
          "shutdown_startedmillis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "status": {
            "$ref": "#/components/schemas/shutdown.get_node:ShutdownStatus"
          },
          "shard_migration": {
            "$ref": "#/components/schemas/shutdown.get_node:ShardMigrationStatus"
          },
          "persistent_tasks": {
            "$ref": "#/components/schemas/shutdown.get_node:PersistentTaskStatus"
          },
          "plugins": {
            "$ref": "#/components/schemas/shutdown.get_node:PluginsStatus"
          }
        },
        "required": [
          "node_id",
          "type",
          "reason",
          "shutdown_startedmillis",
          "status",
          "shard_migration",
          "persistent_tasks",
          "plugins"
        ]
      },
      "shutdown.get_node:ShutdownType": {
        "type": "string",
        "enum": [
          "remove",
          "restart"
        ]
      },
      "shutdown.get_node:ShutdownStatus": {
        "type": "string",
        "enum": [
          "not_started",
          "in_progress",
          "stalled",
          "complete"
        ]
      },
      "shutdown.get_node:ShardMigrationStatus": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/shutdown.get_node:ShutdownStatus"
          }
        },
        "required": [
          "status"
        ]
      },
      "shutdown.get_node:PersistentTaskStatus": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/shutdown.get_node:ShutdownStatus"
          }
        },
        "required": [
          "status"
        ]
      },
      "shutdown.get_node:PluginsStatus": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/shutdown.get_node:ShutdownStatus"
          }
        },
        "required": [
          "status"
        ]
      },
      "shutdown._types:Type": {
        "type": "string",
        "enum": [
          "restart",
          "remove",
          "replace"
        ]
      },
      "simulate.ingest:SimulateIngestDocumentResult": {
        "type": "object",
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/simulate.ingest:IngestDocumentSimulation"
          }
        }
      },
      "simulate.ingest:IngestDocumentSimulation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_source": {
            "description": "JSON body for the document.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "_version": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedVersionNumber"
          },
          "executed_pipelines": {
            "description": "A list of the names of the pipelines executed on this document.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "ignored_fields": {
            "description": "A list of the fields that would be ignored at the indexing step. For example, a field whose\nvalue is larger than the allowed limit would make it through all of the pipelines, but\nwould not be indexed into Elasticsearch.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "string"
              }
            }
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "_id",
          "_index",
          "_source",
          "_version",
          "executed_pipelines"
        ]
      },
      "slm._types:SnapshotLifecycle": {
        "type": "object",
        "properties": {
          "in_progress": {
            "$ref": "#/components/schemas/slm._types:InProgress"
          },
          "last_failure": {
            "$ref": "#/components/schemas/slm._types:Invocation"
          },
          "last_success": {
            "$ref": "#/components/schemas/slm._types:Invocation"
          },
          "modified_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "modified_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "next_execution": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "next_execution_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "policy": {
            "$ref": "#/components/schemas/slm._types:Policy"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "stats": {
            "$ref": "#/components/schemas/slm._types:Statistics"
          }
        },
        "required": [
          "modified_date_millis",
          "next_execution_millis",
          "policy",
          "version",
          "stats"
        ]
      },
      "slm._types:InProgress": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "start_time_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "state": {
            "type": "string"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          }
        },
        "required": [
          "name",
          "start_time_millis",
          "state",
          "uuid"
        ]
      },
      "slm._types:Invocation": {
        "type": "object",
        "properties": {
          "snapshot_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "snapshot_name",
          "time"
        ]
      },
      "slm._types:Policy": {
        "type": "object",
        "properties": {
          "config": {
            "$ref": "#/components/schemas/slm._types:Configuration"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "repository": {
            "type": "string"
          },
          "retention": {
            "$ref": "#/components/schemas/slm._types:Retention"
          },
          "schedule": {
            "$ref": "#/components/schemas/watcher._types:CronExpression"
          }
        },
        "required": [
          "name",
          "repository",
          "schedule"
        ]
      },
      "slm._types:Configuration": {
        "type": "object",
        "properties": {
          "ignore_unavailable": {
            "description": "If false, the snapshot fails if any data stream or index in indices is missing or closed. If true, the snapshot ignores missing or closed data streams and indices.",
            "type": "boolean"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "include_global_state": {
            "description": "If true, the current global state is included in the snapshot.",
            "type": "boolean"
          },
          "feature_states": {
            "description": "A list of feature states to be included in this snapshot. A list of features available for inclusion in the snapshot and their descriptions be can be retrieved using the get features API.\nEach feature state includes one or more system indices containing data necessary for the function of that feature. Providing an empty array will include no feature states in the snapshot, regardless of the value of include_global_state. By default, all available feature states will be included in the snapshot if include_global_state is true, or no feature states if include_global_state is false.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "partial": {
            "description": "If false, the entire snapshot will fail if one or more indices included in the snapshot do not have all primary shards available.",
            "type": "boolean"
          }
        }
      },
      "slm._types:Retention": {
        "type": "object",
        "properties": {
          "expire_after": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_count": {
            "description": "Maximum number of snapshots to retain, even if the snapshots have not yet expired. If the number of snapshots in the repository exceeds this limit, the policy retains the most recent snapshots and deletes older snapshots.",
            "type": "number"
          },
          "min_count": {
            "description": "Minimum number of snapshots to retain, even if the snapshots have expired.",
            "type": "number"
          }
        },
        "required": [
          "expire_after",
          "max_count",
          "min_count"
        ]
      },
      "watcher._types:CronExpression": {
        "type": "string"
      },
      "slm._types:Statistics": {
        "type": "object",
        "properties": {
          "retention_deletion_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "retention_deletion_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "retention_failed": {
            "type": "number"
          },
          "retention_runs": {
            "type": "number"
          },
          "retention_timed_out": {
            "type": "number"
          },
          "policy": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "total_snapshots_deleted": {
            "type": "number"
          },
          "total_snapshot_deletion_failures": {
            "type": "number"
          },
          "total_snapshots_failed": {
            "type": "number"
          },
          "total_snapshots_taken": {
            "type": "number"
          }
        }
      },
      "snapshot.cleanup_repository:CleanupRepositoryResults": {
        "type": "object",
        "properties": {
          "deleted_blobs": {
            "description": "Number of binary large objects (blobs) removed during cleanup.",
            "type": "number"
          },
          "deleted_bytes": {
            "description": "Number of bytes freed by cleanup operations.",
            "type": "number"
          }
        },
        "required": [
          "deleted_blobs",
          "deleted_bytes"
        ]
      },
      "snapshot._types:SnapshotInfo": {
        "type": "object",
        "properties": {
          "data_streams": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "duration": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "duration_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "end_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "end_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/snapshot._types:SnapshotShardFailure"
            }
          },
          "include_global_state": {
            "type": "boolean"
          },
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "index_details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/snapshot._types:IndexDetails"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "reason": {
            "type": "string"
          },
          "repository": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "snapshot": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "state": {
            "type": "string"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "version_id": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "feature_states": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/snapshot._types:InfoFeatureState"
            }
          }
        },
        "required": [
          "data_streams",
          "snapshot",
          "uuid"
        ]
      },
      "snapshot._types:SnapshotShardFailure": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "reason": {
            "type": "string"
          },
          "shard_id": {
            "type": "number"
          },
          "index_uuid": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "status": {
            "type": "string"
          }
        },
        "required": [
          "index",
          "reason",
          "shard_id",
          "index_uuid",
          "status"
        ]
      },
      "snapshot._types:IndexDetails": {
        "type": "object",
        "properties": {
          "shard_count": {
            "type": "number"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size_in_bytes": {
            "type": "number"
          },
          "max_segments_per_shard": {
            "type": "number"
          }
        },
        "required": [
          "shard_count",
          "size_in_bytes",
          "max_segments_per_shard"
        ]
      },
      "snapshot._types:InfoFeatureState": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          }
        },
        "required": [
          "feature_name",
          "indices"
        ]
      },
      "snapshot._types:Repository": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:AzureRepository"
          },
          {
            "$ref": "#/components/schemas/snapshot._types:GcsRepository"
          },
          {
            "$ref": "#/components/schemas/snapshot._types:S3Repository"
          },
          {
            "$ref": "#/components/schemas/snapshot._types:SharedFileSystemRepository"
          },
          {
            "$ref": "#/components/schemas/snapshot._types:ReadOnlyUrlRepository"
          },
          {
            "$ref": "#/components/schemas/snapshot._types:SourceOnlyRepository"
          }
        ]
      },
      "snapshot._types:AzureRepository": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositoryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "azure"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/snapshot._types:AzureRepositorySettings"
              }
            },
            "required": [
              "type",
              "settings"
            ]
          }
        ]
      },
      "snapshot._types:AzureRepositorySettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositorySettingsBase"
          },
          {
            "type": "object",
            "properties": {
              "client": {
                "type": "string"
              },
              "container": {
                "type": "string"
              },
              "base_path": {
                "type": "string"
              },
              "readonly": {
                "type": "boolean"
              },
              "location_mode": {
                "type": "string"
              }
            }
          }
        ]
      },
      "snapshot._types:RepositorySettingsBase": {
        "type": "object",
        "properties": {
          "chunk_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "compress": {
            "type": "boolean"
          },
          "max_restore_bytes_per_sec": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_snapshot_bytes_per_sec": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        }
      },
      "snapshot._types:RepositoryBase": {
        "type": "object",
        "properties": {
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          }
        }
      },
      "snapshot._types:GcsRepository": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositoryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "gcs"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/snapshot._types:GcsRepositorySettings"
              }
            },
            "required": [
              "type",
              "settings"
            ]
          }
        ]
      },
      "snapshot._types:GcsRepositorySettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositorySettingsBase"
          },
          {
            "type": "object",
            "properties": {
              "bucket": {
                "type": "string"
              },
              "client": {
                "type": "string"
              },
              "base_path": {
                "type": "string"
              },
              "readonly": {
                "type": "boolean"
              },
              "application_name": {
                "type": "string"
              }
            },
            "required": [
              "bucket"
            ]
          }
        ]
      },
      "snapshot._types:S3Repository": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositoryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "s3"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/snapshot._types:S3RepositorySettings"
              }
            },
            "required": [
              "type",
              "settings"
            ]
          }
        ]
      },
      "snapshot._types:S3RepositorySettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositorySettingsBase"
          },
          {
            "type": "object",
            "properties": {
              "bucket": {
                "type": "string"
              },
              "client": {
                "type": "string"
              },
              "base_path": {
                "type": "string"
              },
              "readonly": {
                "type": "boolean"
              },
              "server_side_encryption": {
                "type": "boolean"
              },
              "buffer_size": {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              "canned_acl": {
                "type": "string"
              },
              "storage_class": {
                "type": "string"
              }
            },
            "required": [
              "bucket"
            ]
          }
        ]
      },
      "snapshot._types:SharedFileSystemRepository": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositoryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "fs"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/snapshot._types:SharedFileSystemRepositorySettings"
              }
            },
            "required": [
              "type",
              "settings"
            ]
          }
        ]
      },
      "snapshot._types:SharedFileSystemRepositorySettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositorySettingsBase"
          },
          {
            "type": "object",
            "properties": {
              "location": {
                "type": "string"
              },
              "max_number_of_snapshots": {
                "type": "number"
              },
              "readonly": {
                "type": "boolean"
              }
            },
            "required": [
              "location"
            ]
          }
        ]
      },
      "snapshot._types:ReadOnlyUrlRepository": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositoryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "url"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/snapshot._types:ReadOnlyUrlRepositorySettings"
              }
            },
            "required": [
              "type",
              "settings"
            ]
          }
        ]
      },
      "snapshot._types:ReadOnlyUrlRepositorySettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositorySettingsBase"
          },
          {
            "type": "object",
            "properties": {
              "http_max_retries": {
                "type": "number"
              },
              "http_socket_timeout": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "max_number_of_snapshots": {
                "type": "number"
              },
              "url": {
                "type": "string"
              }
            },
            "required": [
              "url"
            ]
          }
        ]
      },
      "snapshot._types:SourceOnlyRepository": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositoryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "source"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/snapshot._types:SourceOnlyRepositorySettings"
              }
            },
            "required": [
              "type",
              "settings"
            ]
          }
        ]
      },
      "snapshot._types:SourceOnlyRepositorySettings": {
        "allOf": [
          {
            "$ref": "#/components/schemas/snapshot._types:RepositorySettingsBase"
          },
          {
            "type": "object",
            "properties": {
              "delegate_type": {
                "type": "string"
              },
              "max_number_of_snapshots": {
                "type": "number"
              },
              "read_only": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "snapshot._types:SnapshotSort": {
        "type": "string",
        "enum": [
          "start_time",
          "duration",
          "name",
          "index_count",
          "repository",
          "shard_count",
          "failed_shard_count"
        ]
      },
      "snapshot.get:SnapshotResponseItem": {
        "type": "object",
        "properties": {
          "repository": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "snapshots": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/snapshot._types:SnapshotInfo"
            }
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "repository"
        ]
      },
      "snapshot.repository_analyze:SnapshotNodeInfo": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "snapshot.repository_analyze:DetailsInfo": {
        "type": "object",
        "properties": {
          "blob": {
            "$ref": "#/components/schemas/snapshot.repository_analyze:BlobDetails"
          },
          "overwrite_elapsed": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "overwrite_elapsed_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "write_elapsed": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "write_elapsed_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "write_throttled": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "write_throttled_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "writer_node": {
            "$ref": "#/components/schemas/snapshot.repository_analyze:SnapshotNodeInfo"
          }
        },
        "required": [
          "blob",
          "write_elapsed",
          "write_elapsed_nanos",
          "write_throttled",
          "write_throttled_nanos",
          "writer_node"
        ]
      },
      "snapshot.repository_analyze:BlobDetails": {
        "type": "object",
        "properties": {
          "name": {
            "description": "The name of the blob.",
            "type": "string"
          },
          "overwritten": {
            "description": "Indicates whether the blob was overwritten while the read operations were ongoing.\n  /**",
            "type": "boolean"
          },
          "read_early": {
            "type": "boolean"
          },
          "read_end": {
            "description": "The position, in bytes, at which read operations completed.",
            "type": "number"
          },
          "read_start": {
            "description": "The position, in bytes, at which read operations started.",
            "type": "number"
          },
          "reads": {
            "$ref": "#/components/schemas/snapshot.repository_analyze:ReadBlobDetails"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size_bytes": {
            "description": "The size of the blob in bytes.",
            "type": "number"
          }
        },
        "required": [
          "name",
          "overwritten",
          "read_early",
          "read_end",
          "read_start",
          "reads",
          "size",
          "size_bytes"
        ]
      },
      "snapshot.repository_analyze:ReadBlobDetails": {
        "type": "object",
        "properties": {
          "before_write_complete": {
            "description": "Indicates whether the read operation may have started before the write operation was complete.",
            "type": "boolean"
          },
          "elapsed": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "elapsed_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "first_byte_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "first_byte_time_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "found": {
            "description": "Indicates whether the blob was found by the read operation.\nIf the read was started before the write completed or the write was ended before completion, it might be false.",
            "type": "boolean"
          },
          "node": {
            "$ref": "#/components/schemas/snapshot.repository_analyze:SnapshotNodeInfo"
          },
          "throttled": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttled_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          }
        },
        "required": [
          "first_byte_time_nanos",
          "found",
          "node"
        ]
      },
      "snapshot.repository_analyze:SummaryInfo": {
        "type": "object",
        "properties": {
          "read": {
            "$ref": "#/components/schemas/snapshot.repository_analyze:ReadSummaryInfo"
          },
          "write": {
            "$ref": "#/components/schemas/snapshot.repository_analyze:WriteSummaryInfo"
          }
        },
        "required": [
          "read",
          "write"
        ]
      },
      "snapshot.repository_analyze:ReadSummaryInfo": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of read operations performed in the test.",
            "type": "number"
          },
          "max_wait": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_wait_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "total_elapsed": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_elapsed_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "total_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_size_bytes": {
            "description": "The total size of all the blobs or partial blobs read in the test, in bytes.",
            "type": "number"
          },
          "total_throttled": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_throttled_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "total_wait": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_wait_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          }
        },
        "required": [
          "count",
          "max_wait",
          "max_wait_nanos",
          "total_elapsed",
          "total_elapsed_nanos",
          "total_size",
          "total_size_bytes",
          "total_throttled",
          "total_throttled_nanos",
          "total_wait",
          "total_wait_nanos"
        ]
      },
      "snapshot.repository_analyze:WriteSummaryInfo": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of write operations performed in the test.",
            "type": "number"
          },
          "total_elapsed": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_elapsed_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "total_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_size_bytes": {
            "description": "The total size of all the blobs written in the test, in bytes.",
            "type": "number"
          },
          "total_throttled": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_throttled_nanos": {
            "description": "The total time spent waiting due to the `max_snapshot_bytes_per_sec` throttle, in nanoseconds.",
            "type": "number"
          }
        },
        "required": [
          "count",
          "total_elapsed",
          "total_elapsed_nanos",
          "total_size",
          "total_size_bytes",
          "total_throttled",
          "total_throttled_nanos"
        ]
      },
      "snapshot.restore:SnapshotRestore": {
        "type": "object",
        "properties": {
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "snapshot": {
            "type": "string"
          },
          "shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          }
        },
        "required": [
          "indices",
          "snapshot",
          "shards"
        ]
      },
      "snapshot._types:Status": {
        "type": "object",
        "properties": {
          "include_global_state": {
            "type": "boolean"
          },
          "indices": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/snapshot._types:SnapshotIndexStats"
            }
          },
          "repository": {
            "type": "string"
          },
          "shards_stats": {
            "$ref": "#/components/schemas/snapshot._types:ShardsStats"
          },
          "snapshot": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "stats": {
            "$ref": "#/components/schemas/snapshot._types:SnapshotStats"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          }
        },
        "required": [
          "include_global_state",
          "indices",
          "repository",
          "shards_stats",
          "snapshot",
          "state",
          "stats",
          "uuid"
        ]
      },
      "snapshot._types:SnapshotIndexStats": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/snapshot._types:SnapshotShardsStatus"
            }
          },
          "shards_stats": {
            "$ref": "#/components/schemas/snapshot._types:ShardsStats"
          },
          "stats": {
            "$ref": "#/components/schemas/snapshot._types:SnapshotStats"
          }
        },
        "required": [
          "shards",
          "shards_stats",
          "stats"
        ]
      },
      "snapshot._types:SnapshotShardsStatus": {
        "type": "object",
        "properties": {
          "stage": {
            "$ref": "#/components/schemas/snapshot._types:ShardsStatsStage"
          },
          "stats": {
            "$ref": "#/components/schemas/snapshot._types:ShardsStatsSummary"
          }
        },
        "required": [
          "stage",
          "stats"
        ]
      },
      "snapshot._types:ShardsStatsStage": {
        "type": "string",
        "enum": [
          "DONE",
          "FAILURE",
          "FINALIZE",
          "INIT",
          "STARTED"
        ]
      },
      "snapshot._types:ShardsStatsSummary": {
        "type": "object",
        "properties": {
          "incremental": {
            "$ref": "#/components/schemas/snapshot._types:ShardsStatsSummaryItem"
          },
          "total": {
            "$ref": "#/components/schemas/snapshot._types:ShardsStatsSummaryItem"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "incremental",
          "total",
          "start_time_in_millis",
          "time_in_millis"
        ]
      },
      "snapshot._types:ShardsStatsSummaryItem": {
        "type": "object",
        "properties": {
          "file_count": {
            "type": "number"
          },
          "size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "file_count",
          "size_in_bytes"
        ]
      },
      "snapshot._types:ShardsStats": {
        "type": "object",
        "properties": {
          "done": {
            "type": "number"
          },
          "failed": {
            "type": "number"
          },
          "finalizing": {
            "type": "number"
          },
          "initializing": {
            "type": "number"
          },
          "started": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "done",
          "failed",
          "finalizing",
          "initializing",
          "started",
          "total"
        ]
      },
      "snapshot._types:SnapshotStats": {
        "type": "object",
        "properties": {
          "incremental": {
            "$ref": "#/components/schemas/snapshot._types:FileCountSnapshotStats"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total": {
            "$ref": "#/components/schemas/snapshot._types:FileCountSnapshotStats"
          }
        },
        "required": [
          "incremental",
          "start_time_in_millis",
          "time_in_millis",
          "total"
        ]
      },
      "snapshot._types:FileCountSnapshotStats": {
        "type": "object",
        "properties": {
          "file_count": {
            "type": "number"
          },
          "size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "file_count",
          "size_in_bytes"
        ]
      },
      "snapshot.verify_repository:CompactNodeInfo": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name"
        ]
      },
      "sql:Column": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "sql:Row": {
        "type": "array",
        "items": {
          "type": "object"
        }
      },
      "sql.query:SqlFormat": {
        "type": "string",
        "enum": [
          "csv",
          "json",
          "tsv",
          "txt",
          "yaml",
          "cbor",
          "smile"
        ]
      },
      "ssl.certificates:CertificateInformation": {
        "type": "object",
        "properties": {
          "alias": {
            "description": "If the path refers to a container file (a jks keystore, or a PKCS#12 file), it is the alias of the certificate.\nOtherwise, it is null.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "expiry": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "format": {
            "description": "The format of the file.\nValid values include `jks`, `PKCS12`, and `PEM`.",
            "type": "string"
          },
          "has_private_key": {
            "description": "Indicates whether Elasticsearch has access to the private key for this certificate.",
            "type": "boolean"
          },
          "issuer": {
            "description": "The Distinguished Name of the certificate's issuer.",
            "type": "string"
          },
          "path": {
            "description": "The path to the certificate, as configured in the `elasticsearch.yml` file.",
            "type": "string"
          },
          "serial_number": {
            "description": "The hexadecimal representation of the certificate's serial number.",
            "type": "string"
          },
          "subject_dn": {
            "description": "The Distinguished Name of the certificate's subject.",
            "type": "string"
          }
        },
        "required": [
          "alias",
          "expiry",
          "format",
          "has_private_key",
          "path",
          "serial_number",
          "subject_dn"
        ]
      },
      "synonyms._types:SynonymsUpdateResult": {
        "type": "object",
        "properties": {
          "result": {
            "$ref": "#/components/schemas/_types:Result"
          },
          "reload_analyzers_details": {
            "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadResult"
          }
        },
        "required": [
          "result",
          "reload_analyzers_details"
        ]
      },
      "synonyms._types:SynonymRuleRead": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "synonyms": {
            "$ref": "#/components/schemas/synonyms._types:SynonymString"
          }
        },
        "required": [
          "id",
          "synonyms"
        ]
      },
      "synonyms._types:SynonymString": {
        "type": "string"
      },
      "synonyms.get_synonyms_sets:SynonymsSetItem": {
        "type": "object",
        "properties": {
          "synonyms_set": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "count": {
            "description": "Number of synonym rules that the synonym set contains",
            "type": "number"
          }
        },
        "required": [
          "synonyms_set",
          "count"
        ]
      },
      "synonyms._types:SynonymRule": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "synonyms": {
            "$ref": "#/components/schemas/synonyms._types:SynonymString"
          }
        },
        "required": [
          "synonyms"
        ]
      },
      "tasks._types:GroupBy": {
        "type": "string",
        "enum": [
          "nodes",
          "parents",
          "none"
        ]
      },
      "text_structure._types:EcsCompatibilityType": {
        "type": "string",
        "enum": [
          "disabled",
          "v1"
        ]
      },
      "text_structure._types:FormatType": {
        "type": "string",
        "enum": [
          "delimited",
          "ndjson",
          "semi_structured_text",
          "xml"
        ]
      },
      "text_structure._types:FieldStat": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "cardinality": {
            "type": "number"
          },
          "top_hits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/text_structure._types:TopHit"
            }
          },
          "mean_value": {
            "type": "number"
          },
          "median_value": {
            "type": "number"
          },
          "max_value": {
            "type": "number"
          },
          "min_value": {
            "type": "number"
          },
          "earliest": {
            "type": "string"
          },
          "latest": {
            "type": "string"
          }
        },
        "required": [
          "count",
          "cardinality",
          "top_hits"
        ]
      },
      "text_structure._types:TopHit": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "value": {
            "type": "object"
          }
        },
        "required": [
          "count",
          "value"
        ]
      },
      "ingest._types:PipelineConfig": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the ingest pipeline.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "processors": {
            "description": "Processors used to perform transformations on documents before indexing.\nProcessors run sequentially in the order specified.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          }
        },
        "required": [
          "processors"
        ]
      },
      "text_structure.test_grok_pattern:MatchedText": {
        "type": "object",
        "properties": {
          "matched": {
            "type": "boolean"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/text_structure.test_grok_pattern:MatchedField"
              }
            }
          }
        },
        "required": [
          "matched"
        ]
      },
      "text_structure.test_grok_pattern:MatchedField": {
        "type": "object",
        "properties": {
          "match": {
            "type": "string"
          },
          "offset": {
            "type": "number"
          },
          "length": {
            "type": "number"
          }
        },
        "required": [
          "match",
          "offset",
          "length"
        ]
      },
      "transform.get_transform:TransformSummary": {
        "type": "object",
        "properties": {
          "authorization": {
            "$ref": "#/components/schemas/ml._types:TransformAuthorization"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "description": {
            "description": "Free text description of the transform.",
            "type": "string"
          },
          "dest": {
            "$ref": "#/components/schemas/_global.reindex:Destination"
          },
          "frequency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "latest": {
            "$ref": "#/components/schemas/transform._types:Latest"
          },
          "pivot": {
            "$ref": "#/components/schemas/transform._types:Pivot"
          },
          "retention_policy": {
            "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
          },
          "settings": {
            "$ref": "#/components/schemas/transform._types:Settings"
          },
          "source": {
            "$ref": "#/components/schemas/transform._types:Source"
          },
          "sync": {
            "$ref": "#/components/schemas/transform._types:SyncContainer"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "dest",
          "id",
          "source"
        ]
      },
      "ml._types:TransformAuthorization": {
        "type": "object",
        "properties": {
          "api_key": {
            "$ref": "#/components/schemas/ml._types:ApiKeyAuthorization"
          },
          "roles": {
            "description": "If a user ID was used for the most recent update to the transform, its roles at the time of the update are listed in the response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "service_account": {
            "description": "If a service account was used for the most recent update to the transform, the account name is listed in the response.",
            "type": "string"
          }
        }
      },
      "transform._types:Latest": {
        "type": "object",
        "properties": {
          "sort": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "unique_key": {
            "description": "Specifies an array of one or more fields that are used to group the data.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          }
        },
        "required": [
          "sort",
          "unique_key"
        ]
      },
      "transform._types:Pivot": {
        "type": "object",
        "properties": {
          "aggregations": {
            "description": "Defines how to aggregate the grouped data. The following aggregations are currently supported: average, bucket\nscript, bucket selector, cardinality, filter, geo bounds, geo centroid, geo line, max, median absolute deviation,\nmin, missing, percentiles, rare terms, scripted metric, stats, sum, terms, top metrics, value count, weighted\naverage.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "group_by": {
            "description": "Defines how to group the data. More than one grouping can be defined per pivot. The following groupings are\ncurrently supported: date histogram, geotile grid, histogram, terms.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/transform._types:PivotGroupByContainer"
            }
          }
        }
      },
      "transform._types:PivotGroupByContainer": {
        "type": "object",
        "properties": {
          "date_histogram": {
            "$ref": "#/components/schemas/_types.aggregations:DateHistogramAggregation"
          },
          "geotile_grid": {
            "$ref": "#/components/schemas/_types.aggregations:GeoTileGridAggregation"
          },
          "histogram": {
            "$ref": "#/components/schemas/_types.aggregations:HistogramAggregation"
          },
          "terms": {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregation"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "transform._types:RetentionPolicyContainer": {
        "type": "object",
        "properties": {
          "time": {
            "$ref": "#/components/schemas/transform._types:RetentionPolicy"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "transform._types:RetentionPolicy": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "max_age": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "field",
          "max_age"
        ]
      },
      "transform._types:Settings": {
        "type": "object",
        "properties": {
          "align_checkpoints": {
            "description": "Specifies whether the transform checkpoint ranges should be optimized for performance. Such optimization can align\ncheckpoint ranges with the date histogram interval when date histogram is specified as a group source in the\ntransform config. As a result, less document updates in the destination index will be performed thus improving\noverall performance.",
            "type": "boolean"
          },
          "dates_as_epoch_millis": {
            "description": "Defines if dates in the ouput should be written as ISO formatted string or as millis since epoch. epoch_millis was\nthe default for transforms created before version 7.11. For compatible output set this value to `true`.",
            "type": "boolean"
          },
          "deduce_mappings": {
            "description": "Specifies whether the transform should deduce the destination index mappings from the transform configuration.",
            "type": "boolean"
          },
          "docs_per_second": {
            "description": "Specifies a limit on the number of input documents per second. This setting throttles the transform by adding a\nwait time between search requests. The default value is null, which disables throttling.",
            "type": "number"
          },
          "max_page_search_size": {
            "description": "Defines the initial page size to use for the composite aggregation for each checkpoint. If circuit breaker\nexceptions occur, the page size is dynamically adjusted to a lower value. The minimum value is `10` and the\nmaximum is `65,536`.",
            "type": "number"
          },
          "unattended": {
            "description": "If `true`, the transform runs in unattended mode. In unattended mode, the transform retries indefinitely in case\nof an error which means the transform never fails. Setting the number of retries other than infinite fails in\nvalidation.",
            "type": "boolean"
          }
        }
      },
      "transform._types:Source": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          }
        },
        "required": [
          "index"
        ]
      },
      "transform._types:SyncContainer": {
        "type": "object",
        "properties": {
          "time": {
            "$ref": "#/components/schemas/transform._types:TimeSync"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "transform._types:TimeSync": {
        "type": "object",
        "properties": {
          "delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "transform.get_transform_stats:TransformStats": {
        "type": "object",
        "properties": {
          "checkpointing": {
            "$ref": "#/components/schemas/transform.get_transform_stats:Checkpointing"
          },
          "health": {
            "$ref": "#/components/schemas/transform.get_transform_stats:TransformStatsHealth"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeAttributes"
          },
          "reason": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "stats": {
            "$ref": "#/components/schemas/transform.get_transform_stats:TransformIndexerStats"
          }
        },
        "required": [
          "checkpointing",
          "id",
          "state",
          "stats"
        ]
      },
      "transform.get_transform_stats:Checkpointing": {
        "type": "object",
        "properties": {
          "changes_last_detected_at": {
            "type": "number"
          },
          "changes_last_detected_at_date_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last": {
            "$ref": "#/components/schemas/transform.get_transform_stats:CheckpointStats"
          },
          "next": {
            "$ref": "#/components/schemas/transform.get_transform_stats:CheckpointStats"
          },
          "operations_behind": {
            "type": "number"
          },
          "last_search_time": {
            "type": "number"
          }
        },
        "required": [
          "last"
        ]
      },
      "transform.get_transform_stats:CheckpointStats": {
        "type": "object",
        "properties": {
          "checkpoint": {
            "type": "number"
          },
          "checkpoint_progress": {
            "$ref": "#/components/schemas/transform.get_transform_stats:TransformProgress"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "timestamp_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time_upper_bound": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "time_upper_bound_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "checkpoint"
        ]
      },
      "transform.get_transform_stats:TransformProgress": {
        "type": "object",
        "properties": {
          "docs_indexed": {
            "type": "number"
          },
          "docs_processed": {
            "type": "number"
          },
          "docs_remaining": {
            "type": "number"
          },
          "percent_complete": {
            "type": "number"
          },
          "total_docs": {
            "type": "number"
          }
        },
        "required": [
          "docs_indexed",
          "docs_processed"
        ]
      },
      "transform.get_transform_stats:TransformStatsHealth": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          }
        },
        "required": [
          "status"
        ]
      },
      "transform.get_transform_stats:TransformIndexerStats": {
        "type": "object",
        "properties": {
          "delete_time_in_ms": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "documents_indexed": {
            "type": "number"
          },
          "documents_deleted": {
            "type": "number"
          },
          "documents_processed": {
            "type": "number"
          },
          "exponential_avg_checkpoint_duration_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "exponential_avg_documents_indexed": {
            "type": "number"
          },
          "exponential_avg_documents_processed": {
            "type": "number"
          },
          "index_failures": {
            "type": "number"
          },
          "index_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_total": {
            "type": "number"
          },
          "pages_processed": {
            "type": "number"
          },
          "processing_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "processing_total": {
            "type": "number"
          },
          "search_failures": {
            "type": "number"
          },
          "search_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "search_total": {
            "type": "number"
          },
          "trigger_count": {
            "type": "number"
          }
        },
        "required": [
          "documents_indexed",
          "documents_processed",
          "exponential_avg_checkpoint_duration_ms",
          "exponential_avg_documents_indexed",
          "exponential_avg_documents_processed",
          "index_failures",
          "index_time_in_ms",
          "index_total",
          "pages_processed",
          "processing_time_in_ms",
          "processing_total",
          "search_failures",
          "search_time_in_ms",
          "search_total",
          "trigger_count"
        ]
      },
      "transform._types:Destination": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "pipeline": {
            "description": "The unique identifier for an ingest pipeline.",
            "type": "string"
          }
        }
      },
      "_global.update:UpdateWriteResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:WriteResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "get": {
                "$ref": "#/components/schemas/_types:InlineGet"
              }
            }
          }
        ]
      },
      "_global.update_by_query_rethrottle:UpdateByQueryRethrottleNode": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_spec_utils:BaseNode"
          },
          {
            "type": "object",
            "properties": {
              "tasks": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/tasks._types:TaskInfo"
                }
              }
            },
            "required": [
              "tasks"
            ]
          }
        ]
      },
      "watcher._types:WatchStatus": {
        "type": "object",
        "properties": {
          "actions": {
            "$ref": "#/components/schemas/watcher._types:Actions"
          },
          "last_checked": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_met_condition": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "state": {
            "$ref": "#/components/schemas/watcher._types:ActivationState"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "execution_state": {
            "type": "string"
          }
        },
        "required": [
          "actions",
          "state",
          "version"
        ]
      },
      "watcher._types:Actions": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/watcher._types:ActionStatus"
        }
      },
      "watcher._types:ActionStatus": {
        "type": "object",
        "properties": {
          "ack": {
            "$ref": "#/components/schemas/watcher._types:AcknowledgeState"
          },
          "last_execution": {
            "$ref": "#/components/schemas/watcher._types:ExecutionState"
          },
          "last_successful_execution": {
            "$ref": "#/components/schemas/watcher._types:ExecutionState"
          },
          "last_throttle": {
            "$ref": "#/components/schemas/watcher._types:ThrottleState"
          }
        },
        "required": [
          "ack"
        ]
      },
      "watcher._types:AcknowledgeState": {
        "type": "object",
        "properties": {
          "state": {
            "$ref": "#/components/schemas/watcher._types:AcknowledgementOptions"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "state",
          "timestamp"
        ]
      },
      "watcher._types:AcknowledgementOptions": {
        "type": "string",
        "enum": [
          "awaits_successful_execution",
          "ackable",
          "acked"
        ]
      },
      "watcher._types:ExecutionState": {
        "type": "object",
        "properties": {
          "successful": {
            "type": "boolean"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "reason": {
            "type": "string"
          }
        },
        "required": [
          "successful",
          "timestamp"
        ]
      },
      "watcher._types:ThrottleState": {
        "type": "object",
        "properties": {
          "reason": {
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "reason",
          "timestamp"
        ]
      },
      "watcher._types:ActivationState": {
        "type": "object",
        "properties": {
          "active": {
            "type": "boolean"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "active",
          "timestamp"
        ]
      },
      "watcher._types:ActivationStatus": {
        "type": "object",
        "properties": {
          "actions": {
            "$ref": "#/components/schemas/watcher._types:Actions"
          },
          "state": {
            "$ref": "#/components/schemas/watcher._types:ActivationState"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "actions",
          "state",
          "version"
        ]
      },
      "watcher._types:ActionExecutionMode": {
        "type": "string",
        "enum": [
          "simulate",
          "force_simulate",
          "execute",
          "force_execute",
          "skip"
        ]
      },
      "watcher._types:SimulatedActions": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "all": {
            "$ref": "#/components/schemas/watcher._types:SimulatedActions"
          },
          "use_all": {
            "type": "boolean"
          }
        },
        "required": [
          "actions",
          "all",
          "use_all"
        ]
      },
      "watcher._types:ScheduleTriggerEvent": {
        "type": "object",
        "properties": {
          "scheduled_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "triggered_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "scheduled_time"
        ]
      },
      "watcher._types:Watch": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/watcher._types:Action"
            }
          },
          "condition": {
            "$ref": "#/components/schemas/watcher._types:ConditionContainer"
          },
          "input": {
            "$ref": "#/components/schemas/watcher._types:InputContainer"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:WatchStatus"
          },
          "throttle_period": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttle_period_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "transform": {
            "$ref": "#/components/schemas/_types:TransformContainer"
          },
          "trigger": {
            "$ref": "#/components/schemas/watcher._types:TriggerContainer"
          }
        },
        "required": [
          "actions",
          "condition",
          "input",
          "trigger"
        ]
      },
      "watcher._types:Action": {
        "type": "object",
        "properties": {
          "action_type": {
            "$ref": "#/components/schemas/watcher._types:ActionType"
          },
          "condition": {
            "$ref": "#/components/schemas/watcher._types:ConditionContainer"
          },
          "foreach": {
            "type": "string"
          },
          "max_iterations": {
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "throttle_period": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttle_period_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "transform": {
            "$ref": "#/components/schemas/_types:TransformContainer"
          },
          "index": {
            "$ref": "#/components/schemas/watcher._types:IndexAction"
          },
          "logging": {
            "$ref": "#/components/schemas/watcher._types:LoggingAction"
          },
          "email": {
            "$ref": "#/components/schemas/watcher._types:EmailAction"
          },
          "pagerduty": {
            "$ref": "#/components/schemas/watcher._types:PagerDutyAction"
          },
          "slack": {
            "$ref": "#/components/schemas/watcher._types:SlackAction"
          },
          "webhook": {
            "$ref": "#/components/schemas/watcher._types:WebhookAction"
          }
        }
      },
      "watcher._types:ActionType": {
        "type": "string",
        "enum": [
          "email",
          "webhook",
          "index",
          "logging",
          "slack",
          "pagerduty"
        ]
      },
      "watcher._types:ConditionContainer": {
        "type": "object",
        "properties": {
          "always": {
            "$ref": "#/components/schemas/watcher._types:AlwaysCondition"
          },
          "array_compare": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/watcher._types:ArrayCompareCondition"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "compare": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "minProperties": 1,
              "maxProperties": 1
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "never": {
            "$ref": "#/components/schemas/watcher._types:NeverCondition"
          },
          "script": {
            "$ref": "#/components/schemas/watcher._types:ScriptCondition"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "watcher._types:AlwaysCondition": {
        "type": "object"
      },
      "watcher._types:ArrayCompareCondition": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string"
          }
        },
        "required": [
          "path"
        ]
      },
      "watcher._types:NeverCondition": {
        "type": "object"
      },
      "watcher._types:ScriptCondition": {
        "type": "object",
        "properties": {
          "lang": {
            "type": "string"
          },
          "params": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "source": {
            "type": "string"
          },
          "id": {
            "type": "string"
          }
        }
      },
      "_types:TransformContainer": {
        "type": "object",
        "properties": {
          "chain": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:TransformContainer"
            }
          },
          "script": {
            "$ref": "#/components/schemas/_types:ScriptTransform"
          },
          "search": {
            "$ref": "#/components/schemas/_types:SearchTransform"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:ScriptTransform": {
        "type": "object",
        "properties": {
          "lang": {
            "type": "string"
          },
          "params": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "source": {
            "type": "string"
          },
          "id": {
            "type": "string"
          }
        }
      },
      "_types:SearchTransform": {
        "type": "object",
        "properties": {
          "request": {
            "$ref": "#/components/schemas/watcher._types:SearchInputRequestDefinition"
          },
          "timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "request",
          "timeout"
        ]
      },
      "watcher._types:SearchInputRequestDefinition": {
        "type": "object",
        "properties": {
          "body": {
            "$ref": "#/components/schemas/watcher._types:SearchInputRequestBody"
          },
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "indices_options": {
            "$ref": "#/components/schemas/_types:IndicesOptions"
          },
          "search_type": {
            "$ref": "#/components/schemas/_types:SearchType"
          },
          "template": {
            "$ref": "#/components/schemas/watcher._types:SearchTemplateRequestBody"
          },
          "rest_total_hits_as_int": {
            "type": "boolean"
          }
        }
      },
      "watcher._types:SearchInputRequestBody": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "query"
        ]
      },
      "watcher._types:SearchTemplateRequestBody": {
        "type": "object",
        "properties": {
          "explain": {
            "type": "boolean"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "profile": {
            "type": "boolean"
          },
          "source": {
            "description": "An inline search template. Supports the same parameters as the search API's\nrequest body. Also supports Mustache variables. If no id is specified, this\nparameter is required.",
            "type": "string"
          }
        }
      },
      "watcher._types:IndexAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "doc_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "refresh": {
            "$ref": "#/components/schemas/_types:Refresh"
          },
          "op_type": {
            "$ref": "#/components/schemas/_types:OpType"
          },
          "timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "execution_time_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "index"
        ]
      },
      "watcher._types:LoggingAction": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "category": {
            "type": "string"
          }
        },
        "required": [
          "text"
        ]
      },
      "watcher._types:EmailAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/watcher._types:Email"
          },
          {
            "type": "object"
          }
        ]
      },
      "watcher._types:Email": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "bcc": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "body": {
            "$ref": "#/components/schemas/watcher._types:EmailBody"
          },
          "cc": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "from": {
            "type": "string"
          },
          "priority": {
            "$ref": "#/components/schemas/watcher._types:EmailPriority"
          },
          "reply_to": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "sent_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "subject": {
            "type": "string"
          },
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "attachments": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/watcher._types:EmailAttachmentContainer"
            }
          }
        },
        "required": [
          "subject",
          "to"
        ]
      },
      "watcher._types:EmailBody": {
        "type": "object",
        "properties": {
          "html": {
            "type": "string"
          },
          "text": {
            "type": "string"
          }
        }
      },
      "watcher._types:EmailPriority": {
        "type": "string",
        "enum": [
          "lowest",
          "low",
          "normal",
          "high",
          "highest"
        ]
      },
      "watcher._types:EmailAttachmentContainer": {
        "type": "object",
        "properties": {
          "http": {
            "$ref": "#/components/schemas/watcher._types:HttpEmailAttachment"
          },
          "reporting": {
            "$ref": "#/components/schemas/watcher._types:ReportingEmailAttachment"
          },
          "data": {
            "$ref": "#/components/schemas/watcher._types:DataEmailAttachment"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "watcher._types:HttpEmailAttachment": {
        "type": "object",
        "properties": {
          "content_type": {
            "type": "string"
          },
          "inline": {
            "type": "boolean"
          },
          "request": {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestDefinition"
          }
        }
      },
      "watcher._types:HttpInputRequestDefinition": {
        "type": "object",
        "properties": {
          "auth": {
            "$ref": "#/components/schemas/watcher._types:HttpInputAuthentication"
          },
          "body": {
            "type": "string"
          },
          "connection_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "method": {
            "$ref": "#/components/schemas/watcher._types:HttpInputMethod"
          },
          "params": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "path": {
            "type": "string"
          },
          "port": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "proxy": {
            "$ref": "#/components/schemas/watcher._types:HttpInputProxy"
          },
          "read_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "scheme": {
            "$ref": "#/components/schemas/watcher._types:ConnectionScheme"
          },
          "url": {
            "type": "string"
          }
        }
      },
      "watcher._types:HttpInputAuthentication": {
        "type": "object",
        "properties": {
          "basic": {
            "$ref": "#/components/schemas/watcher._types:HttpInputBasicAuthentication"
          }
        },
        "required": [
          "basic"
        ]
      },
      "watcher._types:HttpInputBasicAuthentication": {
        "type": "object",
        "properties": {
          "password": {
            "$ref": "#/components/schemas/_types:Password"
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          }
        },
        "required": [
          "password",
          "username"
        ]
      },
      "watcher._types:HttpInputMethod": {
        "type": "string",
        "enum": [
          "head",
          "get",
          "post",
          "put",
          "delete"
        ]
      },
      "watcher._types:HttpInputProxy": {
        "type": "object",
        "properties": {
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "port": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "host",
          "port"
        ]
      },
      "watcher._types:ConnectionScheme": {
        "type": "string",
        "enum": [
          "http",
          "https"
        ]
      },
      "watcher._types:ReportingEmailAttachment": {
        "type": "object",
        "properties": {
          "url": {
            "type": "string"
          },
          "inline": {
            "type": "boolean"
          },
          "retries": {
            "type": "number"
          },
          "interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "request": {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestDefinition"
          }
        },
        "required": [
          "url"
        ]
      },
      "watcher._types:DataEmailAttachment": {
        "type": "object",
        "properties": {
          "format": {
            "$ref": "#/components/schemas/watcher._types:DataAttachmentFormat"
          }
        }
      },
      "watcher._types:DataAttachmentFormat": {
        "type": "string",
        "enum": [
          "json",
          "yaml"
        ]
      },
      "watcher._types:PagerDutyAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/watcher._types:PagerDutyEvent"
          },
          {
            "type": "object"
          }
        ]
      },
      "watcher._types:PagerDutyEvent": {
        "type": "object",
        "properties": {
          "account": {
            "type": "string"
          },
          "attach_payload": {
            "type": "boolean"
          },
          "client": {
            "type": "string"
          },
          "client_url": {
            "type": "string"
          },
          "contexts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:PagerDutyContext"
            }
          },
          "description": {
            "type": "string"
          },
          "event_type": {
            "$ref": "#/components/schemas/watcher._types:PagerDutyEventType"
          },
          "incident_key": {
            "type": "string"
          },
          "proxy": {
            "$ref": "#/components/schemas/watcher._types:PagerDutyEventProxy"
          }
        },
        "required": [
          "attach_payload",
          "description",
          "incident_key"
        ]
      },
      "watcher._types:PagerDutyContext": {
        "type": "object",
        "properties": {
          "href": {
            "type": "string"
          },
          "src": {
            "type": "string"
          },
          "type": {
            "$ref": "#/components/schemas/watcher._types:PagerDutyContextType"
          }
        },
        "required": [
          "type"
        ]
      },
      "watcher._types:PagerDutyContextType": {
        "type": "string",
        "enum": [
          "link",
          "image"
        ]
      },
      "watcher._types:PagerDutyEventType": {
        "type": "string",
        "enum": [
          "trigger",
          "resolve",
          "acknowledge"
        ]
      },
      "watcher._types:PagerDutyEventProxy": {
        "type": "object",
        "properties": {
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "port": {
            "type": "number"
          }
        }
      },
      "watcher._types:SlackAction": {
        "type": "object",
        "properties": {
          "account": {
            "type": "string"
          },
          "message": {
            "$ref": "#/components/schemas/watcher._types:SlackMessage"
          }
        },
        "required": [
          "message"
        ]
      },
      "watcher._types:SlackMessage": {
        "type": "object",
        "properties": {
          "attachments": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:SlackAttachment"
            }
          },
          "dynamic_attachments": {
            "$ref": "#/components/schemas/watcher._types:SlackDynamicAttachment"
          },
          "from": {
            "type": "string"
          },
          "icon": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "to": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "attachments",
          "from",
          "text",
          "to"
        ]
      },
      "watcher._types:SlackAttachment": {
        "type": "object",
        "properties": {
          "author_icon": {
            "type": "string"
          },
          "author_link": {
            "type": "string"
          },
          "author_name": {
            "type": "string"
          },
          "color": {
            "type": "string"
          },
          "fallback": {
            "type": "string"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:SlackAttachmentField"
            }
          },
          "footer": {
            "type": "string"
          },
          "footer_icon": {
            "type": "string"
          },
          "image_url": {
            "type": "string"
          },
          "pretext": {
            "type": "string"
          },
          "text": {
            "type": "string"
          },
          "thumb_url": {
            "type": "string"
          },
          "title": {
            "type": "string"
          },
          "title_link": {
            "type": "string"
          },
          "ts": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitSeconds"
          }
        },
        "required": [
          "author_name",
          "title"
        ]
      },
      "watcher._types:SlackAttachmentField": {
        "type": "object",
        "properties": {
          "short": {
            "type": "boolean"
          },
          "title": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "short",
          "title",
          "value"
        ]
      },
      "watcher._types:SlackDynamicAttachment": {
        "type": "object",
        "properties": {
          "attachment_template": {
            "$ref": "#/components/schemas/watcher._types:SlackAttachment"
          },
          "list_path": {
            "type": "string"
          }
        },
        "required": [
          "attachment_template",
          "list_path"
        ]
      },
      "watcher._types:WebhookAction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestDefinition"
          },
          {
            "type": "object"
          }
        ]
      },
      "watcher._types:InputContainer": {
        "type": "object",
        "properties": {
          "chain": {
            "$ref": "#/components/schemas/watcher._types:ChainInput"
          },
          "http": {
            "$ref": "#/components/schemas/watcher._types:HttpInput"
          },
          "search": {
            "$ref": "#/components/schemas/watcher._types:SearchInput"
          },
          "simple": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "watcher._types:ChainInput": {
        "type": "object",
        "properties": {
          "inputs": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/watcher._types:InputContainer"
              },
              "minProperties": 1,
              "maxProperties": 1
            }
          }
        },
        "required": [
          "inputs"
        ]
      },
      "watcher._types:HttpInput": {
        "type": "object",
        "properties": {
          "extract": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "request": {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestDefinition"
          },
          "response_content_type": {
            "$ref": "#/components/schemas/watcher._types:ResponseContentType"
          }
        }
      },
      "watcher._types:ResponseContentType": {
        "type": "string",
        "enum": [
          "json",
          "yaml",
          "text"
        ]
      },
      "watcher._types:SearchInput": {
        "type": "object",
        "properties": {
          "extract": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "request": {
            "$ref": "#/components/schemas/watcher._types:SearchInputRequestDefinition"
          },
          "timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "request"
        ]
      },
      "watcher._types:TriggerContainer": {
        "type": "object",
        "properties": {
          "schedule": {
            "$ref": "#/components/schemas/watcher._types:ScheduleContainer"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "watcher._types:ScheduleContainer": {
        "type": "object",
        "properties": {
          "cron": {
            "$ref": "#/components/schemas/watcher._types:CronExpression"
          },
          "daily": {
            "$ref": "#/components/schemas/watcher._types:DailySchedule"
          },
          "hourly": {
            "$ref": "#/components/schemas/watcher._types:HourlySchedule"
          },
          "interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "monthly": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/watcher._types:TimeOfMonth"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/watcher._types:TimeOfMonth"
                }
              }
            ]
          },
          "weekly": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/watcher._types:TimeOfWeek"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/watcher._types:TimeOfWeek"
                }
              }
            ]
          },
          "yearly": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/watcher._types:TimeOfYear"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/watcher._types:TimeOfYear"
                }
              }
            ]
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "watcher._types:DailySchedule": {
        "type": "object",
        "properties": {
          "at": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:ScheduleTimeOfDay"
            }
          }
        },
        "required": [
          "at"
        ]
      },
      "watcher._types:HourlySchedule": {
        "type": "object",
        "properties": {
          "minute": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "minute"
        ]
      },
      "watcher._types:TimeOfMonth": {
        "type": "object",
        "properties": {
          "at": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "on": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "at",
          "on"
        ]
      },
      "watcher._types:TimeOfWeek": {
        "type": "object",
        "properties": {
          "at": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "on": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:Day"
            }
          }
        },
        "required": [
          "at",
          "on"
        ]
      },
      "watcher._types:Day": {
        "type": "string",
        "enum": [
          "sunday",
          "monday",
          "tuesday",
          "wednesday",
          "thursday",
          "friday",
          "saturday"
        ]
      },
      "watcher._types:TimeOfYear": {
        "type": "object",
        "properties": {
          "at": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "int": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:Month"
            }
          },
          "on": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "at",
          "int",
          "on"
        ]
      },
      "watcher._types:Month": {
        "type": "string",
        "enum": [
          "january",
          "february",
          "march",
          "april",
          "may",
          "june",
          "july",
          "august",
          "september",
          "october",
          "november",
          "december"
        ]
      },
      "watcher.execute_watch:WatchRecord": {
        "type": "object",
        "properties": {
          "condition": {
            "$ref": "#/components/schemas/watcher._types:ConditionContainer"
          },
          "input": {
            "$ref": "#/components/schemas/watcher._types:InputContainer"
          },
          "messages": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "node": {
            "type": "string"
          },
          "result": {
            "$ref": "#/components/schemas/watcher._types:ExecutionResult"
          },
          "state": {
            "$ref": "#/components/schemas/watcher._types:ExecutionStatus"
          },
          "trigger_event": {
            "$ref": "#/components/schemas/watcher._types:TriggerEventResult"
          },
          "user": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "watch_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:WatchStatus"
          }
        },
        "required": [
          "condition",
          "input",
          "messages",
          "node",
          "result",
          "state",
          "trigger_event",
          "user",
          "watch_id"
        ]
      },
      "watcher._types:ExecutionResult": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher._types:ExecutionResultAction"
            }
          },
          "condition": {
            "$ref": "#/components/schemas/watcher._types:ExecutionResultCondition"
          },
          "execution_duration": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "execution_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "input": {
            "$ref": "#/components/schemas/watcher._types:ExecutionResultInput"
          }
        },
        "required": [
          "actions",
          "condition",
          "execution_duration",
          "execution_time",
          "input"
        ]
      },
      "watcher._types:ExecutionResultAction": {
        "type": "object",
        "properties": {
          "email": {
            "$ref": "#/components/schemas/watcher._types:EmailResult"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index": {
            "$ref": "#/components/schemas/watcher._types:IndexResult"
          },
          "logging": {
            "$ref": "#/components/schemas/watcher._types:LoggingResult"
          },
          "pagerduty": {
            "$ref": "#/components/schemas/watcher._types:PagerDutyResult"
          },
          "reason": {
            "type": "string"
          },
          "slack": {
            "$ref": "#/components/schemas/watcher._types:SlackResult"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:ActionStatusOptions"
          },
          "type": {
            "$ref": "#/components/schemas/watcher._types:ActionType"
          },
          "webhook": {
            "$ref": "#/components/schemas/watcher._types:WebhookResult"
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "id",
          "status",
          "type"
        ]
      },
      "watcher._types:EmailResult": {
        "type": "object",
        "properties": {
          "account": {
            "type": "string"
          },
          "message": {
            "$ref": "#/components/schemas/watcher._types:Email"
          },
          "reason": {
            "type": "string"
          }
        },
        "required": [
          "message"
        ]
      },
      "watcher._types:IndexResult": {
        "type": "object",
        "properties": {
          "response": {
            "$ref": "#/components/schemas/watcher._types:IndexResultSummary"
          }
        },
        "required": [
          "response"
        ]
      },
      "watcher._types:IndexResultSummary": {
        "type": "object",
        "properties": {
          "created": {
            "type": "boolean"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "result": {
            "$ref": "#/components/schemas/_types:Result"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "created",
          "id",
          "index",
          "result",
          "version"
        ]
      },
      "watcher._types:LoggingResult": {
        "type": "object",
        "properties": {
          "logged_text": {
            "type": "string"
          }
        },
        "required": [
          "logged_text"
        ]
      },
      "watcher._types:PagerDutyResult": {
        "type": "object",
        "properties": {
          "event": {
            "$ref": "#/components/schemas/watcher._types:PagerDutyEvent"
          },
          "reason": {
            "type": "string"
          },
          "request": {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestResult"
          },
          "response": {
            "$ref": "#/components/schemas/watcher._types:HttpInputResponseResult"
          }
        },
        "required": [
          "event"
        ]
      },
      "watcher._types:HttpInputRequestResult": {
        "allOf": [
          {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestDefinition"
          },
          {
            "type": "object"
          }
        ]
      },
      "watcher._types:HttpInputResponseResult": {
        "type": "object",
        "properties": {
          "body": {
            "type": "string"
          },
          "headers": {
            "$ref": "#/components/schemas/_types:HttpHeaders"
          },
          "status": {
            "type": "number"
          }
        },
        "required": [
          "body",
          "headers",
          "status"
        ]
      },
      "watcher._types:SlackResult": {
        "type": "object",
        "properties": {
          "account": {
            "type": "string"
          },
          "message": {
            "$ref": "#/components/schemas/watcher._types:SlackMessage"
          }
        },
        "required": [
          "message"
        ]
      },
      "watcher._types:WebhookResult": {
        "type": "object",
        "properties": {
          "request": {
            "$ref": "#/components/schemas/watcher._types:HttpInputRequestResult"
          },
          "response": {
            "$ref": "#/components/schemas/watcher._types:HttpInputResponseResult"
          }
        },
        "required": [
          "request"
        ]
      },
      "watcher._types:ExecutionResultCondition": {
        "type": "object",
        "properties": {
          "met": {
            "type": "boolean"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:ActionStatusOptions"
          },
          "type": {
            "$ref": "#/components/schemas/watcher._types:ConditionType"
          }
        },
        "required": [
          "met",
          "status",
          "type"
        ]
      },
      "watcher._types:ConditionType": {
        "type": "string",
        "enum": [
          "always",
          "never",
          "script",
          "compare",
          "array_compare"
        ]
      },
      "watcher._types:ExecutionResultInput": {
        "type": "object",
        "properties": {
          "payload": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:ActionStatusOptions"
          },
          "type": {
            "$ref": "#/components/schemas/watcher._types:InputType"
          }
        },
        "required": [
          "payload",
          "status",
          "type"
        ]
      },
      "watcher._types:InputType": {
        "type": "string",
        "enum": [
          "http",
          "search",
          "simple"
        ]
      },
      "watcher._types:ExecutionStatus": {
        "type": "string",
        "enum": [
          "awaits_execution",
          "checking",
          "execution_not_needed",
          "throttled",
          "executed",
          "failed",
          "deleted_while_queued",
          "not_executed_already_queued"
        ]
      },
      "watcher._types:TriggerEventResult": {
        "type": "object",
        "properties": {
          "manual": {
            "$ref": "#/components/schemas/watcher._types:TriggerEventContainer"
          },
          "triggered_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "manual",
          "triggered_time",
          "type"
        ]
      },
      "watcher._types:TriggerEventContainer": {
        "type": "object",
        "properties": {
          "schedule": {
            "$ref": "#/components/schemas/watcher._types:ScheduleTriggerEvent"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "watcher._types:QueryWatch": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:WatchStatus"
          },
          "watch": {
            "$ref": "#/components/schemas/watcher._types:Watch"
          },
          "_primary_term": {
            "type": "number"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          }
        },
        "required": [
          "_id"
        ]
      },
      "watcher.stats:WatcherMetric": {
        "type": "string",
        "enum": [
          "_all",
          "all",
          "queued_watches",
          "current_watches",
          "pending_watches"
        ]
      },
      "watcher.stats:WatcherNodeStats": {
        "type": "object",
        "properties": {
          "current_watches": {
            "description": "The current executing watches metric gives insight into the watches that are currently being executed by Watcher.\nAdditional information is shared per watch that is currently executing.\nThis information includes the `watch_id`, the time its execution started and its current execution phase.\nTo include this metric, the `metric` option should be set to `current_watches` or `_all`.\nIn addition you can also specify the `emit_stacktraces=true` parameter, which adds stack traces for each watch that is being run.\nThese stack traces can give you more insight into an execution of a watch.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher.stats:WatchRecordStats"
            }
          },
          "execution_thread_pool": {
            "$ref": "#/components/schemas/watcher._types:ExecutionThreadPool"
          },
          "queued_watches": {
            "description": "Watcher moderates the execution of watches such that their execution won't put too much pressure on the node and its resources.\nIf too many watches trigger concurrently and there isn't enough capacity to run them all, some of the watches are queued, waiting for the current running watches to finish.s\nThe queued watches metric gives insight on these queued watches.\n\nTo include this metric, the `metric` option should include `queued_watches` or `_all`.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/watcher.stats:WatchRecordQueuedStats"
            }
          },
          "watch_count": {
            "description": "The number of watches currently registered.",
            "type": "number"
          },
          "watcher_state": {
            "$ref": "#/components/schemas/watcher.stats:WatcherState"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "required": [
          "execution_thread_pool",
          "watch_count",
          "watcher_state",
          "node_id"
        ]
      },
      "watcher.stats:WatchRecordStats": {
        "allOf": [
          {
            "$ref": "#/components/schemas/watcher.stats:WatchRecordQueuedStats"
          },
          {
            "type": "object",
            "properties": {
              "execution_phase": {
                "$ref": "#/components/schemas/watcher._types:ExecutionPhase"
              },
              "triggered_time": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "executed_actions": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "watch_id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "watch_record_id": {
                "$ref": "#/components/schemas/_types:Id"
              }
            },
            "required": [
              "execution_phase",
              "triggered_time",
              "watch_id",
              "watch_record_id"
            ]
          }
        ]
      },
      "watcher._types:ExecutionPhase": {
        "type": "string",
        "enum": [
          "awaits_execution",
          "started",
          "input",
          "condition",
          "actions",
          "watch_transform",
          "aborted",
          "finished"
        ]
      },
      "watcher.stats:WatchRecordQueuedStats": {
        "type": "object",
        "properties": {
          "execution_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "execution_time"
        ]
      },
      "watcher._types:ExecutionThreadPool": {
        "type": "object",
        "properties": {
          "max_size": {
            "description": "The largest size of the execution thread pool, which indicates the largest number of concurrent running watches.",
            "type": "number"
          },
          "queue_size": {
            "description": "The number of watches that were triggered and are currently queued.",
            "type": "number"
          }
        },
        "required": [
          "max_size",
          "queue_size"
        ]
      },
      "watcher.stats:WatcherState": {
        "type": "string",
        "enum": [
          "stopped",
          "starting",
          "started",
          "stopping"
        ]
      },
      "xpack.info:XPackCategory": {
        "type": "string",
        "enum": [
          "build",
          "features",
          "license"
        ]
      },
      "xpack.info:BuildInformation": {
        "type": "object",
        "properties": {
          "date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "hash": {
            "type": "string"
          }
        },
        "required": [
          "date",
          "hash"
        ]
      },
      "xpack.info:Features": {
        "type": "object",
        "properties": {
          "aggregate_metric": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "analytics": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "ccr": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "data_streams": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "data_tiers": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "enrich": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "enterprise_search": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "eql": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "esql": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "frozen_indices": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "graph": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "ilm": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "logstash": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "logsdb": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "ml": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "monitoring": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "rollup": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "runtime_fields": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "searchable_snapshots": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "security": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "slm": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "spatial": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "sql": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "transform": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "universal_profiling": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "voting_only": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "watcher": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "archive": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          }
        },
        "required": [
          "aggregate_metric",
          "analytics",
          "ccr",
          "data_streams",
          "data_tiers",
          "enrich",
          "enterprise_search",
          "eql",
          "esql",
          "frozen_indices",
          "graph",
          "ilm",
          "logstash",
          "logsdb",
          "ml",
          "monitoring",
          "rollup",
          "searchable_snapshots",
          "security",
          "slm",
          "spatial",
          "sql",
          "transform",
          "universal_profiling",
          "voting_only",
          "watcher",
          "archive"
        ]
      },
      "xpack.info:Feature": {
        "type": "object",
        "properties": {
          "available": {
            "type": "boolean"
          },
          "description": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "native_code_info": {
            "$ref": "#/components/schemas/xpack.info:NativeCodeInformation"
          }
        },
        "required": [
          "available",
          "enabled"
        ]
      },
      "xpack.info:NativeCodeInformation": {
        "type": "object",
        "properties": {
          "build_hash": {
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "build_hash",
          "version"
        ]
      },
      "xpack.info:MinimalLicenseInformation": {
        "type": "object",
        "properties": {
          "expiry_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "mode": {
            "$ref": "#/components/schemas/license._types:LicenseType"
          },
          "status": {
            "$ref": "#/components/schemas/license._types:LicenseStatus"
          },
          "type": {
            "$ref": "#/components/schemas/license._types:LicenseType"
          },
          "uid": {
            "type": "string"
          }
        },
        "required": [
          "expiry_date_in_millis",
          "mode",
          "status",
          "type",
          "uid"
        ]
      },
      "xpack.usage:Base": {
        "type": "object",
        "properties": {
          "available": {
            "type": "boolean"
          },
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "available",
          "enabled"
        ]
      },
      "xpack.usage:Analytics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "stats": {
                "$ref": "#/components/schemas/xpack.usage:AnalyticsStatistics"
              }
            },
            "required": [
              "stats"
            ]
          }
        ]
      },
      "xpack.usage:AnalyticsStatistics": {
        "type": "object",
        "properties": {
          "boxplot_usage": {
            "type": "number"
          },
          "cumulative_cardinality_usage": {
            "type": "number"
          },
          "string_stats_usage": {
            "type": "number"
          },
          "top_metrics_usage": {
            "type": "number"
          },
          "t_test_usage": {
            "type": "number"
          },
          "moving_percentiles_usage": {
            "type": "number"
          },
          "normalize_usage": {
            "type": "number"
          },
          "rate_usage": {
            "type": "number"
          },
          "multi_terms_usage": {
            "type": "number"
          }
        },
        "required": [
          "boxplot_usage",
          "cumulative_cardinality_usage",
          "string_stats_usage",
          "top_metrics_usage",
          "t_test_usage",
          "moving_percentiles_usage",
          "normalize_usage",
          "rate_usage"
        ]
      },
      "xpack.usage:Archive": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "indices_count": {
                "type": "number"
              }
            },
            "required": [
              "indices_count"
            ]
          }
        ]
      },
      "xpack.usage:Watcher": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "execution": {
                "$ref": "#/components/schemas/xpack.usage:WatcherActions"
              },
              "watch": {
                "$ref": "#/components/schemas/xpack.usage:WatcherWatch"
              },
              "count": {
                "$ref": "#/components/schemas/xpack.usage:Counter"
              }
            },
            "required": [
              "execution",
              "watch",
              "count"
            ]
          }
        ]
      },
      "xpack.usage:WatcherActions": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/xpack.usage:WatcherActionTotals"
            }
          }
        },
        "required": [
          "actions"
        ]
      },
      "xpack.usage:WatcherActionTotals": {
        "type": "object",
        "properties": {
          "total": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "total",
          "total_time_in_ms"
        ]
      },
      "xpack.usage:WatcherWatch": {
        "type": "object",
        "properties": {
          "input": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/xpack.usage:Counter"
            }
          },
          "condition": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/xpack.usage:Counter"
            }
          },
          "action": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/xpack.usage:Counter"
            }
          },
          "trigger": {
            "$ref": "#/components/schemas/xpack.usage:WatcherWatchTrigger"
          }
        },
        "required": [
          "input",
          "trigger"
        ]
      },
      "xpack.usage:Counter": {
        "type": "object",
        "properties": {
          "active": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "active",
          "total"
        ]
      },
      "xpack.usage:WatcherWatchTrigger": {
        "type": "object",
        "properties": {
          "schedule": {
            "$ref": "#/components/schemas/xpack.usage:WatcherWatchTriggerSchedule"
          },
          "_all": {
            "$ref": "#/components/schemas/xpack.usage:Counter"
          }
        },
        "required": [
          "_all"
        ]
      },
      "xpack.usage:WatcherWatchTriggerSchedule": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Counter"
          },
          {
            "type": "object",
            "properties": {
              "cron": {
                "$ref": "#/components/schemas/xpack.usage:Counter"
              },
              "_all": {
                "$ref": "#/components/schemas/xpack.usage:Counter"
              }
            },
            "required": [
              "cron",
              "_all"
            ]
          }
        ]
      },
      "xpack.usage:Ccr": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "auto_follow_patterns_count": {
                "type": "number"
              },
              "follower_indices_count": {
                "type": "number"
              }
            },
            "required": [
              "auto_follow_patterns_count",
              "follower_indices_count"
            ]
          }
        ]
      },
      "xpack.usage:DataStreams": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "data_streams": {
                "type": "number"
              },
              "indices_count": {
                "type": "number"
              }
            },
            "required": [
              "data_streams",
              "indices_count"
            ]
          }
        ]
      },
      "xpack.usage:DataTiers": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "data_warm": {
                "$ref": "#/components/schemas/xpack.usage:DataTierPhaseStatistics"
              },
              "data_frozen": {
                "$ref": "#/components/schemas/xpack.usage:DataTierPhaseStatistics"
              },
              "data_cold": {
                "$ref": "#/components/schemas/xpack.usage:DataTierPhaseStatistics"
              },
              "data_content": {
                "$ref": "#/components/schemas/xpack.usage:DataTierPhaseStatistics"
              },
              "data_hot": {
                "$ref": "#/components/schemas/xpack.usage:DataTierPhaseStatistics"
              }
            },
            "required": [
              "data_warm",
              "data_cold",
              "data_content",
              "data_hot"
            ]
          }
        ]
      },
      "xpack.usage:DataTierPhaseStatistics": {
        "type": "object",
        "properties": {
          "node_count": {
            "type": "number"
          },
          "index_count": {
            "type": "number"
          },
          "total_shard_count": {
            "type": "number"
          },
          "primary_shard_count": {
            "type": "number"
          },
          "doc_count": {
            "type": "number"
          },
          "total_size_bytes": {
            "type": "number"
          },
          "primary_size_bytes": {
            "type": "number"
          },
          "primary_shard_size_avg_bytes": {
            "type": "number"
          },
          "primary_shard_size_median_bytes": {
            "type": "number"
          },
          "primary_shard_size_mad_bytes": {
            "type": "number"
          }
        },
        "required": [
          "node_count",
          "index_count",
          "total_shard_count",
          "primary_shard_count",
          "doc_count",
          "total_size_bytes",
          "primary_size_bytes",
          "primary_shard_size_avg_bytes",
          "primary_shard_size_median_bytes",
          "primary_shard_size_mad_bytes"
        ]
      },
      "xpack.usage:Eql": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "features": {
                "$ref": "#/components/schemas/xpack.usage:EqlFeatures"
              },
              "queries": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/xpack.usage:Query"
                }
              }
            },
            "required": [
              "features",
              "queries"
            ]
          }
        ]
      },
      "xpack.usage:EqlFeatures": {
        "type": "object",
        "properties": {
          "join": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "joins": {
            "$ref": "#/components/schemas/xpack.usage:EqlFeaturesJoin"
          },
          "keys": {
            "$ref": "#/components/schemas/xpack.usage:EqlFeaturesKeys"
          },
          "event": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "pipes": {
            "$ref": "#/components/schemas/xpack.usage:EqlFeaturesPipes"
          },
          "sequence": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "sequences": {
            "$ref": "#/components/schemas/xpack.usage:EqlFeaturesSequences"
          }
        },
        "required": [
          "join",
          "joins",
          "keys",
          "event",
          "pipes",
          "sequence",
          "sequences"
        ]
      },
      "xpack.usage:EqlFeaturesJoin": {
        "type": "object",
        "properties": {
          "join_queries_two": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_queries_three": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_until": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_queries_five_or_more": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_queries_four": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "join_queries_two",
          "join_queries_three",
          "join_until",
          "join_queries_five_or_more",
          "join_queries_four"
        ]
      },
      "xpack.usage:EqlFeaturesKeys": {
        "type": "object",
        "properties": {
          "join_keys_two": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_keys_one": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_keys_three": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_keys_five_or_more": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "join_keys_four": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "join_keys_two",
          "join_keys_one",
          "join_keys_three",
          "join_keys_five_or_more",
          "join_keys_four"
        ]
      },
      "xpack.usage:EqlFeaturesPipes": {
        "type": "object",
        "properties": {
          "pipe_tail": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "pipe_head": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "pipe_tail",
          "pipe_head"
        ]
      },
      "xpack.usage:EqlFeaturesSequences": {
        "type": "object",
        "properties": {
          "sequence_queries_three": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "sequence_queries_four": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "sequence_queries_two": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "sequence_until": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "sequence_queries_five_or_more": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "sequence_maxspan": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "sequence_queries_three",
          "sequence_queries_four",
          "sequence_queries_two",
          "sequence_until",
          "sequence_queries_five_or_more",
          "sequence_maxspan"
        ]
      },
      "xpack.usage:Query": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "failed": {
            "type": "number"
          },
          "paging": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        }
      },
      "xpack.usage:Flattened": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "field_count": {
                "type": "number"
              }
            },
            "required": [
              "field_count"
            ]
          }
        ]
      },
      "xpack.usage:FrozenIndices": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "indices_count": {
                "type": "number"
              }
            },
            "required": [
              "indices_count"
            ]
          }
        ]
      },
      "xpack.usage:HealthStatistics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "invocations": {
                "$ref": "#/components/schemas/xpack.usage:Invocations"
              }
            },
            "required": [
              "invocations"
            ]
          }
        ]
      },
      "xpack.usage:Invocations": {
        "type": "object",
        "properties": {
          "total": {
            "type": "number"
          }
        },
        "required": [
          "total"
        ]
      },
      "xpack.usage:Ilm": {
        "type": "object",
        "properties": {
          "policy_count": {
            "type": "number"
          },
          "policy_stats": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/xpack.usage:IlmPolicyStatistics"
            }
          }
        },
        "required": [
          "policy_count",
          "policy_stats"
        ]
      },
      "xpack.usage:IlmPolicyStatistics": {
        "type": "object",
        "properties": {
          "indices_managed": {
            "type": "number"
          },
          "phases": {
            "$ref": "#/components/schemas/xpack.usage:Phases"
          }
        },
        "required": [
          "indices_managed",
          "phases"
        ]
      },
      "xpack.usage:Phases": {
        "type": "object",
        "properties": {
          "cold": {
            "$ref": "#/components/schemas/xpack.usage:Phase"
          },
          "delete": {
            "$ref": "#/components/schemas/xpack.usage:Phase"
          },
          "frozen": {
            "$ref": "#/components/schemas/xpack.usage:Phase"
          },
          "hot": {
            "$ref": "#/components/schemas/xpack.usage:Phase"
          },
          "warm": {
            "$ref": "#/components/schemas/xpack.usage:Phase"
          }
        }
      },
      "xpack.usage:Phase": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "min_age": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "actions",
          "min_age"
        ]
      },
      "xpack.usage:MachineLearning": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "datafeeds": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/xpack.usage:Datafeed"
                }
              },
              "jobs": {
                "description": "Job usage statistics. The `_all` entry is always present and gathers statistics for all jobs.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/xpack.usage:JobUsage"
                }
              },
              "node_count": {
                "type": "number"
              },
              "data_frame_analytics_jobs": {
                "$ref": "#/components/schemas/xpack.usage:MlDataFrameAnalyticsJobs"
              },
              "inference": {
                "$ref": "#/components/schemas/xpack.usage:MlInference"
              }
            },
            "required": [
              "datafeeds",
              "jobs",
              "node_count",
              "data_frame_analytics_jobs",
              "inference"
            ]
          }
        ]
      },
      "xpack.usage:Datafeed": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "xpack.usage:JobUsage": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "created_by": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "detectors": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "forecasts": {
            "$ref": "#/components/schemas/xpack.usage:MlJobForecasts"
          },
          "model_size": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          }
        },
        "required": [
          "count",
          "created_by",
          "detectors",
          "forecasts",
          "model_size"
        ]
      },
      "xpack.usage:MlJobForecasts": {
        "type": "object",
        "properties": {
          "total": {
            "type": "number"
          },
          "forecasted_jobs": {
            "type": "number"
          }
        },
        "required": [
          "total",
          "forecasted_jobs"
        ]
      },
      "xpack.usage:MlDataFrameAnalyticsJobs": {
        "type": "object",
        "properties": {
          "memory_usage": {
            "$ref": "#/components/schemas/xpack.usage:MlDataFrameAnalyticsJobsMemory"
          },
          "_all": {
            "$ref": "#/components/schemas/xpack.usage:MlDataFrameAnalyticsJobsCount"
          },
          "analysis_counts": {
            "$ref": "#/components/schemas/xpack.usage:MlDataFrameAnalyticsJobsAnalysis"
          },
          "stopped": {
            "$ref": "#/components/schemas/xpack.usage:MlDataFrameAnalyticsJobsCount"
          }
        },
        "required": [
          "_all"
        ]
      },
      "xpack.usage:MlDataFrameAnalyticsJobsMemory": {
        "type": "object",
        "properties": {
          "peak_usage_bytes": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          }
        },
        "required": [
          "peak_usage_bytes"
        ]
      },
      "xpack.usage:MlDataFrameAnalyticsJobsCount": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "xpack.usage:MlDataFrameAnalyticsJobsAnalysis": {
        "type": "object",
        "properties": {
          "classification": {
            "type": "number"
          },
          "outlier_detection": {
            "type": "number"
          },
          "regression": {
            "type": "number"
          }
        }
      },
      "xpack.usage:MlInference": {
        "type": "object",
        "properties": {
          "ingest_processors": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/xpack.usage:MlInferenceIngestProcessor"
            }
          },
          "trained_models": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceTrainedModels"
          },
          "deployments": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceDeployments"
          }
        },
        "required": [
          "ingest_processors",
          "trained_models"
        ]
      },
      "xpack.usage:MlInferenceIngestProcessor": {
        "type": "object",
        "properties": {
          "num_docs_processed": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceIngestProcessorCount"
          },
          "pipelines": {
            "$ref": "#/components/schemas/xpack.usage:MlCounter"
          },
          "num_failures": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceIngestProcessorCount"
          },
          "time_ms": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceIngestProcessorCount"
          }
        },
        "required": [
          "num_docs_processed",
          "pipelines",
          "num_failures",
          "time_ms"
        ]
      },
      "xpack.usage:MlInferenceIngestProcessorCount": {
        "type": "object",
        "properties": {
          "max": {
            "type": "number"
          },
          "sum": {
            "type": "number"
          },
          "min": {
            "type": "number"
          }
        },
        "required": [
          "max",
          "sum",
          "min"
        ]
      },
      "xpack.usage:MlCounter": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "xpack.usage:MlInferenceTrainedModels": {
        "type": "object",
        "properties": {
          "estimated_operations": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "estimated_heap_memory_usage_bytes": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "count": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceTrainedModelsCount"
          },
          "_all": {
            "$ref": "#/components/schemas/xpack.usage:MlCounter"
          },
          "model_size_bytes": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          }
        },
        "required": [
          "_all"
        ]
      },
      "xpack.usage:MlInferenceTrainedModelsCount": {
        "type": "object",
        "properties": {
          "total": {
            "type": "number"
          },
          "prepackaged": {
            "type": "number"
          },
          "other": {
            "type": "number"
          },
          "pass_through": {
            "type": "number"
          },
          "regression": {
            "type": "number"
          },
          "classification": {
            "type": "number"
          },
          "ner": {
            "type": "number"
          },
          "text_embedding": {
            "type": "number"
          }
        },
        "required": [
          "total",
          "prepackaged",
          "other"
        ]
      },
      "xpack.usage:MlInferenceDeployments": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "inference_counts": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "model_sizes_bytes": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "time_ms": {
            "$ref": "#/components/schemas/xpack.usage:MlInferenceDeploymentsTimeMs"
          }
        },
        "required": [
          "count",
          "inference_counts",
          "model_sizes_bytes",
          "time_ms"
        ]
      },
      "xpack.usage:MlInferenceDeploymentsTimeMs": {
        "type": "object",
        "properties": {
          "avg": {
            "type": "number"
          }
        },
        "required": [
          "avg"
        ]
      },
      "xpack.usage:Monitoring": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "collection_enabled": {
                "type": "boolean"
              },
              "enabled_exporters": {
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              }
            },
            "required": [
              "collection_enabled",
              "enabled_exporters"
            ]
          }
        ]
      },
      "xpack.usage:RuntimeFieldTypes": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "field_types": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/xpack.usage:RuntimeFieldsType"
                }
              }
            },
            "required": [
              "field_types"
            ]
          }
        ]
      },
      "xpack.usage:RuntimeFieldsType": {
        "type": "object",
        "properties": {
          "chars_max": {
            "type": "number"
          },
          "chars_total": {
            "type": "number"
          },
          "count": {
            "type": "number"
          },
          "doc_max": {
            "type": "number"
          },
          "doc_total": {
            "type": "number"
          },
          "index_count": {
            "type": "number"
          },
          "lang": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "lines_max": {
            "type": "number"
          },
          "lines_total": {
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "scriptless_count": {
            "type": "number"
          },
          "shadowed_count": {
            "type": "number"
          },
          "source_max": {
            "type": "number"
          },
          "source_total": {
            "type": "number"
          }
        },
        "required": [
          "chars_max",
          "chars_total",
          "count",
          "doc_max",
          "doc_total",
          "index_count",
          "lang",
          "lines_max",
          "lines_total",
          "name",
          "scriptless_count",
          "shadowed_count",
          "source_max",
          "source_total"
        ]
      },
      "xpack.usage:SearchableSnapshots": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "indices_count": {
                "type": "number"
              },
              "full_copy_indices_count": {
                "type": "number"
              },
              "shared_cache_indices_count": {
                "type": "number"
              }
            },
            "required": [
              "indices_count"
            ]
          }
        ]
      },
      "xpack.usage:Security": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "api_key_service": {
                "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
              },
              "anonymous": {
                "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
              },
              "audit": {
                "$ref": "#/components/schemas/xpack.usage:Audit"
              },
              "fips_140": {
                "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
              },
              "ipfilter": {
                "$ref": "#/components/schemas/xpack.usage:IpFilter"
              },
              "realms": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/xpack.usage:Realm"
                }
              },
              "role_mapping": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/xpack.usage:RoleMapping"
                }
              },
              "roles": {
                "$ref": "#/components/schemas/xpack.usage:SecurityRoles"
              },
              "ssl": {
                "$ref": "#/components/schemas/xpack.usage:Ssl"
              },
              "system_key": {
                "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
              },
              "token_service": {
                "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
              },
              "operator_privileges": {
                "$ref": "#/components/schemas/xpack.usage:Base"
              }
            },
            "required": [
              "api_key_service",
              "anonymous",
              "audit",
              "fips_140",
              "ipfilter",
              "realms",
              "role_mapping",
              "roles",
              "ssl",
              "token_service",
              "operator_privileges"
            ]
          }
        ]
      },
      "xpack.usage:FeatureToggle": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "xpack.usage:Audit": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
          },
          {
            "type": "object",
            "properties": {
              "outputs": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            }
          }
        ]
      },
      "xpack.usage:IpFilter": {
        "type": "object",
        "properties": {
          "http": {
            "type": "boolean"
          },
          "transport": {
            "type": "boolean"
          }
        },
        "required": [
          "http",
          "transport"
        ]
      },
      "xpack.usage:Realm": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "order": {
                "type": "array",
                "items": {
                  "type": "number"
                }
              },
              "size": {
                "type": "array",
                "items": {
                  "type": "number"
                }
              },
              "cache": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/xpack.usage:RealmCache"
                }
              },
              "has_authorization_realms": {
                "type": "array",
                "items": {
                  "type": "boolean"
                }
              },
              "has_default_username_pattern": {
                "type": "array",
                "items": {
                  "type": "boolean"
                }
              },
              "has_truststore": {
                "type": "array",
                "items": {
                  "type": "boolean"
                }
              },
              "is_authentication_delegated": {
                "type": "array",
                "items": {
                  "type": "boolean"
                }
              }
            }
          }
        ]
      },
      "xpack.usage:RealmCache": {
        "type": "object",
        "properties": {
          "size": {
            "type": "number"
          }
        },
        "required": [
          "size"
        ]
      },
      "xpack.usage:RoleMapping": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "number"
          },
          "size": {
            "type": "number"
          }
        },
        "required": [
          "enabled",
          "size"
        ]
      },
      "xpack.usage:SecurityRoles": {
        "type": "object",
        "properties": {
          "native": {
            "$ref": "#/components/schemas/xpack.usage:SecurityRolesNative"
          },
          "dls": {
            "$ref": "#/components/schemas/xpack.usage:SecurityRolesDls"
          },
          "file": {
            "$ref": "#/components/schemas/xpack.usage:SecurityRolesFile"
          }
        },
        "required": [
          "native",
          "dls",
          "file"
        ]
      },
      "xpack.usage:SecurityRolesNative": {
        "type": "object",
        "properties": {
          "dls": {
            "type": "boolean"
          },
          "fls": {
            "type": "boolean"
          },
          "size": {
            "type": "number"
          }
        },
        "required": [
          "dls",
          "fls",
          "size"
        ]
      },
      "xpack.usage:SecurityRolesDls": {
        "type": "object",
        "properties": {
          "bit_set_cache": {
            "$ref": "#/components/schemas/xpack.usage:SecurityRolesDlsBitSetCache"
          }
        },
        "required": [
          "bit_set_cache"
        ]
      },
      "xpack.usage:SecurityRolesDlsBitSetCache": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_in_bytes": {
            "$ref": "#/components/schemas/_types:ulong"
          }
        },
        "required": [
          "count",
          "memory_in_bytes"
        ]
      },
      "xpack.usage:SecurityRolesFile": {
        "type": "object",
        "properties": {
          "dls": {
            "type": "boolean"
          },
          "fls": {
            "type": "boolean"
          },
          "size": {
            "type": "number"
          }
        },
        "required": [
          "dls",
          "fls",
          "size"
        ]
      },
      "xpack.usage:Ssl": {
        "type": "object",
        "properties": {
          "http": {
            "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
          },
          "transport": {
            "$ref": "#/components/schemas/xpack.usage:FeatureToggle"
          }
        },
        "required": [
          "http",
          "transport"
        ]
      },
      "xpack.usage:Slm": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "policy_count": {
                "type": "number"
              },
              "policy_stats": {
                "$ref": "#/components/schemas/slm._types:Statistics"
              }
            }
          }
        ]
      },
      "xpack.usage:Sql": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "features": {
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              },
              "queries": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/xpack.usage:Query"
                }
              }
            },
            "required": [
              "features",
              "queries"
            ]
          }
        ]
      },
      "xpack.usage:Vector": {
        "allOf": [
          {
            "$ref": "#/components/schemas/xpack.usage:Base"
          },
          {
            "type": "object",
            "properties": {
              "dense_vector_dims_avg_count": {
                "type": "number"
              },
              "dense_vector_fields_count": {
                "type": "number"
              },
              "sparse_vector_fields_count": {
                "type": "number"
              }
            },
            "required": [
              "dense_vector_dims_avg_count",
              "dense_vector_fields_count"
            ]
          }
        ]
      }
    },
    "responses": {
      "async_search.submit#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/async_search._types:AsyncSearchDocumentResponseBase"
            }
          }
        }
      },
      "bulk#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "errors": {
                  "description": "If `true`, one or more of the operations in the bulk request did not complete successfully.",
                  "type": "boolean"
                },
                "items": {
                  "description": "The result of each operation in the bulk request, in the order they were submitted.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_global.bulk:ResponseItem"
                    },
                    "minProperties": 1,
                    "maxProperties": 1
                  }
                },
                "took": {
                  "description": "The length of time, in milliseconds, it took to process the bulk request.",
                  "type": "number"
                },
                "ingest_took": {
                  "type": "number"
                }
              },
              "required": [
                "errors",
                "items",
                "took"
              ]
            }
          }
        }
      },
      "cat.aliases#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.aliases:AliasesRecord"
              }
            }
          }
        }
      },
      "cat.allocation#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.allocation:AllocationRecord"
              }
            }
          }
        }
      },
      "cat.component_templates#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.component_templates:ComponentTemplate"
              }
            }
          }
        }
      },
      "cat.count#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.count:CountRecord"
              }
            }
          }
        }
      },
      "cat.fielddata#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.fielddata:FielddataRecord"
              }
            }
          }
        }
      },
      "cat.indices#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.indices:IndicesRecord"
              }
            }
          }
        }
      },
      "cat.ml_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_data_frame_analytics:DataFrameAnalyticsRecord"
              }
            }
          }
        }
      },
      "cat.ml_datafeeds#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_datafeeds:DatafeedsRecord"
              }
            }
          }
        }
      },
      "cat.ml_jobs#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_jobs:JobsRecord"
              }
            }
          }
        }
      },
      "cat.ml_trained_models#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_trained_models:TrainedModelsRecord"
              }
            }
          }
        }
      },
      "cat.recovery#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.recovery:RecoveryRecord"
              }
            }
          }
        }
      },
      "cat.segments#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.segments:SegmentsRecord"
              }
            }
          }
        }
      },
      "cat.shards#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.shards:ShardsRecord"
              }
            }
          }
        }
      },
      "cat.snapshots#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.snapshots:SnapshotsRecord"
              }
            }
          }
        }
      },
      "cat.templates#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.templates:TemplatesRecord"
              }
            }
          }
        }
      },
      "cat.thread_pool#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.thread_pool:ThreadPoolRecord"
              }
            }
          }
        }
      },
      "cat.transforms#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.transforms:TransformsRecord"
              }
            }
          }
        }
      },
      "ccr.get_auto_follow_pattern#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "patterns": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ccr.get_auto_follow_pattern:AutoFollowPattern"
                  }
                }
              },
              "required": [
                "patterns"
              ]
            }
          }
        }
      },
      "clear_scroll#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "succeeded": {
                  "description": "If `true`, the request succeeded.\nThis does not indicate whether any scrolling search requests were cleared.",
                  "type": "boolean"
                },
                "num_freed": {
                  "description": "The number of scrolling search requests cleared.",
                  "type": "number"
                }
              },
              "required": [
                "succeeded",
                "num_freed"
              ]
            }
          }
        }
      },
      "cluster.allocation_explain#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allocate_explanation": {
                  "type": "string"
                },
                "allocation_delay": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "allocation_delay_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "can_allocate": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_move_to_other_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_rebalance_cluster": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_rebalance_cluster_decisions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.allocation_explain:AllocationDecision"
                  }
                },
                "can_rebalance_to_other_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_remain_decisions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.allocation_explain:AllocationDecision"
                  }
                },
                "can_remain_on_current_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "cluster_info": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:ClusterInfo"
                },
                "configured_delay": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "configured_delay_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "current_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:CurrentNode"
                },
                "current_state": {
                  "type": "string"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "move_explanation": {
                  "type": "string"
                },
                "node_allocation_decisions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.allocation_explain:NodeAllocationExplanation"
                  }
                },
                "primary": {
                  "type": "boolean"
                },
                "rebalance_explanation": {
                  "type": "string"
                },
                "remaining_delay": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "remaining_delay_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "shard": {
                  "type": "number"
                },
                "unassigned_info": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:UnassignedInformation"
                },
                "note": {
                  "type": "string"
                }
              },
              "required": [
                "current_state",
                "index",
                "primary",
                "shard"
              ]
            }
          }
        }
      },
      "cluster.get_component_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "component_templates": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster._types:ComponentTemplate"
                  }
                }
              },
              "required": [
                "component_templates"
              ]
            }
          }
        }
      },
      "cluster.health#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/cluster.health:HealthResponseBody"
            }
          }
        }
      },
      "cluster.put_component_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "cluster.state#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "cluster.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/cluster.stats:StatsResponseBase"
            }
          }
        }
      },
      "connector.put#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "$ref": "#/components/schemas/_types:Result"
                },
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                }
              },
              "required": [
                "result",
                "id"
              ]
            }
          }
        }
      },
      "count#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                }
              },
              "required": [
                "count",
                "_shards"
              ]
            }
          }
        }
      },
      "create#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:WriteResponseBase"
            }
          }
        }
      },
      "enrich.get_policy#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "policies": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/enrich._types:Summary"
                  }
                }
              },
              "required": [
                "policies"
              ]
            }
          }
        }
      },
      "eql.search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/eql._types:EqlSearchResponseBase"
            }
          }
        }
      },
      "explain#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "matched": {
                  "type": "boolean"
                },
                "explanation": {
                  "$ref": "#/components/schemas/_global.explain:ExplanationDetail"
                },
                "get": {
                  "$ref": "#/components/schemas/_types:InlineGet"
                }
              },
              "required": [
                "_index",
                "_id",
                "matched"
              ]
            }
          }
        }
      },
      "field_caps#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "indices": {
                  "$ref": "#/components/schemas/_types:Indices"
                },
                "fields": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_global.field_caps:FieldCapability"
                    }
                  }
                }
              },
              "required": [
                "indices",
                "fields"
              ]
            }
          }
        }
      },
      "fleet.msearch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.msearch:ResponseItem"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "fleet.search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "took": {
                  "type": "number"
                },
                "timed_out": {
                  "type": "boolean"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "hits": {
                  "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
                },
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:Aggregate"
                  }
                },
                "_clusters": {
                  "$ref": "#/components/schemas/_types:ClusterStatistics"
                },
                "fields": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "max_score": {
                  "type": "number"
                },
                "num_reduce_phases": {
                  "type": "number"
                },
                "profile": {
                  "$ref": "#/components/schemas/_global.search._types:Profile"
                },
                "pit_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollId"
                },
                "suggest": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:Suggest"
                    }
                  }
                },
                "terminated_early": {
                  "type": "boolean"
                }
              },
              "required": [
                "took",
                "timed_out",
                "_shards",
                "hits"
              ]
            }
          }
        }
      },
      "graph.explore#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/graph._types:Connection"
                  }
                },
                "failures": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:ShardFailure"
                  }
                },
                "timed_out": {
                  "type": "boolean"
                },
                "took": {
                  "type": "number"
                },
                "vertices": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/graph._types:Vertex"
                  }
                }
              },
              "required": [
                "connections",
                "failures",
                "timed_out",
                "took",
                "vertices"
              ]
            }
          }
        }
      },
      "health_report#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "cluster_name": {
                  "type": "string"
                },
                "indicators": {
                  "$ref": "#/components/schemas/_global.health_report:Indicators"
                },
                "status": {
                  "$ref": "#/components/schemas/_global.health_report:IndicatorHealthStatus"
                }
              },
              "required": [
                "cluster_name",
                "indicators"
              ]
            }
          }
        }
      },
      "ilm.get_lifecycle#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ilm.get_lifecycle:Lifecycle"
              }
            }
          }
        }
      },
      "index#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:WriteResponseBase"
            }
          }
        }
      },
      "indices.analyze#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "detail": {
                  "$ref": "#/components/schemas/indices.analyze:AnalyzeDetail"
                },
                "tokens": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.analyze:AnalyzeToken"
                  }
                }
              }
            }
          }
        }
      },
      "indices.clear_cache#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:ShardsOperationResponseBase"
            }
          }
        }
      },
      "indices.clone#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "acknowledged": {
                  "type": "boolean"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "shards_acknowledged": {
                  "type": "boolean"
                }
              },
              "required": [
                "acknowledged",
                "index",
                "shards_acknowledged"
              ]
            }
          }
        }
      },
      "indices.data_streams_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "backing_indices": {
                  "description": "Total number of backing indices for the selected data streams.",
                  "type": "number"
                },
                "data_stream_count": {
                  "description": "Total number of selected data streams.",
                  "type": "number"
                },
                "data_streams": {
                  "description": "Contains statistics for the selected data streams.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.data_streams_stats:DataStreamsStatsItem"
                  }
                },
                "total_store_sizes": {
                  "$ref": "#/components/schemas/_types:ByteSize"
                },
                "total_store_size_bytes": {
                  "description": "Total size, in bytes, of all shards for the selected data streams.",
                  "type": "number"
                }
              },
              "required": [
                "_shards",
                "backing_indices",
                "data_stream_count",
                "data_streams",
                "total_store_size_bytes"
              ]
            }
          }
        }
      },
      "indices.delete_alias#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.exists_alias#200": {
        "description": "",
        "content": {
          "application/json": {}
        }
      },
      "indices.flush#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:ShardsOperationResponseBase"
            }
          }
        }
      },
      "indices.forcemerge#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/indices.forcemerge._types:ForceMergeResponseBody"
            }
          }
        }
      },
      "indices.get_alias#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.get_alias:IndexAliases"
              }
            }
          }
        }
      },
      "indices.get_data_stream#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "data_streams": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices._types:DataStream"
                  }
                }
              },
              "required": [
                "data_streams"
              ]
            }
          }
        }
      },
      "indices.get_field_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.get_field_mapping:TypeFieldMappings"
              }
            }
          }
        }
      },
      "indices.get_index_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "index_templates": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.get_index_template:IndexTemplateItem"
                  }
                }
              },
              "required": [
                "index_templates"
              ]
            }
          }
        }
      },
      "indices.get_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.get_mapping:IndexMappingRecord"
              }
            }
          }
        }
      },
      "indices.get_settings#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices._types:IndexState"
              }
            }
          }
        }
      },
      "indices.get_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices._types:TemplateMapping"
              }
            }
          }
        }
      },
      "indices.put_alias#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.put_index_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.put_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:IndicesResponseBase"
            }
          }
        }
      },
      "indices.put_settings#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.put_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.recovery#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.recovery:RecoveryStatus"
              }
            }
          }
        }
      },
      "indices.refresh#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:ShardsOperationResponseBase"
            }
          }
        }
      },
      "indices.reload_search_analyzers#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadResult"
            }
          }
        }
      },
      "indices.rollover#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "acknowledged": {
                  "type": "boolean"
                },
                "conditions": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "boolean"
                  }
                },
                "dry_run": {
                  "type": "boolean"
                },
                "new_index": {
                  "type": "string"
                },
                "old_index": {
                  "type": "string"
                },
                "rolled_over": {
                  "type": "boolean"
                },
                "shards_acknowledged": {
                  "type": "boolean"
                }
              },
              "required": [
                "acknowledged",
                "conditions",
                "dry_run",
                "new_index",
                "old_index",
                "rolled_over",
                "shards_acknowledged"
              ]
            }
          }
        }
      },
      "indices.segments#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "indices": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices.segments:IndexSegment"
                  }
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                }
              },
              "required": [
                "indices",
                "_shards"
              ]
            }
          }
        }
      },
      "indices.shard_stores#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "indices": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices.shard_stores:IndicesShardStores"
                  }
                }
              },
              "required": [
                "indices"
              ]
            }
          }
        }
      },
      "indices.shrink#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "acknowledged": {
                  "type": "boolean"
                },
                "shards_acknowledged": {
                  "type": "boolean"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              },
              "required": [
                "acknowledged",
                "shards_acknowledged",
                "index"
              ]
            }
          }
        }
      },
      "indices.simulate_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "overlapping": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.simulate_template:Overlapping"
                  }
                },
                "template": {
                  "$ref": "#/components/schemas/indices.simulate_template:Template"
                }
              },
              "required": [
                "template"
              ]
            }
          }
        }
      },
      "indices.split#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "acknowledged": {
                  "type": "boolean"
                },
                "shards_acknowledged": {
                  "type": "boolean"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                }
              },
              "required": [
                "acknowledged",
                "shards_acknowledged",
                "index"
              ]
            }
          }
        }
      },
      "indices.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "indices": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices.stats:IndicesStats"
                  }
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "_all": {
                  "$ref": "#/components/schemas/indices.stats:IndicesStats"
                }
              },
              "required": [
                "_shards",
                "_all"
              ]
            }
          }
        }
      },
      "indices.validate_query#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "explanations": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.validate_query:IndicesValidationExplanation"
                  }
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "valid": {
                  "type": "boolean"
                },
                "error": {
                  "type": "string"
                }
              },
              "required": [
                "valid"
              ]
            }
          }
        }
      },
      "inference.delete#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/inference._types:DeleteInferenceEndpointResult"
            }
          }
        }
      },
      "inference.get#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "endpoints": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/inference._types:InferenceEndpointInfo"
                  }
                }
              },
              "required": [
                "endpoints"
              ]
            }
          }
        }
      },
      "inference.inference#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/inference._types:InferenceResult"
            }
          }
        }
      },
      "inference.put#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/inference._types:InferenceEndpointInfo"
            }
          }
        }
      },
      "inference.stream_inference#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:StreamResult"
            }
          }
        }
      },
      "inference.update#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/inference._types:InferenceEndpointInfo"
            }
          }
        }
      },
      "ingest.get_geoip_database#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "databases": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest.get_geoip_database:DatabaseConfigurationMetadata"
                  }
                }
              },
              "required": [
                "databases"
              ]
            }
          }
        }
      },
      "ingest.get_ip_location_database#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "databases": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest.get_ip_location_database:DatabaseConfigurationMetadata"
                  }
                }
              },
              "required": [
                "databases"
              ]
            }
          }
        }
      },
      "ingest.get_pipeline#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ingest._types:Pipeline"
              }
            }
          }
        }
      },
      "ingest.simulate#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest._types:SimulateDocumentResult"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "knn_search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "took": {
                  "description": "The milliseconds it took Elasticsearch to run the request.",
                  "type": "number"
                },
                "timed_out": {
                  "description": "If true, the request timed out before completion;\nreturned results may be partial or empty.",
                  "type": "boolean"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "hits": {
                  "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
                },
                "fields": {
                  "description": "The field values for the documents. These fields\nmust be specified in the request using the `fields` parameter.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "max_score": {
                  "description": "The highest returned document score. This value is null for requests\nthat do not sort by score.",
                  "type": "number"
                }
              },
              "required": [
                "took",
                "timed_out",
                "_shards",
                "hits"
              ]
            }
          }
        }
      },
      "license.post#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "acknowledge": {
                  "$ref": "#/components/schemas/license.post:Acknowledgement"
                },
                "acknowledged": {
                  "type": "boolean"
                },
                "license_status": {
                  "$ref": "#/components/schemas/license._types:LicenseStatus"
                }
              },
              "required": [
                "acknowledged",
                "license_status"
              ]
            }
          }
        }
      },
      "logstash.get_pipeline#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/logstash._types:Pipeline"
              }
            }
          }
        }
      },
      "mget#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "The response includes a docs array that contains the documents in the order specified in the request.\nThe structure of the returned documents is similar to that returned by the get API.\nIf there is a failure getting a particular document, the error is included in place of the document.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mget:ResponseItem"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "migration.deprecations#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "cluster_settings": {
                  "description": "Cluster-level deprecation warnings.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/migration.deprecations:Deprecation"
                  }
                },
                "index_settings": {
                  "description": "Index warnings are sectioned off per index and can be filtered using an index-pattern in the query.\nThis section includes warnings for the backing indices of data streams specified in the request path.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/migration.deprecations:Deprecation"
                    }
                  }
                },
                "data_streams": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/migration.deprecations:Deprecation"
                    }
                  }
                },
                "node_settings": {
                  "description": "Node-level deprecation warnings.\nSince only a subset of your nodes might incorporate these settings, it is important to read the details section for more information about which nodes are affected.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/migration.deprecations:Deprecation"
                  }
                },
                "ml_settings": {
                  "description": "Machine learning-related deprecation warnings.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/migration.deprecations:Deprecation"
                  }
                }
              },
              "required": [
                "cluster_settings",
                "index_settings",
                "data_streams",
                "node_settings",
                "ml_settings"
              ]
            }
          }
        }
      },
      "ml.delete_expired_data#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "deleted": {
                  "type": "boolean"
                }
              },
              "required": [
                "deleted"
              ]
            }
          }
        }
      },
      "ml.delete_forecast#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "ml.explain_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "field_selection": {
                  "description": "An array of objects that explain selection for each field, sorted by the field names.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsFieldSelection"
                  }
                },
                "memory_estimation": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalyticsMemoryEstimation"
                }
              },
              "required": [
                "field_selection",
                "memory_estimation"
              ]
            }
          }
        }
      },
      "ml.get_buckets#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "buckets": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:BucketSummary"
                  }
                },
                "count": {
                  "type": "number"
                }
              },
              "required": [
                "buckets",
                "count"
              ]
            }
          }
        }
      },
      "ml.get_calendars#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "calendars": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml.get_calendars:Calendar"
                  }
                },
                "count": {
                  "type": "number"
                }
              },
              "required": [
                "calendars",
                "count"
              ]
            }
          }
        }
      },
      "ml.get_categories#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "categories": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Category"
                  }
                },
                "count": {
                  "type": "number"
                }
              },
              "required": [
                "categories",
                "count"
              ]
            }
          }
        }
      },
      "ml.get_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "data_frame_analytics": {
                  "description": "An array of data frame analytics job resources, which are sorted by the id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSummary"
                  }
                }
              },
              "required": [
                "count",
                "data_frame_analytics"
              ]
            }
          }
        }
      },
      "ml.get_data_frame_analytics_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "data_frame_analytics": {
                  "description": "An array of objects that contain usage information for data frame analytics jobs, which are sorted by the id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalytics"
                  }
                }
              },
              "required": [
                "count",
                "data_frame_analytics"
              ]
            }
          }
        }
      },
      "ml.get_datafeed_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "datafeeds": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DatafeedStats"
                  }
                }
              },
              "required": [
                "count",
                "datafeeds"
              ]
            }
          }
        }
      },
      "ml.get_datafeeds#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "datafeeds": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Datafeed"
                  }
                }
              },
              "required": [
                "count",
                "datafeeds"
              ]
            }
          }
        }
      },
      "ml.get_filters#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "filters": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Filter"
                  }
                }
              },
              "required": [
                "count",
                "filters"
              ]
            }
          }
        }
      },
      "ml.get_influencers#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "influencers": {
                  "description": "Array of influencer objects",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Influencer"
                  }
                }
              },
              "required": [
                "count",
                "influencers"
              ]
            }
          }
        }
      },
      "ml.get_job_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "jobs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:JobStats"
                  }
                }
              },
              "required": [
                "count",
                "jobs"
              ]
            }
          }
        }
      },
      "ml.get_jobs#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "jobs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Job"
                  }
                }
              },
              "required": [
                "count",
                "jobs"
              ]
            }
          }
        }
      },
      "ml.get_memory_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_nodes": {
                  "$ref": "#/components/schemas/_types:NodeStatistics"
                },
                "cluster_name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "nodes": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/ml.get_memory_stats:Memory"
                  }
                }
              },
              "required": [
                "_nodes",
                "cluster_name",
                "nodes"
              ]
            }
          }
        }
      },
      "ml.get_model_snapshots#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "model_snapshots": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:ModelSnapshot"
                  }
                }
              },
              "required": [
                "count",
                "model_snapshots"
              ]
            }
          }
        }
      },
      "ml.get_overall_buckets#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "overall_buckets": {
                  "description": "Array of overall bucket objects",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:OverallBucket"
                  }
                }
              },
              "required": [
                "count",
                "overall_buckets"
              ]
            }
          }
        }
      },
      "ml.get_records#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "records": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Anomaly"
                  }
                }
              },
              "required": [
                "count",
                "records"
              ]
            }
          }
        }
      },
      "ml.get_trained_models#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "trained_model_configs": {
                  "description": "An array of trained model resources, which are sorted by the model_id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelConfig"
                  }
                }
              },
              "required": [
                "count",
                "trained_model_configs"
              ]
            }
          }
        }
      },
      "ml.get_trained_models_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "description": "The total number of trained model statistics that matched the requested ID patterns. Could be higher than the number of items in the trained_model_stats array as the size of the array is restricted by the supplied size parameter.",
                  "type": "number"
                },
                "trained_model_stats": {
                  "description": "An array of trained model statistics, which are sorted by the model_id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelStats"
                  }
                }
              },
              "required": [
                "count",
                "trained_model_stats"
              ]
            }
          }
        }
      },
      "ml.infer_trained_model#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "inference_results": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:InferenceResponseResult"
                  }
                }
              },
              "required": [
                "inference_results"
              ]
            }
          }
        }
      },
      "ml.preview_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "feature_values": {
                  "description": "An array of objects that contain feature name and value pairs. The features have been processed and indicate what will be sent to the model for training.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  }
                }
              },
              "required": [
                "feature_values"
              ]
            }
          }
        }
      },
      "ml.preview_datafeed#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          }
        }
      },
      "monitoring.bulk#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "error": {
                  "$ref": "#/components/schemas/_types:ErrorCause"
                },
                "errors": {
                  "description": "True if there is was an error",
                  "type": "boolean"
                },
                "ignored": {
                  "description": "Was collection disabled?",
                  "type": "boolean"
                },
                "took": {
                  "type": "number"
                }
              },
              "required": [
                "errors",
                "ignored",
                "took"
              ]
            }
          }
        }
      },
      "msearch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.msearch:MultiSearchResult"
            }
          }
        }
      },
      "msearch_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.msearch:MultiSearchResult"
            }
          }
        }
      },
      "mtermvectors#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mtermvectors:TermVectorsResult"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "nodes.hot_threads#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "nodes.info#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.info:ResponseBase"
            }
          }
        }
      },
      "nodes.reload_secure_settings#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.reload_secure_settings:ResponseBase"
            }
          }
        }
      },
      "nodes.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.stats:ResponseBase"
            }
          }
        }
      },
      "nodes.usage#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.usage:ResponseBase"
            }
          }
        }
      },
      "put_script#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "rank_eval#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "metric_score": {
                  "description": "The overall evaluation quality calculated by the defined metric",
                  "type": "number"
                },
                "details": {
                  "description": "The details section contains one entry for every query in the original requests section, keyed by the search request id",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricDetail"
                  }
                },
                "failures": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "metric_score",
                "details",
                "failures"
              ]
            }
          }
        }
      },
      "render_search_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "template_output": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "template_output"
              ]
            }
          }
        }
      },
      "rollup.get_jobs#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "jobs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/rollup.get_jobs:RollupJob"
                  }
                }
              },
              "required": [
                "jobs"
              ]
            }
          }
        }
      },
      "rollup.get_rollup_caps#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/rollup.get_rollup_caps:RollupCapabilities"
              }
            }
          }
        }
      },
      "rollup.rollup_search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "took": {
                  "type": "number"
                },
                "timed_out": {
                  "type": "boolean"
                },
                "terminated_early": {
                  "type": "boolean"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "hits": {
                  "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
                },
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:Aggregate"
                  }
                }
              },
              "required": [
                "took",
                "timed_out",
                "_shards",
                "hits"
              ]
            }
          }
        }
      },
      "scripts_painless_execute#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "type": "object"
                }
              },
              "required": [
                "result"
              ]
            }
          }
        }
      },
      "scroll#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.search:ResponseBody"
            }
          }
        }
      },
      "search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.search:ResponseBody"
            }
          }
        }
      },
      "search_application.get_behavioral_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/search_application._types:AnalyticsCollection"
              }
            }
          }
        }
      },
      "search_application.search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.search:ResponseBody"
            }
          }
        }
      },
      "search_mvt#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:MapboxVectorTiles"
            }
          }
        }
      },
      "search_shards#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "nodes": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_global.search_shards:SearchShardsNodeAttributes"
                  }
                },
                "shards": {
                  "type": "array",
                  "items": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:NodeShard"
                    }
                  }
                },
                "indices": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_global.search_shards:ShardStoreIndex"
                  }
                }
              },
              "required": [
                "nodes",
                "shards",
                "indices"
              ]
            }
          }
        }
      },
      "search_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "took": {
                  "type": "number"
                },
                "timed_out": {
                  "type": "boolean"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "hits": {
                  "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
                },
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:Aggregate"
                  }
                },
                "_clusters": {
                  "$ref": "#/components/schemas/_types:ClusterStatistics"
                },
                "fields": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "max_score": {
                  "type": "number"
                },
                "num_reduce_phases": {
                  "type": "number"
                },
                "profile": {
                  "$ref": "#/components/schemas/_global.search._types:Profile"
                },
                "pit_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollId"
                },
                "suggest": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:Suggest"
                    }
                  }
                },
                "terminated_early": {
                  "type": "boolean"
                }
              },
              "required": [
                "took",
                "timed_out",
                "_shards",
                "hits"
              ]
            }
          }
        }
      },
      "searchable_snapshots.cache_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "nodes": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/searchable_snapshots.cache_stats:Node"
                  }
                }
              },
              "required": [
                "nodes"
              ]
            }
          }
        }
      },
      "searchable_snapshots.clear_cache#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "searchable_snapshots.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "stats": {
                  "type": "object"
                },
                "total": {
                  "type": "object"
                }
              },
              "required": [
                "stats",
                "total"
              ]
            }
          }
        }
      },
      "security.change_password#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "security.create_api_key#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "api_key": {
                  "description": "Generated API key.",
                  "type": "string"
                },
                "expiration": {
                  "description": "Expiration in milliseconds for the API key.",
                  "type": "number"
                },
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "encoded": {
                  "description": "API key credentials which is the base64-encoding of\nthe UTF-8 representation of `id` and `api_key` joined\nby a colon (`:`).",
                  "type": "string"
                }
              },
              "required": [
                "api_key",
                "id",
                "name",
                "encoded"
              ]
            }
          }
        }
      },
      "security.create_service_token#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "created": {
                  "type": "boolean"
                },
                "token": {
                  "$ref": "#/components/schemas/security.create_service_token:Token"
                }
              },
              "required": [
                "created",
                "token"
              ]
            }
          }
        }
      },
      "security.disable_user#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "security.disable_user_profile#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "security.enable_user#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "security.enable_user_profile#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "security.get_privileges#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security.put_privileges:Actions"
                }
              }
            }
          }
        }
      },
      "security.get_role#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security.get_role:Role"
              }
            }
          }
        }
      },
      "security.get_role_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security._types:RoleMapping"
              }
            }
          }
        }
      },
      "security.get_service_accounts#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security.get_service_accounts:RoleDescriptorWrapper"
              }
            }
          }
        }
      },
      "security.get_user#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security._types:User"
              }
            }
          }
        }
      },
      "security.has_privileges#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "application": {
                  "$ref": "#/components/schemas/security.has_privileges:ApplicationsPrivileges"
                },
                "cluster": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "boolean"
                  }
                },
                "has_all_requested": {
                  "type": "boolean"
                },
                "index": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security.has_privileges:Privileges"
                  }
                },
                "username": {
                  "$ref": "#/components/schemas/_types:Username"
                }
              },
              "required": [
                "application",
                "cluster",
                "has_all_requested",
                "index",
                "username"
              ]
            }
          }
        }
      },
      "security.has_privileges_user_profile#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "has_privilege_uids": {
                  "description": "The subset of the requested profile IDs of the users that\nhave all the requested privileges.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfileId"
                  }
                },
                "errors": {
                  "$ref": "#/components/schemas/security.has_privileges_user_profile:HasPrivilegesUserProfileErrors"
                }
              },
              "required": [
                "has_privilege_uids"
              ]
            }
          }
        }
      },
      "security.put_privileges#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security._types:CreatedStatus"
                }
              }
            }
          }
        }
      },
      "security.put_role#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "role": {
                  "$ref": "#/components/schemas/security._types:CreatedStatus"
                }
              },
              "required": [
                "role"
              ]
            }
          }
        }
      },
      "security.put_role_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "created": {
                  "type": "boolean"
                },
                "role_mapping": {
                  "$ref": "#/components/schemas/security._types:CreatedStatus"
                }
              },
              "required": [
                "role_mapping"
              ]
            }
          }
        }
      },
      "security.put_user#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "created": {
                  "description": "A successful call returns a JSON structure that shows whether the user has been created or updated.\nWhen an existing user is updated, `created` is set to `false`.",
                  "type": "boolean"
                }
              },
              "required": [
                "created"
              ]
            }
          }
        }
      },
      "security.query_api_keys#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "description": "The total number of API keys found.",
                  "type": "number"
                },
                "count": {
                  "description": "The number of API keys returned in the response.",
                  "type": "number"
                },
                "api_keys": {
                  "description": "A list of API key information.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ApiKey"
                  }
                },
                "aggregations": {
                  "description": "The aggregations result, if requested.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security.query_api_keys:ApiKeyAggregate"
                  }
                }
              },
              "required": [
                "total",
                "count",
                "api_keys"
              ]
            }
          }
        }
      },
      "security.query_role#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "description": "The total number of roles found.",
                  "type": "number"
                },
                "count": {
                  "description": "The number of roles returned in the response.",
                  "type": "number"
                },
                "roles": {
                  "description": "A list of roles that match the query.\nThe returned role format is an extension of the role definition format.\nIt adds the `transient_metadata.enabled` and the `_sort` fields.\n`transient_metadata.enabled` is set to `false` in case the role is automatically disabled, for example when the role grants privileges that are not allowed by the installed license.\n`_sort` is present when the search query sorts on some field.\nIt contains the array of values that have been used for sorting.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security.query_role:QueryRole"
                  }
                }
              },
              "required": [
                "total",
                "count",
                "roles"
              ]
            }
          }
        }
      },
      "security.query_user#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "description": "The total number of users found.",
                  "type": "number"
                },
                "count": {
                  "description": "The number of users returned in the response.",
                  "type": "number"
                },
                "users": {
                  "description": "A list of users that match the query.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security.query_user:QueryUser"
                  }
                }
              },
              "required": [
                "total",
                "count",
                "users"
              ]
            }
          }
        }
      },
      "security.suggest_user_profiles#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "$ref": "#/components/schemas/security.suggest_user_profiles:TotalUserProfiles"
                },
                "took": {
                  "description": "The number of milliseconds it took Elasticsearch to run the request.",
                  "type": "number"
                },
                "profiles": {
                  "description": "A list of profile documents, ordered by relevance, that match the search criteria.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfile"
                  }
                }
              },
              "required": [
                "total",
                "took",
                "profiles"
              ]
            }
          }
        }
      },
      "security.update_user_profile_data#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "shutdown.get_node#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "nodes": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/shutdown.get_node:NodeShutdownStatus"
                  }
                }
              },
              "required": [
                "nodes"
              ]
            }
          }
        }
      },
      "simulate.ingest#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/simulate.ingest:SimulateIngestDocumentResult"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "slm.get_lifecycle#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/slm._types:SnapshotLifecycle"
              }
            }
          }
        }
      },
      "snapshot.create#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "accepted": {
                  "description": "Equals `true` if the snapshot was accepted. Present when the request had `wait_for_completion` set to `false`",
                  "type": "boolean"
                },
                "snapshot": {
                  "$ref": "#/components/schemas/snapshot._types:SnapshotInfo"
                }
              }
            }
          }
        }
      },
      "snapshot.create_repository#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "snapshot.get_repository#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/snapshot._types:Repository"
              }
            }
          }
        }
      },
      "snapshot.status#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "snapshots": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/snapshot._types:Status"
                  }
                }
              },
              "required": [
                "snapshots"
              ]
            }
          }
        }
      },
      "sql.query#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "columns": {
                  "description": "Column headings for the search results. Each object is a column.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/sql:Column"
                  }
                },
                "cursor": {
                  "description": "The cursor for the next set of paginated results.\nFor CSV, TSV, and TXT responses, this value is returned in the `Cursor` HTTP header.",
                  "type": "string"
                },
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "is_running": {
                  "description": "If `true`, the search is still running.\nIf `false`, the search has finished.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.",
                  "type": "boolean"
                },
                "is_partial": {
                  "description": "If `true`, the response does not contain complete search results.\nIf `is_partial` is `true` and `is_running` is `true`, the search is still running.\nIf `is_partial` is `true` but `is_running` is `false`, the results are partial due to a failure or timeout.\nThis value is returned only for async and saved synchronous searches.\nFor CSV, TSV, and TXT responses, this value is returned in the `Async-partial` HTTP header.",
                  "type": "boolean"
                },
                "rows": {
                  "description": "The values for the search results.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/sql:Row"
                  }
                }
              },
              "required": [
                "rows"
              ]
            }
          }
        }
      },
      "sql.translate#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "size": {
                  "type": "number"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                }
              }
            }
          }
        }
      },
      "tasks.cancel#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/tasks._types:TaskListResponseBase"
            }
          }
        }
      },
      "terms_enum#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "terms": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "complete": {
                  "description": "If `false`, the returned terms set may be incomplete and should be treated as approximate.\nThis can occur due to a few reasons, such as a request timeout or a node error.",
                  "type": "boolean"
                }
              },
              "required": [
                "_shards",
                "terms",
                "complete"
              ]
            }
          }
        }
      },
      "termvectors#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "found": {
                  "type": "boolean"
                },
                "_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "term_vectors": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_global.termvectors:TermVector"
                  }
                },
                "took": {
                  "type": "number"
                },
                "_version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                }
              },
              "required": [
                "found",
                "_index",
                "took",
                "_version"
              ]
            }
          }
        }
      },
      "text_structure.find_message_structure#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "charset": {
                  "type": "string"
                },
                "ecs_compatibility": {
                  "$ref": "#/components/schemas/text_structure._types:EcsCompatibilityType"
                },
                "field_stats": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/text_structure._types:FieldStat"
                  }
                },
                "format": {
                  "$ref": "#/components/schemas/text_structure._types:FormatType"
                },
                "grok_pattern": {
                  "$ref": "#/components/schemas/_types:GrokPattern"
                },
                "java_timestamp_formats": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "joda_timestamp_formats": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "ingest_pipeline": {
                  "$ref": "#/components/schemas/ingest._types:PipelineConfig"
                },
                "mappings": {
                  "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                },
                "multiline_start_pattern": {
                  "type": "string"
                },
                "need_client_timezone": {
                  "type": "boolean"
                },
                "num_lines_analyzed": {
                  "type": "number"
                },
                "num_messages_analyzed": {
                  "type": "number"
                },
                "sample_start": {
                  "type": "string"
                },
                "timestamp_field": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "required": [
                "charset",
                "field_stats",
                "format",
                "ingest_pipeline",
                "mappings",
                "need_client_timezone",
                "num_lines_analyzed",
                "num_messages_analyzed",
                "sample_start"
              ]
            }
          }
        }
      },
      "text_structure.test_grok_pattern#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "matches": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/text_structure.test_grok_pattern:MatchedText"
                  }
                }
              },
              "required": [
                "matches"
              ]
            }
          }
        }
      },
      "transform.get_transform#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "transforms": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/transform.get_transform:TransformSummary"
                  }
                }
              },
              "required": [
                "count",
                "transforms"
              ]
            }
          }
        }
      },
      "transform.preview_transform#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "generated_dest_index": {
                  "$ref": "#/components/schemas/indices._types:IndexState"
                },
                "preview": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "generated_dest_index",
                "preview"
              ]
            }
          }
        }
      },
      "watcher.ack_watch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "status": {
                  "$ref": "#/components/schemas/watcher._types:WatchStatus"
                }
              },
              "required": [
                "status"
              ]
            }
          }
        }
      },
      "watcher.activate_watch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "status": {
                  "$ref": "#/components/schemas/watcher._types:ActivationStatus"
                }
              },
              "required": [
                "status"
              ]
            }
          }
        }
      },
      "watcher.deactivate_watch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "status": {
                  "$ref": "#/components/schemas/watcher._types:ActivationStatus"
                }
              },
              "required": [
                "status"
              ]
            }
          }
        }
      },
      "watcher.execute_watch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "watch_record": {
                  "$ref": "#/components/schemas/watcher.execute_watch:WatchRecord"
                }
              },
              "required": [
                "_id",
                "watch_record"
              ]
            }
          }
        }
      },
      "watcher.put_watch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "created": {
                  "type": "boolean"
                },
                "_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_primary_term": {
                  "type": "number"
                },
                "_seq_no": {
                  "$ref": "#/components/schemas/_types:SequenceNumber"
                },
                "_version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                }
              },
              "required": [
                "created",
                "_id",
                "_primary_term",
                "_seq_no",
                "_version"
              ]
            }
          }
        }
      },
      "watcher.query_watches#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "description": "The total number of watches found.",
                  "type": "number"
                },
                "watches": {
                  "description": "A list of watches based on the `from`, `size`, or `search_after` request body parameters.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/watcher._types:QueryWatch"
                  }
                }
              },
              "required": [
                "count",
                "watches"
              ]
            }
          }
        }
      },
      "watcher.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_nodes": {
                  "$ref": "#/components/schemas/_types:NodeStatistics"
                },
                "cluster_name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "manually_stopped": {
                  "type": "boolean"
                },
                "stats": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/watcher.stats:WatcherNodeStats"
                  }
                }
              },
              "required": [
                "_nodes",
                "cluster_name",
                "manually_stopped",
                "stats"
              ]
            }
          }
        }
      }
    },
    "parameters": {
      "async_search.submit#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "async_search.submit#wait_for_completion_timeout": {
        "in": "query",
        "name": "wait_for_completion_timeout",
        "description": "Blocks and waits until the search is completed up to a certain timeout.\nWhen the async search completes within the timeout, the response wonâ€™t include the ID as the results are not stored in the cluster.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#keep_alive": {
        "in": "query",
        "name": "keep_alive",
        "description": "Specifies how long the async search needs to be available.\nOngoing async searches and any saved search results are deleted after this period.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#keep_on_completion": {
        "in": "query",
        "name": "keep_on_completion",
        "description": "If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "Indicate if an error should be returned if there is a partial search failure or timeout",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "The analyzer to use for the query string",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "Specify whether wildcard and prefix queries should be analyzed (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#batched_reduce_size": {
        "in": "query",
        "name": "batched_reduce_size",
        "description": "Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "The default value is the only supported value.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query (AND or OR)",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "async_search.submit#df": {
        "in": "query",
        "name": "df",
        "description": "The field to use as default where no field prefix is given in the query string",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#docvalue_fields": {
        "in": "query",
        "name": "docvalue_fields",
        "description": "A comma-separated list of fields to return as the docvalue representation of a field for each hit",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "async_search.submit#explain": {
        "in": "query",
        "name": "explain",
        "description": "Specify whether to return detailed information about score computation as part of a hit",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "Whether specified concrete, expanded or aliased indices should be ignored when throttled",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "Specify whether format-based query failures (such as providing text to a numeric field) should be ignored",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#min_compatible_shard_node": {
        "in": "query",
        "name": "min_compatible_shard_node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionString"
        },
        "style": "form"
      },
      "async_search.submit#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specify the node or shard the operation should be performed on (default: random)",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#request_cache": {
        "in": "query",
        "name": "request_cache",
        "description": "Specify if request cache should be used for this request or not, defaults to true",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#routing": {
        "in": "query",
        "name": "routing",
        "description": "A comma-separated list of specific routing values",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "async_search.submit#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Search operation type",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "async_search.submit#stats": {
        "in": "query",
        "name": "stats",
        "description": "Specific 'tag' of the request for logging and statistical purposes",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "async_search.submit#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "A comma-separated list of stored fields to return as part of a hit",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#suggest_field": {
        "in": "query",
        "name": "suggest_field",
        "description": "Specifies which field to use for suggestions.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "async_search.submit#suggest_mode": {
        "in": "query",
        "name": "suggest_mode",
        "description": "Specify suggest mode",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SuggestMode"
        },
        "style": "form"
      },
      "async_search.submit#suggest_size": {
        "in": "query",
        "name": "suggest_size",
        "description": "How many suggestions to return in response",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#suggest_text": {
        "in": "query",
        "name": "suggest_text",
        "description": "The source text for which the suggestions should be returned.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "description": "The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Explicit operation timeout",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#track_total_hits": {
        "in": "query",
        "name": "track_total_hits",
        "description": "Indicate if the number of documents that match the query should be tracked. A number can also be specified, to accurately track the total hit count up to the number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:TrackHits"
        },
        "style": "form"
      },
      "async_search.submit#track_scores": {
        "in": "query",
        "name": "track_scores",
        "description": "Whether to calculate and return scores even if they are not used for sorting",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specify whether aggregation and suggester names should be prefixed by their respective types in the response",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "Indicates whether hits.total should be rendered as an integer or an object in the rest search response",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#version": {
        "in": "query",
        "name": "version",
        "description": "Specify whether to return document version as part of a hit",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#_source": {
        "in": "query",
        "name": "_source",
        "description": "True or false to return the _source field or not, or a list of fields to return",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "async_search.submit#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A list of fields to exclude from the returned _source field",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A list of fields to extract and return from the _source field",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#seq_no_primary_term": {
        "in": "query",
        "name": "seq_no_primary_term",
        "description": "Specify whether to return sequence number and primary term of the last modification of each hit",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#q": {
        "in": "query",
        "name": "q",
        "description": "Query in the Lucene query string syntax",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#size": {
        "in": "query",
        "name": "size",
        "description": "Number of hits to return (default: 10)",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#from": {
        "in": "query",
        "name": "from",
        "description": "Starting offset (default: 0)",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#sort": {
        "in": "query",
        "name": "sort",
        "description": "A comma-separated list of <field>:<direction> pairs",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "bulk#index": {
        "in": "path",
        "name": "index",
        "description": "The name of the data stream, index, or index alias to perform bulk actions on.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "bulk#list_executed_pipelines": {
        "in": "query",
        "name": "list_executed_pipelines",
        "description": "If `true`, the response will include the ingest pipelines that were run for each index or create.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "bulk#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "The pipeline identifier to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "bulk#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.\nIf `wait_for`, wait for a refresh to make this operation visible to search.\nIf `false`, do nothing with refreshes.\nValid values: `true`, `false`, `wait_for`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "bulk#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value that is used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "bulk#_source": {
        "in": "query",
        "name": "_source",
        "description": "Indicates whether to return the `_source` field (`true` or `false`) or contains a list of fields to return.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "bulk#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "bulk#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned.\nYou can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "bulk#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The period each action waits for the following operations: automatic index creation, dynamic mapping updates, and waiting for active shards.\nThe default is `1m` (one minute), which guarantees Elasticsearch waits for at least the timeout before failing.\nThe actual wait time could be longer, particularly when multiple waits occur.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "bulk#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe default is `1`, which waits for each primary shard to be active.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "bulk#require_alias": {
        "in": "query",
        "name": "require_alias",
        "description": "If `true`, the request's actions must target an index alias.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "bulk#require_data_stream": {
        "in": "query",
        "name": "require_data_stream",
        "description": "If `true`, the request's actions must target a data stream (existing or to be created).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.aliases#name": {
        "in": "path",
        "name": "name",
        "description": "A comma-separated list of aliases to retrieve. Supports wildcards (`*`).  To retrieve all aliases, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "cat.aliases#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nIt supports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cat.aliases#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.aliases#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "The period to wait for a connection to the master node.\nIf the master node is not available before the timeout expires, the request fails and returns an error.\nTo indicated that the request should never timeout, you can set it to `-1`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.allocation#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "A comma-separated list of node identifiers or names used to limit the returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "cat.allocation#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.allocation#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.allocation#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.component_templates#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the component template.\nIt accepts wildcard expressions.\nIf it is omitted, all component templates are returned.",
        "required": true,
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "simple"
      },
      "cat.component_templates#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.component_templates#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "The period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.count#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request.\nIt supports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.fielddata#fields": {
        "in": "path",
        "name": "fields",
        "description": "Comma-separated list of fields used to limit returned information.\nTo retrieve all fields, omit this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "simple"
      },
      "cat.fielddata#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.fielddata#fields_": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list of fields used to limit returned information.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "cat.indices#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`). To target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.indices#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.indices#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cat.indices#health": {
        "in": "query",
        "name": "health",
        "description": "The health status used to limit returned indices. By default, the response includes indices of any health status.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:HealthStatus"
        },
        "style": "form"
      },
      "cat.indices#include_unloaded_segments": {
        "in": "query",
        "name": "include_unloaded_segments",
        "description": "If true, the response includes information from segments that are not loaded into memory.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.indices#pri": {
        "in": "query",
        "name": "pri",
        "description": "If true, the response only includes information from primary shards.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.indices#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.indices#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "The ID of the data frame analytics to fetch",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_data_frame_analytics#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Whether to ignore if a wildcard expression matches no configs. (This includes `_all` string or when no configs have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit in which to display byte values",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDfaColumns"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the\nresponse.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDfaColumns"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#time": {
        "in": "query",
        "name": "time",
        "description": "Unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "A numerical character string that uniquely identifies the datafeed.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_datafeeds#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDatafeedColumns"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDatafeedColumns"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.ml_jobs#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_jobs#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no jobs that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty jobs array when there are no matches and the subset of results when there\nare partial matches. If `false`, the API returns a 404 status code when there are no matches or only partial\nmatches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_jobs#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.ml_jobs#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatAnonalyDetectorColumns"
        },
        "style": "form"
      },
      "cat.ml_jobs#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatAnonalyDetectorColumns"
        },
        "style": "form"
      },
      "cat.ml_jobs#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.ml_trained_models#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "A unique identifier for the trained model.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_trained_models#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request: contains wildcard expressions and there are no models that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, the API returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the API returns a 404 status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_trained_models#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.ml_trained_models#h": {
        "in": "query",
        "name": "h",
        "description": "A comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumns"
        },
        "style": "form"
      },
      "cat.ml_trained_models#s": {
        "in": "query",
        "name": "s",
        "description": "A comma-separated list of column names or aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumns"
        },
        "style": "form"
      },
      "cat.ml_trained_models#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of transforms.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "cat.ml_trained_models#size": {
        "in": "query",
        "name": "size",
        "description": "The maximum number of transforms to display.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "cat.ml_trained_models#time": {
        "in": "query",
        "name": "time",
        "description": "Unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.recovery#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`). To target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.recovery#active_only": {
        "in": "query",
        "name": "active_only",
        "description": "If `true`, the response only includes ongoing shard recoveries.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.recovery#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.recovery#detailed": {
        "in": "query",
        "name": "detailed",
        "description": "If `true`, the response includes detailed information about shard recoveries.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.recovery#time": {
        "in": "query",
        "name": "time",
        "description": "Unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.segments#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.segments#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.segments#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.segments#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.shards#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.shards#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.shards#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.shards#time": {
        "in": "query",
        "name": "time",
        "description": "Unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.snapshots#repository": {
        "in": "path",
        "name": "repository",
        "description": "A comma-separated list of snapshot repositories used to limit the request.\nAccepts wildcard expressions.\n`_all` returns all repositories.\nIf any repository fails during the request, Elasticsearch returns an error.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "cat.snapshots#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, the response does not include information from unavailable snapshots.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.snapshots#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.snapshots#time": {
        "in": "query",
        "name": "time",
        "description": "Unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.templates#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the template to return.\nAccepts wildcard expressions. If omitted, all templates are returned.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "cat.templates#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.templates#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.thread_pool#thread_pool_patterns": {
        "in": "path",
        "name": "thread_pool_patterns",
        "description": "A comma-separated list of thread pool names used to limit the request.\nAccepts wildcard expressions.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "cat.thread_pool#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.thread_pool#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request computes the list of selected nodes from the\nlocal cluster state. If `false` the list of selected nodes are computed\nfrom the cluster state of the master node. In both cases the coordinating\nnode will send requests for further information to each selected node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.thread_pool#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.transforms#transform_id": {
        "in": "path",
        "name": "transform_id",
        "description": "A transform identifier or a wildcard expression.\nIf you do not specify one of these options, the API returns information for all transforms.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.transforms#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request: contains wildcard expressions and there are no transforms that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, it returns an empty transforms array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.transforms#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of transforms.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "cat.transforms#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTransformColumns"
        },
        "style": "form"
      },
      "cat.transforms#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTransformColumns"
        },
        "style": "form"
      },
      "cat.transforms#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.transforms#size": {
        "in": "query",
        "name": "size",
        "description": "The maximum number of transforms to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ccr.get_auto_follow_pattern#name": {
        "in": "path",
        "name": "name",
        "description": "Specifies the auto-follow pattern collection that you want to retrieve. If you do not specify a name, the API returns information for all collections.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "clear_scroll#scroll_id": {
        "in": "path",
        "name": "scroll_id",
        "description": "A comma-separated list of scroll IDs to clear.\nTo clear all scroll IDs, use `_all`.\nIMPORTANT: Scroll IDs can be long. It is recommended to specify scroll IDs in the request body parameter.",
        "required": true,
        "deprecated": true,
        "schema": {
          "$ref": "#/components/schemas/_types:ScrollIds"
        },
        "style": "simple"
      },
      "cluster.allocation_explain#include_disk_info": {
        "in": "query",
        "name": "include_disk_info",
        "description": "If true, returns information about disk usage and shard sizes.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.allocation_explain#include_yes_decisions": {
        "in": "query",
        "name": "include_yes_decisions",
        "description": "If true, returns YES decisions in explanation.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of component template names used to limit the request.\nWildcard (`*`) expressions are supported.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "cluster.get_component_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "Return all default configurations for the component template (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.health#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and index aliases used to limit the request. Wildcard expressions (`*`) are supported. To target all data streams and indices in a cluster, omit this parameter or use _all or `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cluster.health#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cluster.health#level": {
        "in": "query",
        "name": "level",
        "description": "Can be one of cluster, indices or shards. Controls the details level of the health information returned.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Level"
        },
        "style": "form"
      },
      "cluster.health#local": {
        "in": "query",
        "name": "local",
        "description": "If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.health#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.health#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.health#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "A number controlling to how many active shards to wait for, all to wait for all shards in the cluster to be active, or 0 to not wait.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "cluster.health#wait_for_events": {
        "in": "query",
        "name": "wait_for_events",
        "description": "Can be one of immediate, urgent, high, normal, low, languid. Wait until all currently queued events with the given priority are processed.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForEvents"
        },
        "style": "form"
      },
      "cluster.health#wait_for_nodes": {
        "in": "query",
        "name": "wait_for_nodes",
        "description": "The request waits until the specified number N of nodes is available. It also accepts >=N, <=N, >N and <N. Alternatively, it is possible to use ge(N), le(N), gt(N) and lt(N) notation.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            }
          ]
        },
        "style": "form"
      },
      "cluster.health#wait_for_no_initializing_shards": {
        "in": "query",
        "name": "wait_for_no_initializing_shards",
        "description": "A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard initializations. Defaults to false, which means it will not wait for initializing shards.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.health#wait_for_no_relocating_shards": {
        "in": "query",
        "name": "wait_for_no_relocating_shards",
        "description": "A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard relocations. Defaults to false, which means it will not wait for relocating shards.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.health#wait_for_status": {
        "in": "query",
        "name": "wait_for_status",
        "description": "One of green, yellow or red. Will wait (until the timeout provided) until the status of the cluster changes to the one provided or better, i.e. green > yellow > red. By default, will not wait for any status.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:HealthStatus"
        },
        "style": "form"
      },
      "cluster.put_component_template#name": {
        "in": "path",
        "name": "name",
        "description": "Name of the component template to create.\nElasticsearch includes the following built-in component templates: `logs-mappings`; `logs-settings`; `metrics-mappings`; `metrics-settings`;`synthetics-mapping`; `synthetics-settings`.\nElastic Agent uses these templates to configure backing indices for its data streams.\nIf you use Elastic Agent and want to overwrite one of these templates, set the `version` for your replacement template higher than the current version.\nIf you donâ€™t use Elastic Agent and want to disable all built-in component and index templates, set `stack.templates.enabled` to `false` using the cluster update settings API.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "cluster.put_component_template#create": {
        "in": "query",
        "name": "create",
        "description": "If `true`, this request cannot replace or update existing component templates.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.put_component_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.state#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limit the information returned to the specified metrics",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "cluster.state#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cluster.state#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cluster.state#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "Return settings in flat format (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#local": {
        "in": "query",
        "name": "local",
        "description": "Return local information, do not retrieve the state from master node (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Specify timeout for connection to master",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.state#wait_for_metadata_version": {
        "in": "query",
        "name": "wait_for_metadata_version",
        "description": "Wait for the metadata version to be equal or greater than the specified metadata version",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "cluster.state#wait_for_timeout": {
        "in": "query",
        "name": "wait_for_timeout",
        "description": "The maximum time to wait for wait_for_metadata_version before timing out",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node filters used to limit returned information. Defaults to all nodes in the cluster.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "cluster.stats#include_remotes": {
        "in": "query",
        "name": "include_remotes",
        "description": "Include remote cluster data into the response",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.stats#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for each node to respond.\nIf a node does not respond before its timeout expires, the response does not include its stats.\nHowever, timed out nodes are included in the responseâ€™s `_nodes.failed` property. Defaults to no timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "connector.put#connector_id": {
        "in": "path",
        "name": "connector_id",
        "description": "The unique identifier of the connector to be created or updated. ID is auto-generated if not provided.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "count#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "count#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "count#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query: `AND` or `OR`.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "count#df": {
        "in": "query",
        "name": "df",
        "description": "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "count#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nIt supports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "count#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If `true`, concrete, expanded, or aliased indices are ignored when frozen.",
        "deprecated": true,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#min_score": {
        "in": "query",
        "name": "min_score",
        "description": "The minimum `_score` value that documents must have to be included in the result.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "count#preference": {
        "in": "query",
        "name": "preference",
        "description": "The node or shard the operation should be performed on.\nBy default, it is random.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "count#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "count#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "description": "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "count#q": {
        "in": "query",
        "name": "q",
        "description": "The query in Lucene query string syntax. This parameter cannot be used with a request body.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "create#id": {
        "in": "path",
        "name": "id",
        "description": "A unique identifier for the document.\nTo automatically generate a document ID, use the `POST /<target>/_doc/` request format.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "create#index": {
        "in": "path",
        "name": "index",
        "description": "The name of the data stream or index to target.\nIf the target doesn't exist and matches the name or wildcard (`*`) pattern of an index template with a `data_stream` definition, this request creates the data stream.\nIf the target doesn't exist and doesnâ€™t match a data stream template, this request creates the index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "create#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, setting the value to `_none` turns off the default ingest pipeline for this request.\nIf a final pipeline is configured, it will always run regardless of the value of this parameter.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "create#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.\nIf `wait_for`, it waits for a refresh to make this operation visible to search.\nIf `false`, it does nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "create#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value that is used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "create#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.\nElasticsearch waits for at least the specified timeout period before failing.\nThe actual wait time could be longer, particularly when multiple waits occur.\n\nThis parameter is useful for situations where the primary shard assigned to perform the operation might not be available when the operation runs.\nSome reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation.\nBy default, the operation will wait on the primary shard to become available for at least 1 minute before failing and responding with an error.\nThe actual wait time could be longer, particularly when multiple waits occur.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "create#version": {
        "in": "query",
        "name": "version",
        "description": "The explicit version number for concurrency control.\nIt must be a non-negative long number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "create#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "The version type.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "create#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nYou can set it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe default value of `1` means it waits for each primary shard to be active.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "enrich.get_policy#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of enrich policy names used to limit the request.\nTo return information for all enrich policies, omit this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "eql.search#index": {
        "in": "path",
        "name": "index",
        "description": "The name of the index to scope the operation",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "eql.search#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "eql.search#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "eql.search#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If true, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "eql.search#keep_alive": {
        "in": "query",
        "name": "keep_alive",
        "description": "Period for which the search and its results are stored on the cluster.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "eql.search#keep_on_completion": {
        "in": "query",
        "name": "keep_on_completion",
        "description": "If true, the search and its results are stored on the cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "eql.search#wait_for_completion_timeout": {
        "in": "query",
        "name": "wait_for_completion_timeout",
        "description": "Timeout duration to wait for the request to finish. Defaults to no timeout, meaning the request waits for complete search results.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "explain#id": {
        "in": "path",
        "name": "id",
        "description": "The document identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "explain#index": {
        "in": "path",
        "name": "index",
        "description": "Index names that are used to limit the request.\nOnly a single index name can be provided to this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "explain#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "explain#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "explain#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query: `AND` or `OR`.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "explain#df": {
        "in": "query",
        "name": "df",
        "description": "The field to use as default where no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "explain#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "explain#preference": {
        "in": "query",
        "name": "preference",
        "description": "The node or shard the operation should be performed on.\nIt is random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "explain#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "explain#_source": {
        "in": "query",
        "name": "_source",
        "description": "`True` or `false` to return the `_source` field or not or a list of fields to return.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "explain#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "explain#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned.\nYou can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "explain#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "A comma-separated list of stored fields to return in the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "explain#q": {
        "in": "query",
        "name": "q",
        "description": "The query in the Lucene query string syntax.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "field_caps#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request. Supports wildcards (*). To target all data streams and indices, omit this parameter or use * or _all.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "field_caps#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "field_caps#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "field_caps#fields": {
        "in": "query",
        "name": "fields",
        "description": "A comma-separated list of fields to retrieve capabilities for. Wildcard (`*`) expressions are supported.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "field_caps#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "field_caps#include_unmapped": {
        "in": "query",
        "name": "include_unmapped",
        "description": "If true, unmapped fields are included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "field_caps#filters": {
        "in": "query",
        "name": "filters",
        "description": "A comma-separated list of filters to apply to the response.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "field_caps#types": {
        "in": "query",
        "name": "types",
        "description": "A comma-separated list of field types to include.\nAny fields that do not match one of these types will be excluded from the results.\nIt defaults to empty, meaning that all field types are returned.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "field_caps#include_empty_fields": {
        "in": "query",
        "name": "include_empty_fields",
        "description": "If false, empty fields are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#index": {
        "in": "path",
        "name": "index",
        "description": "A single target to search. If the target is an index alias, it must resolve to a single index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            {
              "$ref": "#/components/schemas/_types:IndexAlias"
            }
          ]
        },
        "style": "simple"
      },
      "fleet.msearch#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "fleet.msearch#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If true, concrete, expanded or aliased indices are ignored when frozen.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If true, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#max_concurrent_searches": {
        "in": "query",
        "name": "max_concurrent_searches",
        "description": "Maximum number of concurrent searches the multi search API can execute.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.msearch#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "Maximum number of concurrent shard requests that each sub-search request executes per node.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.msearch#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.msearch#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Indicates whether global term and document frequencies should be used when scoring returned documents.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "fleet.msearch#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#wait_for_checkpoints": {
        "in": "query",
        "name": "wait_for_checkpoints",
        "description": "A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/fleet._types:Checkpoint"
          }
        },
        "style": "form"
      },
      "fleet.msearch#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "If true, returns partial results if there are shard request timeouts or [shard failures](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#shard-failures). If false, returns\nan error with no partial results. Defaults to the configured cluster setting `search.default_allow_partial_results`\nwhich is true by default.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#index": {
        "in": "path",
        "name": "index",
        "description": "A single target to search. If the target is an index alias, it must resolve to a single index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            {
              "$ref": "#/components/schemas/_types:IndexAlias"
            }
          ]
        },
        "style": "simple"
      },
      "fleet.search#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#analyzer": {
        "in": "query",
        "name": "analyzer",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#batched_reduce_size": {
        "in": "query",
        "name": "batched_reduce_size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#default_operator": {
        "in": "query",
        "name": "default_operator",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "fleet.search#df": {
        "in": "query",
        "name": "df",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#docvalue_fields": {
        "in": "query",
        "name": "docvalue_fields",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "fleet.search#explain": {
        "in": "query",
        "name": "explain",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#lenient": {
        "in": "query",
        "name": "lenient",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#min_compatible_shard_node": {
        "in": "query",
        "name": "min_compatible_shard_node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionString"
        },
        "style": "form"
      },
      "fleet.search#preference": {
        "in": "query",
        "name": "preference",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#request_cache": {
        "in": "query",
        "name": "request_cache",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#routing": {
        "in": "query",
        "name": "routing",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "fleet.search#scroll": {
        "in": "query",
        "name": "scroll",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "fleet.search#search_type": {
        "in": "query",
        "name": "search_type",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "fleet.search#stats": {
        "in": "query",
        "name": "stats",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "fleet.search#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#suggest_field": {
        "in": "query",
        "name": "suggest_field",
        "description": "Specifies which field to use for suggestions.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "fleet.search#suggest_mode": {
        "in": "query",
        "name": "suggest_mode",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SuggestMode"
        },
        "style": "form"
      },
      "fleet.search#suggest_size": {
        "in": "query",
        "name": "suggest_size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#suggest_text": {
        "in": "query",
        "name": "suggest_text",
        "description": "The source text for which the suggestions should be returned.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#timeout": {
        "in": "query",
        "name": "timeout",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "fleet.search#track_total_hits": {
        "in": "query",
        "name": "track_total_hits",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:TrackHits"
        },
        "style": "form"
      },
      "fleet.search#track_scores": {
        "in": "query",
        "name": "track_scores",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#version": {
        "in": "query",
        "name": "version",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#_source": {
        "in": "query",
        "name": "_source",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "fleet.search#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#seq_no_primary_term": {
        "in": "query",
        "name": "seq_no_primary_term",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#q": {
        "in": "query",
        "name": "q",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#size": {
        "in": "query",
        "name": "size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#from": {
        "in": "query",
        "name": "from",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#sort": {
        "in": "query",
        "name": "sort",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "fleet.search#wait_for_checkpoints": {
        "in": "query",
        "name": "wait_for_checkpoints",
        "description": "A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/fleet._types:Checkpoint"
          }
        },
        "style": "form"
      },
      "fleet.search#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "If true, returns partial results if there are shard request timeouts or [shard failures](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#shard-failures). If false, returns\nan error with no partial results. Defaults to the configured cluster setting `search.default_allow_partial_results`\nwhich is true by default.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "graph.explore#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "graph.explore#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "graph.explore#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Specifies the period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "health_report#feature": {
        "in": "path",
        "name": "feature",
        "description": "A feature of the cluster, as returned by the top-level health report API.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "simple"
      },
      "health_report#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Explicit operation timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "health_report#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "Opt-in for more information about the health of the system.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "health_report#size": {
        "in": "query",
        "name": "size",
        "description": "Limit the number of affected resources the health report API returns.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ilm.get_lifecycle#policy": {
        "in": "path",
        "name": "policy",
        "description": "Identifier for the policy.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "ilm.get_lifecycle#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ilm.get_lifecycle#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "index#id": {
        "in": "path",
        "name": "id",
        "description": "A unique identifier for the document.\nTo automatically generate a document ID, use the `POST /<target>/_doc/` request format and omit this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "index#index": {
        "in": "path",
        "name": "index",
        "description": "The name of the data stream or index to target.\nIf the target doesn't exist and matches the name or wildcard (`*`) pattern of an index template with a `data_stream` definition, this request creates the data stream.\nIf the target doesn't exist and doesn't match a data stream template, this request creates the index.\nYou can check for existing targets with the resolve index API.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "index#if_primary_term": {
        "in": "query",
        "name": "if_primary_term",
        "description": "Only perform the operation if the document has this primary term.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "index#if_seq_no": {
        "in": "query",
        "name": "if_seq_no",
        "description": "Only perform the operation if the document has this sequence number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SequenceNumber"
        },
        "style": "form"
      },
      "index#op_type": {
        "in": "query",
        "name": "op_type",
        "description": "Set to `create` to only index the document if it does not already exist (put if absent).\nIf a document with the specified `_id` already exists, the indexing operation will fail.\nThe behavior is the same as using the `<index>/_create` endpoint.\nIf a document ID is specified, this paramater defaults to `index`.\nOtherwise, it defaults to `create`.\nIf the request targets a data stream, an `op_type` of `create` is required.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:OpType"
        },
        "style": "form"
      },
      "index#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "The ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "index#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search.\nIf `wait_for`, it waits for a refresh to make this operation visible to search.\nIf `false`, it does nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "index#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value that is used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "index#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.\n\nThis parameter is useful for situations where the primary shard assigned to perform the operation might not be available when the operation runs.\nSome reasons for this might be that the primary shard is currently recovering from a gateway or undergoing relocation.\nBy default, the operation will wait on the primary shard to become available for at least 1 minute before failing and responding with an error.\nThe actual wait time could be longer, particularly when multiple waits occur.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "index#version": {
        "in": "query",
        "name": "version",
        "description": "An explicit version number for concurrency control.\nIt must be a non-negative long number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "index#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "The version type.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "index#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nYou can set it to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).\nThe default value of `1` means it waits for each primary shard to be active.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "index#require_alias": {
        "in": "query",
        "name": "require_alias",
        "description": "If `true`, the destination must be an index alias.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.analyze#index": {
        "in": "path",
        "name": "index",
        "description": "Index used to derive the analyzer.\nIf specified, the `analyzer` or field parameter overrides this value.\nIf no index is specified or the index does not have a default analyzer, the analyze API uses the standard analyzer.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.clear_cache#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.clear_cache#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.clear_cache#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.clear_cache#fielddata": {
        "in": "query",
        "name": "fielddata",
        "description": "If `true`, clears the fields cache.\nUse the `fields` parameter to clear the cache of specific fields only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.clear_cache#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list of field names used to limit the `fielddata` parameter.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.clear_cache#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.clear_cache#query": {
        "in": "query",
        "name": "query",
        "description": "If `true`, clears the query cache.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.clear_cache#request": {
        "in": "query",
        "name": "request",
        "description": "If `true`, clears the request cache.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.clone#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the source index to clone.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.clone#target": {
        "in": "path",
        "name": "target",
        "description": "Name of the target index to create.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.clone#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.clone#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.clone#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "indices.data_streams_stats#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of data streams used to limit the request.\nWildcard expressions (`*`) are supported.\nTo target all data streams in a cluster, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.data_streams_stats#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.delete_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices used to limit the request.\nSupports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.delete_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of aliases to remove.\nSupports wildcards (`*`). To remove all aliases, use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.delete_alias#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.delete_alias#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.exists_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of aliases to check. Supports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.exists_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices used to limit the request. Supports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.exists_alias#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.exists_alias#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.exists_alias#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, requests that include a missing data stream or index in the target indices or data streams return an error.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.exists_alias#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": true,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.flush#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases to flush.\nSupports wildcards (`*`).\nTo flush all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.flush#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.flush#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.flush#force": {
        "in": "query",
        "name": "force",
        "description": "If `true`, the request forces a flush even if there are no changes to commit to the index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.flush#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.flush#wait_if_ongoing": {
        "in": "query",
        "name": "wait_if_ongoing",
        "description": "If `true`, the flush operation blocks until execution when another flush operation is running.\nIf `false`, Elasticsearch returns an error if you request a flush when another flush operation is running.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.forcemerge#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.forcemerge#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.forcemerge#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.forcemerge#flush": {
        "in": "query",
        "name": "flush",
        "description": "Specify whether the index should be flushed after performing the operation (default: true)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.forcemerge#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.forcemerge#max_num_segments": {
        "in": "query",
        "name": "max_num_segments",
        "description": "The number of segments the index should be merged into (default: dynamic)",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "indices.forcemerge#only_expunge_deletes": {
        "in": "query",
        "name": "only_expunge_deletes",
        "description": "Specify whether the operation should only expunge deleted documents",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.forcemerge#wait_for_completion": {
        "in": "query",
        "name": "wait_for_completion",
        "description": "Should the request wait until the force merge is completed.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of aliases to retrieve.\nSupports wildcards (`*`).\nTo retrieve all aliases, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.get_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_alias#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_alias#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_alias#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_alias#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": true,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_data_stream#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of data stream names used to limit the request.\nWildcard (`*`) expressions are supported. If omitted, all data streams are returned.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DataStreamNames"
        },
        "style": "simple"
      },
      "indices.get_data_stream#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_data_stream#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If true, returns all relevant default configurations for the index template.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_data_stream#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_data_stream#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "Whether the maximum timestamp for each data stream should be calculated and returned.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_field_mapping#fields": {
        "in": "path",
        "name": "fields",
        "description": "Comma-separated list or wildcard expression of fields used to limit returned information.\nSupports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "simple"
      },
      "indices.get_field_mapping#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_field_mapping#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_field_mapping#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_field_mapping#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_field_mapping#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If `true`, return all default settings in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_field_mapping#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_index_template#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of index template names used to limit the request. Wildcard (*) expressions are supported.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.get_index_template#local": {
        "in": "query",
        "name": "local",
        "description": "If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_index_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If true, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_index_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_index_template#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If true, returns all relevant default configurations for the index template.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_mapping#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_mapping#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_settings#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit\nthe request. Supports wildcards (`*`). To target all data streams and\nindices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_settings#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list or wildcard expression of settings to retrieve.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.get_settings#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_settings#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If `true`, return all default settings in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_template#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of index template names used to limit the request.\nWildcard (`*`) expressions are supported.\nTo return all index templates, omit this parameter or use a value of `_all` or `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.get_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_template#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices to add.\nSupports wildcards (`*`).\nWildcard patterns that match both data streams and indices return an error.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.put_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Alias to update.\nIf the alias doesnâ€™t exist, the request creates it.\nIndex alias names support date math.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.put_alias#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_alias#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_index_template#name": {
        "in": "path",
        "name": "name",
        "description": "Index or template name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.put_index_template#create": {
        "in": "query",
        "name": "create",
        "description": "If `true`, this request cannot replace or update existing index templates.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_index_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_index_template#cause": {
        "in": "query",
        "name": "cause",
        "description": "User defined reason for creating/updating the index template",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "indices.put_mapping#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.put_mapping#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_mapping#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.put_mapping#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_mapping#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_mapping#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_mapping#write_index_only": {
        "in": "query",
        "name": "write_index_only",
        "description": "If `true`, the mappings are applied only to the current write index for the target.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit\nthe request. Supports wildcards (`*`). To target all data streams and\nindices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.put_settings#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match. If the request can target\ndata streams, this argument determines whether wildcard expressions match\nhidden data streams. Supports comma-separated values, such as\n`open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.put_settings#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_settings#preserve_existing": {
        "in": "query",
        "name": "preserve_existing",
        "description": "If `true`, existing index settings remain unchanged.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the\n timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_template#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the template",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.put_template#create": {
        "in": "query",
        "name": "create",
        "description": "If true, this request cannot replace or update existing index templates.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_template#order": {
        "in": "query",
        "name": "order",
        "description": "Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower 'order' values are merged first. Templates with higher\n'order' values are merged later, overriding templates with lower values.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "indices.put_template#cause": {
        "in": "query",
        "name": "cause",
        "description": "User defined reason for creating/updating the index template",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "indices.recovery#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.recovery#active_only": {
        "in": "query",
        "name": "active_only",
        "description": "If `true`, the response only includes ongoing shard recoveries.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.recovery#detailed": {
        "in": "query",
        "name": "detailed",
        "description": "If `true`, the response includes detailed information about shard recoveries.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.refresh#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.refresh#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.refresh#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.refresh#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.reload_search_analyzers#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names to reload analyzers for",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.reload_search_analyzers#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.reload_search_analyzers#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.reload_search_analyzers#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.rollover#alias": {
        "in": "path",
        "name": "alias",
        "description": "Name of the data stream or index alias to roll over.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexAlias"
        },
        "style": "simple"
      },
      "indices.rollover#new_index": {
        "in": "path",
        "name": "new_index",
        "description": "Name of the index to create.\nSupports date math.\nData streams do not support this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.rollover#dry_run": {
        "in": "query",
        "name": "dry_run",
        "description": "If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.rollover#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.rollover#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.rollover#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "indices.segments#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.segments#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.segments#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.segments#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.segments#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "If `true`, the request returns a verbose response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.shard_stores#index": {
        "in": "path",
        "name": "index",
        "description": "List of data streams, indices, and aliases used to limit the request.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.shard_stores#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias, or _all\nvalue targets only missing or closed indices. This behavior applies even if the request\ntargets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.shard_stores#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match. If the request can target data streams,\nthis argument determines whether wildcard expressions match hidden data streams.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.shard_stores#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If true, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.shard_stores#status": {
        "in": "query",
        "name": "status",
        "description": "List of shard health statuses used to limit the request.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/indices.shard_stores:ShardStoreStatus"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/indices.shard_stores:ShardStoreStatus"
              }
            }
          ]
        },
        "style": "form"
      },
      "indices.shrink#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the source index to shrink.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.shrink#target": {
        "in": "path",
        "name": "target",
        "description": "Name of the target index to create.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.shrink#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.shrink#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.shrink#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "indices.simulate_template#name": {
        "in": "path",
        "name": "name",
        "description": "Name of the index template to simulate. To test a template configuration before you add it to the cluster, omit\nthis parameter and specify the template configuration in the request body.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.simulate_template#create": {
        "in": "query",
        "name": "create",
        "description": "If true, the template passed in the body is only used if no existing templates match the same index patterns. If false, the simulation uses the template with the highest priority. Note that the template is not permanently added or updated in either case; it is only used for the simulation.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.simulate_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.simulate_template#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If true, returns all relevant default configurations for the index template.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.split#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the source index to split.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.split#target": {
        "in": "path",
        "name": "target",
        "description": "Name of the target index to create.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.split#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.split#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.split#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "indices.stats#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limit the information returned the specific metrics.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "indices.stats#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.stats#completion_fields": {
        "in": "query",
        "name": "completion_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata and suggest statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.stats#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument\ndetermines whether wildcard expressions match hidden data streams. Supports comma-separated values,\nsuch as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.stats#fielddata_fields": {
        "in": "query",
        "name": "fielddata_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.stats#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.stats#forbid_closed_indices": {
        "in": "query",
        "name": "forbid_closed_indices",
        "description": "If true, statistics are not collected from closed indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#groups": {
        "in": "query",
        "name": "groups",
        "description": "Comma-separated list of search groups to include in the search statistics.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "indices.stats#include_segment_file_sizes": {
        "in": "query",
        "name": "include_segment_file_sizes",
        "description": "If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#include_unloaded_segments": {
        "in": "query",
        "name": "include_unloaded_segments",
        "description": "If true, the response includes information from segments that are not loaded into memory.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#level": {
        "in": "query",
        "name": "level",
        "description": "Indicates whether statistics are aggregated at the cluster, index, or shard level.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Level"
        },
        "style": "form"
      },
      "indices.validate_query#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams or indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.validate_query#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#all_shards": {
        "in": "query",
        "name": "all_shards",
        "description": "If `true`, the validation is executed on all shards instead of one random shard per index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "indices.validate_query#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If `true`, wildcard and prefix queries are analyzed.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query: `AND` or `OR`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "indices.validate_query#df": {
        "in": "query",
        "name": "df",
        "description": "Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "indices.validate_query#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.validate_query#explain": {
        "in": "query",
        "name": "explain",
        "description": "If `true`, the response returns detailed information if an error has occurred.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#rewrite": {
        "in": "query",
        "name": "rewrite",
        "description": "If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#q": {
        "in": "query",
        "name": "q",
        "description": "Query in the Lucene query string syntax.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "inference.delete#task_type": {
        "in": "path",
        "name": "task_type",
        "description": "The task type",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/inference._types:TaskType"
        },
        "style": "simple"
      },
      "inference.delete#inference_id": {
        "in": "path",
        "name": "inference_id",
        "description": "The inference Id",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "inference.delete#dry_run": {
        "in": "query",
        "name": "dry_run",
        "description": "When true, the endpoint is not deleted, and a list of ingest processors which reference this endpoint is returned",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "inference.delete#force": {
        "in": "query",
        "name": "force",
        "description": "When true, the inference endpoint is forcefully deleted even if it is still being used by ingest processors or semantic text fields",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "inference.get#task_type": {
        "in": "path",
        "name": "task_type",
        "description": "The task type",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/inference._types:TaskType"
        },
        "style": "simple"
      },
      "inference.get#inference_id": {
        "in": "path",
        "name": "inference_id",
        "description": "The inference Id",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "inference.inference#task_type": {
        "in": "path",
        "name": "task_type",
        "description": "The task type",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/inference._types:TaskType"
        },
        "style": "simple"
      },
      "inference.inference#inference_id": {
        "in": "path",
        "name": "inference_id",
        "description": "The inference Id",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "inference.inference#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Specifies the amount of time to wait for the inference request to complete.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "inference.put#task_type": {
        "in": "path",
        "name": "task_type",
        "description": "The task type",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/inference._types:TaskType"
        },
        "style": "simple"
      },
      "inference.put#inference_id": {
        "in": "path",
        "name": "inference_id",
        "description": "The inference Id",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "inference.stream_inference#inference_id": {
        "in": "path",
        "name": "inference_id",
        "description": "The unique identifier for the inference endpoint.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "inference.stream_inference#task_type": {
        "in": "path",
        "name": "task_type",
        "description": "The type of task that the model performs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/inference._types:TaskType"
        },
        "style": "simple"
      },
      "inference.update#inference_id": {
        "in": "path",
        "name": "inference_id",
        "description": "The unique identifier of the inference endpoint.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "inference.update#task_type": {
        "in": "path",
        "name": "task_type",
        "description": "The type of inference task that the model performs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/inference._types:TaskType"
        },
        "style": "simple"
      },
      "ingest.get_geoip_database#id": {
        "in": "path",
        "name": "id",
        "description": "Comma-separated list of database configuration IDs to retrieve.\nWildcard (`*`) expressions are supported.\nTo get all database configurations, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ingest.get_geoip_database#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ingest.get_ip_location_database#id": {
        "in": "path",
        "name": "id",
        "description": "Comma-separated list of database configuration IDs to retrieve.\nWildcard (`*`) expressions are supported.\nTo get all database configurations, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ingest.get_ip_location_database#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nA value of `-1` indicates that the request should never time out.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ingest.get_pipeline#id": {
        "in": "path",
        "name": "id",
        "description": "Comma-separated list of pipeline IDs to retrieve.\nWildcard (`*`) expressions are supported.\nTo get all ingest pipelines, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ingest.get_pipeline#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ingest.get_pipeline#summary": {
        "in": "query",
        "name": "summary",
        "description": "Return pipelines without their definitions (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ingest.simulate#id": {
        "in": "path",
        "name": "id",
        "description": "Pipeline to test.\nIf you donâ€™t specify a `pipeline` in the request body, this parameter is required.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ingest.simulate#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "If `true`, the response includes output data for each processor in the executed pipeline.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "knn_search#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names to search;\nuse `_all` or to perform the operation on all indices.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "knn_search#routing": {
        "in": "query",
        "name": "routing",
        "description": "A comma-separated list of specific routing values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "license.post#acknowledge": {
        "in": "query",
        "name": "acknowledge",
        "description": "Specifies whether you acknowledge the license changes.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "logstash.get_pipeline#id": {
        "in": "path",
        "name": "id",
        "description": "A comma-separated list of pipeline identifiers.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "mget#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the index to retrieve documents from when `ids` are specified, or when a document in the `docs` array does not specify an index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "mget#force_synthetic_source": {
        "in": "query",
        "name": "force_synthetic_source",
        "description": "Should this request force synthetic _source?\nUse this to test if the mapping supports synthetic _source and to get a sense of the worst case performance.\nFetches with this enabled will be slower the enabling synthetic source natively in the index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mget#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specifies the node or shard the operation should be performed on. Random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "mget#realtime": {
        "in": "query",
        "name": "realtime",
        "description": "If `true`, the request is real-time as opposed to near-real-time.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mget#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, the request refreshes relevant shards before retrieving documents.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mget#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "mget#_source": {
        "in": "query",
        "name": "_source",
        "description": "True or false to return the `_source` field or not, or a list of fields to return.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "mget#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "mget#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned. You can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "mget#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "If `true`, retrieves the document fields stored in the index rather than the document `_source`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "migration.deprecations#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separate list of data streams or indices to check. Wildcard (*) expressions are supported.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "ml.delete_expired_data#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for an anomaly detection job. It can be a job identifier, a\ngroup name, or a wildcard expression.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.delete_expired_data#requests_per_second": {
        "in": "query",
        "name": "requests_per_second",
        "description": "The desired requests per second for the deletion processes. The default\nbehavior is no throttling.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.delete_expired_data#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "How long can the underlying delete processes run until they are canceled.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.delete_forecast#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.delete_forecast#forecast_id": {
        "in": "path",
        "name": "forecast_id",
        "description": "A comma-separated list of forecast identifiers. If you do not specify\nthis optional parameter or if you specify `_all` or `*` the API deletes\nall forecasts from the job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.delete_forecast#allow_no_forecasts": {
        "in": "query",
        "name": "allow_no_forecasts",
        "description": "Specifies whether an error occurs when there are no forecasts. In\nparticular, if this parameter is set to `false` and there are no\nforecasts associated with the job, attempts to delete all forecasts\nreturn an error.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.delete_forecast#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Specifies the period of time to wait for the completion of the delete\noperation. When this period of time elapses, the API fails and returns an\nerror.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.explain_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_buckets#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_buckets#timestamp": {
        "in": "path",
        "name": "timestamp",
        "description": "The timestamp of a single bucket result. If you do not specify this\nparameter, the API returns information about all buckets.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "simple"
      },
      "ml.get_buckets#anomaly_score": {
        "in": "query",
        "name": "anomaly_score",
        "description": "Returns buckets with anomaly scores greater or equal than this value.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_buckets#desc": {
        "in": "query",
        "name": "desc",
        "description": "If `true`, the buckets are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_buckets#end": {
        "in": "query",
        "name": "end",
        "description": "Returns buckets with timestamps earlier than this time. `-1` means it is\nunset and results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_buckets#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If `true`, the output excludes interim results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_buckets#expand": {
        "in": "query",
        "name": "expand",
        "description": "If true, the output includes anomaly records.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_buckets#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of buckets.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_buckets#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of buckets to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_buckets#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested buckets.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_buckets#start": {
        "in": "query",
        "name": "start",
        "description": "Returns buckets with timestamps after this time. `-1` means it is unset\nand results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_calendars#calendar_id": {
        "in": "path",
        "name": "calendar_id",
        "description": "A string that uniquely identifies a calendar. You can get information for multiple calendars by using a comma-separated list of ids or a wildcard expression. You can get information for all calendars by using `_all` or `*` or by omitting the calendar identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_calendars#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_calendars#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_categories#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_categories#category_id": {
        "in": "path",
        "name": "category_id",
        "description": "Identifier for the category, which is unique in the job. If you specify\nneither the category ID nor the partition_field_value, the API returns\ninformation about all categories. If you specify only the\npartition_field_value, it returns information about all categories for\nthe specified partition.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:CategoryId"
        },
        "style": "simple"
      },
      "ml.get_categories#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of categories.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_categories#partition_field_value": {
        "in": "query",
        "name": "partition_field_value",
        "description": "Only return categories for the specified partition.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "ml.get_categories#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of categories to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job. If you do not specify this\noption, the API returns information for the first hundred data frame\nanalytics jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_data_frame_analytics#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of data frame analytics jobs.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of data frame analytics jobs to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job. If you do not specify this\noption, the API returns information for the first hundred data frame\nanalytics jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_data_frame_analytics_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of data frame analytics jobs.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of data frame analytics jobs to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "Defines whether the stats response should be verbose.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_datafeed_stats#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "Identifier for the datafeed. It can be a datafeed identifier or a\nwildcard expression. If you do not specify one of these options, the API\nreturns information about all datafeeds.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_datafeed_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_datafeeds#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "Identifier for the datafeed. It can be a datafeed identifier or a\nwildcard expression. If you do not specify one of these options, the API\nreturns information about all datafeeds.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_datafeeds#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_datafeeds#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_filters#filter_id": {
        "in": "path",
        "name": "filter_id",
        "description": "A string that uniquely identifies a filter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_filters#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of filters.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_filters#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of filters to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_influencers#desc": {
        "in": "query",
        "name": "desc",
        "description": "If true, the results are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_influencers#end": {
        "in": "query",
        "name": "end",
        "description": "Returns influencers with timestamps earlier than this time.\nThe default value means it is unset and results are not limited to\nspecific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_influencers#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If true, the output excludes interim results. By default, interim results\nare included.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_influencers#influencer_score": {
        "in": "query",
        "name": "influencer_score",
        "description": "Returns influencers with anomaly scores greater than or equal to this\nvalue.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of influencers.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of influencers to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested influencers. By default, the\ninfluencers are sorted by the `influencer_score` value.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_influencers#start": {
        "in": "query",
        "name": "start",
        "description": "Returns influencers with timestamps after this time. The default value\nmeans it is unset and results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_job_stats#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job. It can be a job identifier, a\ngroup name, a comma-separated list of jobs, or a wildcard expression. If\nyou do not specify one of these options, the API returns information for\nall anomaly detection jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_job_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If `false`, the API returns a `404` status\ncode when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_jobs#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job. It can be a job identifier, a\ngroup name, or a wildcard expression. If you do not specify one of these\noptions, the API returns information for all anomaly detection jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_jobs#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If this parameter is `false`, the request returns a `404` status\ncode when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_jobs#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_memory_stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "The names of particular nodes in the cluster to target. For example, `nodeId1,nodeId2` or\n`ml:true`",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_memory_stats#human": {
        "in": "query",
        "name": "human",
        "description": "Specify this query parameter to include the fields with units in the response. Otherwise only\nthe `_in_bytes` sizes are returned in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_memory_stats#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout\nexpires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.get_memory_stats#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request\nfails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_model_snapshots#snapshot_id": {
        "in": "path",
        "name": "snapshot_id",
        "description": "A numerical character string that uniquely identifies the model snapshot. You can get information for multiple\nsnapshots by using a comma-separated list or a wildcard expression. You can get all snapshots by using `_all`,\nby specifying `*` as the snapshot ID, or by omitting the snapshot ID.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_model_snapshots#desc": {
        "in": "query",
        "name": "desc",
        "description": "If true, the results are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#end": {
        "in": "query",
        "name": "end",
        "description": "Returns snapshots with timestamps earlier than this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of snapshots.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of snapshots to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested snapshots. By default, the\nsnapshots are sorted by their timestamp.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#start": {
        "in": "query",
        "name": "start",
        "description": "Returns snapshots with timestamps after this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job. It can be a job identifier, a\ngroup name, a comma-separated list of jobs or groups, or a wildcard\nexpression.\n\nYou can summarize the bucket results for all anomaly detection jobs by\nusing `_all` or by specifying `*` as the `<job_id>`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_overall_buckets#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the request returns an empty `jobs` array when there are no\nmatches and the subset of results when there are partial matches. If this\nparameter is `false`, the request returns a `404` status code when there\nare no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#bucket_span": {
        "in": "query",
        "name": "bucket_span",
        "description": "The span of the overall buckets. Must be greater or equal to the largest\nbucket span of the specified anomaly detection jobs, which is the default\nvalue.\n\nBy default, an overall bucket has a span equal to the largest bucket span\nof the specified anomaly detection jobs. To override that behavior, use\nthe optional `bucket_span` parameter.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#end": {
        "in": "query",
        "name": "end",
        "description": "Returns overall buckets with timestamps earlier than this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If `true`, the output excludes interim results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#overall_score": {
        "in": "query",
        "name": "overall_score",
        "description": "Returns overall buckets with overall scores greater than or equal to this\nvalue.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            }
          ]
        },
        "style": "form"
      },
      "ml.get_overall_buckets#start": {
        "in": "query",
        "name": "start",
        "description": "Returns overall buckets with timestamps after this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#top_n": {
        "in": "query",
        "name": "top_n",
        "description": "The number of top anomaly detection job bucket scores to be used in the\n`overall_score` calculation.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_records#desc": {
        "in": "query",
        "name": "desc",
        "description": "If true, the results are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_records#end": {
        "in": "query",
        "name": "end",
        "description": "Returns records with timestamps earlier than this time. The default value\nmeans results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_records#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If `true`, the output excludes interim results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_records#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of records.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#record_score": {
        "in": "query",
        "name": "record_score",
        "description": "Returns records with anomaly scores greater or equal than this value.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of records to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested records.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_records#start": {
        "in": "query",
        "name": "start",
        "description": "Returns records with timestamps after this time. The default value means\nresults are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_trained_models#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "The unique identifier of the trained model or a model alias.\n\nYou can get information for multiple trained models in a single API\nrequest by using a comma-separated list of model IDs or a wildcard\nexpression.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_trained_models#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#decompress_definition": {
        "in": "query",
        "name": "decompress_definition",
        "description": "Specifies whether the included model definition should be returned as a\nJSON map (true) or in a custom compressed format (false).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of models.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_trained_models#include": {
        "in": "query",
        "name": "include",
        "description": "A comma delimited string of optional fields to include in the response\nbody.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/ml._types:Include"
        },
        "style": "form"
      },
      "ml.get_trained_models#include_model_definition": {
        "in": "query",
        "name": "include_model_definition",
        "description": "parameter is deprecated! Use [include=definition] instead",
        "deprecated": true,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of models to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_trained_models#tags": {
        "in": "query",
        "name": "tags",
        "description": "A comma delimited string of tags. A trained model can have many tags, or\nnone. When supplied, only trained models that contain all the supplied\ntags are returned.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "ml.get_trained_models_stats#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "The unique identifier of the trained model or a model alias. It can be a\ncomma-separated list or a wildcard expression.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_trained_models_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models_stats#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of models.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_trained_models_stats#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of models to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.infer_trained_model#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "The unique identifier of the trained model.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.infer_trained_model#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Controls the amount of time to wait for inference results.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.preview_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.preview_datafeed#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "A numerical character string that uniquely identifies the datafeed. This identifier can contain lowercase\nalphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric\ncharacters. NOTE: If you use this path parameter, you cannot provide datafeed or anomaly detection job\nconfiguration details in the request body.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.preview_datafeed#start": {
        "in": "query",
        "name": "start",
        "description": "The start time from where the datafeed preview should begin",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.preview_datafeed#end": {
        "in": "query",
        "name": "end",
        "description": "The end time when the datafeed preview should stop",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "monitoring.bulk#type": {
        "in": "path",
        "name": "type",
        "description": "Default document type for items which don't provide one",
        "required": true,
        "deprecated": true,
        "schema": {
          "type": "string"
        },
        "style": "simple"
      },
      "monitoring.bulk#system_id": {
        "in": "query",
        "name": "system_id",
        "description": "Identifier of the monitored system",
        "required": true,
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "monitoring.bulk#system_api_version": {
        "in": "query",
        "name": "system_api_version",
        "description": "",
        "required": true,
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "monitoring.bulk#interval": {
        "in": "query",
        "name": "interval",
        "description": "Collection interval (e.g., '10s' or '10000ms') of the payload",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "msearch#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and index aliases to search.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "msearch#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "msearch#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If true, concrete, expanded or aliased indices are ignored when frozen.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If true, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#include_named_queries_score": {
        "in": "query",
        "name": "include_named_queries_score",
        "description": "Indicates whether hit.matched_queries should be rendered as a map that includes\nthe name of the matched query associated with its score (true)\nor as an array containing the name of the matched queries (false)\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#max_concurrent_searches": {
        "in": "query",
        "name": "max_concurrent_searches",
        "description": "Maximum number of concurrent searches the multi search API can execute.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "Maximum number of concurrent shard requests that each sub-search request executes per node.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom routing value used to route search operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "msearch#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Indicates whether global term and document frequencies should be used when scoring returned documents.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "msearch#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch_template#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "msearch_template#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If `true`, network round-trips are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch_template#max_concurrent_searches": {
        "in": "query",
        "name": "max_concurrent_searches",
        "description": "The maximum number of concurrent searches the API can run.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch_template#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "The type of the search operation.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "msearch_template#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch_template#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "If `true`, the response prefixes aggregation and suggester names with their respective types.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#index": {
        "in": "path",
        "name": "index",
        "description": "The name of the index that contains the documents.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "mtermvectors#ids": {
        "in": "query",
        "name": "ids",
        "description": "A comma-separated list of documents ids. You must define ids as parameter or set \"ids\" or \"docs\" in the request body",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "style": "form"
      },
      "mtermvectors#fields": {
        "in": "query",
        "name": "fields",
        "description": "A comma-separated list or wildcard expressions of fields to include in the statistics.\nIt is used as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "mtermvectors#field_statistics": {
        "in": "query",
        "name": "field_statistics",
        "description": "If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#offsets": {
        "in": "query",
        "name": "offsets",
        "description": "If `true`, the response includes term offsets.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#payloads": {
        "in": "query",
        "name": "payloads",
        "description": "If `true`, the response includes term payloads.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#positions": {
        "in": "query",
        "name": "positions",
        "description": "If `true`, the response includes term positions.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#preference": {
        "in": "query",
        "name": "preference",
        "description": "The node or shard the operation should be performed on.\nIt is random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "mtermvectors#realtime": {
        "in": "query",
        "name": "realtime",
        "description": "If true, the request is real-time as opposed to near-real-time.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "mtermvectors#term_statistics": {
        "in": "query",
        "name": "term_statistics",
        "description": "If true, the response includes term frequency and document frequency.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#version": {
        "in": "query",
        "name": "version",
        "description": "If `true`, returns the document version as part of a hit.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "mtermvectors#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "The version type.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "nodes.hot_threads#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "List of node IDs or names used to limit returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.hot_threads#ignore_idle_threads": {
        "in": "query",
        "name": "ignore_idle_threads",
        "description": "If true, known idle threads (e.g. waiting in a socket select, or to get\na task from an empty queue) are filtered out.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.hot_threads#interval": {
        "in": "query",
        "name": "interval",
        "description": "The interval to do the second sampling of threads.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.hot_threads#snapshots": {
        "in": "query",
        "name": "snapshots",
        "description": "Number of samples of thread stacktrace.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "nodes.hot_threads#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response\nis received before the timeout expires, the request fails and\nreturns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.hot_threads#threads": {
        "in": "query",
        "name": "threads",
        "description": "Specifies the number of hot threads to provide information for.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "nodes.hot_threads#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received\nbefore the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.hot_threads#type": {
        "in": "query",
        "name": "type",
        "description": "The type to sample.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ThreadType"
        },
        "style": "form"
      },
      "nodes.hot_threads#sort": {
        "in": "query",
        "name": "sort",
        "description": "The sort order for 'cpu' type (default: total)",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ThreadType"
        },
        "style": "form"
      },
      "nodes.info#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node IDs or names used to limit returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.info#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limits the information returned to the specific metrics. Supports a comma-separated list, such as http,ingest.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.info#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If true, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.info#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.info#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.reload_secure_settings#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "The names of particular nodes in the cluster to target.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.reload_secure_settings#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node IDs or names used to limit returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.stats#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limit the information returned to the specified metrics",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.stats#index_metric": {
        "in": "path",
        "name": "index_metric",
        "description": "Limit the information returned for indices metric to the specific index metrics. It can be used only if indices (or all) metric is specified.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.stats#completion_fields": {
        "in": "query",
        "name": "completion_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata and suggest statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "nodes.stats#fielddata_fields": {
        "in": "query",
        "name": "fielddata_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "nodes.stats#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "nodes.stats#groups": {
        "in": "query",
        "name": "groups",
        "description": "Comma-separated list of search groups to include in the search statistics.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.stats#include_segment_file_sizes": {
        "in": "query",
        "name": "include_segment_file_sizes",
        "description": "If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.stats#level": {
        "in": "query",
        "name": "level",
        "description": "Indicates whether statistics are aggregated at the cluster, index, or shard level.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Level"
        },
        "style": "form"
      },
      "nodes.stats#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.stats#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.stats#types": {
        "in": "query",
        "name": "types",
        "description": "A comma-separated list of document types for the indexing index metric.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "nodes.stats#include_unloaded_segments": {
        "in": "query",
        "name": "include_unloaded_segments",
        "description": "If `true`, the response includes information from segments that are not loaded into memory.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.usage#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.usage#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limits the information returned to the specific metrics.\nA comma-separated list of the following options: `_all`, `rest_actions`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.usage#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "put_script#id": {
        "in": "path",
        "name": "id",
        "description": "The identifier for the stored script or search template.\nIt must be unique within the cluster.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "put_script#context": {
        "in": "path",
        "name": "context",
        "description": "The context in which the script or search template should run.\nTo prevent errors, the API immediately compiles the script or template in this context.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "put_script#context_": {
        "in": "query",
        "name": "context",
        "description": "The context in which the script or search template should run.\nTo prevent errors, the API immediately compiles the script or template in this context.\nIf you specify both this and the `<context>` path parameter, the API uses the request path parameter.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "form"
      },
      "put_script#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.\nIt can also be set to `-1` to indicate that the request should never timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "put_script#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.\nIt can also be set to `-1` to indicate that the request should never timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "rank_eval#index": {
        "in": "path",
        "name": "index",
        "description": "A  comma-separated list of data streams, indices, and index aliases used to limit the request.\nWildcard (`*`) expressions are supported.\nTo target all data streams and indices in a cluster, omit this parameter or use `_all` or `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "rank_eval#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "rank_eval#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "rank_eval#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "rank_eval#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Search operation type",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "render_search_template#id": {
        "in": "path",
        "name": "id",
        "description": "The ID of the search template to render.\nIf no `source` is specified, this or the `id` request body parameter is required.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "rollup.get_jobs#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the rollup job.\nIf it is `_all` or omitted, the API returns all rollup jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "rollup.get_rollup_caps#id": {
        "in": "path",
        "name": "id",
        "description": "Index, indices or index-pattern to return rollup capabilities for.\n`_all` may be used to fetch rollup capabilities from all jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "rollup.rollup_search#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams and indices used to limit the request.\nThis parameter has the following rules:\n\n* At least one data stream, index, or wildcard expression must be specified. This target can include a rollup or non-rollup index. For data streams, the stream's backing indices can only serve as non-rollup indices. Omitting the parameter or using `_all` are not permitted.\n* Multiple non-rollup indices may be specified.\n* Only one rollup index may be specified. If more than one are supplied, an exception occurs.\n* Wildcard expressions (`*`) may be used. If they match more than one rollup index, an exception occurs. However, you can use an expression to match multiple non-rollup indices or data streams.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "rollup.rollup_search#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "Indicates whether hits.total should be rendered as an integer or an object in the rest search response",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "rollup.rollup_search#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specify whether aggregation and suggester names should be prefixed by their respective types in the response",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "scroll#scroll_id": {
        "in": "path",
        "name": "scroll_id",
        "description": "The scroll ID",
        "required": true,
        "deprecated": true,
        "schema": {
          "$ref": "#/components/schemas/_types:ScrollId"
        },
        "style": "simple"
      },
      "scroll#scroll": {
        "in": "query",
        "name": "scroll",
        "description": "The period to retain the search context for scrolling.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "scroll#scroll_id_": {
        "in": "query",
        "name": "scroll_id",
        "description": "The scroll ID for scrolled search",
        "deprecated": true,
        "schema": {
          "$ref": "#/components/schemas/_types:ScrollId"
        },
        "style": "form"
      },
      "scroll#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, the API responseâ€™s hit.total property is returned as an integer. If false, the API responseâ€™s hit.total property is returned as an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "If `true` and there are shard request timeouts or shard failures, the request returns partial results.\nIf `false`, it returns an error with no partial results.\n\nTo override the default behavior, you can set the `search.default_allow_partial_results` cluster setting to `false`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "The analyzer to use for the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#batched_reduce_size": {
        "in": "query",
        "name": "batched_reduce_size",
        "description": "The number of shard results that should be reduced at once on the coordinating node.\nIf the potential number of shards in the request can be large, this value should be used as a protection mechanism to reduce the memory overhead per search request.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If `true`, network round-trips between the coordinating node and the remote clusters are minimized when running cross-cluster search (CCS) requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for the query string query: `AND` or `OR`.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "search#df": {
        "in": "query",
        "name": "df",
        "description": "The field to use as a default when no field prefix is given in the query string.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#docvalue_fields": {
        "in": "query",
        "name": "docvalue_fields",
        "description": "A comma-separated list of fields to return as the docvalue representation of a field for each hit.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nIt supports comma-separated values such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "search#explain": {
        "in": "query",
        "name": "explain",
        "description": "If `true`, the request returns detailed information about score computation as part of a hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If `true`, concrete, expanded or aliased indices will be ignored when frozen.",
        "deprecated": true,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#include_named_queries_score": {
        "in": "query",
        "name": "include_named_queries_score",
        "description": "If `true`, the response includes the score contribution from any named queries.\n\nThis functionality reruns each named query on every hit in a search response.\nTypically, this adds a small overhead to a request.\nHowever, using computationally expensive named queries on a large number of hits may add significant overhead.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can be used only when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "The number of concurrent shard requests per node that the search runs concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#min_compatible_shard_node": {
        "in": "query",
        "name": "min_compatible_shard_node",
        "description": "The minimum version of the node that can handle the request.\nAny handling node with a lower version will fail the request.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionString"
        },
        "style": "form"
      },
      "search#preference": {
        "in": "query",
        "name": "preference",
        "description": "The nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness. Valid values are:\n\n* `_only_local` to run the search only on shards on the local node;\n* `_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method;\n* `_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs, where, if suitable shards exist on more than one selected node, use shards on those nodes using the default method, or if none of the specified nodes are available, select shards from any available node using the default method;\n* `_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs, or if not, select shards using the default method;\n* `_shards:<shard>,<shard>` to run the search only on the specified shards;\n* `<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "A threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\n\n* The request targets more than 128 shards.\n* The request targets one or more read-only index.\n* The primary sort of the query targets an indexed field.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#request_cache": {
        "in": "query",
        "name": "request_cache",
        "description": "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nIt defaults to index level settings.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value that is used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "search#scroll": {
        "in": "query",
        "name": "scroll",
        "description": "The period to retain the search context for scrolling.\nBy default, this value cannot exceed `1d` (24 hours).\nYou can change this limit by using the `search.max_keep_alive` cluster-level setting.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "search#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Indicates how distributed term frequencies are calculated for relevance scoring.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "search#stats": {
        "in": "query",
        "name": "stats",
        "description": "Specific `tag` of the request for logging and statistical purposes.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "search#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "A comma-separated list of stored fields to return as part of a hit.\nIf no fields are specified, no stored fields are included in the response.\nIf this field is specified, the `_source` parameter defaults to `false`.\nYou can pass `_source: true` to return both source fields and stored fields in the search response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#suggest_field": {
        "in": "query",
        "name": "suggest_field",
        "description": "The field to use for suggestions.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "search#suggest_mode": {
        "in": "query",
        "name": "suggest_mode",
        "description": "The suggest mode.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SuggestMode"
        },
        "style": "form"
      },
      "search#suggest_size": {
        "in": "query",
        "name": "suggest_size",
        "description": "The number of suggestions to return.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#suggest_text": {
        "in": "query",
        "name": "suggest_text",
        "description": "The source text for which the suggestions should be returned.\nThis parameter can be used only when the `suggest_field` and `suggest_text` query string parameters are specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "description": "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nIt defaults to no timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "search#track_total_hits": {
        "in": "query",
        "name": "track_total_hits",
        "description": "The number of hits matching the query to count accurately.\nIf `true`, the exact number of hits is returned at the cost of some performance.\nIf `false`, the response does not include the total number of hits matching the query.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:TrackHits"
        },
        "style": "form"
      },
      "search#track_scores": {
        "in": "query",
        "name": "track_scores",
        "description": "If `true`, the request calculates and returns document scores, even if the scores are not used for sorting.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "If `true`, aggregation and suggester names are be prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#version": {
        "in": "query",
        "name": "version",
        "description": "If `true`, the request returns the document version as part of a hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#_source": {
        "in": "query",
        "name": "_source",
        "description": "The source fields that are returned for matching documents.\nThese fields are returned in the `hits._source` property of the search response.\nValid values are:\n\n* `true` to return the entire document source.\n* `false` to not return the document source.\n* `<string>` to return the source fields that are specified as a comma-separated list that supports wildcard (`*`) patterns.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "search#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned.\nYou can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#seq_no_primary_term": {
        "in": "query",
        "name": "seq_no_primary_term",
        "description": "If `true`, the request returns the sequence number and primary term of the last modification of each hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#q": {
        "in": "query",
        "name": "q",
        "description": "A query in the Lucene query string syntax.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.\n\nIMPORTANT: This parameter overrides the query parameter in the request body.\nIf both parameters are specified, documents matching the query request body parameter are not returned.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#size": {
        "in": "query",
        "name": "size",
        "description": "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#from": {
        "in": "query",
        "name": "from",
        "description": "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#sort": {
        "in": "query",
        "name": "sort",
        "description": "A comma-separated list of `<field>:<direction>` pairs.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "search#force_synthetic_source": {
        "in": "query",
        "name": "force_synthetic_source",
        "description": "Should this request force synthetic _source?\nUse this to test if the mapping supports synthetic _source and to get a sense of the worst case performance.\nFetches with this enabled will be slower the enabling synthetic source natively in the index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_application.get_behavioral_analytics#name": {
        "in": "path",
        "name": "name",
        "description": "A list of analytics collections to limit the returned information",
        "required": true,
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "style": "simple"
      },
      "search_application.search#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the search application to be searched.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "search_application.search#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Determines whether aggregation names are prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_mvt#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, or aliases to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search_mvt#field": {
        "in": "path",
        "name": "field",
        "description": "Field containing geospatial data to return",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "simple"
      },
      "search_mvt#zoom": {
        "in": "path",
        "name": "zoom",
        "description": "Zoom level for the vector tile to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:ZoomLevel"
        },
        "style": "simple"
      },
      "search_mvt#x": {
        "in": "path",
        "name": "x",
        "description": "X coordinate for the vector tile to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:Coordinate"
        },
        "style": "simple"
      },
      "search_mvt#y": {
        "in": "path",
        "name": "y",
        "description": "Y coordinate for the vector tile to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:Coordinate"
        },
        "style": "simple"
      },
      "search_mvt#exact_bounds": {
        "in": "query",
        "name": "exact_bounds",
        "description": "If `false`, the meta layer's feature is the bounding box of the tile.\nIf true, the meta layer's feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_mvt#extent": {
        "in": "query",
        "name": "extent",
        "description": "The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search_mvt#grid_agg": {
        "in": "query",
        "name": "grid_agg",
        "description": "Aggregation used to create a grid for `field`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:GridAggregationType"
        },
        "style": "form"
      },
      "search_mvt#grid_precision": {
        "in": "query",
        "name": "grid_precision",
        "description": "Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon't include the aggs layer.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search_mvt#grid_type": {
        "in": "query",
        "name": "grid_type",
        "description": "Determines the geometry type for features in the aggs layer. In the aggs layer,\neach feature represents a geotile_grid cell. If 'grid' each feature is a Polygon\nof the cells bounding box. If 'point' each feature is a Point that is the centroid\nof the cell.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:GridType"
        },
        "style": "form"
      },
      "search_mvt#size": {
        "in": "query",
        "name": "size",
        "description": "Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don't include the hits layer.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search_mvt#with_labels": {
        "in": "query",
        "name": "with_labels",
        "description": "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_shards#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search_shards#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_shards#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "search_shards#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_shards#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_shards#preference": {
        "in": "query",
        "name": "preference",
        "description": "The node or shard the operation should be performed on.\nIt is random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search_shards#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "search_template#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases to search.\nIt supports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search_template#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If `true`, network round-trips are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "search_template#explain": {
        "in": "query",
        "name": "explain",
        "description": "If `true`, the response includes additional details about score computation as part of a hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.",
        "deprecated": true,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#preference": {
        "in": "query",
        "name": "preference",
        "description": "The node or shard the operation should be performed on.\nIt is random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search_template#profile": {
        "in": "query",
        "name": "profile",
        "description": "If `true`, the query execution is profiled.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "search_template#scroll": {
        "in": "query",
        "name": "scroll",
        "description": "Specifies how long a consistent view of the index\nshould be maintained for scrolled search.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "search_template#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "The type of the search operation.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "search_template#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If `true`, `hits.total` is rendered as an integer in the response.\nIf `false`, it is rendered as an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "If `true`, the response prefixes aggregation and suggester names with their respective types.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "searchable_snapshots.cache_stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "The names of the nodes in the cluster to target.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "searchable_snapshots.cache_stats#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "searchable_snapshots.clear_cache#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases to clear from the cache.\nIt supports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "searchable_snapshots.clear_cache#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "searchable_snapshots.clear_cache#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "searchable_snapshots.clear_cache#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "searchable_snapshots.clear_cache#pretty": {
        "in": "query",
        "name": "pretty",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "searchable_snapshots.clear_cache#human": {
        "in": "query",
        "name": "human",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "searchable_snapshots.stats#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams and indices to retrieve statistics for.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "searchable_snapshots.stats#level": {
        "in": "query",
        "name": "level",
        "description": "Return stats aggregated at cluster, index or shard level",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/searchable_snapshots._types:StatsLevel"
        },
        "style": "form"
      },
      "security.change_password#username": {
        "in": "path",
        "name": "username",
        "description": "The user whose password you want to change. If you do not specify this\nparameter, the password is changed for the current user.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Username"
        },
        "style": "simple"
      },
      "security.change_password#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.create_api_key#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.create_service_token#namespace": {
        "in": "path",
        "name": "namespace",
        "description": "The name of the namespace, which is a top-level grouping of service accounts.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Namespace"
        },
        "style": "simple"
      },
      "security.create_service_token#service": {
        "in": "path",
        "name": "service",
        "description": "The name of the service.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Service"
        },
        "style": "simple"
      },
      "security.create_service_token#name": {
        "in": "path",
        "name": "name",
        "description": "The name for the service account token.\nIf omitted, a random name will be generated.\n\nToken names must be at least one and no more than 256 characters.\nThey can contain alphanumeric characters (a-z, A-Z, 0-9), dashes (`-`), and underscores (`_`), but cannot begin with an underscore.\n\nNOTE: Token names must be unique in the context of the associated service account.\nThey must also be globally unique with their fully qualified names, which are comprised of the service account principal and token name, such as `<namespace>/<service>/<token-name>`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.create_service_token#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` (the default) then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.disable_user#username": {
        "in": "path",
        "name": "username",
        "description": "An identifier for the user.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Username"
        },
        "style": "simple"
      },
      "security.disable_user#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.disable_user_profile#uid": {
        "in": "path",
        "name": "uid",
        "description": "Unique identifier for the user profile.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/security._types:UserProfileId"
        },
        "style": "simple"
      },
      "security.disable_user_profile#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation visible to search.\nIf 'wait_for', it waits for a refresh to make this operation visible to search.\nIf 'false', it does nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.enable_user#username": {
        "in": "path",
        "name": "username",
        "description": "An identifier for the user.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Username"
        },
        "style": "simple"
      },
      "security.enable_user#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.enable_user_profile#uid": {
        "in": "path",
        "name": "uid",
        "description": "A unique identifier for the user profile.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/security._types:UserProfileId"
        },
        "style": "simple"
      },
      "security.enable_user_profile#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation\nvisible to search.\nIf 'wait_for', it waits for a refresh to make this operation visible to search.\nIf 'false', nothing is done with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.get_privileges#application": {
        "in": "path",
        "name": "application",
        "description": "The name of the application.\nApplication privileges are always associated with exactly one application.\nIf you do not specify this parameter, the API returns information about all privileges for all applications.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.get_privileges#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the privilege.\nIf you do not specify this parameter, the API returns information about all privileges for the requested application.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "security.get_role#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the role.\nYou can specify multiple roles as a comma-separated list.\nIf you do not specify this parameter, the API returns information about all roles.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "security.get_role_mapping#name": {
        "in": "path",
        "name": "name",
        "description": "The distinct name that identifies the role mapping. The name is used solely as an identifier to facilitate interaction via the API; it does not affect the behavior of the mapping in any way. You can specify multiple mapping names as a comma-separated list. If you do not specify this parameter, the API returns information about all role mappings.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "security.get_service_accounts#namespace": {
        "in": "path",
        "name": "namespace",
        "description": "The name of the namespace.\nOmit this parameter to retrieve information about all service accounts.\nIf you omit this parameter, you must also omit the `service` parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Namespace"
        },
        "style": "simple"
      },
      "security.get_service_accounts#service": {
        "in": "path",
        "name": "service",
        "description": "The service name.\nOmit this parameter to retrieve information about all service accounts that belong to the specified `namespace`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Service"
        },
        "style": "simple"
      },
      "security.get_user#username": {
        "in": "path",
        "name": "username",
        "description": "An identifier for the user. You can specify multiple usernames as a comma-separated list. If you omit this parameter, the API retrieves information about all users.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/_types:Username"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_types:Username"
              }
            }
          ]
        },
        "style": "simple"
      },
      "security.get_user#with_profile_uid": {
        "in": "query",
        "name": "with_profile_uid",
        "description": "Determines whether to retrieve the user profile UID, if it exists, for the users.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.has_privileges#user": {
        "in": "path",
        "name": "user",
        "description": "Username",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.put_privileges#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.put_role#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the role.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.put_role#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.put_role_mapping#name": {
        "in": "path",
        "name": "name",
        "description": "The distinct name that identifies the role mapping.\nThe name is used solely as an identifier to facilitate interaction via the API; it does not affect the behavior of the mapping in any way.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.put_role_mapping#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.put_user#username": {
        "in": "path",
        "name": "username",
        "description": "An identifier for the user.\n\nNOTE: Usernames must be at least 1 and no more than 507 characters.\nThey can contain alphanumeric characters (a-z, A-Z, 0-9), spaces, punctuation, and printable symbols in the Basic Latin (ASCII) block.\nLeading or trailing whitespace is not allowed.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Username"
        },
        "style": "simple"
      },
      "security.put_user#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "Valid values are `true`, `false`, and `wait_for`.\nThese values have the same meaning as in the index API, but the default value for this API is true.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.query_api_keys#with_limited_by": {
        "in": "query",
        "name": "with_limited_by",
        "description": "Return the snapshot of the owner user's role descriptors associated with the API key.\nAn API key's actual permission is the intersection of its assigned role descriptors and the owner user's role descriptors (effectively limited by it).\nAn API key cannot retrieve any API keyâ€™s limited-by role descriptors (including itself) unless it has `manage_api_key` or higher privileges.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.query_api_keys#with_profile_uid": {
        "in": "query",
        "name": "with_profile_uid",
        "description": "Determines whether to also retrieve the profile UID for the API key owner principal.\nIf it exists, the profile UID is returned under the `profile_uid` response field for each API key.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.query_api_keys#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Determines whether aggregation names are prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.query_user#with_profile_uid": {
        "in": "query",
        "name": "with_profile_uid",
        "description": "Determines whether to retrieve the user profile UID, if it exists, for the users.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.suggest_user_profiles#data": {
        "in": "query",
        "name": "data",
        "description": "A comma-separated list of filters for the `data` field of the profile document.\nTo return all content use `data=*`.\nTo return a subset of content, use `data=<key>` to retrieve content nested under the specified `<key>`.\nBy default, the API returns no `data` content.\nIt is an error to specify `data` as both the query parameter and the request body field.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "security.update_user_profile_data#uid": {
        "in": "path",
        "name": "uid",
        "description": "A unique identifier for the user profile.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/security._types:UserProfileId"
        },
        "style": "simple"
      },
      "security.update_user_profile_data#if_seq_no": {
        "in": "query",
        "name": "if_seq_no",
        "description": "Only perform the operation if the document has this sequence number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SequenceNumber"
        },
        "style": "form"
      },
      "security.update_user_profile_data#if_primary_term": {
        "in": "query",
        "name": "if_primary_term",
        "description": "Only perform the operation if the document has this primary term.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "security.update_user_profile_data#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation\nvisible to search.\nIf 'wait_for', it waits for a refresh to make this operation visible to search.\nIf 'false', nothing is done with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "shutdown.get_node#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Which node for which to retrieve the shutdown status",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "shutdown.get_node#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "shutdown.get_node#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "simulate.ingest#index": {
        "in": "path",
        "name": "index",
        "description": "The index to simulate ingesting into.\nThis value can be overridden by specifying an index on each document.\nIf you specify this parameter in the request path, it is used for any documents that do not explicitly specify an index argument.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "simulate.ingest#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "The pipeline to use as the default pipeline.\nThis value can be used to override the default pipeline of the index.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:PipelineName"
        },
        "style": "form"
      },
      "slm.get_lifecycle#policy_id": {
        "in": "path",
        "name": "policy_id",
        "description": "Comma-separated list of snapshot lifecycle policies to retrieve",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "slm.get_lifecycle#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "The period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "slm.get_lifecycle#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "snapshot.create#repository": {
        "in": "path",
        "name": "repository",
        "description": "Repository for the snapshot.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "snapshot.create#snapshot": {
        "in": "path",
        "name": "snapshot",
        "description": "Name of the snapshot. Must be unique in the repository.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "snapshot.create#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "snapshot.create#wait_for_completion": {
        "in": "query",
        "name": "wait_for_completion",
        "description": "If `true`, the request returns a response when the snapshot is complete. If `false`, the request returns a response when the snapshot initializes.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "snapshot.create_repository#repository": {
        "in": "path",
        "name": "repository",
        "description": "A repository name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "snapshot.create_repository#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Explicit operation timeout for connection to master node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "snapshot.create_repository#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Explicit operation timeout",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "snapshot.create_repository#verify": {
        "in": "query",
        "name": "verify",
        "description": "Whether to verify the repository after creation",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "snapshot.get_repository#repository": {
        "in": "path",
        "name": "repository",
        "description": "A comma-separated list of repository names",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "snapshot.get_repository#local": {
        "in": "query",
        "name": "local",
        "description": "Return local information, do not retrieve the state from master node (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "snapshot.get_repository#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Explicit operation timeout for connection to master node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "snapshot.status#repository": {
        "in": "path",
        "name": "repository",
        "description": "A repository name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "snapshot.status#snapshot": {
        "in": "path",
        "name": "snapshot",
        "description": "A comma-separated list of snapshot names",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "snapshot.status#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether to ignore unavailable snapshots, defaults to false which means a SnapshotMissingException is thrown",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "snapshot.status#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Explicit operation timeout for connection to master node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "sql.query#format": {
        "in": "query",
        "name": "format",
        "description": "The format for the response.\nYou can also specify a format using the `Accept` HTTP header.\nIf you specify both this parameter and the `Accept` HTTP header, this parameter takes precedence.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/sql.query:SqlFormat"
        },
        "style": "form"
      },
      "tasks.cancel#task_id": {
        "in": "path",
        "name": "task_id",
        "description": "The task identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TaskId"
        },
        "style": "simple"
      },
      "tasks.cancel#actions": {
        "in": "query",
        "name": "actions",
        "description": "A comma-separated list or wildcard expression of actions that is used to limit the request.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "tasks.cancel#nodes": {
        "in": "query",
        "name": "nodes",
        "description": "A comma-separated list of node IDs or names that is used to limit the request.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "tasks.cancel#parent_task_id": {
        "in": "query",
        "name": "parent_task_id",
        "description": "A parent task ID that is used to limit the tasks.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "tasks.cancel#wait_for_completion": {
        "in": "query",
        "name": "wait_for_completion",
        "description": "If true, the request blocks until all found tasks are complete.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "terms_enum#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and index aliases to search.\nWildcard (`*`) expressions are supported.\nTo search all data streams or indices, omit this parameter or use `*`  or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "termvectors#index": {
        "in": "path",
        "name": "index",
        "description": "The name of the index that contains the document.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "termvectors#id": {
        "in": "path",
        "name": "id",
        "description": "A unique identifier for the document.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "termvectors#fields": {
        "in": "query",
        "name": "fields",
        "description": "A comma-separated list or wildcard expressions of fields to include in the statistics.\nIt is used as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "termvectors#field_statistics": {
        "in": "query",
        "name": "field_statistics",
        "description": "If `true`, the response includes:\n\n* The document count (how many documents contain this field).\n* The sum of document frequencies (the sum of document frequencies for all terms in this field).\n* The sum of total term frequencies (the sum of total term frequencies of each term in this field).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#offsets": {
        "in": "query",
        "name": "offsets",
        "description": "If `true`, the response includes term offsets.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#payloads": {
        "in": "query",
        "name": "payloads",
        "description": "If `true`, the response includes term payloads.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#positions": {
        "in": "query",
        "name": "positions",
        "description": "If `true`, the response includes term positions.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#preference": {
        "in": "query",
        "name": "preference",
        "description": "The node or shard the operation should be performed on.\nIt is random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "termvectors#realtime": {
        "in": "query",
        "name": "realtime",
        "description": "If true, the request is real-time as opposed to near-real-time.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#routing": {
        "in": "query",
        "name": "routing",
        "description": "A custom value that is used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "termvectors#term_statistics": {
        "in": "query",
        "name": "term_statistics",
        "description": "If `true`, the response includes:\n\n* The total term frequency (how often a term occurs in all documents).\n* The document frequency (the number of documents containing the current term).\n\nBy default these values are not returned since term statistics can have a serious performance impact.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#version": {
        "in": "query",
        "name": "version",
        "description": "If `true`, returns the document version as part of a hit.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "termvectors#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "The version type.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#column_names": {
        "in": "query",
        "name": "column_names",
        "description": "If the format is `delimited`, you can specify the column names in a comma-separated list.\nIf this parameter is not specified, the structure finder uses the column names from the header row of the text.\nIf the text does not have a header role, columns are named \"column1\", \"column2\", \"column3\", for example.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#delimiter": {
        "in": "query",
        "name": "delimiter",
        "description": "If you the format is `delimited`, you can specify the character used to delimit the values in each row.\nOnly a single character is supported; the delimiter cannot have multiple characters.\nBy default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (`|`).\nIn this default scenario, all rows must have the same number of fields for the delimited format to be detected.\nIf you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#ecs_compatibility": {
        "in": "query",
        "name": "ecs_compatibility",
        "description": "The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nThis setting primarily has an impact when a whole message Grok pattern such as `%{CATALINALOG}` matches the input.\nIf the structure finder identifies a common structure but has no idea of meaning then generic field names such as `path`, `ipaddress`, `field1`, and `field2` are used in the `grok_pattern` output, with the intention that a user who knows the meanings rename these fields before using it.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/text_structure._types:EcsCompatibilityType"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#explain": {
        "in": "query",
        "name": "explain",
        "description": "If this parameter is set to true, the response includes a field named `explanation`, which is an array of strings that indicate how the structure finder produced its result.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#format": {
        "in": "query",
        "name": "format",
        "description": "The high level structure of the text.\nBy default, the API chooses the format.\nIn this default scenario, all rows must have the same number of fields for a delimited format to be detected.\nIf the format is `delimited` and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/text_structure._types:FormatType"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#grok_pattern": {
        "in": "query",
        "name": "grok_pattern",
        "description": "If the format is `semi_structured_text`, you can specify a Grok pattern that is used to extract fields from every message in the text.\nThe name of the timestamp field in the Grok pattern must match what is specified in the `timestamp_field` parameter.\nIf that parameter is not specified, the name of the timestamp field in the Grok pattern must match \"timestamp\".\nIf `grok_pattern` is not specified, the structure finder creates a Grok pattern.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:GrokPattern"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#quote": {
        "in": "query",
        "name": "quote",
        "description": "If the format is `delimited`, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character.\nOnly a single character is supported.\nIf this parameter is not specified, the default value is a double quote (`\"`).\nIf your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#should_trim_fields": {
        "in": "query",
        "name": "should_trim_fields",
        "description": "If the format is `delimited`, you can specify whether values between delimiters should have whitespace trimmed from them.\nIf this parameter is not specified and the delimiter is pipe (`|`), the default value is true.\nOtherwise, the default value is `false`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "The maximum amount of time that the structure analysis can take.\nIf the analysis is still running when the timeout expires, it will be stopped.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#timestamp_field": {
        "in": "query",
        "name": "timestamp_field",
        "description": "The name of the field that contains the primary timestamp of each record in the text.\nIn particular, if the text was ingested into an index, this is the field that would be used to populate the `@timestamp` field.\n\nIf the format is `semi_structured_text`, this field must match the name of the appropriate extraction in the `grok_pattern`.\nTherefore, for semi-structured text, it is best not to specify this parameter unless `grok_pattern` is also specified.\n\nFor structured text, if you specify this parameter, the field must exist within the text.\n\nIf this parameter is not specified, the structure finder makes a decision about which field (if any) is the primary timestamp field.\nFor structured text, it is not compulsory to have a timestamp in the text.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "text_structure.find_message_structure#timestamp_format": {
        "in": "query",
        "name": "timestamp_format",
        "description": "The Java time format of the timestamp field in the text.\nOnly a subset of Java time format letter groups are supported:\n\n* `a`\n* `d`\n* `dd`\n* `EEE`\n* `EEEE`\n* `H`\n* `HH`\n* `h`\n* `M`\n* `MM`\n* `MMM`\n* `MMMM`\n* `mm`\n* `ss`\n* `XX`\n* `XXX`\n* `yy`\n* `yyyy`\n* `zzz`\n\nAdditionally `S` letter groups (fractional seconds) of length one to nine are supported providing they occur after `ss` and are separated from the `ss` by a period (`.`), comma (`,`), or colon (`:`).\nSpacing and punctuation is also permitted with the exception a question mark (`?`), newline, and carriage return, together with literal text enclosed in single quotes.\nFor example, `MM/dd HH.mm.ss,SSSSSS 'in' yyyy` is a valid override format.\n\nOne valuable use case for this parameter is when the format is semi-structured text, there are multiple timestamp formats in the text, and you know which format corresponds to the primary timestamp, but you do not want to specify the full `grok_pattern`.\nAnother is when the timestamp format is one that the structure finder does not consider by default.\n\nIf this parameter is not specified, the structure finder chooses the best format from a built-in set.\n\nIf the special value `null` is specified, the structure finder will not look for a primary timestamp in the text.\nWhen the format is semi-structured text, this will result in the structure finder treating the text as single-line messages.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "text_structure.test_grok_pattern#ecs_compatibility": {
        "in": "query",
        "name": "ecs_compatibility",
        "description": "The mode of compatibility with ECS compliant Grok patterns.\nUse this parameter to specify whether to use ECS Grok patterns instead of legacy ones when the structure finder creates a Grok pattern.\nValid values are `disabled` and `v1`.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "transform.get_transform#transform_id": {
        "in": "path",
        "name": "transform_id",
        "description": "Identifier for the transform. It can be a transform identifier or a\nwildcard expression. You can get information for all transforms by using\n`_all`, by specifying `*` as the `<transform_id>`, or by omitting the\n`<transform_id>`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "transform.get_transform#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "transform.get_transform#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of transforms.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "transform.get_transform#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of transforms to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "transform.get_transform#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Excludes fields that were automatically added when creating the\ntransform. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "transform.preview_transform#transform_id": {
        "in": "path",
        "name": "transform_id",
        "description": "Identifier for the transform to preview. If you specify this path parameter, you cannot provide transform\nconfiguration details in the request body.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "transform.preview_transform#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the\ntimeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "watcher.ack_watch#watch_id": {
        "in": "path",
        "name": "watch_id",
        "description": "The watch identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "watcher.ack_watch#action_id": {
        "in": "path",
        "name": "action_id",
        "description": "A comma-separated list of the action identifiers to acknowledge.\nIf you omit this parameter, all of the actions of the watch are acknowledged.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "watcher.activate_watch#watch_id": {
        "in": "path",
        "name": "watch_id",
        "description": "The watch identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "watcher.deactivate_watch#watch_id": {
        "in": "path",
        "name": "watch_id",
        "description": "The watch identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "watcher.execute_watch#id": {
        "in": "path",
        "name": "id",
        "description": "The watch identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "watcher.execute_watch#debug": {
        "in": "query",
        "name": "debug",
        "description": "Defines whether the watch runs in debug mode.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "watcher.put_watch#id": {
        "in": "path",
        "name": "id",
        "description": "The identifier for the watch.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "watcher.put_watch#active": {
        "in": "query",
        "name": "active",
        "description": "The initial state of the watch.\nThe default value is `true`, which means the watch is active by default.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "watcher.put_watch#if_primary_term": {
        "in": "query",
        "name": "if_primary_term",
        "description": "only update the watch if the last operation that has changed the watch has the specified primary term",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "watcher.put_watch#if_seq_no": {
        "in": "query",
        "name": "if_seq_no",
        "description": "only update the watch if the last operation that has changed the watch has the specified sequence number",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SequenceNumber"
        },
        "style": "form"
      },
      "watcher.put_watch#version": {
        "in": "query",
        "name": "version",
        "description": "Explicit version number for concurrency control",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "watcher.stats#metric": {
        "in": "path",
        "name": "metric",
        "description": "Defines which additional metrics are included in the response.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/watcher.stats:WatcherMetric"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/watcher.stats:WatcherMetric"
              }
            }
          ]
        },
        "style": "simple"
      },
      "watcher.stats#emit_stacktraces": {
        "in": "query",
        "name": "emit_stacktraces",
        "description": "Defines whether stack traces are generated for each watch that is running.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "watcher.stats#metric_": {
        "in": "query",
        "name": "metric",
        "description": "Defines which additional metrics are included in the response.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/watcher.stats:WatcherMetric"
            },
            {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/watcher.stats:WatcherMetric"
              }
            }
          ]
        },
        "style": "form"
      }
    },
    "requestBodies": {
      "async_search.submit": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "collapse": {
                  "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
                },
                "explain": {
                  "description": "If true, returns detailed information about score computation as part of a hit.",
                  "type": "boolean"
                },
                "ext": {
                  "description": "Configuration of search extensions defined by Elasticsearch plugins.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "from": {
                  "description": "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.",
                  "type": "number"
                },
                "highlight": {
                  "$ref": "#/components/schemas/_global.search._types:Highlight"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "indices_boost": {
                  "description": "Boosts the _score of documents from specified indices.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                "docvalue_fields": {
                  "description": "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "knn": {
                  "description": "Defines the approximate kNN search to run.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types:KnnSearch"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:KnnSearch"
                      }
                    }
                  ]
                },
                "min_score": {
                  "description": "Minimum _score for matching documents. Documents with a lower _score are\nnot included in the search results.",
                  "type": "number"
                },
                "post_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "profile": {
                  "type": "boolean"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "rescore": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_global.search._types:Rescore"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.search._types:Rescore"
                      }
                    }
                  ]
                },
                "script_fields": {
                  "description": "Retrieve a script evaluation (based on different fields) for each hit.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types:ScriptField"
                  }
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                },
                "size": {
                  "description": "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.",
                  "type": "number"
                },
                "slice": {
                  "$ref": "#/components/schemas/_types:SlicedScroll"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "suggest": {
                  "$ref": "#/components/schemas/_global.search._types:Suggester"
                },
                "terminate_after": {
                  "description": "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.",
                  "type": "number"
                },
                "timeout": {
                  "description": "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
                  "type": "string"
                },
                "track_scores": {
                  "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
                  "type": "boolean"
                },
                "version": {
                  "description": "If true, returns document version as part of a hit.",
                  "type": "boolean"
                },
                "seq_no_primary_term": {
                  "description": "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.",
                  "type": "boolean"
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "pit": {
                  "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "stats": {
                  "description": "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "bulk": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.bulk:OperationContainer"
                  },
                  {
                    "$ref": "#/components/schemas/_global.bulk:UpdateAction"
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            }
          }
        },
        "required": true
      },
      "clear_scroll": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollIds"
                }
              }
            }
          }
        }
      },
      "cluster.allocation_explain": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "current_node": {
                  "description": "Specifies the node ID or the name of the node to only explain a shard that is currently located on the specified node.",
                  "type": "string"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "primary": {
                  "description": "If true, returns explanation for the primary shard for the given shard ID.",
                  "type": "boolean"
                },
                "shard": {
                  "description": "Specifies the ID of the shard that you would like an explanation for.",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "cluster.put_component_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "template": {
                  "$ref": "#/components/schemas/indices._types:IndexState"
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "deprecated": {
                  "description": "Marks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.",
                  "type": "boolean"
                }
              },
              "required": [
                "template"
              ]
            }
          }
        },
        "required": true
      },
      "connector.put": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "description": {
                  "type": "string"
                },
                "index_name": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "is_native": {
                  "type": "boolean"
                },
                "language": {
                  "type": "string"
                },
                "name": {
                  "type": "string"
                },
                "service_type": {
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "count": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            }
          }
        }
      },
      "create": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        },
        "required": true
      },
      "eql.search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "description": "EQL query you wish to run.",
                  "type": "string"
                },
                "case_sensitive": {
                  "type": "boolean"
                },
                "event_category_field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "tiebreaker_field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "timestamp_field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "fetch_size": {
                  "$ref": "#/components/schemas/_types:uint"
                },
                "filter": {
                  "description": "Query, written in Query DSL, used to filter the events on which the EQL query runs.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                      }
                    }
                  ]
                },
                "keep_alive": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "keep_on_completion": {
                  "type": "boolean"
                },
                "wait_for_completion_timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "size": {
                  "$ref": "#/components/schemas/_types:uint"
                },
                "fields": {
                  "description": "Array of wildcard (*) patterns. The response returns values for field names matching these patterns in the fields property of each hit.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                      }
                    }
                  ]
                },
                "result_position": {
                  "$ref": "#/components/schemas/eql.search:ResultPosition"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                }
              },
              "required": [
                "query"
              ]
            }
          }
        },
        "required": true
      },
      "explain": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            }
          }
        }
      },
      "field_caps": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "index_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                }
              }
            }
          }
        }
      },
      "fleet.msearch": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.msearch:RequestItem"
              }
            }
          }
        },
        "required": true
      },
      "fleet.search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "collapse": {
                  "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
                },
                "explain": {
                  "description": "If true, returns detailed information about score computation as part of a hit.",
                  "type": "boolean"
                },
                "ext": {
                  "description": "Configuration of search extensions defined by Elasticsearch plugins.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "from": {
                  "description": "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.",
                  "type": "number"
                },
                "highlight": {
                  "$ref": "#/components/schemas/_global.search._types:Highlight"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "indices_boost": {
                  "description": "Boosts the _score of documents from specified indices.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                "docvalue_fields": {
                  "description": "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "min_score": {
                  "description": "Minimum _score for matching documents. Documents with a lower _score are\nnot included in the search results.",
                  "type": "number"
                },
                "post_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "profile": {
                  "type": "boolean"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "rescore": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_global.search._types:Rescore"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.search._types:Rescore"
                      }
                    }
                  ]
                },
                "script_fields": {
                  "description": "Retrieve a script evaluation (based on different fields) for each hit.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types:ScriptField"
                  }
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                },
                "size": {
                  "description": "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.",
                  "type": "number"
                },
                "slice": {
                  "$ref": "#/components/schemas/_types:SlicedScroll"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "suggest": {
                  "$ref": "#/components/schemas/_global.search._types:Suggester"
                },
                "terminate_after": {
                  "description": "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.",
                  "type": "number"
                },
                "timeout": {
                  "description": "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
                  "type": "string"
                },
                "track_scores": {
                  "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
                  "type": "boolean"
                },
                "version": {
                  "description": "If true, returns document version as part of a hit.",
                  "type": "boolean"
                },
                "seq_no_primary_term": {
                  "description": "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.",
                  "type": "boolean"
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "pit": {
                  "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "stats": {
                  "description": "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "graph.explore": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "$ref": "#/components/schemas/graph._types:Hop"
                },
                "controls": {
                  "$ref": "#/components/schemas/graph._types:ExploreControls"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "vertices": {
                  "description": "Specifies one or more fields that contain the terms you want to include in the graph as vertices.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/graph._types:VertexDefinition"
                  }
                }
              }
            }
          }
        }
      },
      "index": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        },
        "required": true
      },
      "indices.analyze": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "analyzer": {
                  "description": "The name of the analyzer that should be applied to the provided `text`.\nThis could be a built-in analyzer, or an analyzer thatâ€™s been configured in the index.",
                  "type": "string"
                },
                "attributes": {
                  "description": "Array of token attributes used to filter the output of the `explain` parameter.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "char_filter": {
                  "description": "Array of character filters used to preprocess characters before the tokenizer.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.analysis:CharFilter"
                  }
                },
                "explain": {
                  "description": "If `true`, the response includes token attributes and additional details.",
                  "type": "boolean"
                },
                "field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "filter": {
                  "description": "Array of token filters used to apply after the tokenizer.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.analysis:TokenFilter"
                  }
                },
                "normalizer": {
                  "description": "Normalizer to use to convert text into a single token.",
                  "type": "string"
                },
                "text": {
                  "$ref": "#/components/schemas/indices.analyze:TextToAnalyze"
                },
                "tokenizer": {
                  "$ref": "#/components/schemas/_types.analysis:Tokenizer"
                }
              }
            }
          }
        }
      },
      "indices.clone": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "Aliases for the resulting index.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "settings": {
                  "description": "Configuration options for the target index.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "indices.put_alias": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "index_routing": {
                  "$ref": "#/components/schemas/_types:Routing"
                },
                "is_write_index": {
                  "description": "If `true`, sets the write index or data stream for the alias.\nIf an alias points to multiple indices or data streams and `is_write_index` isnâ€™t set, the alias rejects write requests.\nIf an index alias points to one index and `is_write_index` isnâ€™t set, the index automatically acts as the write index.\nData stream aliases donâ€™t automatically set a write data stream, even if the alias points to one data stream.",
                  "type": "boolean"
                },
                "routing": {
                  "$ref": "#/components/schemas/_types:Routing"
                },
                "search_routing": {
                  "$ref": "#/components/schemas/_types:Routing"
                }
              }
            }
          }
        }
      },
      "indices.put_index_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "index_patterns": {
                  "$ref": "#/components/schemas/_types:Indices"
                },
                "composed_of": {
                  "description": "An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:Name"
                  }
                },
                "template": {
                  "$ref": "#/components/schemas/indices.put_index_template:IndexTemplateMapping"
                },
                "data_stream": {
                  "$ref": "#/components/schemas/indices._types:DataStreamVisibility"
                },
                "priority": {
                  "description": "Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
                  "type": "number"
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "allow_auto_create": {
                  "description": "This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.",
                  "type": "boolean"
                },
                "ignore_missing_component_templates": {
                  "description": "The configuration option ignore_missing_component_templates can be used when an index template\nreferences a component template that might not exist",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "deprecated": {
                  "description": "Marks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.",
                  "type": "boolean"
                }
              }
            }
          }
        },
        "required": true
      },
      "indices.put_mapping": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "date_detection": {
                  "description": "Controls whether dynamic date detection is enabled.",
                  "type": "boolean"
                },
                "dynamic": {
                  "$ref": "#/components/schemas/_types.mapping:DynamicMapping"
                },
                "dynamic_date_formats": {
                  "description": "If date detection is enabled then new string fields are checked\nagainst 'dynamic_date_formats' and if the value matches then\na new date field is added instead of string.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "dynamic_templates": {
                  "description": "Specify dynamic templates for the mapping.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types.mapping:DynamicTemplate"
                    }
                  }
                },
                "_field_names": {
                  "$ref": "#/components/schemas/_types.mapping:FieldNamesField"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "numeric_detection": {
                  "description": "Automatically map strings into numeric data types for all fields.",
                  "type": "boolean"
                },
                "properties": {
                  "description": "Mapping for a field. For new fields, this mapping can include:\n\n- Field name\n- Field data type\n- Mapping parameters",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.mapping:Property"
                  }
                },
                "_routing": {
                  "$ref": "#/components/schemas/_types.mapping:RoutingField"
                },
                "_source": {
                  "$ref": "#/components/schemas/_types.mapping:SourceField"
                },
                "runtime": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                }
              }
            }
          }
        },
        "required": true
      },
      "indices.put_settings": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/indices._types:IndexSettings"
            }
          }
        },
        "required": true
      },
      "indices.put_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "Aliases for the index.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "index_patterns": {
                  "description": "Array of wildcard expressions used to match the names\nof indices during creation.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                },
                "mappings": {
                  "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                },
                "order": {
                  "description": "Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower 'order' values are merged first. Templates with higher\n'order' values are merged later, overriding templates with lower values.",
                  "type": "number"
                },
                "settings": {
                  "$ref": "#/components/schemas/indices._types:IndexSettings"
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                }
              }
            }
          }
        },
        "required": true
      },
      "indices.rollover": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "Aliases for the target index.\nData streams do not support this parameter.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "conditions": {
                  "$ref": "#/components/schemas/indices.rollover:RolloverConditions"
                },
                "mappings": {
                  "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                },
                "settings": {
                  "description": "Configuration options for the index.\nData streams do not support this parameter.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "indices.shrink": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "The key is the alias name.\nIndex alias names support date math.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "settings": {
                  "description": "Configuration options for the target index.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "indices.simulate_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allow_auto_create": {
                  "description": "This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.",
                  "type": "boolean"
                },
                "index_patterns": {
                  "$ref": "#/components/schemas/_types:Indices"
                },
                "composed_of": {
                  "description": "An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:Name"
                  }
                },
                "template": {
                  "$ref": "#/components/schemas/indices.put_index_template:IndexTemplateMapping"
                },
                "data_stream": {
                  "$ref": "#/components/schemas/indices._types:DataStreamVisibility"
                },
                "priority": {
                  "description": "Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
                  "type": "number"
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "ignore_missing_component_templates": {
                  "description": "The configuration option ignore_missing_component_templates can be used when an index template\nreferences a component template that might not exist",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "deprecated": {
                  "description": "Marks this index template as deprecated. When creating or updating a non-deprecated index template\nthat uses deprecated components, Elasticsearch will emit a deprecation warning.",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "indices.split": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "Aliases for the resulting index.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "settings": {
                  "description": "Configuration options for the target index.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "indices.validate_query": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            }
          }
        }
      },
      "inference.inference": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "description": "Query input, required for rerank task.\nNot required for other tasks.",
                  "type": "string"
                },
                "input": {
                  "description": "Inference input.\nEither a string or an array of strings.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                },
                "task_settings": {
                  "$ref": "#/components/schemas/inference._types:TaskSettings"
                }
              },
              "required": [
                "input"
              ]
            }
          }
        }
      },
      "inference.put": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/inference._types:InferenceEndpoint"
            }
          }
        },
        "required": true
      },
      "inference.stream_inference": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "input": {
                  "description": "The text on which you want to perform the inference task.\nIt can be a single string or an array.\n\nNOTE: Inference endpoints for the completion task type currently only support a single string as input.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                }
              },
              "required": [
                "input"
              ]
            }
          }
        }
      },
      "inference.update": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/inference._types:InferenceEndpoint"
            }
          }
        },
        "required": true
      },
      "ingest.simulate": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "Sample documents to test in the pipeline.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest._types:Document"
                  }
                },
                "pipeline": {
                  "$ref": "#/components/schemas/ingest._types:Pipeline"
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        },
        "required": true
      },
      "knn_search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "docvalue_fields": {
                  "description": "The request returns doc values for field names matching these patterns\nin the `hits.fields` property of the response.\nIt accepts wildcard (`*`) patterns.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "filter": {
                  "description": "A query to filter the documents that can match. The kNN search will return the top\n`k` documents that also match this filter. The value can be a single query or a\nlist of queries. If `filter` isn't provided, all documents are allowed to match.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                      }
                    }
                  ]
                },
                "knn": {
                  "$ref": "#/components/schemas/_global.knn_search._types:Query"
                }
              },
              "required": [
                "knn"
              ]
            }
          }
        }
      },
      "license.post": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "license": {
                  "$ref": "#/components/schemas/license._types:License"
                },
                "licenses": {
                  "description": "A sequence of one or more JSON documents containing the license information.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/license._types:License"
                  }
                }
              }
            }
          }
        }
      },
      "mget": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "The documents you want to retrieve. Required if no index is specified in the request URI.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mget:Operation"
                  }
                },
                "ids": {
                  "$ref": "#/components/schemas/_types:Ids"
                }
              }
            }
          }
        },
        "required": true
      },
      "ml.delete_expired_data": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "requests_per_second": {
                  "description": "The desired requests per second for the deletion processes. The default\nbehavior is no throttling.",
                  "type": "number"
                },
                "timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                }
              }
            }
          }
        }
      },
      "ml.explain_data_frame_analytics": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "source": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                },
                "dest": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                },
                "analysis": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                },
                "description": {
                  "description": "A description of the job.",
                  "type": "string"
                },
                "model_memory_limit": {
                  "description": "The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try to\ncreate data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.",
                  "type": "string"
                },
                "max_num_threads": {
                  "description": "The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.",
                  "type": "number"
                },
                "analyzed_fields": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                },
                "allow_lazy_start": {
                  "description": "Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node.",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "ml.get_buckets": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "anomaly_score": {
                  "description": "Refer to the description for the `anomaly_score` query parameter.",
                  "type": "number"
                },
                "desc": {
                  "description": "Refer to the description for the `desc` query parameter.",
                  "type": "boolean"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "exclude_interim": {
                  "description": "Refer to the description for the `exclude_interim` query parameter.",
                  "type": "boolean"
                },
                "expand": {
                  "description": "Refer to the description for the `expand` query parameter.",
                  "type": "boolean"
                },
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                }
              }
            }
          }
        }
      },
      "ml.get_calendars": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                }
              }
            }
          }
        }
      },
      "ml.get_categories": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                }
              }
            }
          }
        }
      },
      "ml.get_influencers": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                }
              }
            }
          }
        }
      },
      "ml.get_model_snapshots": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "desc": {
                  "description": "Refer to the description for the `desc` query parameter.",
                  "type": "boolean"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                }
              }
            }
          }
        }
      },
      "ml.get_overall_buckets": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allow_no_match": {
                  "description": "Refer to the description for the `allow_no_match` query parameter.",
                  "type": "boolean"
                },
                "bucket_span": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "exclude_interim": {
                  "description": "Refer to the description for the `exclude_interim` query parameter.",
                  "type": "boolean"
                },
                "overall_score": {
                  "description": "Refer to the description for the `overall_score` query parameter.",
                  "oneOf": [
                    {
                      "type": "number"
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "top_n": {
                  "description": "Refer to the description for the `top_n` query parameter.",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "ml.get_records": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "desc": {
                  "description": "Refer to the description for the `desc` query parameter.",
                  "type": "boolean"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "exclude_interim": {
                  "description": "Refer to the description for the `exclude_interim` query parameter.",
                  "type": "boolean"
                },
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                },
                "record_score": {
                  "description": "Refer to the description for the `record_score` query parameter.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                }
              }
            }
          }
        }
      },
      "ml.infer_trained_model": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "An array of objects to pass to the model for inference. The objects should contain a fields matching your\nconfigured trained model input. Typically, for NLP models, the field name is `text_field`.\nCurrently, for NLP models, only a single value is allowed.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                },
                "inference_config": {
                  "$ref": "#/components/schemas/ml._types:InferenceConfigUpdateContainer"
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        },
        "required": true
      },
      "ml.preview_data_frame_analytics": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "config": {
                  "$ref": "#/components/schemas/ml.preview_data_frame_analytics:DataframePreviewConfig"
                }
              }
            }
          }
        }
      },
      "ml.preview_datafeed": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "datafeed_config": {
                  "$ref": "#/components/schemas/ml._types:DatafeedConfig"
                },
                "job_config": {
                  "$ref": "#/components/schemas/ml._types:JobConfig"
                }
              }
            }
          }
        }
      },
      "monitoring.bulk": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.bulk:OperationContainer"
                  },
                  {
                    "$ref": "#/components/schemas/_global.bulk:UpdateAction"
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            }
          }
        },
        "required": true
      },
      "msearch": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.msearch:RequestItem"
              }
            }
          }
        },
        "required": true
      },
      "msearch_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.msearch_template:RequestItem"
              }
            }
          }
        },
        "required": true
      },
      "mtermvectors": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "An array of existing or artificial documents.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mtermvectors:Operation"
                  }
                },
                "ids": {
                  "description": "A simplified syntax to specify documents by their ID if they're in the same index.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:Id"
                  }
                }
              }
            }
          }
        }
      },
      "nodes.reload_secure_settings": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "secure_settings_password": {
                  "$ref": "#/components/schemas/_types:Password"
                }
              }
            }
          }
        }
      },
      "put_script": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "script": {
                  "$ref": "#/components/schemas/_types:StoredScript"
                }
              },
              "required": [
                "script"
              ]
            }
          }
        },
        "required": true
      },
      "rank_eval": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "requests": {
                  "description": "A set of typical search requests, together with their provided ratings.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.rank_eval:RankEvalRequestItem"
                  }
                },
                "metric": {
                  "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetric"
                }
              },
              "required": [
                "requests"
              ]
            }
          }
        },
        "required": true
      },
      "render_search_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "file": {
                  "type": "string"
                },
                "params": {
                  "description": "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "source": {
                  "description": "An inline search template.\nIt supports the same parameters as the search API's request body.\nThese parameters also support Mustache variables.\nIf no `id` or `<templated-id>` is specified, this parameter is required.",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "rollup.rollup_search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/rollup-agg-limitations.html"
                  },
                  "description": "Specifies aggregations.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "size": {
                  "description": "Must be zero if set, as rollups work on pre-aggregated data.",
                  "type": "number"
                }
              }
            }
          }
        },
        "required": true
      },
      "scripts_painless_execute": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "description": "The context that the script should run in.",
                  "type": "string"
                },
                "context_setup": {
                  "$ref": "#/components/schemas/_global.scripts_painless_execute:PainlessContextSetup"
                },
                "script": {
                  "$ref": "#/components/schemas/_types:Script"
                }
              }
            }
          }
        }
      },
      "scroll": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "scroll": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollId"
                }
              },
              "required": [
                "scroll_id"
              ]
            }
          }
        }
      },
      "search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "description": "Defines the aggregations that are run as part of the search request.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "collapse": {
                  "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
                },
                "explain": {
                  "description": "If `true`, the request returns detailed information about score computation as part of a hit.",
                  "type": "boolean"
                },
                "ext": {
                  "description": "Configuration of search extensions defined by Elasticsearch plugins.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "from": {
                  "description": "The starting document offset, which must be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "highlight": {
                  "$ref": "#/components/schemas/_global.search._types:Highlight"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "indices_boost": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-filter-context.html#relevance-scores"
                  },
                  "description": "Boost the `_score` of documents from specified indices.\nThe boost value is the factor by which scores are multiplied.\nA boost value greater than `1.0` increases the score.\nA boost value between `0` and `1.0` decreases the score.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                "docvalue_fields": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-fields.html#docvalue-fields"
                  },
                  "description": "An array of wildcard (`*`) field patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "knn": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/knn-search.html#approximate-knn"
                  },
                  "description": "The approximate kNN search to run.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types:KnnSearch"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:KnnSearch"
                      }
                    }
                  ]
                },
                "rank": {
                  "$ref": "#/components/schemas/_types:RankContainer"
                },
                "min_score": {
                  "description": "The minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in the search results.",
                  "type": "number"
                },
                "post_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "profile": {
                  "description": "Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution.",
                  "type": "boolean"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "rescore": {
                  "description": "Can be used to improve precision by reordering just the top (for example 100 - 500) documents returned by the `query` and `post_filter` phases.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_global.search._types:Rescore"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.search._types:Rescore"
                      }
                    }
                  ]
                },
                "retriever": {
                  "$ref": "#/components/schemas/_types:RetrieverContainer"
                },
                "script_fields": {
                  "description": "Retrieve a script evaluation (based on different fields) for each hit.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types:ScriptField"
                  }
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                },
                "size": {
                  "description": "The number of hits to return, which must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` property.",
                  "type": "number"
                },
                "slice": {
                  "$ref": "#/components/schemas/_types:SlicedScroll"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "description": "An array of wildcard (`*`) field patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "suggest": {
                  "$ref": "#/components/schemas/_global.search._types:Suggester"
                },
                "terminate_after": {
                  "description": "The maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\n\nIMPORTANT: Use with caution.\nElasticsearch applies this property to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this property for requests that target data streams with backing indices across multiple data tiers.\n\nIf set to `0` (default), the query does not terminate early.",
                  "type": "number"
                },
                "timeout": {
                  "description": "The period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
                  "type": "string"
                },
                "track_scores": {
                  "description": "If `true`, calculate and return document scores, even if the scores are not used for sorting.",
                  "type": "boolean"
                },
                "version": {
                  "description": "If `true`, the request returns the document version as part of a hit.",
                  "type": "boolean"
                },
                "seq_no_primary_term": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/optimistic-concurrency-control.html"
                  },
                  "description": "If `true`, the request returns sequence number and primary term of the last modification of each hit.",
                  "type": "boolean"
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "pit": {
                  "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "stats": {
                  "description": "The stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "search_application.search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "Query parameters specific to this request, which will override any defaults specified in the template.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "search_mvt": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggs": {
                  "description": "Sub-aggregations for the geotile_grid.\n\nIt supports the following aggregation types:\n\n- `avg`\n- `boxplot`\n- `cardinality`\n- `extended stats`\n- `max`\n- `median absolute deviation`\n- `min`\n- `percentile`\n- `percentile-rank`\n- `stats`\n- `sum`\n- `value count`\n\nThe aggregation names can't start with `_mvt_`. The `_mvt_` prefix is reserved for internal aggregations.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "buffer": {
                  "description": "The size, in pixels, of a clipping buffer outside the tile. This allows renderers\nto avoid outline artifacts from geometries that extend past the extent of the tile.",
                  "type": "number"
                },
                "exact_bounds": {
                  "description": "If `false`, the meta layer's feature is the bounding box of the tile.\nIf `true`, the meta layer's feature is a bounding box resulting from a\n`geo_bounds` aggregation. The aggregation runs on <field> values that intersect\nthe `<zoom>/<x>/<y>` tile with `wrap_longitude` set to `false`. The resulting\nbounding box may be larger than the vector tile.",
                  "type": "boolean"
                },
                "extent": {
                  "description": "The size, in pixels, of a side of the tile. Vector tiles are square with equal sides.",
                  "type": "number"
                },
                "fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "grid_agg": {
                  "$ref": "#/components/schemas/_global.search_mvt._types:GridAggregationType"
                },
                "grid_precision": {
                  "description": "Additional zoom levels available through the aggs layer. For example, if `<zoom>` is `7`\nand `grid_precision` is `8`, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndon't include the aggs layer.",
                  "type": "number"
                },
                "grid_type": {
                  "$ref": "#/components/schemas/_global.search_mvt._types:GridType"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "size": {
                  "description": "The maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results don't include the hits layer.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "with_labels": {
                  "description": "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.\n\n* `Point` and `MultiPoint` features will have one of the points selected.\n* `Polygon` and `MultiPolygon` features will have a single point generated, either the centroid, if it is within the polygon, or another point within the polygon selected from the sorted triangle-tree.\n* `LineString` features will likewise provide a roughly central point selected from the triangle-tree.\n* The aggregation results will provide one central point for each aggregation bucket.\n\nAll attributes from the original features will also be copied to the new label features.\nIn addition, the new features will be distinguishable using the tag `_mvt_label_position`.",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "search_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "explain": {
                  "description": "If `true`, returns detailed information about score calculation as part of each hit.\nIf you specify both this and the `explain` query parameter, the API uses only the query parameter.",
                  "type": "boolean"
                },
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "params": {
                  "description": "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "profile": {
                  "description": "If `true`, the query execution is profiled.",
                  "type": "boolean"
                },
                "source": {
                  "description": "An inline search template. Supports the same parameters as the search API's\nrequest body. It also supports Mustache variables. If no `id` is specified, this\nparameter is required.",
                  "type": "string"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.change_password": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "password": {
                  "$ref": "#/components/schemas/_types:Password"
                },
                "password_hash": {
                  "description": "A hash of the new password value. This must be produced using the same\nhashing algorithm as has been configured for password storage. For more details,\nsee the explanation of the `xpack.security.authc.password_hashing.algorithm`\nsetting.",
                  "type": "string"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.create_api_key": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "expiration": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "role_descriptors": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html"
                  },
                  "description": "An array of role descriptors for this API key.\nWhen it is not specified or it is an empty array, the API key will have a point in time snapshot of permissions of the authenticated user.\nIf you supply role descriptors, the resultant permissions are an intersection of API keys permissions and the authenticated user's permissions thereby limiting the access scope for API keys.\nThe structure of role descriptor is the same as the request for the create role API.\nFor more details, refer to the create or update roles API.\n\nNOTE: Due to the way in which this permission intersection is calculated, it is not possible to create an API key that is a child of another API key, unless the derived key is created without any privileges.\nIn this case, you must explicitly specify a role descriptor with no privileges.\nThe derived API key can be used for authentication; it will not have authority to call Elasticsearch APIs.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security._types:RoleDescriptor"
                  }
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.has_privileges": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "application": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security.has_privileges:ApplicationPrivilegesCheck"
                  }
                },
                "cluster": {
                  "description": "A list of the cluster privileges that you want to check.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ClusterPrivilege"
                  }
                },
                "index": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security.has_privileges:IndexPrivilegesCheck"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "security.has_privileges_user_profile": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "uids": {
                  "description": "A list of profile IDs. The privileges are checked for associated users of the profiles.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfileId"
                  }
                },
                "privileges": {
                  "$ref": "#/components/schemas/security.has_privileges_user_profile:PrivilegesCheck"
                }
              },
              "required": [
                "uids",
                "privileges"
              ]
            }
          }
        },
        "required": true
      },
      "security.put_privileges": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security.put_privileges:Actions"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.put_role": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "applications": {
                  "description": "A list of application privilege entries.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
                  }
                },
                "cluster": {
                  "description": "A list of cluster privileges. These privileges define the cluster-level actions for users with this role.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ClusterPrivilege"
                  }
                },
                "global": {
                  "description": "An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "indices": {
                  "description": "A list of indices permissions entries.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:IndicesPrivileges"
                  }
                },
                "remote_indices": {
                  "description": "A list of remote indices permissions entries.\n\nNOTE: Remote indices are effective for remote clusters configured with the API key based model.\nThey have no effect for remote clusters configured with the certificate based model.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:RemoteIndicesPrivileges"
                  }
                },
                "remote_cluster": {
                  "description": "A list of remote cluster permissions entries.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:RemoteClusterPrivileges"
                  }
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "run_as": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/run-as-privilege.html"
                  },
                  "description": "A list of users that the owners of this role can impersonate. *Note*: in Serverless, the run-as feature is disabled. For API compatibility, you can still specify an empty `run_as` field, but a non-empty list will be rejected.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "description": {
                  "description": "Optional description of the role descriptor",
                  "type": "string"
                },
                "transient_metadata": {
                  "description": "Indicates roles that might be incompatible with the current cluster license, specifically roles with document and field level security. When the cluster license doesnâ€™t allow certain features for a given role, this parameter is updated dynamically to list the incompatible features. If `enabled` is `false`, the role is ignored, but is still listed in the response from the authenticate API.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "security.put_role_mapping": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "enabled": {
                  "description": "Mappings that have `enabled` set to `false` are ignored when role mapping is performed.",
                  "type": "boolean"
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "roles": {
                  "description": "A list of role names that are granted to the users that match the role mapping rules.\nExactly one of `roles` or `role_templates` must be specified.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "role_templates": {
                  "description": "A list of Mustache templates that will be evaluated to determine the roles names that should granted to the users that match the role mapping rules.\nExactly one of `roles` or `role_templates` must be specified.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:RoleTemplate"
                  }
                },
                "rules": {
                  "$ref": "#/components/schemas/security._types:RoleMappingRule"
                },
                "run_as": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "security.put_user": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "username": {
                  "$ref": "#/components/schemas/_types:Username"
                },
                "email": {
                  "description": "The email of the user.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "nullable": true,
                      "type": "string"
                    }
                  ]
                },
                "full_name": {
                  "description": "The full name of the user.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "nullable": true,
                      "type": "string"
                    }
                  ]
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "password": {
                  "$ref": "#/components/schemas/_types:Password"
                },
                "password_hash": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-settings.html#hashing-settings"
                  },
                  "description": "A hash of the user's password.\nThis must be produced using the same hashing algorithm as has been configured for password storage.\nFor more details, see the explanation of the `xpack.security.authc.password_hashing.algorithm` setting in the user cache and password hash algorithm documentation.\nUsing this parameter allows the client to pre-hash the password for performance and/or confidentiality reasons.\nThe `password` parameter and the `password_hash` parameter cannot be used in the same request.",
                  "type": "string"
                },
                "roles": {
                  "description": "A set of roles the user has.\nThe roles determine the user's access permissions.\nTo create a user without any roles, specify an empty list (`[]`).",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "enabled": {
                  "description": "Specifies whether the user is enabled.",
                  "type": "boolean"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.query_api_keys": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "description": "Any aggregations to run over the corpus of returned API keys.\nAggregations and queries work together. Aggregations are computed only on the API keys that match the query.\nThis supports only a subset of aggregation types, namely: `terms`, `range`, `date_range`, `missing`,\n`cardinality`, `value_count`, `composite`, `filter`, and `filters`.\nAdditionally, aggregations only run over the same subset of fields that query works with.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security.query_api_keys:ApiKeyAggregationContainer"
                  }
                },
                "query": {
                  "$ref": "#/components/schemas/security.query_api_keys:ApiKeyQueryContainer"
                },
                "from": {
                  "description": "The starting document offset.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "size": {
                  "description": "The number of hits to return.\nIt must not be negative.\nThe `size` parameter can be set to `0`, in which case no API key matches are returned, only the aggregation results.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                }
              }
            }
          }
        }
      },
      "security.query_role": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/security.query_role:RoleQueryContainer"
                },
                "from": {
                  "description": "The starting document offset.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "size": {
                  "description": "The number of hits to return.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                }
              }
            }
          }
        }
      },
      "security.query_user": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/security.query_user:UserQueryContainer"
                },
                "from": {
                  "description": "The starting document offset.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "size": {
                  "description": "The number of hits to return.\nIt must not be negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                }
              }
            }
          }
        }
      },
      "security.suggest_user_profiles": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "name": {
                  "description": "A query string used to match name-related fields in user profile documents.\nName-related fields are the user's `username`, `full_name`, and `email`.",
                  "type": "string"
                },
                "size": {
                  "description": "The number of profiles to return.",
                  "type": "number"
                },
                "data": {
                  "description": "A comma-separated list of filters for the `data` field of the profile document.\nTo return all content use `data=*`.\nTo return a subset of content, use `data=<key>` to retrieve content nested under the specified `<key>`.\nBy default, the API returns no `data` content.\nIt is an error to specify `data` as both the query parameter and the request body field.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                },
                "hint": {
                  "$ref": "#/components/schemas/security.suggest_user_profiles:Hint"
                }
              }
            }
          }
        }
      },
      "security.update_user_profile_data": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "labels": {
                  "description": "Searchable data that you want to associate with the user profile.\nThis field supports a nested data structure.\nWithin the labels object, top-level keys cannot begin with an underscore (`_`) or contain a period (`.`).",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "data": {
                  "description": "Non-searchable data that you want to associate with the user profile.\nThis field supports a nested data structure.\nWithin the `data` object, top-level keys cannot begin with an underscore (`_`) or contain a period (`.`).\nThe data object is not searchable, but can be retrieved with the get user profile API.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "simulate.ingest": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "Sample documents to test in the pipeline.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest._types:Document"
                  }
                },
                "component_template_substitutions": {
                  "description": "A map of component template names to substitute component template definition objects.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/cluster._types:ComponentTemplateNode"
                  }
                },
                "index_template_substitutions": {
                  "description": "A map of index template names to substitute index template definition objects.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:IndexTemplate"
                  }
                },
                "mapping_addition": {
                  "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                },
                "pipeline_substitutions": {
                  "description": "Pipelines to test.\nIf you donâ€™t specify the `pipeline` request path parameter, this parameter is required.\nIf you specify both this and the request path parameter, the API only uses the request path parameter.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/ingest._types:Pipeline"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        },
        "required": true
      },
      "snapshot.create": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "ignore_unavailable": {
                  "description": "If `true`, the request ignores data streams and indices in `indices` that are missing or closed. If `false`, the request returns an error for any data stream or index that is missing or closed.",
                  "type": "boolean"
                },
                "include_global_state": {
                  "description": "If `true`, the current cluster state is included in the snapshot. The cluster state includes persistent cluster settings, composable index templates, legacy index templates, ingest pipelines, and ILM policies. It also includes data stored in system indices, such as Watches and task records (configurable via `feature_states`).",
                  "type": "boolean"
                },
                "indices": {
                  "$ref": "#/components/schemas/_types:Indices"
                },
                "feature_states": {
                  "description": "Feature states to include in the snapshot. Each feature state includes one or more system indices containing related data. You can view a list of eligible features using the get features API. If `include_global_state` is `true`, all current feature states are included by default. If `include_global_state` is `false`, no feature states are included by default.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "partial": {
                  "description": "If `true`, allows restoring a partial snapshot of indices with unavailable shards. Only shards that were successfully included in the snapshot will be restored. All missing shards will be recreated as empty. If `false`, the entire restore operation will fail if one or more indices included in the snapshot do not have all primary shards available.",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "snapshot.create_repository": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/snapshot._types:Repository"
            }
          }
        },
        "required": true
      },
      "sql.query": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allow_partial_search_results": {
                  "description": "If `true`, the response has partial results when there are shard request timeouts or shard failures.\nIf `false`, the API returns an error with no partial results.",
                  "type": "boolean"
                },
                "catalog": {
                  "description": "The default catalog (cluster) for queries.\nIf unspecified, the queries execute on the data in the local cluster only.",
                  "type": "string"
                },
                "columnar": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-rest-columnar.html"
                  },
                  "description": "If `true`, the results are in a columnar fashion: one row represents all the values of a certain column from the current page of results.\nThe API supports this parameter only for CBOR, JSON, SMILE, and YAML responses.",
                  "type": "boolean"
                },
                "cursor": {
                  "description": "The cursor used to retrieve a set of paginated results.\nIf you specify a cursor, the API only uses the `columnar` and `time_zone` request body parameters.\nIt ignores other request body parameters.",
                  "type": "string"
                },
                "fetch_size": {
                  "description": "The maximum number of rows (or entries) to return in one response.",
                  "type": "number"
                },
                "field_multi_value_leniency": {
                  "description": "If `false`, the API returns an exception when encountering multiple values for a field.\nIf `true`, the API is lenient and returns the first value from the array with no guarantee of consistent results.",
                  "type": "boolean"
                },
                "filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "index_using_frozen": {
                  "description": "If `true`, the search can run on frozen indices.",
                  "type": "boolean"
                },
                "keep_alive": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "keep_on_completion": {
                  "description": "If `true`, Elasticsearch stores synchronous searches if you also specify the `wait_for_completion_timeout` parameter.\nIf `false`, Elasticsearch only stores async searches that don't finish before the `wait_for_completion_timeout`.",
                  "type": "boolean"
                },
                "page_timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "params": {
                  "description": "The values for parameters in the query.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "query": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sql-spec.html"
                  },
                  "description": "The SQL query to run.",
                  "type": "string"
                },
                "request_timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "time_zone": {
                  "$ref": "#/components/schemas/_types:TimeZone"
                },
                "wait_for_completion_timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                }
              }
            }
          }
        },
        "required": true
      },
      "sql.translate": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "fetch_size": {
                  "description": "The maximum number of rows (or entries) to return in one response.",
                  "type": "number"
                },
                "filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "query": {
                  "description": "The SQL query to run.",
                  "type": "string"
                },
                "time_zone": {
                  "$ref": "#/components/schemas/_types:TimeZone"
                }
              },
              "required": [
                "query"
              ]
            }
          }
        },
        "required": true
      },
      "terms_enum": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "size": {
                  "description": "The number of matching terms to return.",
                  "type": "number"
                },
                "timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "case_insensitive": {
                  "description": "When `true`, the provided search string is matched against index terms without case sensitivity.",
                  "type": "boolean"
                },
                "index_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "string": {
                  "description": "The string to match at the start of indexed terms.\nIf it is not provided, all terms in the field are considered.\n\n> info\n> The prefix string cannot be larger than the largest possible keyword value, which is Lucene's term byte-length limit of 32766.",
                  "type": "string"
                },
                "search_after": {
                  "description": "The string after which terms in the index should be returned.\nIt allows for a form of pagination if the last result from one request is passed as the `search_after` parameter for a subsequent request.",
                  "type": "string"
                }
              },
              "required": [
                "field"
              ]
            }
          }
        }
      },
      "termvectors": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "doc": {
                  "description": "An artificial document (a document not present in the index) for which you want to retrieve term vectors.",
                  "type": "object"
                },
                "filter": {
                  "$ref": "#/components/schemas/_global.termvectors:Filter"
                },
                "per_field_analyzer": {
                  "description": "Override the default per-field analyzer.\nThis is useful in order to generate term vectors in any fashion, especially when using artificial documents.\nWhen providing an analyzer for a field that already stores term vectors, the term vectors will be regenerated.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "text_structure.find_message_structure": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "messages": {
                  "description": "The list of messages you want to analyze.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "required": [
                "messages"
              ]
            }
          }
        },
        "required": true
      },
      "text_structure.test_grok_pattern": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "grok_pattern": {
                  "$ref": "#/components/schemas/_types:GrokPattern"
                },
                "text": {
                  "description": "The lines of text to run the Grok pattern on.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "required": [
                "grok_pattern",
                "text"
              ]
            }
          }
        },
        "required": true
      },
      "transform.preview_transform": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "dest": {
                  "$ref": "#/components/schemas/transform._types:Destination"
                },
                "description": {
                  "description": "Free text description of the transform.",
                  "type": "string"
                },
                "frequency": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "pivot": {
                  "$ref": "#/components/schemas/transform._types:Pivot"
                },
                "source": {
                  "$ref": "#/components/schemas/transform._types:Source"
                },
                "settings": {
                  "$ref": "#/components/schemas/transform._types:Settings"
                },
                "sync": {
                  "$ref": "#/components/schemas/transform._types:SyncContainer"
                },
                "retention_policy": {
                  "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                },
                "latest": {
                  "$ref": "#/components/schemas/transform._types:Latest"
                }
              }
            }
          }
        }
      },
      "watcher.execute_watch": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "action_modes": {
                  "description": "Determines how to handle the watch actions as part of the watch execution.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/watcher._types:ActionExecutionMode"
                  }
                },
                "alternative_input": {
                  "description": "When present, the watch uses this object as a payload instead of executing its own input.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "ignore_condition": {
                  "description": "When set to `true`, the watch execution uses the always condition. This can also be specified as an HTTP parameter.",
                  "type": "boolean"
                },
                "record_execution": {
                  "description": "When set to `true`, the watch record representing the watch execution result is persisted to the `.watcher-history` index for the current time.\nIn addition, the status of the watch is updated, possibly throttling subsequent runs.\nThis can also be specified as an HTTP parameter.",
                  "type": "boolean"
                },
                "simulated_actions": {
                  "$ref": "#/components/schemas/watcher._types:SimulatedActions"
                },
                "trigger_data": {
                  "$ref": "#/components/schemas/watcher._types:ScheduleTriggerEvent"
                },
                "watch": {
                  "$ref": "#/components/schemas/watcher._types:Watch"
                }
              }
            }
          }
        }
      },
      "watcher.put_watch": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "actions": {
                  "description": "The list of actions that will be run if the condition matches.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/watcher._types:Action"
                  }
                },
                "condition": {
                  "$ref": "#/components/schemas/watcher._types:ConditionContainer"
                },
                "input": {
                  "$ref": "#/components/schemas/watcher._types:InputContainer"
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "throttle_period": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "throttle_period_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "transform": {
                  "$ref": "#/components/schemas/_types:TransformContainer"
                },
                "trigger": {
                  "$ref": "#/components/schemas/watcher._types:TriggerContainer"
                }
              }
            }
          }
        }
      },
      "watcher.query_watches": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "from": {
                  "description": "The offset from the first result to fetch.\nIt must be non-negative.",
                  "type": "number"
                },
                "size": {
                  "description": "The number of hits to return.\nIt must be non-negative.",
                  "type": "number"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                }
              }
            }
          }
        }
      }
    }
  }
}