{
  "openapi": "3.0.3",
  "info": {
    "title": "Elasticsearch Request & Response Specification",
    "license": {
      "name": "Apache 2.0",
      "url": "https://github.com/elastic/elasticsearch-specification/blob/main/LICENSE"
    },
    "version": ""
  },
  "paths": {
    "/_async_search/{id}": {
      "get": {
        "description": "Retrieves the results of a previously submitted async search request given its ID.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html"
        },
        "operationId": "async_search.get#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the async search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "Specifies how long the async search should be available in the cluster.\nWhen not specified, the `keep_alive` set with the corresponding submit async request will be used.\nOtherwise, it is possible to override the value and extend the validity of the request.\nWhen this period expires, the search, if still running, is cancelled.\nIf the search is completed, its saved results are deleted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "typed_keys",
            "description": "Specify whether aggregation and suggester names should be prefixed by their respective types in the response",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion_timeout",
            "description": "Specifies to wait for the search to be completed up until the provided timeout.\nFinal results will be returned if available before the timeout expires, otherwise the currently available results will be returned once the timeout expires.\nBy default no timeout is set meaning that the currently available results will be returned without any additional wait.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/async_search._types:AsyncSearchDocumentResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an async search by ID. If the search is still running, the search request will be cancelled. Otherwise, the saved search results are deleted.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html"
        },
        "operationId": "async_search.delete#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the async search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_async_search/status/{id}": {
      "get": {
        "description": "Retrieves the status of a previously submitted async search request given its ID.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html"
        },
        "operationId": "async_search.status#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "A unique identifier for the async search.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/async_search.status:StatusResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_async_search": {
      "post": {
        "description": "Executes a search request asynchronously.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html"
        },
        "operationId": "async_search.submit#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/async_search.submit#wait_for_completion_timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_on_completion"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_alive"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyzer"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#default_operator"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#df"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#explain"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#lenient"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#preference"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#request_cache"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#routing"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#scroll"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#search_type"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stats"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stored_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_field"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_text"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#terminate_after"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_scores"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#typed_keys"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#version"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_includes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#q"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#from"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/async_search.submit"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/async_search.submit#200"
          }
        }
      }
    },
    "/{index}/_async_search": {
      "post": {
        "description": "Executes a search request asynchronously.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/async-search.html"
        },
        "operationId": "async_search.submit#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/async_search.submit#index"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#wait_for_completion_timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_on_completion"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#keep_alive"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyzer"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#default_operator"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#df"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#explain"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#lenient"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#preference"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#request_cache"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#routing"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#scroll"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#search_type"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stats"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#stored_fields"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_field"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#suggest_text"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#terminate_after"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#timeout"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#track_scores"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#typed_keys"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#version"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#_source_includes"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#q"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#size"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#from"
          },
          {
            "$ref": "#/components/parameters/async_search.submit#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/async_search.submit"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/async_search.submit#200"
          }
        }
      }
    },
    "/_bulk": {
      "put": {
        "description": "Allows to perform multiple index/update/delete operations in a single request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html"
        },
        "operationId": "bulk#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      },
      "post": {
        "description": "Allows to perform multiple index/update/delete operations in a single request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html"
        },
        "operationId": "bulk#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      }
    },
    "/{index}/_bulk": {
      "put": {
        "description": "Allows to perform multiple index/update/delete operations in a single request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html"
        },
        "operationId": "bulk#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#index"
          },
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      },
      "post": {
        "description": "Allows to perform multiple index/update/delete operations in a single request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-bulk.html"
        },
        "operationId": "bulk#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/bulk#index"
          },
          {
            "$ref": "#/components/parameters/bulk#pipeline"
          },
          {
            "$ref": "#/components/parameters/bulk#refresh"
          },
          {
            "$ref": "#/components/parameters/bulk#routing"
          },
          {
            "$ref": "#/components/parameters/bulk#_source"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/bulk#_source_includes"
          },
          {
            "$ref": "#/components/parameters/bulk#timeout"
          },
          {
            "$ref": "#/components/parameters/bulk#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/bulk#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/bulk"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/bulk#200"
          }
        }
      }
    },
    "/_cat/aliases": {
      "get": {
        "description": "Shows information about currently configured aliases to indices including filter and routing infos.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-alias.html"
        },
        "operationId": "cat.aliases#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.aliases#expand_wildcards"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.aliases#200"
          }
        }
      }
    },
    "/_cat/aliases/{name}": {
      "get": {
        "description": "Shows information about currently configured aliases to indices including filter and routing infos.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-alias.html"
        },
        "operationId": "cat.aliases#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.aliases#name"
          },
          {
            "$ref": "#/components/parameters/cat.aliases#expand_wildcards"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.aliases#200"
          }
        }
      }
    },
    "/_cat/allocation": {
      "get": {
        "description": "Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-allocation.html"
        },
        "operationId": "cat.allocation#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.allocation#bytes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.allocation#200"
          }
        }
      }
    },
    "/_cat/allocation/{node_id}": {
      "get": {
        "description": "Provides a snapshot of how many shards are allocated to each data node and how much disk space they are using.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-allocation.html"
        },
        "operationId": "cat.allocation#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.allocation#node_id"
          },
          {
            "$ref": "#/components/parameters/cat.allocation#bytes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.allocation#200"
          }
        }
      }
    },
    "/_cat/component_templates": {
      "get": {
        "description": "Returns information about existing component_templates templates.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-component-templates.html"
        },
        "operationId": "cat.component_templates#0",
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.component_templates#200"
          }
        }
      }
    },
    "/_cat/component_templates/{name}": {
      "get": {
        "description": "Returns information about existing component_templates templates.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/cat-component-templates.html"
        },
        "operationId": "cat.component_templates#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.component_templates#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.component_templates#200"
          }
        }
      }
    },
    "/_cat/count": {
      "get": {
        "description": "Provides quick access to the document count of the entire cluster, or individual indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-count.html"
        },
        "operationId": "cat.count#0",
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.count#200"
          }
        }
      }
    },
    "/_cat/count/{index}": {
      "get": {
        "description": "Provides quick access to the document count of the entire cluster, or individual indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-count.html"
        },
        "operationId": "cat.count#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.count#index"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.count#200"
          }
        }
      }
    },
    "/_cat/fielddata": {
      "get": {
        "description": "Shows how much heap memory is currently being used by fielddata on every data node in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-fielddata.html"
        },
        "operationId": "cat.fielddata#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.fielddata#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.fielddata#fields_"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.fielddata#200"
          }
        }
      }
    },
    "/_cat/fielddata/{fields}": {
      "get": {
        "description": "Shows how much heap memory is currently being used by fielddata on every data node in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-fielddata.html"
        },
        "operationId": "cat.fielddata#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.fielddata#fields"
          },
          {
            "$ref": "#/components/parameters/cat.fielddata#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.fielddata#fields_"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.fielddata#200"
          }
        }
      }
    },
    "/_cat": {
      "get": {
        "description": "Returns help for the Cat APIs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat.html"
        },
        "operationId": "cat.help#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.help:HelpRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/indices": {
      "get": {
        "description": "Returns information about indices: number of primaries and replicas, document counts, disk size, ...",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-indices.html"
        },
        "operationId": "cat.indices#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.indices#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.indices#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cat.indices#health"
          },
          {
            "$ref": "#/components/parameters/cat.indices#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/cat.indices#pri"
          },
          {
            "$ref": "#/components/parameters/cat.indices#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.indices#200"
          }
        }
      }
    },
    "/_cat/indices/{index}": {
      "get": {
        "description": "Returns information about indices: number of primaries and replicas, document counts, disk size, ...",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-indices.html"
        },
        "operationId": "cat.indices#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.indices#index"
          },
          {
            "$ref": "#/components/parameters/cat.indices#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.indices#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cat.indices#health"
          },
          {
            "$ref": "#/components/parameters/cat.indices#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/cat.indices#pri"
          },
          {
            "$ref": "#/components/parameters/cat.indices#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.indices#200"
          }
        }
      }
    },
    "/_cat/master": {
      "get": {
        "description": "Returns information about the master node.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-master.html"
        },
        "operationId": "cat.master#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.master:MasterRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/ml/data_frame/analytics": {
      "get": {
        "description": "Gets configuration and usage information about data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-dfanalytics.html"
        },
        "operationId": "cat.ml_data_frame_analytics#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_data_frame_analytics#200"
          }
        }
      }
    },
    "/_cat/ml/data_frame/analytics/{id}": {
      "get": {
        "description": "Gets configuration and usage information about data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-dfanalytics.html"
        },
        "operationId": "cat.ml_data_frame_analytics#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_data_frame_analytics#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_data_frame_analytics#200"
          }
        }
      }
    },
    "/_cat/ml/datafeeds": {
      "get": {
        "description": "Gets configuration and usage information about datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-datafeeds.html"
        },
        "operationId": "cat.ml_datafeeds#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_datafeeds#200"
          }
        }
      }
    },
    "/_cat/ml/datafeeds/{datafeed_id}": {
      "get": {
        "description": "Gets configuration and usage information about datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-datafeeds.html"
        },
        "operationId": "cat.ml_datafeeds#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_datafeeds#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_datafeeds#200"
          }
        }
      }
    },
    "/_cat/ml/anomaly_detectors": {
      "get": {
        "description": "Gets configuration and usage information about anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-anomaly-detectors.html"
        },
        "operationId": "cat.ml_jobs#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_jobs#200"
          }
        }
      }
    },
    "/_cat/ml/anomaly_detectors/{job_id}": {
      "get": {
        "description": "Gets configuration and usage information about anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-anomaly-detectors.html"
        },
        "operationId": "cat.ml_jobs#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_jobs#job_id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_jobs#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_jobs#200"
          }
        }
      }
    },
    "/_cat/ml/trained_models": {
      "get": {
        "description": "Gets configuration and usage information about inference trained models.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-trained-model.html"
        },
        "operationId": "cat.ml_trained_models#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_trained_models#200"
          }
        }
      }
    },
    "/_cat/ml/trained_models/{model_id}": {
      "get": {
        "description": "Gets configuration and usage information about inference trained models.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-trained-model.html"
        },
        "operationId": "cat.ml_trained_models#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#model_id"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#bytes"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#h"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#s"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/cat.ml_trained_models#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.ml_trained_models#200"
          }
        }
      }
    },
    "/_cat/nodeattrs": {
      "get": {
        "description": "Returns information about custom node attributes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-nodeattrs.html"
        },
        "operationId": "cat.nodeattrs#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.nodeattrs:NodeAttributesRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/nodes": {
      "get": {
        "description": "Returns basic statistics about performance of cluster nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-nodes.html"
        },
        "operationId": "cat.nodes#0",
        "parameters": [
          {
            "in": "query",
            "name": "bytes",
            "description": "The unit used to display byte values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Bytes"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "full_id",
            "description": "If `true`, return the full node ID. If `false`, return the shortened node ID.",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "type": "boolean"
                },
                {
                  "type": "string"
                }
              ]
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_unloaded_segments",
            "description": "If true, the response includes information from segments that are not loaded into memory.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.nodes:NodesRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/pending_tasks": {
      "get": {
        "description": "Returns a concise representation of the cluster pending tasks.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-pending-tasks.html"
        },
        "operationId": "cat.pending_tasks#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.pending_tasks:PendingTasksRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/plugins": {
      "get": {
        "description": "Returns information about installed plugins across nodes node.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-plugins.html"
        },
        "operationId": "cat.plugins#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.plugins:PluginsRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/segments": {
      "get": {
        "description": "Provides low-level information about the segments in the shards of an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-segments.html"
        },
        "operationId": "cat.segments#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.segments#bytes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.segments#200"
          }
        }
      }
    },
    "/_cat/segments/{index}": {
      "get": {
        "description": "Provides low-level information about the segments in the shards of an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-segments.html"
        },
        "operationId": "cat.segments#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.segments#index"
          },
          {
            "$ref": "#/components/parameters/cat.segments#bytes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.segments#200"
          }
        }
      }
    },
    "/_cat/shards": {
      "get": {
        "description": "Provides a detailed view of shard allocation on nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html"
        },
        "operationId": "cat.shards#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.shards#bytes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.shards#200"
          }
        }
      }
    },
    "/_cat/shards/{index}": {
      "get": {
        "description": "Provides a detailed view of shard allocation on nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-shards.html"
        },
        "operationId": "cat.shards#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.shards#index"
          },
          {
            "$ref": "#/components/parameters/cat.shards#bytes"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.shards#200"
          }
        }
      }
    },
    "/_cat/snapshots": {
      "get": {
        "description": "Returns all snapshots in a specific repository.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-snapshots.html"
        },
        "operationId": "cat.snapshots#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.snapshots#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.snapshots#200"
          }
        }
      }
    },
    "/_cat/snapshots/{repository}": {
      "get": {
        "description": "Returns all snapshots in a specific repository.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-snapshots.html"
        },
        "operationId": "cat.snapshots#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.snapshots#repository"
          },
          {
            "$ref": "#/components/parameters/cat.snapshots#ignore_unavailable"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.snapshots#200"
          }
        }
      }
    },
    "/_cat/tasks": {
      "get": {
        "description": "Returns information about the tasks currently executing on one or more nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/tasks.html"
        },
        "operationId": "cat.tasks#0",
        "parameters": [
          {
            "in": "query",
            "name": "actions",
            "description": "The task action names, which are used to limit the response.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "detailed",
            "description": "If `true`, the response includes detailed information about shard recoveries.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "node_id",
            "description": "Unique node identifiers, which are used to limit the response.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "parent_task_id",
            "description": "The parent task identifier, which is used to limit the response.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cat.tasks:TasksRecord"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_cat/templates": {
      "get": {
        "description": "Returns information about existing templates.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-templates.html"
        },
        "operationId": "cat.templates#0",
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.templates#200"
          }
        }
      }
    },
    "/_cat/templates/{name}": {
      "get": {
        "description": "Returns information about existing templates.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-templates.html"
        },
        "operationId": "cat.templates#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.templates#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.templates#200"
          }
        }
      }
    },
    "/_cat/thread_pool": {
      "get": {
        "description": "Returns cluster-wide thread pool statistics per node.\nBy default the active, queue and rejected statistics are returned for all thread pools.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-thread-pool.html"
        },
        "operationId": "cat.thread_pool#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.thread_pool#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.thread_pool#200"
          }
        }
      }
    },
    "/_cat/thread_pool/{thread_pool_patterns}": {
      "get": {
        "description": "Returns cluster-wide thread pool statistics per node.\nBy default the active, queue and rejected statistics are returned for all thread pools.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-thread-pool.html"
        },
        "operationId": "cat.thread_pool#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.thread_pool#thread_pool_patterns"
          },
          {
            "$ref": "#/components/parameters/cat.thread_pool#time"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.thread_pool#200"
          }
        }
      }
    },
    "/_cat/transforms": {
      "get": {
        "description": "Gets configuration and usage information about transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-transforms.html"
        },
        "operationId": "cat.transforms#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.transforms#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#from"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#h"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#s"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#time"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.transforms#200"
          }
        }
      }
    },
    "/_cat/transforms/{transform_id}": {
      "get": {
        "description": "Gets configuration and usage information about transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cat-transforms.html"
        },
        "operationId": "cat.transforms#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cat.transforms#transform_id"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#from"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#h"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#s"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#time"
          },
          {
            "$ref": "#/components/parameters/cat.transforms#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cat.transforms#200"
          }
        }
      }
    },
    "/_search/scroll": {
      "get": {
        "description": "Allows to retrieve a large numbers of results from a single search request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll"
        },
        "operationId": "scroll#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "post": {
        "description": "Allows to retrieve a large numbers of results from a single search request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll"
        },
        "operationId": "scroll#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "delete": {
        "description": "Explicitly clears the search context for a scroll.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/clear-scroll-api.html"
        },
        "operationId": "clear_scroll#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/clear_scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/clear_scroll#200"
          }
        }
      }
    },
    "/_search/scroll/{scroll_id}": {
      "get": {
        "description": "Allows to retrieve a large numbers of results from a single search request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll"
        },
        "operationId": "scroll#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll_id"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "post": {
        "description": "Allows to retrieve a large numbers of results from a single search request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-request-body.html#request-body-search-scroll"
        },
        "operationId": "scroll#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/scroll#scroll_id"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll"
          },
          {
            "$ref": "#/components/parameters/scroll#scroll_id_"
          },
          {
            "$ref": "#/components/parameters/scroll#rest_total_hits_as_int"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scroll#200"
          }
        }
      },
      "delete": {
        "description": "Explicitly clears the search context for a scroll.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/clear-scroll-api.html"
        },
        "operationId": "clear_scroll#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/clear_scroll#scroll_id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/clear_scroll"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/clear_scroll#200"
          }
        }
      }
    },
    "/_pit": {
      "delete": {
        "description": "Close a point in time",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/point-in-time-api.html"
        },
        "operationId": "close_point_in_time#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/_types:Id"
                  }
                },
                "required": [
                  "id"
                ]
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "succeeded": {
                      "type": "boolean"
                    },
                    "num_freed": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "succeeded",
                    "num_freed"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_cluster/allocation/explain": {
      "get": {
        "description": "Provides explanations for shard allocations in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-allocation-explain.html"
        },
        "operationId": "cluster.allocation_explain#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_disk_info"
          },
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_yes_decisions"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.allocation_explain"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.allocation_explain#200"
          }
        }
      },
      "post": {
        "description": "Provides explanations for shard allocations in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-allocation-explain.html"
        },
        "operationId": "cluster.allocation_explain#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_disk_info"
          },
          {
            "$ref": "#/components/parameters/cluster.allocation_explain#include_yes_decisions"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.allocation_explain"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.allocation_explain#200"
          }
        }
      }
    },
    "/_component_template/{name}": {
      "get": {
        "description": "Returns one or more component templates",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html"
        },
        "operationId": "cluster.get_component_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.get_component_template#name"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#include_defaults"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#local"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.get_component_template#200"
          }
        }
      },
      "put": {
        "description": "Creates or updates a component template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html"
        },
        "operationId": "cluster.put_component_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.put_component_template#name"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#create"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#master_timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.put_component_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.put_component_template#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates a component template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html"
        },
        "operationId": "cluster.put_component_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.put_component_template#name"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#create"
          },
          {
            "$ref": "#/components/parameters/cluster.put_component_template#master_timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/cluster.put_component_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.put_component_template#200"
          }
        }
      },
      "delete": {
        "description": "Deletes a component template",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html"
        },
        "operationId": "cluster.delete_component_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list or wildcard expression of component template names used to limit the request.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns information about whether a particular component template exist",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html"
        },
        "operationId": "cluster.exists_component_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of component template names used to limit the request.\nWildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If true, the request retrieves information from the local node only.\nDefaults to false, which means information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_component_template": {
      "get": {
        "description": "Returns one or more component templates",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-component-template.html"
        },
        "operationId": "cluster.get_component_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.get_component_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#include_defaults"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#local"
          },
          {
            "$ref": "#/components/parameters/cluster.get_component_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.get_component_template#200"
          }
        }
      }
    },
    "/_cluster/settings": {
      "get": {
        "description": "Returns cluster settings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-get-settings.html"
        },
        "operationId": "cluster.get_settings#0",
        "parameters": [
          {
            "in": "query",
            "name": "flat_settings",
            "description": "If `true`, returns settings in flat format.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If `true`, returns default cluster settings from the local node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "persistent": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    },
                    "transient": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    },
                    "defaults": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    }
                  },
                  "required": [
                    "persistent",
                    "transient"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Updates the cluster settings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-update-settings.html"
        },
        "operationId": "cluster.put_settings#0",
        "parameters": [
          {
            "in": "query",
            "name": "flat_settings",
            "description": "Return settings in flat format (default: false)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit operation timeout",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "persistent": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  },
                  "transient": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "persistent": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    },
                    "transient": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "object"
                      }
                    }
                  },
                  "required": [
                    "acknowledged",
                    "persistent",
                    "transient"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_cluster/health": {
      "get": {
        "description": "Returns basic information about the health of the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-health.html"
        },
        "operationId": "cluster.health#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.health#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#level"
          },
          {
            "$ref": "#/components/parameters/cluster.health#local"
          },
          {
            "$ref": "#/components/parameters/cluster.health#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_events"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_nodes"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_initializing_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_relocating_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_status"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.health#200"
          }
        }
      }
    },
    "/_cluster/health/{index}": {
      "get": {
        "description": "Returns basic information about the health of the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-health.html"
        },
        "operationId": "cluster.health#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.health#index"
          },
          {
            "$ref": "#/components/parameters/cluster.health#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#level"
          },
          {
            "$ref": "#/components/parameters/cluster.health#local"
          },
          {
            "$ref": "#/components/parameters/cluster.health#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_events"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_nodes"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_initializing_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_no_relocating_shards"
          },
          {
            "$ref": "#/components/parameters/cluster.health#wait_for_status"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.health#200"
          }
        }
      }
    },
    "/_info/{target}": {
      "get": {
        "description": "Returns different information about the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-info.html"
        },
        "operationId": "cluster.info#0",
        "parameters": [
          {
            "in": "path",
            "name": "target",
            "description": "Limits the information returned to the specific target. Supports a comma-separated list, such as http,ingest.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ClusterInfoTargets"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "http": {
                      "$ref": "#/components/schemas/nodes._types:Http"
                    },
                    "ingest": {
                      "$ref": "#/components/schemas/nodes._types:Ingest"
                    },
                    "thread_pool": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/nodes._types:ThreadCount"
                      }
                    },
                    "script": {
                      "$ref": "#/components/schemas/nodes._types:Scripting"
                    }
                  },
                  "required": [
                    "cluster_name"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_cluster/pending_tasks": {
      "get": {
        "description": "Returns a list of any cluster-level changes (e.g. create index, update mapping,\nallocate or fail shard) which have not yet been executed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-pending.html"
        },
        "operationId": "cluster.pending_tasks#0",
        "parameters": [
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tasks": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/cluster.pending_tasks:PendingTask"
                      }
                    }
                  },
                  "required": [
                    "tasks"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_cluster/reroute": {
      "post": {
        "description": "Allows to manually change the allocation of individual shards in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-reroute.html"
        },
        "operationId": "cluster.reroute#0",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "description": "If true, then the request simulates the operation only and returns the resulting state.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "explain",
            "description": "If true, then the response contains an explanation of why the commands can or cannot be executed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "metric",
            "description": "Limits the information returned to the specified metrics.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Metrics"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "retry_failed",
            "description": "If true, then retries allocation of shards that are blocked due to too many subsequent allocation failures.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "commands": {
                    "description": "Defines the commands to perform.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/cluster.reroute:Command"
                    }
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "explanations": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/cluster.reroute:RerouteExplanation"
                      }
                    },
                    "state": {
                      "description": "There aren't any guarantees on the output/structure of the raw cluster state.\nHere you will find the internal representation of the cluster, which can\ndiffer from the external representation.",
                      "type": "object"
                    }
                  },
                  "required": [
                    "acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_cluster/state": {
      "get": {
        "description": "Returns a comprehensive information about the state of the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state.html"
        },
        "operationId": "cluster.state#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.state#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/cluster.state#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.state#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.state#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cluster.state#local"
          },
          {
            "$ref": "#/components/parameters/cluster.state#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_metadata_version"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.state#200"
          }
        }
      }
    },
    "/_cluster/state/{metric}": {
      "get": {
        "description": "Returns a comprehensive information about the state of the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state.html"
        },
        "operationId": "cluster.state#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.state#metric"
          },
          {
            "$ref": "#/components/parameters/cluster.state#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/cluster.state#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.state#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.state#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cluster.state#local"
          },
          {
            "$ref": "#/components/parameters/cluster.state#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_metadata_version"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.state#200"
          }
        }
      }
    },
    "/_cluster/state/{metric}/{index}": {
      "get": {
        "description": "Returns a comprehensive information about the state of the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-state.html"
        },
        "operationId": "cluster.state#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.state#metric"
          },
          {
            "$ref": "#/components/parameters/cluster.state#index"
          },
          {
            "$ref": "#/components/parameters/cluster.state#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/cluster.state#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/cluster.state#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.state#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/cluster.state#local"
          },
          {
            "$ref": "#/components/parameters/cluster.state#master_timeout"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_metadata_version"
          },
          {
            "$ref": "#/components/parameters/cluster.state#wait_for_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.state#200"
          }
        }
      }
    },
    "/_cluster/stats": {
      "get": {
        "description": "Returns high-level overview of cluster statistics.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-stats.html"
        },
        "operationId": "cluster.stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.stats#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.stats#200"
          }
        }
      }
    },
    "/_cluster/stats/nodes/{node_id}": {
      "get": {
        "description": "Returns high-level overview of cluster statistics.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-stats.html"
        },
        "operationId": "cluster.stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/cluster.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/cluster.stats#flat_settings"
          },
          {
            "$ref": "#/components/parameters/cluster.stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/cluster.stats#200"
          }
        }
      }
    },
    "/_count": {
      "get": {
        "description": "Returns number of documents matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html"
        },
        "operationId": "count#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      },
      "post": {
        "description": "Returns number of documents matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html"
        },
        "operationId": "count#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      }
    },
    "/{index}/_count": {
      "get": {
        "description": "Returns number of documents matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html"
        },
        "operationId": "count#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#index"
          },
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      },
      "post": {
        "description": "Returns number of documents matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-count.html"
        },
        "operationId": "count#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/count#index"
          },
          {
            "$ref": "#/components/parameters/count#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/count#analyzer"
          },
          {
            "$ref": "#/components/parameters/count#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/count#default_operator"
          },
          {
            "$ref": "#/components/parameters/count#df"
          },
          {
            "$ref": "#/components/parameters/count#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/count#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/count#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/count#lenient"
          },
          {
            "$ref": "#/components/parameters/count#min_score"
          },
          {
            "$ref": "#/components/parameters/count#preference"
          },
          {
            "$ref": "#/components/parameters/count#routing"
          },
          {
            "$ref": "#/components/parameters/count#terminate_after"
          },
          {
            "$ref": "#/components/parameters/count#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/count"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/count#200"
          }
        }
      }
    },
    "/{index}/_create/{id}": {
      "put": {
        "description": "Creates a new document in the index.\n\nReturns a 409 response when a document with a same ID already exists in the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html"
        },
        "operationId": "create#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/create#index"
          },
          {
            "$ref": "#/components/parameters/create#id"
          },
          {
            "$ref": "#/components/parameters/create#pipeline"
          },
          {
            "$ref": "#/components/parameters/create#refresh"
          },
          {
            "$ref": "#/components/parameters/create#routing"
          },
          {
            "$ref": "#/components/parameters/create#timeout"
          },
          {
            "$ref": "#/components/parameters/create#version"
          },
          {
            "$ref": "#/components/parameters/create#version_type"
          },
          {
            "$ref": "#/components/parameters/create#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/create"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/create#200"
          }
        }
      },
      "post": {
        "description": "Creates a new document in the index.\n\nReturns a 409 response when a document with a same ID already exists in the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html"
        },
        "operationId": "create#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/create#index"
          },
          {
            "$ref": "#/components/parameters/create#id"
          },
          {
            "$ref": "#/components/parameters/create#pipeline"
          },
          {
            "$ref": "#/components/parameters/create#refresh"
          },
          {
            "$ref": "#/components/parameters/create#routing"
          },
          {
            "$ref": "#/components/parameters/create#timeout"
          },
          {
            "$ref": "#/components/parameters/create#version"
          },
          {
            "$ref": "#/components/parameters/create#version_type"
          },
          {
            "$ref": "#/components/parameters/create#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/create"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/create#200"
          }
        }
      }
    },
    "/{index}/_doc/{id}": {
      "get": {
        "description": "Returns a document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html"
        },
        "operationId": "get#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the index that contains the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Unique identifier of the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on. Random by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If `true`, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If true, Elasticsearch refreshes the affected shards to make this operation visible to search. If false, do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Target the specified primary shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "True or false to return the _source field or not, or a list of fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stored_fields",
            "description": "List of stored fields to return as part of a hit.\nIf no fields are specified, no stored fields are included in the response.\nIf this field is specified, the `_source` parameter defaults to false.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "Explicit version number for concurrency control. The specified version must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Specific version type: internal, external, external_gte.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_global.get:GetResult"
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates or updates a document in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html"
        },
        "operationId": "index#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/index#index"
          },
          {
            "$ref": "#/components/parameters/index#id"
          },
          {
            "$ref": "#/components/parameters/index#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/index#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/index#op_type"
          },
          {
            "$ref": "#/components/parameters/index#pipeline"
          },
          {
            "$ref": "#/components/parameters/index#refresh"
          },
          {
            "$ref": "#/components/parameters/index#routing"
          },
          {
            "$ref": "#/components/parameters/index#timeout"
          },
          {
            "$ref": "#/components/parameters/index#version"
          },
          {
            "$ref": "#/components/parameters/index#version_type"
          },
          {
            "$ref": "#/components/parameters/index#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/index#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/index"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/index#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates a document in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html"
        },
        "operationId": "index#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/index#index"
          },
          {
            "$ref": "#/components/parameters/index#id"
          },
          {
            "$ref": "#/components/parameters/index#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/index#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/index#op_type"
          },
          {
            "$ref": "#/components/parameters/index#pipeline"
          },
          {
            "$ref": "#/components/parameters/index#refresh"
          },
          {
            "$ref": "#/components/parameters/index#routing"
          },
          {
            "$ref": "#/components/parameters/index#timeout"
          },
          {
            "$ref": "#/components/parameters/index#version"
          },
          {
            "$ref": "#/components/parameters/index#version_type"
          },
          {
            "$ref": "#/components/parameters/index#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/index#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/index"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/index#200"
          }
        }
      },
      "delete": {
        "description": "Removes a document from the index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete.html"
        },
        "operationId": "delete#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the target index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Unique identifier for the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "if_primary_term",
            "description": "Only perform the operation if the document has this primary term.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "if_seq_no",
            "description": "Only perform the operation if the document has this sequence number.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SequenceNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` do nothing with refreshes.\nValid values: `true`, `false`, `wait_for`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for active shards.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "Explicit version number for concurrency control.\nThe specified version must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Specific version type: `external`, `external_gte`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:WriteResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns information about whether a document exists in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html"
        },
        "operationId": "exists#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases.\nSupports wildcards (`*`).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Identifier of the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If `true`, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes all shards involved in the delete by query after the request completes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Target the specified primary shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "`true` or `false` to return the `_source` field or not, or a list of fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stored_fields",
            "description": "List of stored fields to return as part of a hit.\nIf no fields are specified, no stored fields are included in the response.\nIf this field is specified, the `_source` parameter defaults to false.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "Explicit version number for concurrency control.\nThe specified version must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Specific version type: `external`, `external_gte`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/{index}/_delete_by_query": {
      "post": {
        "description": "Deletes documents matching the provided query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-delete-by-query.html"
        },
        "operationId": "delete_by_query#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams or indices, omit this parameter or use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyzer",
            "description": "Analyzer to use for the query string.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyze_wildcard",
            "description": "If `true`, wildcard and prefix queries are analyzed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "conflicts",
            "description": "What to do if delete by query hits version conflicts: `abort` or `proceed`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Conflicts"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "default_operator",
            "description": "The default operator for query string query: `AND` or `OR`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types.query_dsl:Operator"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "df",
            "description": "Field to use as default where no field prefix is given in the query string.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lenient",
            "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_docs",
            "description": "Maximum number of documents to process.\nDefaults to all documents.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes all shards involved in the delete by query after the request completes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "request_cache",
            "description": "If `true`, the request cache is used for this request.\nDefaults to the index-level setting.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "q",
            "description": "Query in the Lucene query string syntax.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll",
            "description": "Period to retain the search context for scrolling.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll_size",
            "description": "Size of the scroll request that powers the operation.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_timeout",
            "description": "Explicit timeout for each search request.\nDefaults to no timeout.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_type",
            "description": "The type of the search operation.\nAvailable options: `query_then_fetch`, `dfs_query_then_fetch`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SearchType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "slices",
            "description": "The number of slices this task should be divided into.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Slices"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "sort",
            "description": "A comma-separated list of <field>:<direction> pairs.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stats",
            "description": "Specific `tag` of the request for logging and statistical purposes.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "terminate_after",
            "description": "Maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\nUse with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period each deletion request waits for active shards.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "If `true`, returns the document version as part of a hit.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the operation is complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "max_docs": {
                    "description": "The maximum number of documents to delete.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "slice": {
                    "$ref": "#/components/schemas/_types:SlicedScroll"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "batches": {
                      "type": "number"
                    },
                    "deleted": {
                      "type": "number"
                    },
                    "failures": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:BulkIndexByScrollFailure"
                      }
                    },
                    "noops": {
                      "type": "number"
                    },
                    "requests_per_second": {
                      "type": "number"
                    },
                    "retries": {
                      "$ref": "#/components/schemas/_types:Retries"
                    },
                    "slice_id": {
                      "type": "number"
                    },
                    "task": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    },
                    "throttled": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "throttled_until": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_until_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "timed_out": {
                      "type": "boolean"
                    },
                    "took": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "total": {
                      "type": "number"
                    },
                    "version_conflicts": {
                      "type": "number"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_scripts/{id}": {
      "get": {
        "description": "Returns a script.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html"
        },
        "operationId": "get_script#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the stored script or search template.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "found": {
                      "type": "boolean"
                    },
                    "script": {
                      "$ref": "#/components/schemas/_types:StoredScript"
                    }
                  },
                  "required": [
                    "_id",
                    "found"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates or updates a script.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html"
        },
        "operationId": "put_script#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates a script.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html"
        },
        "operationId": "put_script#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      },
      "delete": {
        "description": "Deletes a script.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html"
        },
        "operationId": "delete_script#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the stored script or search template.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_enrich/policy/{name}": {
      "get": {
        "description": "Gets information about an enrich policy.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-enrich-policy-api.html"
        },
        "operationId": "enrich.get_policy#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/enrich.get_policy#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/enrich.get_policy#200"
          }
        }
      },
      "put": {
        "description": "Creates a new enrich policy.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-enrich-policy-api.html"
        },
        "operationId": "enrich.put_policy#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the enrich policy to create or update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "geo_match": {
                    "$ref": "#/components/schemas/enrich._types:Policy"
                  },
                  "match": {
                    "$ref": "#/components/schemas/enrich._types:Policy"
                  },
                  "range": {
                    "$ref": "#/components/schemas/enrich._types:Policy"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an existing enrich policy and its enrich index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-enrich-policy-api.html"
        },
        "operationId": "enrich.delete_policy#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Enrich policy to delete.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_enrich/policy/{name}/_execute": {
      "put": {
        "description": "Creates the enrich index for an existing enrich policy.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/execute-enrich-policy-api.html"
        },
        "operationId": "enrich.execute_policy#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Enrich policy to execute.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks other enrich policy execution requests until complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "$ref": "#/components/schemas/enrich.execute_policy:ExecuteEnrichPolicyStatus"
                    },
                    "task_id": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    }
                  },
                  "required": [
                    "status"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_enrich/policy": {
      "get": {
        "description": "Gets information about an enrich policy.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-enrich-policy-api.html"
        },
        "operationId": "enrich.get_policy#1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/enrich.get_policy#200"
          }
        }
      }
    },
    "/_enrich/_stats": {
      "get": {
        "description": "Gets enrich coordinator statistics and information about enrich policies that are currently executing.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/enrich-stats-api.html"
        },
        "operationId": "enrich.stats#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "coordinator_stats": {
                      "description": "Objects containing information about each coordinating ingest node for configured enrich processors.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/enrich.stats:CoordinatorStats"
                      }
                    },
                    "executing_policies": {
                      "description": "Objects containing information about each enrich policy that is currently executing.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/enrich.stats:ExecutingPolicy"
                      }
                    },
                    "cache_stats": {
                      "description": "Objects containing information about the enrich cache stats on each ingest node.",
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/enrich.stats:CacheStats"
                      }
                    }
                  },
                  "required": [
                    "coordinator_stats",
                    "executing_policies"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_source/{id}": {
      "get": {
        "description": "Returns the source of a document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html"
        },
        "operationId": "get_source#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the index that contains the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Unique identifier of the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on. Random by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "Boolean) If true, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If true, Elasticsearch refreshes the affected shards to make this operation visible to search. If false, do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Target the specified primary shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "True or false to return the _source field or not, or a list of fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stored_fields",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "Explicit version number for concurrency control. The specified version must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Specific version type: internal, external, external_gte.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns information about whether a document source exists in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-get.html"
        },
        "operationId": "exists_source#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases.\nSupports wildcards (`*`).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Identifier of the document.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realtime",
            "description": "If true, the request is real-time as opposed to near-real-time.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes all shards involved in the delete by query after the request completes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Target the specified primary shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "`true` or `false` to return the `_source` field or not, or a list of fields to return.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "A comma-separated list of source fields to exclude in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "A comma-separated list of source fields to include in the response.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "Explicit version number for concurrency control.\nThe specified version must match the current version of the document for the request to succeed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Specific version type: `external`, `external_gte`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionType"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_field_caps": {
      "get": {
        "description": "Returns the information about the capabilities of fields among multiple indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html"
        },
        "operationId": "field_caps#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        }
      },
      "post": {
        "description": "Returns the information about the capabilities of fields among multiple indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html"
        },
        "operationId": "field_caps#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        }
      }
    },
    "/{index}/_field_caps": {
      "get": {
        "description": "Returns the information about the capabilities of fields among multiple indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html"
        },
        "operationId": "field_caps#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#index"
          },
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        }
      },
      "post": {
        "description": "Returns the information about the capabilities of fields among multiple indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-field-caps.html"
        },
        "operationId": "field_caps#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/field_caps#index"
          },
          {
            "$ref": "#/components/parameters/field_caps#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/field_caps#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/field_caps#fields"
          },
          {
            "$ref": "#/components/parameters/field_caps#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/field_caps#include_unmapped"
          },
          {
            "$ref": "#/components/parameters/field_caps#filters"
          },
          {
            "$ref": "#/components/parameters/field_caps#types"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/field_caps"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/field_caps#200"
          }
        }
      }
    },
    "/{index}/_fleet/global_checkpoints": {
      "get": {
        "description": "Returns the current global checkpoints for an index. This API is design for internal use by the fleet server project.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-global-checkpoints.html"
        },
        "operationId": "fleet.global_checkpoints#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A single index or index alias that resolves to a single index.",
            "required": true,
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                {
                  "$ref": "#/components/schemas/_types:IndexAlias"
                }
              ]
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_advance",
            "description": "A boolean value which controls whether to wait (until the timeout) for the global checkpoints\nto advance past the provided `checkpoints`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_index",
            "description": "A boolean value which controls whether to wait (until the timeout) for the target index to exist\nand all primary shards be active. Can only be true when `wait_for_advance` is true.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "checkpoints",
            "description": "A comma separated list of previous global checkpoints. When used in combination with `wait_for_advance`,\nthe API will only return once the global checkpoints advances past the checkpoints. Providing an empty list\nwill cause Elasticsearch to immediately return the current global checkpoints.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/fleet._types:Checkpoint"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a global checkpoints to advance past `checkpoints`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "global_checkpoints": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/fleet._types:Checkpoint"
                      }
                    },
                    "timed_out": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "global_checkpoints",
                    "timed_out"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_fleet/_fleet_msearch": {
      "get": {
        "description": "Multi Search API where the search will only be executed after specified checkpoints are available due to a refresh. This API is designed for internal use by the fleet server project.",
        "operationId": "fleet.msearch#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        }
      },
      "post": {
        "description": "Multi Search API where the search will only be executed after specified checkpoints are available due to a refresh. This API is designed for internal use by the fleet server project.",
        "operationId": "fleet.msearch#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        }
      }
    },
    "/{index}/_fleet/_fleet_msearch": {
      "get": {
        "description": "Multi Search API where the search will only be executed after specified checkpoints are available due to a refresh. This API is designed for internal use by the fleet server project.",
        "operationId": "fleet.msearch#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#index"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        }
      },
      "post": {
        "description": "Multi Search API where the search will only be executed after specified checkpoints are available due to a refresh. This API is designed for internal use by the fleet server project.",
        "operationId": "fleet.msearch#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.msearch#index"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.msearch#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.msearch#200"
          }
        }
      }
    },
    "/{index}/_fleet/_fleet_search": {
      "get": {
        "description": "Search API where the search will only be executed after specified checkpoints are available due to a refresh. This API is designed for internal use by the fleet server project.",
        "operationId": "fleet.search#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.search#index"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyzer"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/fleet.search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.search#default_operator"
          },
          {
            "$ref": "#/components/parameters/fleet.search#df"
          },
          {
            "$ref": "#/components/parameters/fleet.search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.search#explain"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.search#lenient"
          },
          {
            "$ref": "#/components/parameters/fleet.search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/fleet.search#preference"
          },
          {
            "$ref": "#/components/parameters/fleet.search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#request_cache"
          },
          {
            "$ref": "#/components/parameters/fleet.search#routing"
          },
          {
            "$ref": "#/components/parameters/fleet.search#scroll"
          },
          {
            "$ref": "#/components/parameters/fleet.search#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stats"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/fleet.search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/fleet.search#timeout"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_scores"
          },
          {
            "$ref": "#/components/parameters/fleet.search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.search#version"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/fleet.search#q"
          },
          {
            "$ref": "#/components/parameters/fleet.search#size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#from"
          },
          {
            "$ref": "#/components/parameters/fleet.search#sort"
          },
          {
            "$ref": "#/components/parameters/fleet.search#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.search#200"
          }
        }
      },
      "post": {
        "description": "Search API where the search will only be executed after specified checkpoints are available due to a refresh. This API is designed for internal use by the fleet server project.",
        "operationId": "fleet.search#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/fleet.search#index"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyzer"
          },
          {
            "$ref": "#/components/parameters/fleet.search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/fleet.search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/fleet.search#default_operator"
          },
          {
            "$ref": "#/components/parameters/fleet.search#df"
          },
          {
            "$ref": "#/components/parameters/fleet.search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/fleet.search#explain"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/fleet.search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/fleet.search#lenient"
          },
          {
            "$ref": "#/components/parameters/fleet.search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/fleet.search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/fleet.search#preference"
          },
          {
            "$ref": "#/components/parameters/fleet.search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#request_cache"
          },
          {
            "$ref": "#/components/parameters/fleet.search#routing"
          },
          {
            "$ref": "#/components/parameters/fleet.search#scroll"
          },
          {
            "$ref": "#/components/parameters/fleet.search#search_type"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stats"
          },
          {
            "$ref": "#/components/parameters/fleet.search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/fleet.search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/fleet.search#timeout"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/fleet.search#track_scores"
          },
          {
            "$ref": "#/components/parameters/fleet.search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/fleet.search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/fleet.search#version"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/fleet.search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/fleet.search#q"
          },
          {
            "$ref": "#/components/parameters/fleet.search#size"
          },
          {
            "$ref": "#/components/parameters/fleet.search#from"
          },
          {
            "$ref": "#/components/parameters/fleet.search#sort"
          },
          {
            "$ref": "#/components/parameters/fleet.search#wait_for_checkpoints"
          },
          {
            "$ref": "#/components/parameters/fleet.search#allow_partial_search_results"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/fleet.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/fleet.search#200"
          }
        }
      }
    },
    "/{index}/_graph/explore": {
      "get": {
        "description": "Explore extracted and summarized information about the documents and terms in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/graph-explore-api.html"
        },
        "operationId": "graph.explore#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/graph.explore#index"
          },
          {
            "$ref": "#/components/parameters/graph.explore#routing"
          },
          {
            "$ref": "#/components/parameters/graph.explore#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/graph.explore"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/graph.explore#200"
          }
        }
      },
      "post": {
        "description": "Explore extracted and summarized information about the documents and terms in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/graph-explore-api.html"
        },
        "operationId": "graph.explore#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/graph.explore#index"
          },
          {
            "$ref": "#/components/parameters/graph.explore#routing"
          },
          {
            "$ref": "#/components/parameters/graph.explore#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/graph.explore"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/graph.explore#200"
          }
        }
      }
    },
    "/{index}/_doc": {
      "post": {
        "description": "Creates or updates a document in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-index_.html"
        },
        "operationId": "index#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/index#index"
          },
          {
            "$ref": "#/components/parameters/index#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/index#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/index#op_type"
          },
          {
            "$ref": "#/components/parameters/index#pipeline"
          },
          {
            "$ref": "#/components/parameters/index#refresh"
          },
          {
            "$ref": "#/components/parameters/index#routing"
          },
          {
            "$ref": "#/components/parameters/index#timeout"
          },
          {
            "$ref": "#/components/parameters/index#version"
          },
          {
            "$ref": "#/components/parameters/index#version_type"
          },
          {
            "$ref": "#/components/parameters/index#wait_for_active_shards"
          },
          {
            "$ref": "#/components/parameters/index#require_alias"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/index"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/index#200"
          }
        }
      }
    },
    "/_analyze": {
      "get": {
        "description": "Performs the analysis process on a text and return the tokens breakdown of the text.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html"
        },
        "operationId": "indices.analyze#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      },
      "post": {
        "description": "Performs the analysis process on a text and return the tokens breakdown of the text.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html"
        },
        "operationId": "indices.analyze#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      }
    },
    "/{index}/_analyze": {
      "get": {
        "description": "Performs the analysis process on a text and return the tokens breakdown of the text.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html"
        },
        "operationId": "indices.analyze#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.analyze#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      },
      "post": {
        "description": "Performs the analysis process on a text and return the tokens breakdown of the text.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-analyze.html"
        },
        "operationId": "indices.analyze#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.analyze#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.analyze"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.analyze#200"
          }
        }
      }
    },
    "/{index}/_close": {
      "post": {
        "description": "Closes an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-close.html"
        },
        "operationId": "indices.close#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list or wildcard expression of index names used to limit the request.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "indices": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/indices.close:CloseIndexResult"
                      }
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "indices",
                    "shards_acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{index}": {
      "get": {
        "description": "Returns information about one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-index.html"
        },
        "operationId": "indices.get#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and index aliases used to limit the request.\nWildcard expressions (*) are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard expressions can match. If the request can target data streams, this argument\ndetermines whether wildcard expressions match hidden data streams. Supports comma-separated values,\nsuch as open,hidden.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "flat_settings",
            "description": "If true, returns settings in flat format.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If false, requests that target a missing index return an error.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If true, return all default settings in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "features",
            "description": "Return only information on specified index features",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/indices.get:Features"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:IndexState"
                  }
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates an index with optional settings and mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-index.html"
        },
        "operationId": "indices.create#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the index you wish to create.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation. \nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aliases": {
                    "description": "Aliases for the index.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/indices._types:Alias"
                    }
                  },
                  "mappings": {
                    "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                  },
                  "settings": {
                    "$ref": "#/components/schemas/indices._types:IndexSettings"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "index": {
                      "$ref": "#/components/schemas/_types:IndexName"
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    },
                    "acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "index",
                    "shards_acknowledged",
                    "acknowledged"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-delete-index.html"
        },
        "operationId": "indices.delete#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of indices to delete.\nYou cannot specify index aliases.\nBy default, this parameter does not support wildcards (`*`) or `_all`.\nTo use wildcards or `_all`, set the `action.destructive_requires_name` cluster setting to `false`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:IndicesResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns information about whether a particular index exists.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-exists.html"
        },
        "operationId": "indices.exists#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases. Supports wildcards (`*`).",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "flat_settings",
            "description": "If `true`, returns settings in flat format.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If `true`, return all default settings in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "If `true`, the request retrieves information from the local node only.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_data_stream/{name}": {
      "get": {
        "description": "Returns data streams.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.get_data_stream#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_data_stream#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#include_defaults"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_data_stream#200"
          }
        }
      },
      "put": {
        "description": "Creates a data stream",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.create_data_stream#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the data stream, which must meet the following criteria:\nLowercase only;\nCannot include `\\`, `/`, `*`, `?`, `\"`, `<`, `>`, `|`, `,`, `#`, `:`, or a space character;\nCannot start with `-`, `_`, `+`, or `.ds-`;\nCannot be `.` or `..`;\nCannot be longer than 255 bytes. Multi-byte characters count towards this limit faster.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamName"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a data stream.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.delete_data_stream#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of data streams to delete. Wildcard (`*`) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of data stream that wildcard patterns can match. Supports comma-separated values,such as `open,hidden`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_data_stream/_stats": {
      "get": {
        "description": "Provides statistics on operations happening in a data stream.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.data_streams_stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.data_streams_stats#expand_wildcards"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.data_streams_stats#200"
          }
        }
      }
    },
    "/_data_stream/{name}/_stats": {
      "get": {
        "description": "Provides statistics on operations happening in a data stream.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.data_streams_stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.data_streams_stats#name"
          },
          {
            "$ref": "#/components/parameters/indices.data_streams_stats#expand_wildcards"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.data_streams_stats#200"
          }
        }
      }
    },
    "/{index}/_alias/{name}": {
      "get": {
        "description": "Returns an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.get_alias#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      },
      "put": {
        "description": "Creates or updates an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.put_alias#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.put_alias#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "delete": {
        "description": "Deletes an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.delete_alias#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.delete_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.delete_alias#200"
          }
        }
      },
      "head": {
        "description": "Returns information about whether a particular alias exists.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.exists_alias#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.exists_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.exists_alias#200"
          }
        }
      }
    },
    "/{index}/_aliases/{name}": {
      "put": {
        "description": "Creates or updates an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.put_alias#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.put_alias#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_alias#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_alias"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_alias#200"
          }
        }
      },
      "delete": {
        "description": "Deletes an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.delete_alias#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.delete_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.delete_alias#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.delete_alias#200"
          }
        }
      }
    },
    "/_data_stream/{name}/_lifecycle": {
      "get": {
        "description": "Returns the data stream lifecycle of the selected data streams.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams-get-lifecycle.html"
        },
        "operationId": "indices.get_data_lifecycle#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of data streams to limit the request.\nSupports wildcards (`*`).\nTo target all data streams, omit this parameter or use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If `true`, return all default settings in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "data_streams": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.get_data_lifecycle:DataStreamWithLifecycle"
                      }
                    }
                  },
                  "required": [
                    "data_streams"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Updates the data stream lifecycle of the selected data streams.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams-put-lifecycle.html"
        },
        "operationId": "indices.put_data_lifecycle#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of data streams used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `hidden`, `open`, `closed`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "data_retention": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "downsampling": {
                    "$ref": "#/components/schemas/indices._types:DataStreamLifecycleDownsampling"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes the data stream lifecycle of the selected data streams.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams-delete-lifecycle.html"
        },
        "operationId": "indices.delete_data_lifecycle#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "A comma-separated list of data streams of which the data stream lifecycle will be deleted; use `*` to get all data streams",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DataStreamNames"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Whether wildcard expressions should get expanded to open or closed indices (default: open)",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Explicit timestamp for the document",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_index_template/{name}": {
      "get": {
        "description": "Returns an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.get_index_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_index_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#include_defaults"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_index_template#200"
          }
        }
      },
      "put": {
        "description": "Creates or updates an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.put_index_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_index_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#create"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_index_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_index_template#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.put_index_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_index_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_index_template#create"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_index_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_index_template#200"
          }
        }
      },
      "delete": {
        "description": "Deletes an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.delete_index_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of index template names used to limit the request. Wildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns information about whether a particular index template exists.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.exists_index_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated list of index template names used to limit the request. Wildcard (*) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_template/{name}": {
      "get": {
        "description": "Returns an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.get_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_template#200"
          }
        }
      },
      "put": {
        "description": "Creates or updates an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.put_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#order"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_template#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.put_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_template#order"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_template#200"
          }
        }
      },
      "delete": {
        "description": "Deletes an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.delete_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the legacy index template to delete.\nWildcard (`*`) expressions are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns information about whether a particular index template exists.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.exists_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The comma separated names of the index templates",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "flat_settings",
            "description": "Return settings in flat format (default: false)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "local",
            "description": "Return local information, do not retrieve the state from master node (default: false)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Explicit operation timeout for connection to master node",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/{index}/_disk_usage": {
      "post": {
        "description": "Analyzes the disk usage of each field of an index or data stream",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-disk-usage.html"
        },
        "operationId": "indices.disk_usage#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nIts recommended to execute this API with a single index (or the latest backing index of a data stream) as the API consumes resources significantly.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "flush",
            "description": "If `true`, the API performs a flush before analysis.\nIf `false`, the response may not include uncommitted data.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `true`, missing or closed indices are not included in the response.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "run_expensive_tasks",
            "description": "Analyzing field disk usage is resource-intensive.\nTo use the API, this parameter must be set to `true`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_downsample/{target_index}": {
      "post": {
        "description": "Downsample an index",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-downsample-data-stream.html"
        },
        "operationId": "indices.downsample#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Name of the time series index to downsample.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "target_index",
            "description": "Name of the index to create.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/indices._types:DownsampleConfig"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/_alias/{name}": {
      "get": {
        "description": "Returns an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.get_alias#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      },
      "head": {
        "description": "Returns information about whether a particular alias exists.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.exists_alias#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.exists_alias#name"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.exists_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.exists_alias#200"
          }
        }
      }
    },
    "/{index}/_lifecycle/explain": {
      "get": {
        "description": "Retrieves information about the index's current data stream lifecycle, such as any potential encountered error, time since creation etc.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/data-streams-explain-lifecycle.html"
        },
        "operationId": "indices.explain_data_lifecycle#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index to explain",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "indicates if the API should return the default values the system uses for the index's lifecycle",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Specify timeout for connection to master",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "indices": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/indices.explain_data_lifecycle:DataStreamLifecycleExplain"
                      }
                    }
                  },
                  "required": [
                    "indices"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_alias": {
      "get": {
        "description": "Returns an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.get_alias#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      }
    },
    "/{index}/_alias": {
      "get": {
        "description": "Returns an alias.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.get_alias#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_alias#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_alias#local"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_alias#200"
          }
        }
      }
    },
    "/_data_stream": {
      "get": {
        "description": "Returns data streams.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.get_data_stream#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_data_stream#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_data_stream#include_defaults"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_data_stream#200"
          }
        }
      }
    },
    "/_index_template": {
      "get": {
        "description": "Returns an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.get_index_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_index_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.get_index_template#include_defaults"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_index_template#200"
          }
        }
      }
    },
    "/_mapping": {
      "get": {
        "description": "Returns mappings for one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html"
        },
        "operationId": "indices.get_mapping#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_mapping#200"
          }
        }
      }
    },
    "/{index}/_mapping": {
      "get": {
        "description": "Returns mappings for one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-mapping.html"
        },
        "operationId": "indices.get_mapping#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_mapping#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_mapping#200"
          }
        }
      },
      "put": {
        "description": "Updates the index mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html"
        },
        "operationId": "indices.put_mapping#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#write_index_only"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_mapping#200"
          }
        }
      },
      "post": {
        "description": "Updates the index mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-put-mapping.html"
        },
        "operationId": "indices.put_mapping#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_mapping#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_mapping#write_index_only"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_mapping#200"
          }
        }
      }
    },
    "/_settings": {
      "get": {
        "description": "Returns settings for one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html"
        },
        "operationId": "indices.get_settings#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      },
      "put": {
        "description": "Updates the index settings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html"
        },
        "operationId": "indices.put_settings#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#preserve_existing"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_settings"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_settings#200"
          }
        }
      }
    },
    "/{index}/_settings": {
      "get": {
        "description": "Returns settings for one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html"
        },
        "operationId": "indices.get_settings#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      },
      "put": {
        "description": "Updates the index settings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-update-settings.html"
        },
        "operationId": "indices.put_settings#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.put_settings#index"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#preserve_existing"
          },
          {
            "$ref": "#/components/parameters/indices.put_settings#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.put_settings"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.put_settings#200"
          }
        }
      }
    },
    "/{index}/_settings/{name}": {
      "get": {
        "description": "Returns settings for one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html"
        },
        "operationId": "indices.get_settings#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#index"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      }
    },
    "/_settings/{name}": {
      "get": {
        "description": "Returns settings for one or more indices.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-get-settings.html"
        },
        "operationId": "indices.get_settings#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_settings#name"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#include_defaults"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_settings#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_settings#200"
          }
        }
      }
    },
    "/_template": {
      "get": {
        "description": "Returns an index template.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.get_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.get_template#flat_settings"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#local"
          },
          {
            "$ref": "#/components/parameters/indices.get_template#master_timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.get_template#200"
          }
        }
      }
    },
    "/_data_stream/_migrate/{name}": {
      "post": {
        "description": "Migrates an alias to a data stream",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.migrate_to_data_stream#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Name of the index alias to convert to a data stream.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_data_stream/_modify": {
      "post": {
        "description": "Modifies a data stream",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/data-streams.html"
        },
        "operationId": "indices.modify_data_stream#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "actions": {
                    "description": "Actions to perform.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/indices.modify_data_stream:Action"
                    }
                  }
                },
                "required": [
                  "actions"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_open": {
      "post": {
        "description": "Opens an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-open-close.html"
        },
        "operationId": "indices.open#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nBy default, you must explicitly name the indices you using to limit the request.\nTo limit a request using `_all`, `*`, or other wildcard expressions, change the `action.destructive_requires_name` setting to false.\nYou can update this setting in the `elasticsearch.yml` file or using the cluster update settings API.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "shards_acknowledged": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "shards_acknowledged"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_recovery": {
      "get": {
        "description": "Returns information about ongoing index shard recoveries.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html"
        },
        "operationId": "indices.recovery#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.recovery#active_only"
          },
          {
            "$ref": "#/components/parameters/indices.recovery#detailed"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.recovery#200"
          }
        }
      }
    },
    "/{index}/_recovery": {
      "get": {
        "description": "Returns information about ongoing index shard recoveries.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-recovery.html"
        },
        "operationId": "indices.recovery#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.recovery#index"
          },
          {
            "$ref": "#/components/parameters/indices.recovery#active_only"
          },
          {
            "$ref": "#/components/parameters/indices.recovery#detailed"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.recovery#200"
          }
        }
      }
    },
    "/_resolve/index/{name}": {
      "get": {
        "description": "Returns information about any matching indices, aliases, and data streams",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-resolve-index-api.html"
        },
        "operationId": "indices.resolve_index#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Comma-separated name(s) or index pattern(s) of the indices, aliases, and data streams to resolve.\nResources on remote clusters can be specified using the `<cluster>`:`<name>` syntax.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.resolve_index:ResolveIndexItem"
                      }
                    },
                    "aliases": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.resolve_index:ResolveIndexAliasItem"
                      }
                    },
                    "data_streams": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/indices.resolve_index:ResolveIndexDataStreamsItem"
                      }
                    }
                  },
                  "required": [
                    "indices",
                    "aliases",
                    "data_streams"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{alias}/_rollover": {
      "post": {
        "description": "Updates an alias to point to a new index when the existing index\nis considered to be too large or too old.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-rollover-index.html"
        },
        "operationId": "indices.rollover#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.rollover#alias"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#dry_run"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.rollover"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.rollover#200"
          }
        }
      }
    },
    "/{alias}/_rollover/{new_index}": {
      "post": {
        "description": "Updates an alias to point to a new index when the existing index\nis considered to be too large or too old.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-rollover-index.html"
        },
        "operationId": "indices.rollover#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.rollover#alias"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#new_index"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#dry_run"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#timeout"
          },
          {
            "$ref": "#/components/parameters/indices.rollover#wait_for_active_shards"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.rollover"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.rollover#200"
          }
        }
      }
    },
    "/_index_template/_simulate_index/{name}": {
      "post": {
        "description": "Simulate matching the given index name against the index templates in the system",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.simulate_index_template#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Index or template name to simulate",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "create",
            "description": "If `true`, the template passed in the body is only used if no existing\ntemplates match the same index patterns. If `false`, the simulation uses\nthe template with the highest priority. Note that the template is not\npermanently added or updated in either case; it is only used for the\nsimulation.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received\nbefore the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "include_defaults",
            "description": "If true, returns all relevant default configurations for the index template.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_auto_create": {
                    "description": "This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that template even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false`, then indices or data streams matching the template must always be explicitly created, and may never be automatically created.",
                    "type": "boolean"
                  },
                  "index_patterns": {
                    "$ref": "#/components/schemas/_types:Indices"
                  },
                  "composed_of": {
                    "description": "An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Name"
                    }
                  },
                  "template": {
                    "$ref": "#/components/schemas/indices.put_index_template:IndexTemplateMapping"
                  },
                  "data_stream": {
                    "$ref": "#/components/schemas/indices._types:DataStreamVisibility"
                  },
                  "priority": {
                    "description": "Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
                    "type": "number"
                  },
                  "version": {
                    "$ref": "#/components/schemas/_types:VersionNumber"
                  },
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object"
                }
              }
            }
          }
        }
      }
    },
    "/_index_template/_simulate": {
      "post": {
        "description": "Simulate resolving the given template name or body",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.simulate_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.simulate_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#include_defaults"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.simulate_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.simulate_template#200"
          }
        }
      }
    },
    "/_index_template/_simulate/{name}": {
      "post": {
        "description": "Simulate resolving the given template name or body",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-templates.html"
        },
        "operationId": "indices.simulate_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.simulate_template#name"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#create"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#master_timeout"
          },
          {
            "$ref": "#/components/parameters/indices.simulate_template#include_defaults"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.simulate_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.simulate_template#200"
          }
        }
      }
    },
    "/_stats": {
      "get": {
        "description": "Provides statistics on operations happening in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html"
        },
        "operationId": "indices.stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        }
      }
    },
    "/_stats/{metric}": {
      "get": {
        "description": "Provides statistics on operations happening in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html"
        },
        "operationId": "indices.stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#metric"
          },
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        }
      }
    },
    "/{index}/_stats": {
      "get": {
        "description": "Provides statistics on operations happening in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html"
        },
        "operationId": "indices.stats#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#index"
          },
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        }
      }
    },
    "/{index}/_stats/{metric}": {
      "get": {
        "description": "Provides statistics on operations happening in an index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-stats.html"
        },
        "operationId": "indices.stats#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.stats#index"
          },
          {
            "$ref": "#/components/parameters/indices.stats#metric"
          },
          {
            "$ref": "#/components/parameters/indices.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#fields"
          },
          {
            "$ref": "#/components/parameters/indices.stats#forbid_closed_indices"
          },
          {
            "$ref": "#/components/parameters/indices.stats#groups"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/indices.stats#include_unloaded_segments"
          },
          {
            "$ref": "#/components/parameters/indices.stats#level"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.stats#200"
          }
        }
      }
    },
    "/_aliases": {
      "post": {
        "description": "Updates index aliases.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/indices-aliases.html"
        },
        "operationId": "indices.update_aliases#0",
        "parameters": [
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "actions": {
                    "description": "Actions to perform.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/indices.update_aliases:Action"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_validate/query": {
      "get": {
        "description": "Allows a user to validate a potentially expensive query without executing it.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html"
        },
        "operationId": "indices.validate_query#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        }
      },
      "post": {
        "description": "Allows a user to validate a potentially expensive query without executing it.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html"
        },
        "operationId": "indices.validate_query#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        }
      }
    },
    "/{index}/_validate/query": {
      "get": {
        "description": "Allows a user to validate a potentially expensive query without executing it.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html"
        },
        "operationId": "indices.validate_query#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#index"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        }
      },
      "post": {
        "description": "Allows a user to validate a potentially expensive query without executing it.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-validate.html"
        },
        "operationId": "indices.validate_query#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/indices.validate_query#index"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#all_shards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyzer"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#default_operator"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#df"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#explain"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#lenient"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#rewrite"
          },
          {
            "$ref": "#/components/parameters/indices.validate_query#q"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/indices.validate_query"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/indices.validate_query#200"
          }
        }
      }
    },
    "/": {
      "get": {
        "description": "Returns basic information about the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html"
        },
        "operationId": "info#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "cluster_uuid": {
                      "$ref": "#/components/schemas/_types:Uuid"
                    },
                    "name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "tagline": {
                      "type": "string"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:ElasticsearchVersionInfo"
                    }
                  },
                  "required": [
                    "cluster_name",
                    "cluster_uuid",
                    "name",
                    "tagline",
                    "version"
                  ]
                }
              }
            }
          }
        }
      },
      "head": {
        "description": "Returns whether the cluster is running.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/index.html"
        },
        "operationId": "ping#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_ingest/pipeline/{id}": {
      "get": {
        "description": "Returns a pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/get-pipeline-api.html"
        },
        "operationId": "ingest.get_pipeline#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#id"
          },
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#summary"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_pipeline#200"
          }
        }
      },
      "put": {
        "description": "Creates or updates a pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ingest.html"
        },
        "operationId": "ingest.put_pipeline#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "ID of the ingest pipeline to create or update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "if_version",
            "description": "Required version for optimistic concurrency control for pipeline updates",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:VersionNumber"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "description": {
                    "description": "Description of the ingest pipeline.",
                    "type": "string"
                  },
                  "on_failure": {
                    "description": "Processors to run immediately after a processor failure. Each processor supports a processor-level `on_failure` value. If a processor without an `on_failure` value fails, Elasticsearch uses this pipeline-level parameter as a fallback. The processors in this parameter run sequentially in the order specified. Elasticsearch will not attempt to run the pipeline's remaining processors.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
                    }
                  },
                  "processors": {
                    "description": "Processors used to perform transformations on documents before indexing. Processors run sequentially in the order specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
                    }
                  },
                  "version": {
                    "$ref": "#/components/schemas/_types:VersionNumber"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-pipeline-api.html"
        },
        "operationId": "ingest.delete_pipeline#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Pipeline ID or wildcard expression of pipeline IDs used to limit the request.\nTo delete all ingest pipelines in a cluster, use a value of `*`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "master_timeout",
            "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ingest/geoip/stats": {
      "get": {
        "description": "Returns statistical information about geoip databases",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/geoip-processor.html"
        },
        "operationId": "ingest.geo_ip_stats#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stats": {
                      "$ref": "#/components/schemas/ingest.geo_ip_stats:GeoIpDownloadStatistics"
                    },
                    "nodes": {
                      "description": "Downloaded GeoIP2 databases for each node.",
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/ingest.geo_ip_stats:GeoIpNodeDatabases"
                      }
                    }
                  },
                  "required": [
                    "stats",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ingest/pipeline": {
      "get": {
        "description": "Returns a pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/get-pipeline-api.html"
        },
        "operationId": "ingest.get_pipeline#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ingest.get_pipeline#summary"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.get_pipeline#200"
          }
        }
      }
    },
    "/_ingest/processor/grok": {
      "get": {
        "description": "Returns a list of the built-in patterns.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/grok-processor.html"
        },
        "operationId": "ingest.processor_grok#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "patterns": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "patterns"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ingest/pipeline/_simulate": {
      "get": {
        "description": "Allows to simulate a pipeline with example documents.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html"
        },
        "operationId": "ingest.simulate#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        }
      },
      "post": {
        "description": "Allows to simulate a pipeline with example documents.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html"
        },
        "operationId": "ingest.simulate#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        }
      }
    },
    "/_ingest/pipeline/{id}/_simulate": {
      "get": {
        "description": "Allows to simulate a pipeline with example documents.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html"
        },
        "operationId": "ingest.simulate#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#id"
          },
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        }
      },
      "post": {
        "description": "Allows to simulate a pipeline with example documents.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/simulate-pipeline-api.html"
        },
        "operationId": "ingest.simulate#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ingest.simulate#id"
          },
          {
            "$ref": "#/components/parameters/ingest.simulate#verbose"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ingest.simulate"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ingest.simulate#200"
          }
        }
      }
    },
    "/_logstash/pipeline/{id}": {
      "get": {
        "description": "Retrieves Logstash Pipelines used by Central Management",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/logstash-api-get-pipeline.html"
        },
        "operationId": "logstash.get_pipeline#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/logstash.get_pipeline#id"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/logstash.get_pipeline#200"
          }
        }
      },
      "put": {
        "description": "Adds and updates Logstash Pipelines used for Central Management",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/logstash-api-put-pipeline.html"
        },
        "operationId": "logstash.put_pipeline#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the pipeline.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/logstash._types:Pipeline"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      },
      "delete": {
        "description": "Deletes Logstash Pipelines used by Central Management",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/logstash-api-delete-pipeline.html"
        },
        "operationId": "logstash.delete_pipeline#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the pipeline.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_logstash/pipeline": {
      "get": {
        "description": "Retrieves Logstash Pipelines used by Central Management",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/logstash-api-get-pipeline.html"
        },
        "operationId": "logstash.get_pipeline#0",
        "responses": {
          "200": {
            "$ref": "#/components/responses/logstash.get_pipeline#200"
          }
        }
      }
    },
    "/_mget": {
      "get": {
        "description": "Allows to get multiple documents in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html"
        },
        "operationId": "mget#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        }
      },
      "post": {
        "description": "Allows to get multiple documents in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html"
        },
        "operationId": "mget#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        }
      }
    },
    "/{index}/_mget": {
      "get": {
        "description": "Allows to get multiple documents in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html"
        },
        "operationId": "mget#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#index"
          },
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        }
      },
      "post": {
        "description": "Allows to get multiple documents in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-get.html"
        },
        "operationId": "mget#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/mget#index"
          },
          {
            "$ref": "#/components/parameters/mget#preference"
          },
          {
            "$ref": "#/components/parameters/mget#realtime"
          },
          {
            "$ref": "#/components/parameters/mget#refresh"
          },
          {
            "$ref": "#/components/parameters/mget#routing"
          },
          {
            "$ref": "#/components/parameters/mget#_source"
          },
          {
            "$ref": "#/components/parameters/mget#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/mget#_source_includes"
          },
          {
            "$ref": "#/components/parameters/mget#stored_fields"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mget"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mget#200"
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/deployment/cache/_clear": {
      "post": {
        "description": "Clear the cached results from a trained model deployment",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/clear-trained-model-deployment-cache.html"
        },
        "operationId": "ml.clear_trained_model_deployment_cache#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cleared": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "cleared"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_close": {
      "post": {
        "description": "Closes one or more anomaly detection jobs. A job can be opened and closed multiple times throughout its lifecycle.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-close-job.html"
        },
        "operationId": "ml.close_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job. It can be a job identifier, a group name, or a wildcard expression. You can close multiple anomaly detection jobs in a single API request by using a group name, a comma-separated list of jobs, or a wildcard expression. You can close all jobs by using `_all` or by specifying `*` as the job identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request: contains wildcard expressions and there are no jobs that match; contains the  `_all` string or no identifiers and there are no matches; or contains wildcard expressions and there are only partial matches. By default, it returns an empty jobs array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Use to close a failed job, or to forcefully close a job which has not responded to its initial close request; the request returns without performing the associated actions such as flushing buffers and persisting the model snapshots.\nIf you want the job to be in a consistent state after the close job API returns, do not set to `true`. This parameter should be used only in situations where the job has already failed or where you are not interested in results the job might have recently produced or might produce in the future.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait until a job has closed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_no_match": {
                    "description": "Refer to the description for the `allow_no_match` query parameter.",
                    "type": "boolean"
                  },
                  "force": {
                    "description": "Refer to the descriptiion for the `force` query parameter.",
                    "type": "boolean"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "closed": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "closed"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/calendars/{calendar_id}": {
      "get": {
        "description": "Retrieves configuration information for calendars.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-calendar.html"
        },
        "operationId": "ml.get_calendars#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#calendar_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        }
      },
      "put": {
        "description": "Instantiates a calendar.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-calendar.html"
        },
        "operationId": "ml.put_calendar#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "job_ids": {
                    "description": "An array of anomaly detection job identifiers.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "description": {
                    "description": "A description of the calendar.",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "calendar_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "description": {
                      "description": "A description of the calendar.",
                      "type": "string"
                    },
                    "job_ids": {
                      "$ref": "#/components/schemas/_types:Ids"
                    }
                  },
                  "required": [
                    "calendar_id",
                    "job_ids"
                  ]
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Retrieves configuration information for calendars.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-calendar.html"
        },
        "operationId": "ml.get_calendars#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#calendar_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        }
      },
      "delete": {
        "description": "Deletes a calendar.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-calendar.html"
        },
        "operationId": "ml.delete_calendar#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/calendars/{calendar_id}/events/{event_id}": {
      "delete": {
        "description": "Deletes scheduled events from a calendar.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-calendar-event.html"
        },
        "operationId": "ml.delete_calendar_event#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "event_id",
            "description": "Identifier for the scheduled event.\nYou can obtain this identifier by using the get calendar events API.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/calendars/{calendar_id}/jobs/{job_id}": {
      "put": {
        "description": "Adds an anomaly detection job to a calendar.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-calendar-job.html"
        },
        "operationId": "ml.put_calendar_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "job_id",
            "description": "An identifier for the anomaly detection jobs. It can be a job identifier, a group name, or a comma-separated list of jobs or groups.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "calendar_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "description": {
                      "description": "A description of the calendar.",
                      "type": "string"
                    },
                    "job_ids": {
                      "$ref": "#/components/schemas/_types:Ids"
                    }
                  },
                  "required": [
                    "calendar_id",
                    "job_ids"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes anomaly detection jobs from a calendar.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-calendar-job.html"
        },
        "operationId": "ml.delete_calendar_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "job_id",
            "description": "An identifier for the anomaly detection jobs. It can be a job identifier, a group name, or a\ncomma-separated list of jobs or groups.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "calendar_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "description": {
                      "description": "A description of the calendar.",
                      "type": "string"
                    },
                    "job_ids": {
                      "$ref": "#/components/schemas/_types:Ids"
                    }
                  },
                  "required": [
                    "calendar_id",
                    "job_ids"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}": {
      "get": {
        "description": "Retrieves configuration information for data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-dfanalytics.html"
        },
        "operationId": "ml.get_data_frame_analytics#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#id"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics#200"
          }
        }
      },
      "put": {
        "description": "Instantiates a data frame analytics job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-dfanalytics.html"
        },
        "operationId": "ml.put_data_frame_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_lazy_start": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
                    },
                    "description": "Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node. If\nset to `false` and a machine learning node with capacity to run the job\ncannot be immediately found, the API returns an error. If set to `true`,\nthe API does not return an error; the job waits in the `starting` state\nuntil sufficient machine learning node capacity is available. This\nbehavior is also affected by the cluster-wide\n`xpack.ml.max_lazy_ml_nodes` setting.",
                    "type": "boolean"
                  },
                  "analysis": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                  },
                  "analyzed_fields": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                  },
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "dest": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                  },
                  "max_num_threads": {
                    "description": "The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.",
                    "type": "number"
                  },
                  "model_memory_limit": {
                    "description": "The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try\nto create data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.",
                    "type": "string"
                  },
                  "source": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                  },
                  "headers": {
                    "$ref": "#/components/schemas/_types:HttpHeaders"
                  },
                  "version": {
                    "$ref": "#/components/schemas/_types:VersionString"
                  }
                },
                "required": [
                  "analysis",
                  "dest",
                  "source"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsAuthorization"
                    },
                    "allow_lazy_start": {
                      "type": "boolean"
                    },
                    "analysis": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                    },
                    "analyzed_fields": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                    },
                    "create_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "description": {
                      "type": "string"
                    },
                    "dest": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "max_num_threads": {
                      "type": "number"
                    },
                    "model_memory_limit": {
                      "type": "string"
                    },
                    "source": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    }
                  },
                  "required": [
                    "allow_lazy_start",
                    "analysis",
                    "create_time",
                    "dest",
                    "id",
                    "max_num_threads",
                    "model_memory_limit",
                    "source",
                    "version"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an existing data frame analytics job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-dfanalytics.html"
        },
        "operationId": "ml.delete_data_frame_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If `true`, it deletes a job that is not stopped; this method is quicker than stopping and deleting the job.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The time to wait for the job to be deleted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/datafeeds/{datafeed_id}": {
      "get": {
        "description": "Retrieves configuration information for datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed.html"
        },
        "operationId": "ml.get_datafeeds#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeeds#200"
          }
        }
      },
      "put": {
        "description": "Instantiates a datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-datafeed.html"
        },
        "operationId": "ml.put_datafeed#0",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed.\nThis identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.\nIt must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If true, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the `_all`\nstring or when no indices are specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument determines\nwhether wildcard expressions match hidden data streams. Supports comma-separated values.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_throttled",
            "description": "If true, concrete, expanded, or aliased indices are ignored when frozen.",
            "deprecated": true,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If true, unavailable indices (missing or closed) are ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aggregations": {
                    "description": "If set, the datafeed performs aggregation searches.\nSupport for aggregations is limited and should be used only with low cardinality data.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                    }
                  },
                  "chunking_config": {
                    "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                  },
                  "delayed_data_check_config": {
                    "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "indices": {
                    "$ref": "#/components/schemas/_types:Indices"
                  },
                  "indices_options": {
                    "$ref": "#/components/schemas/_types:IndicesOptions"
                  },
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "max_empty_searches": {
                    "description": "If a real-time datafeed has never seen any data (including during any initial training period), it automatically\nstops and closes the associated job after this many real-time searches return no documents. In other words,\nit stops after `frequency` times `max_empty_searches` of real-time operation. If not set, a datafeed with no\nend time that sees no data remains started until it is explicitly stopped. By default, it is not set.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "query_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "runtime_mappings": {
                    "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                  },
                  "script_fields": {
                    "description": "Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.\nThe detector configuration objects in a job can contain functions that use these script fields.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types:ScriptField"
                    }
                  },
                  "scroll_size": {
                    "description": "The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.\nThe maximum value is the value of `index.max_result_window`, which is 10,000 by default.",
                    "type": "number"
                  },
                  "headers": {
                    "$ref": "#/components/schemas/_types:HttpHeaders"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "aggregations": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                      }
                    },
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DatafeedAuthorization"
                    },
                    "chunking_config": {
                      "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                    },
                    "delayed_data_check_config": {
                      "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                    },
                    "datafeed_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "frequency": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "indices_options": {
                      "$ref": "#/components/schemas/_types:IndicesOptions"
                    },
                    "max_empty_searches": {
                      "type": "number"
                    },
                    "query": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    },
                    "query_delay": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "runtime_mappings": {
                      "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                    },
                    "script_fields": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types:ScriptField"
                      }
                    },
                    "scroll_size": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "chunking_config",
                    "datafeed_id",
                    "indices",
                    "job_id",
                    "query",
                    "query_delay",
                    "scroll_size"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an existing datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-datafeed.html"
        },
        "operationId": "ml.delete_datafeed#0",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed. This\nidentifier can contain lowercase alphanumeric characters (a-z and 0-9),\nhyphens, and underscores. It must start and end with alphanumeric\ncharacters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Use to forcefully delete a started datafeed; this method is quicker than\nstopping and deleting the datafeed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/_delete_expired_data/{job_id}": {
      "delete": {
        "description": "Deletes expired and unused machine learning data.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-expired-data.html"
        },
        "operationId": "ml.delete_expired_data#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#requests_per_second"
          },
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.delete_expired_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_expired_data#200"
          }
        }
      }
    },
    "/_ml/_delete_expired_data": {
      "delete": {
        "description": "Deletes expired and unused machine learning data.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-expired-data.html"
        },
        "operationId": "ml.delete_expired_data#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#requests_per_second"
          },
          {
            "$ref": "#/components/parameters/ml.delete_expired_data#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.delete_expired_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_expired_data#200"
          }
        }
      }
    },
    "/_ml/filters/{filter_id}": {
      "get": {
        "description": "Retrieves filters.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-filter.html"
        },
        "operationId": "ml.get_filters#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_filters#filter_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_filters#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_filters#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_filters#200"
          }
        }
      },
      "put": {
        "description": "Instantiates a filter.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-filter.html"
        },
        "operationId": "ml.put_filter#0",
        "parameters": [
          {
            "in": "path",
            "name": "filter_id",
            "description": "A string that uniquely identifies a filter.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A description of the filter.",
                    "type": "string"
                  },
                  "items": {
                    "description": "The items of the filter. A wildcard `*` can be used at the beginning or the end of an item.\nUp to 10000 items are allowed in each filter.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "description": {
                      "type": "string"
                    },
                    "filter_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "description",
                    "filter_id",
                    "items"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a filter.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-filter.html"
        },
        "operationId": "ml.delete_filter#0",
        "parameters": [
          {
            "in": "path",
            "name": "filter_id",
            "description": "A string that uniquely identifies a filter.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_forecast": {
      "post": {
        "description": "Predicts the future behavior of a time series by using its historical behavior.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-forecast.html"
        },
        "operationId": "ml.forecast#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job. The job must be open when you\ncreate a forecast; otherwise, an error occurs.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "duration",
            "description": "A period of time that indicates how far into the future to forecast. For\nexample, `30d` corresponds to 30 days. The forecast starts at the last\nrecord that was processed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expires_in",
            "description": "The period of time that forecast results are retained. After a forecast\nexpires, the results are deleted. If set to a value of 0, the forecast is\nnever automatically deleted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_model_memory",
            "description": "The maximum memory the forecast can use. If the forecast needs to use\nmore than the provided amount, it will spool to disk. Default is 20mb,\nmaximum is 500mb and minimum is 1mb. If set to 40% or more of the jobs\nconfigured memory limit, it is automatically reduced to below that\namount.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "duration": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "expires_in": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "max_model_memory": {
                    "description": "Refer to the description for the `max_model_memory` query parameter.",
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "forecast_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "forecast_id"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes forecasts from a machine learning job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-forecast.html"
        },
        "operationId": "ml.delete_forecast#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_forecast#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#allow_no_forecasts"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_forecast#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_forecast/{forecast_id}": {
      "delete": {
        "description": "Deletes forecasts from a machine learning job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-forecast.html"
        },
        "operationId": "ml.delete_forecast#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.delete_forecast#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#forecast_id"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#allow_no_forecasts"
          },
          {
            "$ref": "#/components/parameters/ml.delete_forecast#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.delete_forecast#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}": {
      "get": {
        "description": "Retrieves configuration information for anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job.html"
        },
        "operationId": "ml.get_jobs#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_jobs#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_jobs#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_jobs#200"
          }
        }
      },
      "put": {
        "description": "Instantiates an anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-job.html"
        },
        "operationId": "ml.put_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "The identifier for the anomaly detection job. This identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_lazy_open": {
                    "description": "Advanced configuration option. Specifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node. By default, if a machine learning node with capacity to run the job cannot immediately be found, the open anomaly detection jobs API returns an error. However, this is also subject to the cluster-wide `xpack.ml.max_lazy_ml_nodes` setting. If this option is set to true, the open anomaly detection jobs API does not return an error and the job waits in the opening state until sufficient machine learning node capacity is available.",
                    "type": "boolean"
                  },
                  "analysis_config": {
                    "$ref": "#/components/schemas/ml._types:AnalysisConfig"
                  },
                  "analysis_limits": {
                    "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                  },
                  "background_persist_interval": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "custom_settings": {
                    "$ref": "#/components/schemas/ml._types:CustomSettings"
                  },
                  "daily_model_snapshot_retention_after_days": {
                    "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job. It specifies a period of time (in days) after which only the first snapshot per day is retained. This period is relative to the timestamp of the most recent snapshot for this job. Valid values range from 0 to `model_snapshot_retention_days`.",
                    "type": "number"
                  },
                  "data_description": {
                    "$ref": "#/components/schemas/ml._types:DataDescription"
                  },
                  "datafeed_config": {
                    "$ref": "#/components/schemas/ml._types:DatafeedConfig"
                  },
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "groups": {
                    "description": "A list of job groups. A job can belong to no groups or many.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "model_plot_config": {
                    "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                  },
                  "model_snapshot_retention_days": {
                    "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job. It specifies the maximum period of time (in days) that snapshots are retained. This period is relative to the timestamp of the most recent snapshot for this job. By default, snapshots ten days older than the newest snapshot are deleted.",
                    "type": "number"
                  },
                  "renormalization_window_days": {
                    "description": "Advanced configuration option. The period over which adjustments to the score are applied, as new data is seen. The default value is the longer of 30 days or 100 bucket spans.",
                    "type": "number"
                  },
                  "results_index_name": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "results_retention_days": {
                    "description": "Advanced configuration option. The period of time (in days) that results are retained. Age is calculated relative to the timestamp of the latest bucket result. If this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch. The default value is null, which means all results are retained. Annotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results. Annotations added by users are retained forever.",
                    "type": "number"
                  }
                },
                "required": [
                  "analysis_config",
                  "data_description"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allow_lazy_open": {
                      "type": "boolean"
                    },
                    "analysis_config": {
                      "$ref": "#/components/schemas/ml._types:AnalysisConfigRead"
                    },
                    "analysis_limits": {
                      "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                    },
                    "background_persist_interval": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "create_time": {
                      "$ref": "#/components/schemas/_types:DateTime"
                    },
                    "custom_settings": {
                      "$ref": "#/components/schemas/ml._types:CustomSettings"
                    },
                    "daily_model_snapshot_retention_after_days": {
                      "type": "number"
                    },
                    "data_description": {
                      "$ref": "#/components/schemas/ml._types:DataDescription"
                    },
                    "datafeed_config": {
                      "$ref": "#/components/schemas/ml._types:Datafeed"
                    },
                    "description": {
                      "type": "string"
                    },
                    "groups": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "job_type": {
                      "type": "string"
                    },
                    "job_version": {
                      "type": "string"
                    },
                    "model_plot_config": {
                      "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                    },
                    "model_snapshot_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "model_snapshot_retention_days": {
                      "type": "number"
                    },
                    "renormalization_window_days": {
                      "type": "number"
                    },
                    "results_index_name": {
                      "type": "string"
                    },
                    "results_retention_days": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "allow_lazy_open",
                    "analysis_config",
                    "analysis_limits",
                    "create_time",
                    "daily_model_snapshot_retention_after_days",
                    "data_description",
                    "job_id",
                    "job_type",
                    "job_version",
                    "model_snapshot_retention_days",
                    "results_index_name"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an existing anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-job.html"
        },
        "operationId": "ml.delete_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Use to forcefully delete an opened job; this method is quicker than\nclosing and deleting the job.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delete_user_annotations",
            "description": "Specifies whether annotations that have been added by the\nuser should be deleted along with any auto-generated annotations when the job is\nreset.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "Specifies whether the request should return immediately or wait until the\njob deletion completes.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}": {
      "get": {
        "description": "Retrieves information about model snapshots.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html"
        },
        "operationId": "ml.get_model_snapshots#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#snapshot_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        }
      },
      "post": {
        "description": "Retrieves information about model snapshots.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html"
        },
        "operationId": "ml.get_model_snapshots#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#snapshot_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        }
      },
      "delete": {
        "description": "Deletes an existing model snapshot.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-delete-snapshot.html"
        },
        "operationId": "ml.delete_model_snapshot#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "Identifier for the model snapshot.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}": {
      "get": {
        "description": "Retrieves configuration information for a trained inference model.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-trained-models.html"
        },
        "operationId": "ml.get_trained_models#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#decompress_definition"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#exclude_generated"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#include"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#tags"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models#200"
          }
        }
      },
      "put": {
        "description": "Creates an inference trained model.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-trained-models.html"
        },
        "operationId": "ml.put_trained_model#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "defer_definition_decompression",
            "description": "If set to `true` and a `compressed_definition` is provided, the request defers definition decompression and skips relevant validations.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "compressed_definition": {
                    "description": "The compressed (GZipped and Base64 encoded) inference definition of the\nmodel. If compressed_definition is specified, then definition cannot be\nspecified.",
                    "type": "string"
                  },
                  "definition": {
                    "$ref": "#/components/schemas/ml.put_trained_model:Definition"
                  },
                  "description": {
                    "description": "A human-readable description of the inference trained model.",
                    "type": "string"
                  },
                  "inference_config": {
                    "$ref": "#/components/schemas/ml._types:InferenceConfigCreateContainer"
                  },
                  "input": {
                    "$ref": "#/components/schemas/ml.put_trained_model:Input"
                  },
                  "metadata": {
                    "description": "An object map that contains metadata about the model.",
                    "type": "object"
                  },
                  "model_type": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelType"
                  },
                  "model_size_bytes": {
                    "description": "The estimated memory usage in bytes to keep the trained model in memory.\nThis property is supported only if defer_definition_decompression is true\nor the model definition is not supplied.",
                    "type": "number"
                  },
                  "tags": {
                    "description": "An array of tags to organize the model.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ml._types:TrainedModelConfig"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an existing trained inference model that is currently not referenced by an ingest pipeline.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-trained-models.html"
        },
        "operationId": "ml.delete_trained_model#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Forcefully deletes a trained model that is referenced by ingest pipelines or has a started deployment.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/model_aliases/{model_alias}": {
      "put": {
        "description": "Creates a new model alias (or reassigns an existing one) to refer to the trained model",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-trained-models-aliases.html"
        },
        "operationId": "ml.put_trained_model_alias#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The identifier for the trained model that the alias refers to.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "model_alias",
            "description": "The alias to create or update. This value cannot end in numbers.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "reassign",
            "description": "Specifies whether the alias gets reassigned to the specified trained\nmodel if it is already assigned to a different model. If the alias is\nalready assigned and this parameter is false, the API returns an error.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a model alias that refers to the trained model",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-trained-models-aliases.html"
        },
        "operationId": "ml.delete_trained_model_alias#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The trained model ID to which the model alias refers.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "model_alias",
            "description": "The model alias to delete.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/_estimate_model_memory": {
      "post": {
        "description": "Estimates the model memory",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-apis.html"
        },
        "operationId": "ml.estimate_model_memory#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "analysis_config": {
                    "$ref": "#/components/schemas/ml._types:AnalysisConfig"
                  },
                  "max_bucket_cardinality": {
                    "description": "Estimates of the highest cardinality in a single bucket that is observed\nfor influencer fields over the time period that the job analyzes data.\nTo produce a good answer, values must be provided for all influencer\nfields. Providing values for fields that are not listed as `influencers`\nhas no effect on the estimation.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  },
                  "overall_cardinality": {
                    "description": "Estimates of the cardinality that is observed for fields over the whole\ntime period that the job analyzes data. To produce a good answer, values\nmust be provided for fields referenced in the `by_field_name`,\n`over_field_name` and `partition_field_name` of any detectors. Providing\nvalues for other fields has no effect on the estimation. It can be\nomitted from the request if no detectors have a `by_field_name`,\n`over_field_name` or `partition_field_name`.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "model_memory_estimate": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "model_memory_estimate"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/_evaluate": {
      "post": {
        "description": "Evaluates the data frame analytics for an annotated index.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/evaluate-dfanalytics.html"
        },
        "operationId": "ml.evaluate_data_frame#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "evaluation": {
                    "$ref": "#/components/schemas/ml._types:DataframeEvaluationContainer"
                  },
                  "index": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  }
                },
                "required": [
                  "evaluation",
                  "index"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "classification": {
                      "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummary"
                    },
                    "outlier_detection": {
                      "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeOutlierDetectionSummary"
                    },
                    "regression": {
                      "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeRegressionSummary"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/analytics/_explain": {
      "get": {
        "description": "Explains a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/explain-dfanalytics.html"
        },
        "operationId": "ml.explain_data_frame_analytics#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        }
      },
      "post": {
        "description": "Explains a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/explain-dfanalytics.html"
        },
        "operationId": "ml.explain_data_frame_analytics#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}/_explain": {
      "get": {
        "description": "Explains a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/explain-dfanalytics.html"
        },
        "operationId": "ml.explain_data_frame_analytics#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.explain_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        }
      },
      "post": {
        "description": "Explains a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/explain-dfanalytics.html"
        },
        "operationId": "ml.explain_data_frame_analytics#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.explain_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.explain_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.explain_data_frame_analytics#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_flush": {
      "post": {
        "description": "Forces any buffered data to be processed by the job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-flush-job.html"
        },
        "operationId": "ml.flush_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "advance_time",
            "description": "Specifies to advance to a particular time value. Results are generated\nand the model is updated for data from the specified time interval.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "calc_interim",
            "description": "If true, calculates the interim results for the most recent bucket or all\nbuckets within the latency period.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "end",
            "description": "When used in conjunction with `calc_interim` and `start`, specifies the\nrange of buckets on which to calculate interim results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "skip_time",
            "description": "Specifies to skip to a particular time value. Results are not generated\nand the model is not updated for data from the specified time interval.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "start",
            "description": "When used in conjunction with `calc_interim`, specifies the range of\nbuckets on which to calculate interim results.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "advance_time": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "calc_interim": {
                    "description": "Refer to the description for the `calc_interim` query parameter.",
                    "type": "boolean"
                  },
                  "end": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "skip_time": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "start": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "flushed": {
                      "type": "boolean"
                    },
                    "last_finalized_bucket_end": {
                      "description": "Provides the timestamp (in milliseconds since the epoch) of the end of\nthe last bucket that was processed.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "flushed"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/buckets/{timestamp}": {
      "get": {
        "description": "Retrieves anomaly detection job results for one or more buckets.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html"
        },
        "operationId": "ml.get_buckets#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#timestamp"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        }
      },
      "post": {
        "description": "Retrieves anomaly detection job results for one or more buckets.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html"
        },
        "operationId": "ml.get_buckets#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#timestamp"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/buckets": {
      "get": {
        "description": "Retrieves anomaly detection job results for one or more buckets.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html"
        },
        "operationId": "ml.get_buckets#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        }
      },
      "post": {
        "description": "Retrieves anomaly detection job results for one or more buckets.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-bucket.html"
        },
        "operationId": "ml.get_buckets#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#anomaly_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#expand"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_buckets#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_buckets#200"
          }
        }
      }
    },
    "/_ml/calendars/{calendar_id}/events": {
      "get": {
        "description": "Retrieves information about the scheduled events in calendars.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-calendar-event.html"
        },
        "operationId": "ml.get_calendar_events#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar. You can get information for multiple calendars by using a comma-separated list of ids or a wildcard expression. You can get information for all calendars by using `_all` or `*` or by omitting the calendar identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "end",
            "description": "Specifies to get events with timestamps earlier than this time.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Skips the specified number of events.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "job_id",
            "description": "Specifies to get events for a specific anomaly detection job identifier or job group. It must be used with a calendar identifier of `_all` or `*`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies the maximum number of events to obtain.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "start",
            "description": "Specifies to get events with timestamps after this time.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "events": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ml._types:CalendarEvent"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "events"
                  ]
                }
              }
            }
          }
        }
      },
      "post": {
        "description": "Posts scheduled events in a calendar.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-post-calendar-event.html"
        },
        "operationId": "ml.post_calendar_events#0",
        "parameters": [
          {
            "in": "path",
            "name": "calendar_id",
            "description": "A string that uniquely identifies a calendar.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "events": {
                    "description": "A list of one of more scheduled events. The events start and end times can be specified as integer milliseconds since the epoch or as a string in ISO 8601 format.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ml._types:CalendarEvent"
                    }
                  }
                },
                "required": [
                  "events"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "events": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ml._types:CalendarEvent"
                      }
                    }
                  },
                  "required": [
                    "events"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/calendars": {
      "get": {
        "description": "Retrieves configuration information for calendars.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-calendar.html"
        },
        "operationId": "ml.get_calendars#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        }
      },
      "post": {
        "description": "Retrieves configuration information for calendars.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-calendar.html"
        },
        "operationId": "ml.get_calendars#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_calendars#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_calendars#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_calendars"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_calendars#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/categories/{category_id}": {
      "get": {
        "description": "Retrieves anomaly detection job results for one or more categories.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html"
        },
        "operationId": "ml.get_categories#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#category_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        }
      },
      "post": {
        "description": "Retrieves anomaly detection job results for one or more categories.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html"
        },
        "operationId": "ml.get_categories#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#category_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/categories": {
      "get": {
        "description": "Retrieves anomaly detection job results for one or more categories.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html"
        },
        "operationId": "ml.get_categories#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        }
      },
      "post": {
        "description": "Retrieves anomaly detection job results for one or more categories.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-category.html"
        },
        "operationId": "ml.get_categories#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_categories#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#partition_field_value"
          },
          {
            "$ref": "#/components/parameters/ml.get_categories#size"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_categories"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_categories#200"
          }
        }
      }
    },
    "/_ml/data_frame/analytics": {
      "get": {
        "description": "Retrieves configuration information for data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-dfanalytics.html"
        },
        "operationId": "ml.get_data_frame_analytics#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics#200"
          }
        }
      }
    },
    "/_ml/data_frame/analytics/_stats": {
      "get": {
        "description": "Retrieves usage information for data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-dfanalytics-stats.html"
        },
        "operationId": "ml.get_data_frame_analytics_stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics_stats#200"
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}/_stats": {
      "get": {
        "description": "Retrieves usage information for data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-dfanalytics-stats.html"
        },
        "operationId": "ml.get_data_frame_analytics_stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#id"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_data_frame_analytics_stats#verbose"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_data_frame_analytics_stats#200"
          }
        }
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_stats": {
      "get": {
        "description": "Retrieves usage information for datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed-stats.html"
        },
        "operationId": "ml.get_datafeed_stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeed_stats#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeed_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeed_stats#200"
          }
        }
      }
    },
    "/_ml/datafeeds/_stats": {
      "get": {
        "description": "Retrieves usage information for datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed-stats.html"
        },
        "operationId": "ml.get_datafeed_stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeed_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeed_stats#200"
          }
        }
      }
    },
    "/_ml/datafeeds": {
      "get": {
        "description": "Retrieves configuration information for datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-datafeed.html"
        },
        "operationId": "ml.get_datafeeds#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_datafeeds#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_datafeeds#200"
          }
        }
      }
    },
    "/_ml/filters": {
      "get": {
        "description": "Retrieves filters.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-filter.html"
        },
        "operationId": "ml.get_filters#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_filters#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_filters#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_filters#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/influencers": {
      "get": {
        "description": "Retrieves anomaly detection job results for one or more influencers.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-influencer.html"
        },
        "operationId": "ml.get_influencers#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_influencers#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#influencer_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_influencers"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_influencers#200"
          }
        }
      },
      "post": {
        "description": "Retrieves anomaly detection job results for one or more influencers.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-influencer.html"
        },
        "operationId": "ml.get_influencers#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_influencers#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#influencer_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_influencers#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_influencers"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_influencers#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/_stats": {
      "get": {
        "description": "Retrieves usage information for anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job-stats.html"
        },
        "operationId": "ml.get_job_stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_job_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_job_stats#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_stats": {
      "get": {
        "description": "Retrieves usage information for anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job-stats.html"
        },
        "operationId": "ml.get_job_stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_job_stats#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_job_stats#allow_no_match"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_job_stats#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors": {
      "get": {
        "description": "Retrieves configuration information for anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job.html"
        },
        "operationId": "ml.get_jobs#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_jobs#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_jobs#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_jobs#200"
          }
        }
      }
    },
    "/_ml/memory/_stats": {
      "get": {
        "description": "Returns information on how ML is using memory.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-ml-memory.html"
        },
        "operationId": "ml.get_memory_stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#human"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_memory_stats#200"
          }
        }
      }
    },
    "/_ml/memory/{node_id}/_stats": {
      "get": {
        "description": "Returns information on how ML is using memory.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-ml-memory.html"
        },
        "operationId": "ml.get_memory_stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#node_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#human"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/ml.get_memory_stats#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_memory_stats#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_upgrade/_stats": {
      "get": {
        "description": "Gets stats for anomaly detection job model snapshot upgrades that are in progress.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-job-model-snapshot-upgrade-stats.html"
        },
        "operationId": "ml.get_model_snapshot_upgrade_stats#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "A numerical character string that uniquely identifies the model snapshot. You can get information for multiple\nsnapshots by using a comma-separated list or a wildcard expression. You can get all snapshots by using `_all`,\nby specifying `*` as the snapshot ID, or by omitting the snapshot ID.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n -  Contains wildcard expressions and there are no jobs that match.\n -  Contains the _all string or no identifiers and there are no matches.\n -  Contains wildcard expressions and there are only partial matches.\n\nThe default value is true, which returns an empty jobs array when there are no matches and the subset of results\nwhen there are partial matches. If this parameter is false, the request returns a 404 status code when there are\nno matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "model_snapshot_upgrades": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/ml._types:ModelSnapshotUpgrade"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "model_snapshot_upgrades"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots": {
      "get": {
        "description": "Retrieves information about model snapshots.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html"
        },
        "operationId": "ml.get_model_snapshots#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        }
      },
      "post": {
        "description": "Retrieves information about model snapshots.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-snapshot.html"
        },
        "operationId": "ml.get_model_snapshots#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_model_snapshots#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_model_snapshots"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_model_snapshots#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/overall_buckets": {
      "get": {
        "description": "Retrieves overall bucket results that summarize the bucket results of multiple anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-overall-buckets.html"
        },
        "operationId": "ml.get_overall_buckets#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#bucket_span"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#overall_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#start"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#top_n"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_overall_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_overall_buckets#200"
          }
        }
      },
      "post": {
        "description": "Retrieves overall bucket results that summarize the bucket results of multiple anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-overall-buckets.html"
        },
        "operationId": "ml.get_overall_buckets#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#bucket_span"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#overall_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#start"
          },
          {
            "$ref": "#/components/parameters/ml.get_overall_buckets#top_n"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_overall_buckets"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_overall_buckets#200"
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/results/records": {
      "get": {
        "description": "Retrieves anomaly records for an anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-record.html"
        },
        "operationId": "ml.get_records#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_records#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#record_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_records"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_records#200"
          }
        }
      },
      "post": {
        "description": "Retrieves anomaly records for an anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-get-record.html"
        },
        "operationId": "ml.get_records#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_records#job_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#desc"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#end"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#exclude_interim"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#record_score"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#sort"
          },
          {
            "$ref": "#/components/parameters/ml.get_records#start"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.get_records"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_records#200"
          }
        }
      }
    },
    "/_ml/trained_models": {
      "get": {
        "description": "Retrieves configuration information for a trained inference model.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-trained-models.html"
        },
        "operationId": "ml.get_trained_models#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#decompress_definition"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#exclude_generated"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#include"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#size"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models#tags"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models#200"
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/_stats": {
      "get": {
        "description": "Retrieves usage information for trained inference models.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-trained-models-stats.html"
        },
        "operationId": "ml.get_trained_models_stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models_stats#200"
          }
        }
      }
    },
    "/_ml/trained_models/_stats": {
      "get": {
        "description": "Retrieves usage information for trained inference models.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-trained-models-stats.html"
        },
        "operationId": "ml.get_trained_models_stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#from"
          },
          {
            "$ref": "#/components/parameters/ml.get_trained_models_stats#size"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.get_trained_models_stats#200"
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/_infer": {
      "post": {
        "description": "Evaluate a trained model.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/infer-trained-model.html"
        },
        "operationId": "ml.infer_trained_model#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.infer_trained_model"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.infer_trained_model#200"
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_infer": {
      "post": {
        "description": "Evaluate a trained model.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/infer-trained-model.html"
        },
        "operationId": "ml.infer_trained_model#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#model_id"
          },
          {
            "$ref": "#/components/parameters/ml.infer_trained_model#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.infer_trained_model"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.infer_trained_model#200"
          }
        }
      }
    },
    "/_ml/info": {
      "get": {
        "description": "Returns defaults and limits used by machine learning.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-ml-info.html"
        },
        "operationId": "ml.info#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "defaults": {
                      "$ref": "#/components/schemas/ml.info:Defaults"
                    },
                    "limits": {
                      "$ref": "#/components/schemas/ml.info:Limits"
                    },
                    "upgrade_mode": {
                      "type": "boolean"
                    },
                    "native_code": {
                      "$ref": "#/components/schemas/ml.info:NativeCode"
                    }
                  },
                  "required": [
                    "defaults",
                    "limits",
                    "upgrade_mode",
                    "native_code"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_open": {
      "post": {
        "description": "Opens one or more anomaly detection jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-open-job.html"
        },
        "operationId": "ml.open_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait until a job has opened.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "opened": {
                      "type": "boolean"
                    },
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeId"
                    }
                  },
                  "required": [
                    "opened",
                    "node"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/analytics/_preview": {
      "get": {
        "description": "Previews that will be analyzed given a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/preview-dfanalytics.html"
        },
        "operationId": "ml.preview_data_frame_analytics#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        }
      },
      "post": {
        "description": "Previews that will be analyzed given a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/preview-dfanalytics.html"
        },
        "operationId": "ml.preview_data_frame_analytics#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}/_preview": {
      "get": {
        "description": "Previews that will be analyzed given a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/preview-dfanalytics.html"
        },
        "operationId": "ml.preview_data_frame_analytics#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        }
      },
      "post": {
        "description": "Previews that will be analyzed given a data frame analytics config.",
        "externalDocs": {
          "url": "http://www.elastic.co/guide/en/elasticsearch/reference/current/preview-dfanalytics.html"
        },
        "operationId": "ml.preview_data_frame_analytics#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_data_frame_analytics#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_data_frame_analytics"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_data_frame_analytics#200"
          }
        }
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_preview": {
      "get": {
        "description": "Previews a datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html"
        },
        "operationId": "ml.preview_datafeed#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        }
      },
      "post": {
        "description": "Previews a datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html"
        },
        "operationId": "ml.preview_datafeed#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#datafeed_id"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        }
      }
    },
    "/_ml/datafeeds/_preview": {
      "get": {
        "description": "Previews a datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html"
        },
        "operationId": "ml.preview_datafeed#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        }
      },
      "post": {
        "description": "Previews a datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-preview-datafeed.html"
        },
        "operationId": "ml.preview_datafeed#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#start"
          },
          {
            "$ref": "#/components/parameters/ml.preview_datafeed#end"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/ml.preview_datafeed"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/ml.preview_datafeed#200"
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/definition/{part}": {
      "put": {
        "description": "Creates part of a trained model definition",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-trained-model-definition-part.html"
        },
        "operationId": "ml.put_trained_model_definition_part#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "part",
            "description": "The definition part number. When the definition is loaded for inference the definition parts are streamed in the\norder of their part number. The first part must be `0` and the final part must be `total_parts - 1`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "definition": {
                    "description": "The definition part for the model. Must be a base64 encoded string.",
                    "type": "string"
                  },
                  "total_definition_length": {
                    "description": "The total uncompressed definition length in bytes. Not base64 encoded.",
                    "type": "number"
                  },
                  "total_parts": {
                    "description": "The total number of parts that will be uploaded. Must be greater than 0.",
                    "type": "number"
                  }
                },
                "required": [
                  "definition",
                  "total_definition_length",
                  "total_parts"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/vocabulary": {
      "put": {
        "description": "Creates a trained model vocabulary",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-trained-model-vocabulary.html"
        },
        "operationId": "ml.put_trained_model_vocabulary#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "vocabulary": {
                    "description": "The model vocabulary, which must not be empty.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "merges": {
                    "description": "The optional model merges if required by the tokenizer.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                },
                "required": [
                  "vocabulary"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_reset": {
      "post": {
        "description": "Resets an existing anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-reset-job.html"
        },
        "operationId": "ml.reset_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "The ID of the job to reset.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "Should this request wait until the operation has completed before\nreturning.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delete_user_annotations",
            "description": "Specifies whether annotations that have been added by the\nuser should be deleted along with any auto-generated annotations when the job is\nreset.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_revert": {
      "post": {
        "description": "Reverts to a specific snapshot.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-revert-snapshot.html"
        },
        "operationId": "ml.revert_model_snapshot#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "You can specify `empty` as the <snapshot_id>. Reverting to the empty\nsnapshot means the anomaly detection job starts learning a new model from\nscratch when it is started.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "delete_intervening_results",
            "description": "If true, deletes the results in the time period between the latest\nresults and the time of the reverted snapshot. It also resets the model\nto accept records for this time period. If you choose not to delete\nintervening results when reverting a snapshot, the job will not accept\ninput data that is older than the current time. If you want to resend\ndata, then delete the intervening results.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "delete_intervening_results": {
                    "description": "Refer to the description for the `delete_intervening_results` query parameter.",
                    "type": "boolean"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "model": {
                      "$ref": "#/components/schemas/ml._types:ModelSnapshot"
                    }
                  },
                  "required": [
                    "model"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/set_upgrade_mode": {
      "post": {
        "description": "Sets a cluster wide upgrade_mode setting that prepares machine learning indices for an upgrade.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-set-upgrade-mode.html"
        },
        "operationId": "ml.set_upgrade_mode#0",
        "parameters": [
          {
            "in": "query",
            "name": "enabled",
            "description": "When `true`, it enables `upgrade_mode` which temporarily halts all job\nand datafeed tasks and prohibits new job and datafeed tasks from\nstarting.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "The time to wait for the request to be completed.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}/_start": {
      "post": {
        "description": "Starts a data frame analytics job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/start-dfanalytics.html"
        },
        "operationId": "ml.start_data_frame_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the amount of time to wait until the data frame analytics job\nstarts.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeId"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "node"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_start": {
      "post": {
        "description": "Starts one or more datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-start-datafeed.html"
        },
        "operationId": "ml.start_datafeed#0",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed. This identifier can contain lowercase\nalphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric\ncharacters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "end",
            "description": "The time that the datafeed should end, which can be specified by using one of the following formats:\n\n* ISO 8601 format with milliseconds, for example `2017-01-22T06:00:00.000Z`\n* ISO 8601 format without milliseconds, for example `2017-01-22T06:00:00+00:00`\n* Milliseconds since the epoch, for example `1485061200000`\n\nDate-time arguments using either of the ISO 8601 formats must have a time zone designator, where `Z` is accepted\nas an abbreviation for UTC time. When a URL is expected (for example, in browsers), the `+` used in time zone\ndesignators must be encoded as `%2B`.\nThe end time value is exclusive. If you do not specify an end time, the datafeed\nruns continuously.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "start",
            "description": "The time that the datafeed should begin, which can be specified by using the same formats as the `end` parameter.\nThis value is inclusive.\nIf you do not specify a start time and the datafeed is associated with a new anomaly detection job, the analysis\nstarts from the earliest time for which data is available.\nIf you restart a stopped datafeed and specify a start value that is earlier than the timestamp of the latest\nprocessed record, the datafeed continues from 1 millisecond after the timestamp of the latest processed record.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:DateTime"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Specifies the amount of time to wait until a datafeed starts.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "end": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "start": {
                    "$ref": "#/components/schemas/_types:DateTime"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeIds"
                    },
                    "started": {
                      "description": "For a successful response, this value is always `true`. On failure, an exception is returned instead.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "node",
                    "started"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_start": {
      "post": {
        "description": "Start a trained model deployment.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/start-trained-model-deployment.html"
        },
        "operationId": "ml.start_trained_model_deployment#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model. Currently, only PyTorch models are supported.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "cache_size",
            "description": "The inference cache size (in memory outside the JVM heap) per node for the model.\nThe default value is the same size as the `model_size_bytes`. To disable the cache,\n`0b` can be provided.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ByteSize"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "number_of_allocations",
            "description": "The number of model allocations on each node where the model is deployed.\nAll allocations on a node share the same copy of the model in memory but use\na separate set of threads to evaluate the model.\nIncreasing this value generally increases the throughput.\nIf this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "priority",
            "description": "The deployment priority.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/ml._types:TrainingPriority"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "queue_capacity",
            "description": "Specifies the number of inference requests that are allowed in the queue. After the number of requests exceeds\nthis value, new requests are rejected with a 429 error.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "threads_per_allocation",
            "description": "Sets the number of threads used by each model allocation during inference. This generally increases\nthe inference speed. The inference process is a compute-bound process; any number\ngreater than the number of available hardware threads on the machine does not increase the\ninference speed. If this setting is greater than the number of hardware threads\nit will automatically be changed to a value less than the number of hardware threads.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Specifies the amount of time to wait for the model to deploy.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for",
            "description": "Specifies the allocation status to wait for before returning.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/ml._types:DeploymentAllocationState"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "assignment": {
                      "$ref": "#/components/schemas/ml._types:TrainedModelAssignment"
                    }
                  },
                  "required": [
                    "assignment"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}/_stop": {
      "post": {
        "description": "Stops one or more data frame analytics jobs.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/stop-dfanalytics.html"
        },
        "operationId": "ml.stop_data_frame_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is true, which returns an empty data_frame_analytics\narray when there are no matches and the subset of results when there are\npartial matches. If this parameter is false, the request returns a 404\nstatus code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If true, the data frame analytics job is stopped forcefully.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the amount of time to wait until the data frame analytics job\nstops. Defaults to 20 seconds.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_stop": {
      "post": {
        "description": "Stops one or more datafeeds.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-stop-datafeed.html"
        },
        "operationId": "ml.stop_datafeed#0",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "Identifier for the datafeed. You can stop multiple datafeeds in a single API request by using a comma-separated\nlist of datafeeds or a wildcard expression. You can close all datafeeds by using `_all` or by specifying `*` as\nthe identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If `true`, the datafeed is stopped forcefully.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Specifies the amount of time to wait until a datafeed stops.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_no_match": {
                    "description": "Refer to the description for the `allow_no_match` query parameter.",
                    "type": "boolean"
                  },
                  "force": {
                    "description": "Refer to the description for the `force` query parameter.",
                    "type": "boolean"
                  },
                  "timeout": {
                    "$ref": "#/components/schemas/_types:Duration"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/trained_models/{model_id}/deployment/_stop": {
      "post": {
        "description": "Stop a trained model deployment.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/stop-trained-model-deployment.html"
        },
        "operationId": "ml.stop_trained_model_deployment#0",
        "parameters": [
          {
            "in": "path",
            "name": "model_id",
            "description": "The unique identifier of the trained model.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request: contains wildcard expressions and there are no deployments that match;\ncontains the  `_all` string or no identifiers and there are no matches; or contains wildcard expressions and\nthere are only partial matches. By default, it returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "Forcefully stops the deployment, even if it is used by ingest pipelines. You can't use these pipelines until you\nrestart the model deployment.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "stopped": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "stopped"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/data_frame/analytics/{id}/_update": {
      "post": {
        "description": "Updates certain properties of a data frame analytics job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/update-dfanalytics.html"
        },
        "operationId": "ml.update_data_frame_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "model_memory_limit": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
                    },
                    "description": "The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try\nto create data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.",
                    "type": "string"
                  },
                  "max_num_threads": {
                    "description": "The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.",
                    "type": "number"
                  },
                  "allow_lazy_start": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
                    },
                    "description": "Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node.",
                    "type": "boolean"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsAuthorization"
                    },
                    "allow_lazy_start": {
                      "type": "boolean"
                    },
                    "analysis": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                    },
                    "analyzed_fields": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                    },
                    "create_time": {
                      "type": "number"
                    },
                    "description": {
                      "type": "string"
                    },
                    "dest": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "max_num_threads": {
                      "type": "number"
                    },
                    "model_memory_limit": {
                      "type": "string"
                    },
                    "source": {
                      "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    }
                  },
                  "required": [
                    "allow_lazy_start",
                    "analysis",
                    "create_time",
                    "dest",
                    "id",
                    "max_num_threads",
                    "model_memory_limit",
                    "source",
                    "version"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/datafeeds/{datafeed_id}/_update": {
      "post": {
        "description": "Updates certain properties of a datafeed.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-datafeed.html"
        },
        "operationId": "ml.update_datafeed#0",
        "parameters": [
          {
            "in": "path",
            "name": "datafeed_id",
            "description": "A numerical character string that uniquely identifies the datafeed.\nThis identifier can contain lowercase alphanumeric characters (a-z and 0-9), hyphens, and underscores.\nIt must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `true`, wildcard indices expressions that resolve into no concrete indices are ignored. This includes the\n`_all` string or when no indices are specified.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument determines\nwhether wildcard expressions match hidden data streams. Supports comma-separated values. Valid values are:\n\n* `all`: Match any data stream or index, including hidden ones.\n* `closed`: Match closed, non-hidden indices. Also matches any non-hidden data stream. Data streams cannot be closed.\n* `hidden`: Match hidden data streams and hidden indices. Must be combined with `open`, `closed`, or both.\n* `none`: Wildcard patterns are not accepted.\n* `open`: Match open, non-hidden indices. Also matches any non-hidden data stream.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_throttled",
            "description": "If `true`, concrete, expanded or aliased indices are ignored when frozen.",
            "deprecated": true,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `true`, unavailable indices (missing or closed) are ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "aggregations": {
                    "description": "If set, the datafeed performs aggregation searches. Support for aggregations is limited and should be used only\nwith low cardinality data.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                    }
                  },
                  "chunking_config": {
                    "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                  },
                  "delayed_data_check_config": {
                    "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "indices": {
                    "description": "An array of index names. Wildcards are supported. If any of the indices are in remote clusters, the machine\nlearning nodes must have the `remote_cluster_client` role.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "indices_options": {
                    "$ref": "#/components/schemas/_types:IndicesOptions"
                  },
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "max_empty_searches": {
                    "description": "If a real-time datafeed has never seen any data (including during any initial training period), it automatically\nstops and closes the associated job after this many real-time searches return no documents. In other words,\nit stops after `frequency` times `max_empty_searches` of real-time operation. If not set, a datafeed with no\nend time that sees no data remains started until it is explicitly stopped. By default, it is not set.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "query_delay": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "runtime_mappings": {
                    "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                  },
                  "script_fields": {
                    "description": "Specifies scripts that evaluate custom expressions and returns script fields to the datafeed.\nThe detector configuration objects in a job can contain functions that use these script fields.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_types:ScriptField"
                    }
                  },
                  "scroll_size": {
                    "description": "The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations.\nThe maximum value is the value of `index.max_result_window`.",
                    "type": "number"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:DatafeedAuthorization"
                    },
                    "aggregations": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                      }
                    },
                    "chunking_config": {
                      "$ref": "#/components/schemas/ml._types:ChunkingConfig"
                    },
                    "delayed_data_check_config": {
                      "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
                    },
                    "datafeed_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "frequency": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "indices_options": {
                      "$ref": "#/components/schemas/_types:IndicesOptions"
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "max_empty_searches": {
                      "type": "number"
                    },
                    "query": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    },
                    "query_delay": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "runtime_mappings": {
                      "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                    },
                    "script_fields": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types:ScriptField"
                      }
                    },
                    "scroll_size": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "chunking_config",
                    "datafeed_id",
                    "indices",
                    "job_id",
                    "query",
                    "query_delay",
                    "scroll_size"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/filters/{filter_id}/_update": {
      "post": {
        "description": "Updates the description of a filter, adds items, or removes items.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-filter.html"
        },
        "operationId": "ml.update_filter#0",
        "parameters": [
          {
            "in": "path",
            "name": "filter_id",
            "description": "A string that uniquely identifies a filter.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "add_items": {
                    "description": "The items to add to the filter.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "description": {
                    "description": "A description for the filter.",
                    "type": "string"
                  },
                  "remove_items": {
                    "description": "The items to remove from the filter.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "description": {
                      "type": "string"
                    },
                    "filter_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "items": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "description",
                    "filter_id",
                    "items"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/_update": {
      "post": {
        "description": "Updates certain properties of an anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-job.html"
        },
        "operationId": "ml.update_job#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "allow_lazy_open": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
                    },
                    "description": "Advanced configuration option. Specifies whether this job can open when\nthere is insufficient machine learning node capacity for it to be\nimmediately assigned to a node. If `false` and a machine learning node\nwith capacity to run the job cannot immediately be found, the open\nanomaly detection jobs API returns an error. However, this is also\nsubject to the cluster-wide `xpack.ml.max_lazy_ml_nodes` setting. If this\noption is set to `true`, the open anomaly detection jobs API does not\nreturn an error and the job waits in the opening state until sufficient\nmachine learning node capacity is available.",
                    "type": "boolean"
                  },
                  "analysis_limits": {
                    "$ref": "#/components/schemas/ml._types:AnalysisMemoryLimit"
                  },
                  "background_persist_interval": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "custom_settings": {
                    "description": "Advanced configuration option. Contains custom meta data about the job.\nFor example, it can contain custom URL information as shown in Adding\ncustom URLs to machine learning results.",
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  },
                  "categorization_filters": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "description": {
                    "description": "A description of the job.",
                    "type": "string"
                  },
                  "model_plot_config": {
                    "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                  },
                  "model_prune_window": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "daily_model_snapshot_retention_after_days": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-ad-run-jobs.html#ml-ad-model-snapshots"
                    },
                    "description": "Advanced configuration option, which affects the automatic removal of old\nmodel snapshots for this job. It specifies a period of time (in days)\nafter which only the first snapshot per day is retained. This period is\nrelative to the timestamp of the most recent snapshot for this job. Valid\nvalues range from 0 to `model_snapshot_retention_days`. For jobs created\nbefore version 7.8.0, the default value matches\n`model_snapshot_retention_days`.",
                    "type": "number"
                  },
                  "model_snapshot_retention_days": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-ad-run-jobs.html#ml-ad-model-snapshots"
                    },
                    "description": "Advanced configuration option, which affects the automatic removal of old\nmodel snapshots for this job. It specifies the maximum period of time (in\ndays) that snapshots are retained. This period is relative to the\ntimestamp of the most recent snapshot for this job.",
                    "type": "number"
                  },
                  "renormalization_window_days": {
                    "description": "Advanced configuration option. The period over which adjustments to the\nscore are applied, as new data is seen.",
                    "type": "number"
                  },
                  "results_retention_days": {
                    "description": "Advanced configuration option. The period of time (in days) that results\nare retained. Age is calculated relative to the timestamp of the latest\nbucket result. If this property has a non-null value, once per day at\n00:30 (server time), results that are the specified number of days older\nthan the latest bucket result are deleted from Elasticsearch. The default\nvalue is null, which means all results are retained.",
                    "type": "number"
                  },
                  "groups": {
                    "description": "A list of job groups. A job can belong to no groups or many.",
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  },
                  "detectors": {
                    "description": "An array of detector update objects.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/ml._types:Detector"
                    }
                  },
                  "per_partition_categorization": {
                    "$ref": "#/components/schemas/ml._types:PerPartitionCategorization"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allow_lazy_open": {
                      "type": "boolean"
                    },
                    "analysis_config": {
                      "$ref": "#/components/schemas/ml._types:AnalysisConfigRead"
                    },
                    "analysis_limits": {
                      "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                    },
                    "background_persist_interval": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "create_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "finished_time": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "custom_settings": {
                      "type": "object",
                      "additionalProperties": {
                        "type": "string"
                      }
                    },
                    "daily_model_snapshot_retention_after_days": {
                      "type": "number"
                    },
                    "data_description": {
                      "$ref": "#/components/schemas/ml._types:DataDescription"
                    },
                    "datafeed_config": {
                      "$ref": "#/components/schemas/ml._types:Datafeed"
                    },
                    "description": {
                      "type": "string"
                    },
                    "groups": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "job_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "job_type": {
                      "type": "string"
                    },
                    "job_version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    },
                    "model_plot_config": {
                      "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                    },
                    "model_snapshot_id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "model_snapshot_retention_days": {
                      "type": "number"
                    },
                    "renormalization_window_days": {
                      "type": "number"
                    },
                    "results_index_name": {
                      "$ref": "#/components/schemas/_types:IndexName"
                    },
                    "results_retention_days": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "allow_lazy_open",
                    "analysis_config",
                    "analysis_limits",
                    "create_time",
                    "daily_model_snapshot_retention_after_days",
                    "data_description",
                    "job_id",
                    "job_type",
                    "job_version",
                    "model_snapshot_retention_days",
                    "results_index_name"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_update": {
      "post": {
        "description": "Updates certain properties of a snapshot.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-update-snapshot.html"
        },
        "operationId": "ml.update_model_snapshot#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "Identifier for the model snapshot.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "description": {
                    "description": "A description of the model snapshot.",
                    "type": "string"
                  },
                  "retain": {
                    "description": "If `true`, this snapshot will not be deleted during automatic cleanup of\nsnapshots older than `model_snapshot_retention_days`. However, this\nsnapshot will be deleted when the job is deleted.",
                    "type": "boolean"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "acknowledged": {
                      "type": "boolean"
                    },
                    "model": {
                      "$ref": "#/components/schemas/ml._types:ModelSnapshot"
                    }
                  },
                  "required": [
                    "acknowledged",
                    "model"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/{job_id}/model_snapshots/{snapshot_id}/_upgrade": {
      "post": {
        "description": "Upgrades a given job snapshot to the current major version.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-upgrade-job-model-snapshot.html"
        },
        "operationId": "ml.upgrade_job_snapshot#0",
        "parameters": [
          {
            "in": "path",
            "name": "job_id",
            "description": "Identifier for the anomaly detection job.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "snapshot_id",
            "description": "A numerical character string that uniquely identifies the model snapshot.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "When true, the API wont respond until the upgrade is complete.\nOtherwise, it responds as soon as the upgrade task is assigned to a node.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait for the request to complete.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "node": {
                      "$ref": "#/components/schemas/_types:NodeId"
                    },
                    "completed": {
                      "description": "When true, this means the task is complete. When false, it is still running.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "node",
                    "completed"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/_validate": {
      "post": {
        "description": "Validates an anomaly detection job.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-jobs.html"
        },
        "operationId": "ml.validate#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "job_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "analysis_config": {
                    "$ref": "#/components/schemas/ml._types:AnalysisConfig"
                  },
                  "analysis_limits": {
                    "$ref": "#/components/schemas/ml._types:AnalysisLimits"
                  },
                  "data_description": {
                    "$ref": "#/components/schemas/ml._types:DataDescription"
                  },
                  "description": {
                    "type": "string"
                  },
                  "model_plot": {
                    "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
                  },
                  "model_snapshot_id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "model_snapshot_retention_days": {
                    "type": "number"
                  },
                  "results_index_name": {
                    "$ref": "#/components/schemas/_types:IndexName"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_ml/anomaly_detectors/_validate/detector": {
      "post": {
        "description": "Validates an anomaly detection detector.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-jobs.html"
        },
        "operationId": "ml.validate_detector#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/ml._types:Detector"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_msearch": {
      "get": {
        "description": "Allows to execute several search operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html"
        },
        "operationId": "msearch#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        }
      },
      "post": {
        "description": "Allows to execute several search operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html"
        },
        "operationId": "msearch#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        }
      }
    },
    "/{index}/_msearch": {
      "get": {
        "description": "Allows to execute several search operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html"
        },
        "operationId": "msearch#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#index"
          },
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        }
      },
      "post": {
        "description": "Allows to execute several search operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-multi-search.html"
        },
        "operationId": "msearch#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch#index"
          },
          {
            "$ref": "#/components/parameters/msearch#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/msearch#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/msearch#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/msearch#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/msearch#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch#routing"
          },
          {
            "$ref": "#/components/parameters/msearch#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch#200"
          }
        }
      }
    },
    "/_msearch/template": {
      "get": {
        "description": "Allows to execute several search template operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html"
        },
        "operationId": "msearch_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        }
      },
      "post": {
        "description": "Allows to execute several search template operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html"
        },
        "operationId": "msearch_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        }
      }
    },
    "/{index}/_msearch/template": {
      "get": {
        "description": "Allows to execute several search template operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html"
        },
        "operationId": "msearch_template#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#index"
          },
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        }
      },
      "post": {
        "description": "Allows to execute several search template operations in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-multi-search.html"
        },
        "operationId": "msearch_template#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/msearch_template#index"
          },
          {
            "$ref": "#/components/parameters/msearch_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/msearch_template#max_concurrent_searches"
          },
          {
            "$ref": "#/components/parameters/msearch_template#search_type"
          },
          {
            "$ref": "#/components/parameters/msearch_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/msearch_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/msearch_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/msearch_template#200"
          }
        }
      }
    },
    "/_mtermvectors": {
      "get": {
        "description": "Returns multiple termvectors in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html"
        },
        "operationId": "mtermvectors#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      },
      "post": {
        "description": "Returns multiple termvectors in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html"
        },
        "operationId": "mtermvectors#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      }
    },
    "/{index}/_mtermvectors": {
      "get": {
        "description": "Returns multiple termvectors in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html"
        },
        "operationId": "mtermvectors#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#index"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      },
      "post": {
        "description": "Returns multiple termvectors in one request.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-multi-termvectors.html"
        },
        "operationId": "mtermvectors#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/mtermvectors#index"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#ids"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#fields"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#positions"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#preference"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#routing"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version"
          },
          {
            "$ref": "#/components/parameters/mtermvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/mtermvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/mtermvectors#200"
          }
        }
      }
    },
    "/_nodes/hot_threads": {
      "get": {
        "description": "Returns information about hot threads on each node in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-hot-threads.html"
        },
        "operationId": "nodes.hot_threads#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.hot_threads#ignore_idle_threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#interval"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#snapshots"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#type"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#sort"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.hot_threads#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/hot_threads": {
      "get": {
        "description": "Returns information about hot threads on each node in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-hot-threads.html"
        },
        "operationId": "nodes.hot_threads#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.hot_threads#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#ignore_idle_threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#interval"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#snapshots"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#threads"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#type"
          },
          {
            "$ref": "#/components/parameters/nodes.hot_threads#sort"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.hot_threads#200"
          }
        }
      }
    },
    "/_nodes": {
      "get": {
        "description": "Returns information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-info.html"
        },
        "operationId": "nodes.info#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        }
      }
    },
    "/_nodes/{node_id}": {
      "get": {
        "description": "Returns information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-info.html"
        },
        "operationId": "nodes.info#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        }
      }
    },
    "/_nodes/{metric}": {
      "get": {
        "description": "Returns information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-info.html"
        },
        "operationId": "nodes.info#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/{metric}": {
      "get": {
        "description": "Returns information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-info.html"
        },
        "operationId": "nodes.info#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.info#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.info#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.info#flat_settings"
          },
          {
            "$ref": "#/components/parameters/nodes.info#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.info#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.info#200"
          }
        }
      }
    },
    "/_nodes/stats": {
      "get": {
        "description": "Returns statistical information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
        },
        "operationId": "nodes.stats#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/stats": {
      "get": {
        "description": "Returns statistical information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
        },
        "operationId": "nodes.stats#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/stats/{metric}": {
      "get": {
        "description": "Returns statistical information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
        },
        "operationId": "nodes.stats#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/stats/{metric}": {
      "get": {
        "description": "Returns statistical information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
        },
        "operationId": "nodes.stats#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/stats/{metric}/{index_metric}": {
      "get": {
        "description": "Returns statistical information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
        },
        "operationId": "nodes.stats#4",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#index_metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/stats/{metric}/{index_metric}": {
      "get": {
        "description": "Returns statistical information about nodes in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
        },
        "operationId": "nodes.stats#5",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.stats#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#index_metric"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#completion_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fielddata_fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#fields"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#groups"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_segment_file_sizes"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#level"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#master_timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#timeout"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#types"
          },
          {
            "$ref": "#/components/parameters/nodes.stats#include_unloaded_segments"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.stats#200"
          }
        }
      }
    },
    "/_nodes/usage": {
      "get": {
        "description": "Returns low-level information about REST actions usage on nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-usage.html"
        },
        "operationId": "nodes.usage#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/usage": {
      "get": {
        "description": "Returns low-level information about REST actions usage on nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-usage.html"
        },
        "operationId": "nodes.usage#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        }
      }
    },
    "/_nodes/usage/{metric}": {
      "get": {
        "description": "Returns low-level information about REST actions usage on nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-usage.html"
        },
        "operationId": "nodes.usage#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        }
      }
    },
    "/_nodes/{node_id}/usage/{metric}": {
      "get": {
        "description": "Returns low-level information about REST actions usage on nodes.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-usage.html"
        },
        "operationId": "nodes.usage#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/nodes.usage#node_id"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#metric"
          },
          {
            "$ref": "#/components/parameters/nodes.usage#timeout"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/nodes.usage#200"
          }
        }
      }
    },
    "/{index}/_pit": {
      "post": {
        "description": "Open a point in time that can be used in subsequent searches",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/point-in-time-api.html"
        },
        "operationId": "open_point_in_time#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "A comma-separated list of index names to open point in time; use `_all` or empty string to perform the operation on all indices",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "keep_alive",
            "description": "Extends the time to live of the corresponding point in time.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`. Valid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "required": [
                    "id"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_scripts/{id}/{context}": {
      "put": {
        "description": "Creates or updates a script.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html"
        },
        "operationId": "put_script#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#context"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      },
      "post": {
        "description": "Creates or updates a script.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/modules-scripting.html"
        },
        "operationId": "put_script#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/put_script#id"
          },
          {
            "$ref": "#/components/parameters/put_script#context"
          },
          {
            "$ref": "#/components/parameters/put_script#master_timeout"
          },
          {
            "$ref": "#/components/parameters/put_script#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/put_script"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/put_script#200"
          }
        }
      }
    },
    "/_query_rules/{ruleset_id}": {
      "get": {
        "description": "Returns the details about a query ruleset.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/get-query-ruleset.html"
        },
        "operationId": "query_ruleset.get#0",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/query_ruleset._types:QueryRuleset"
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates or updates a query ruleset.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/put-query-ruleset.html"
        },
        "operationId": "query_ruleset.put#0",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset to be created or updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/query_ruleset._types:QueryRuleset"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a query ruleset.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-query-ruleset.html"
        },
        "operationId": "query_ruleset.delete#0",
        "parameters": [
          {
            "in": "path",
            "name": "ruleset_id",
            "description": "The unique identifier of the query ruleset to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_query_rules": {
      "get": {
        "description": "Lists query rulesets.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/list-query-rulesets.html"
        },
        "operationId": "query_ruleset.list#0",
        "parameters": [
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "specifies a max number of results to get",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/query_ruleset.list:QueryRulesetListItem"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_rank_eval": {
      "get": {
        "description": "Allows to evaluate the quality of ranked search results over a set of typical search queries",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-rank-eval.html"
        },
        "operationId": "rank_eval#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        }
      },
      "post": {
        "description": "Allows to evaluate the quality of ranked search results over a set of typical search queries",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-rank-eval.html"
        },
        "operationId": "rank_eval#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        }
      }
    },
    "/{index}/_rank_eval": {
      "get": {
        "description": "Allows to evaluate the quality of ranked search results over a set of typical search queries",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-rank-eval.html"
        },
        "operationId": "rank_eval#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#index"
          },
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        }
      },
      "post": {
        "description": "Allows to evaluate the quality of ranked search results over a set of typical search queries",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-rank-eval.html"
        },
        "operationId": "rank_eval#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/rank_eval#index"
          },
          {
            "$ref": "#/components/parameters/rank_eval#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/rank_eval#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/rank_eval#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/rank_eval#search_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/rank_eval"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/rank_eval#200"
          }
        }
      }
    },
    "/_render/template": {
      "get": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/render-search-template-api.html"
        },
        "operationId": "render_search_template#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      },
      "post": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/render-search-template-api.html"
        },
        "operationId": "render_search_template#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      }
    },
    "/_render/template/{id}": {
      "get": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/render-search-template-api.html"
        },
        "operationId": "render_search_template#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/render_search_template#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      },
      "post": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/render-search-template-api.html"
        },
        "operationId": "render_search_template#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/render_search_template#id"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/render_search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/render_search_template#200"
          }
        }
      }
    },
    "/_scripts/painless/_execute": {
      "get": {
        "description": "Allows an arbitrary script to be executed and a result to be returned",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html"
        },
        "operationId": "scripts_painless_execute#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/scripts_painless_execute"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scripts_painless_execute#200"
          }
        }
      },
      "post": {
        "description": "Allows an arbitrary script to be executed and a result to be returned",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/painless/master/painless-execute-api.html"
        },
        "operationId": "scripts_painless_execute#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/scripts_painless_execute"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/scripts_painless_execute#200"
          }
        }
      }
    },
    "/_search": {
      "get": {
        "description": "Returns results matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html"
        },
        "operationId": "search#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      },
      "post": {
        "description": "Returns results matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html"
        },
        "operationId": "search#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      }
    },
    "/{index}/_search": {
      "get": {
        "description": "Returns results matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html"
        },
        "operationId": "search#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#index"
          },
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      },
      "post": {
        "description": "Returns results matching a query.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-search.html"
        },
        "operationId": "search#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/search#index"
          },
          {
            "$ref": "#/components/parameters/search#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search#allow_partial_search_results"
          },
          {
            "$ref": "#/components/parameters/search#analyzer"
          },
          {
            "$ref": "#/components/parameters/search#analyze_wildcard"
          },
          {
            "$ref": "#/components/parameters/search#batched_reduce_size"
          },
          {
            "$ref": "#/components/parameters/search#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search#default_operator"
          },
          {
            "$ref": "#/components/parameters/search#df"
          },
          {
            "$ref": "#/components/parameters/search#docvalue_fields"
          },
          {
            "$ref": "#/components/parameters/search#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search#explain"
          },
          {
            "$ref": "#/components/parameters/search#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search#lenient"
          },
          {
            "$ref": "#/components/parameters/search#max_concurrent_shard_requests"
          },
          {
            "$ref": "#/components/parameters/search#min_compatible_shard_node"
          },
          {
            "$ref": "#/components/parameters/search#preference"
          },
          {
            "$ref": "#/components/parameters/search#pre_filter_shard_size"
          },
          {
            "$ref": "#/components/parameters/search#request_cache"
          },
          {
            "$ref": "#/components/parameters/search#routing"
          },
          {
            "$ref": "#/components/parameters/search#scroll"
          },
          {
            "$ref": "#/components/parameters/search#search_type"
          },
          {
            "$ref": "#/components/parameters/search#stats"
          },
          {
            "$ref": "#/components/parameters/search#stored_fields"
          },
          {
            "$ref": "#/components/parameters/search#suggest_field"
          },
          {
            "$ref": "#/components/parameters/search#suggest_mode"
          },
          {
            "$ref": "#/components/parameters/search#suggest_size"
          },
          {
            "$ref": "#/components/parameters/search#suggest_text"
          },
          {
            "$ref": "#/components/parameters/search#terminate_after"
          },
          {
            "$ref": "#/components/parameters/search#timeout"
          },
          {
            "$ref": "#/components/parameters/search#track_total_hits"
          },
          {
            "$ref": "#/components/parameters/search#track_scores"
          },
          {
            "$ref": "#/components/parameters/search#typed_keys"
          },
          {
            "$ref": "#/components/parameters/search#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search#version"
          },
          {
            "$ref": "#/components/parameters/search#_source"
          },
          {
            "$ref": "#/components/parameters/search#_source_excludes"
          },
          {
            "$ref": "#/components/parameters/search#_source_includes"
          },
          {
            "$ref": "#/components/parameters/search#seq_no_primary_term"
          },
          {
            "$ref": "#/components/parameters/search#q"
          },
          {
            "$ref": "#/components/parameters/search#size"
          },
          {
            "$ref": "#/components/parameters/search#from"
          },
          {
            "$ref": "#/components/parameters/search#sort"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search#200"
          }
        }
      }
    },
    "/_application/search_application/{name}": {
      "get": {
        "description": "Returns the details about a search application.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/get-search-application.html"
        },
        "operationId": "search_application.get#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/search_application._types:SearchApplication"
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates or updates a search application.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/put-search-application.html"
        },
        "operationId": "search_application.put#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "create",
            "description": "If `true`, this request cannot replace or update existing Search Applications.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "$ref": "#/components/schemas/search_application._types:SearchApplication"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    }
                  },
                  "required": [
                    "result"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a search application.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/put-search-application.html"
        },
        "operationId": "search_application.delete#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the search application to delete",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_application/analytics/{name}": {
      "get": {
        "description": "Returns the existing behavioral analytics collections.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/list-analytics-collection.html"
        },
        "operationId": "search_application.get_behavioral_analytics#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_application.get_behavioral_analytics#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.get_behavioral_analytics#200"
          }
        }
      },
      "put": {
        "description": "Creates a behavioral analytics collection.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/put-analytics-collection.html"
        },
        "operationId": "search_application.put_behavioral_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the analytics collection to be created or updated.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/search_application.put_behavioral_analytics:AnalyticsAcknowledgeResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Delete a behavioral analytics collection.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-analytics-collection.html"
        },
        "operationId": "search_application.delete_behavioral_analytics#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "The name of the analytics collection to be deleted",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_application/analytics": {
      "get": {
        "description": "Returns the existing behavioral analytics collections.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/list-analytics-collection.html"
        },
        "operationId": "search_application.get_behavioral_analytics#0",
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.get_behavioral_analytics#200"
          }
        }
      }
    },
    "/_application/search_application": {
      "get": {
        "description": "Returns the existing search applications.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/list-search-applications.html"
        },
        "operationId": "search_application.list#0",
        "parameters": [
          {
            "in": "query",
            "name": "q",
            "description": "Query in the Lucene query string syntax.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies a max number of results to get.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/search_application.list:SearchApplicationListItem"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_application/search_application/{name}/_search": {
      "get": {
        "description": "Perform a search against a search application",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-application-search.html"
        },
        "operationId": "search_application.search#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_application.search#name"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_application.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.search#200"
          }
        }
      },
      "post": {
        "description": "Perform a search against a search application",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-application-search.html"
        },
        "operationId": "search_application.search#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_application.search#name"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_application.search"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_application.search#200"
          }
        }
      }
    },
    "/{index}/_mvt/{field}/{zoom}/{x}/{y}": {
      "get": {
        "description": "Searches a vector tile for geospatial values. Returns results as a binary Mapbox vector tile.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-vector-tile-api.html"
        },
        "operationId": "search_mvt#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_mvt#index"
          },
          {
            "$ref": "#/components/parameters/search_mvt#field"
          },
          {
            "$ref": "#/components/parameters/search_mvt#zoom"
          },
          {
            "$ref": "#/components/parameters/search_mvt#x"
          },
          {
            "$ref": "#/components/parameters/search_mvt#y"
          },
          {
            "$ref": "#/components/parameters/search_mvt#exact_bounds"
          },
          {
            "$ref": "#/components/parameters/search_mvt#extent"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_agg"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_precision"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_type"
          },
          {
            "$ref": "#/components/parameters/search_mvt#size"
          },
          {
            "$ref": "#/components/parameters/search_mvt#with_labels"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_mvt"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_mvt#200"
          }
        }
      },
      "post": {
        "description": "Searches a vector tile for geospatial values. Returns results as a binary Mapbox vector tile.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/search-vector-tile-api.html"
        },
        "operationId": "search_mvt#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_mvt#index"
          },
          {
            "$ref": "#/components/parameters/search_mvt#field"
          },
          {
            "$ref": "#/components/parameters/search_mvt#zoom"
          },
          {
            "$ref": "#/components/parameters/search_mvt#x"
          },
          {
            "$ref": "#/components/parameters/search_mvt#y"
          },
          {
            "$ref": "#/components/parameters/search_mvt#exact_bounds"
          },
          {
            "$ref": "#/components/parameters/search_mvt#extent"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_agg"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_precision"
          },
          {
            "$ref": "#/components/parameters/search_mvt#grid_type"
          },
          {
            "$ref": "#/components/parameters/search_mvt#size"
          },
          {
            "$ref": "#/components/parameters/search_mvt#with_labels"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_mvt"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_mvt#200"
          }
        }
      }
    },
    "/_search/template": {
      "get": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search_template#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        }
      },
      "post": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search_template#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        }
      }
    },
    "/{index}/_search/template": {
      "get": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search_template#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#index"
          },
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        }
      },
      "post": {
        "description": "Allows to use the Mustache language to pre-render a search definition.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-template.html"
        },
        "operationId": "search_template#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/search_template#index"
          },
          {
            "$ref": "#/components/parameters/search_template#allow_no_indices"
          },
          {
            "$ref": "#/components/parameters/search_template#ccs_minimize_roundtrips"
          },
          {
            "$ref": "#/components/parameters/search_template#expand_wildcards"
          },
          {
            "$ref": "#/components/parameters/search_template#explain"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_throttled"
          },
          {
            "$ref": "#/components/parameters/search_template#ignore_unavailable"
          },
          {
            "$ref": "#/components/parameters/search_template#preference"
          },
          {
            "$ref": "#/components/parameters/search_template#profile"
          },
          {
            "$ref": "#/components/parameters/search_template#routing"
          },
          {
            "$ref": "#/components/parameters/search_template#scroll"
          },
          {
            "$ref": "#/components/parameters/search_template#search_type"
          },
          {
            "$ref": "#/components/parameters/search_template#rest_total_hits_as_int"
          },
          {
            "$ref": "#/components/parameters/search_template#typed_keys"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/search_template"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/search_template#200"
          }
        }
      }
    },
    "/_security/profile/_activate": {
      "post": {
        "description": "Creates or updates the user profile on behalf of another user.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-activate-user-profile.html"
        },
        "operationId": "security.activate_user_profile#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "access_token": {
                    "type": "string"
                  },
                  "grant_type": {
                    "$ref": "#/components/schemas/security._types:GrantType"
                  },
                  "password": {
                    "type": "string"
                  },
                  "username": {
                    "type": "string"
                  }
                },
                "required": [
                  "grant_type"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/security._types:UserProfileWithMetadata"
                }
              }
            }
          }
        }
      }
    },
    "/_security/_authenticate": {
      "get": {
        "description": "Enables authentication as a user and retrieve information about the authenticated user.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-authenticate.html"
        },
        "operationId": "security.authenticate#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_key": {
                      "$ref": "#/components/schemas/security._types:ApiKey"
                    },
                    "authentication_realm": {
                      "$ref": "#/components/schemas/security._types:RealmInfo"
                    },
                    "email": {
                      "oneOf": [
                        {
                          "type": "string"
                        },
                        {
                          "nullable": true,
                          "type": "string"
                        }
                      ]
                    },
                    "full_name": {
                      "oneOf": [
                        {
                          "$ref": "#/components/schemas/_types:Name"
                        },
                        {
                          "nullable": true,
                          "type": "string"
                        }
                      ]
                    },
                    "lookup_realm": {
                      "$ref": "#/components/schemas/security._types:RealmInfo"
                    },
                    "metadata": {
                      "$ref": "#/components/schemas/_types:Metadata"
                    },
                    "roles": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "username": {
                      "$ref": "#/components/schemas/_types:Username"
                    },
                    "enabled": {
                      "type": "boolean"
                    },
                    "authentication_type": {
                      "type": "string"
                    },
                    "token": {
                      "$ref": "#/components/schemas/security.authenticate:Token"
                    }
                  },
                  "required": [
                    "authentication_realm",
                    "lookup_realm",
                    "metadata",
                    "roles",
                    "username",
                    "enabled",
                    "authentication_type"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/api_key/{ids}/_clear_cache": {
      "post": {
        "description": "Clear a subset or all entries from the API key cache.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-api-key-cache.html"
        },
        "operationId": "security.clear_api_key_cache#0",
        "parameters": [
          {
            "in": "path",
            "name": "ids",
            "description": "Comma-separated list of API key IDs to evict from the API key cache.\nTo evict all API keys, use `*`.\nDoes not support other wildcard patterns.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Ids"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/privilege/{application}/_clear_cache": {
      "post": {
        "description": "Evicts application privileges from the native application privileges cache.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-privilege-cache.html"
        },
        "operationId": "security.clear_cached_privileges#0",
        "parameters": [
          {
            "in": "path",
            "name": "application",
            "description": "A comma-separated list of application names",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/realm/{realms}/_clear_cache": {
      "post": {
        "description": "Evicts users from the user cache. Can completely clear the cache or evict specific users.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-cache.html"
        },
        "operationId": "security.clear_cached_realms#0",
        "parameters": [
          {
            "in": "path",
            "name": "realms",
            "description": "Comma-separated list of realms to clear",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "usernames",
            "description": "Comma-separated list of usernames to clear from the cache",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/role/{name}/_clear_cache": {
      "post": {
        "description": "Evicts roles from the native role cache.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-role-cache.html"
        },
        "operationId": "security.clear_cached_roles#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Role name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}/credential/token/{name}/_clear_cache": {
      "post": {
        "description": "Evicts tokens from the service account token caches.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-clear-service-token-caches.html"
        },
        "operationId": "security.clear_cached_service_tokens#0",
        "parameters": [
          {
            "in": "path",
            "name": "namespace",
            "description": "An identifier for the namespace",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Namespace"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "service",
            "description": "An identifier for the service name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Service"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "name",
            "description": "A comma-separated list of service token names",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "_nodes": {
                      "$ref": "#/components/schemas/_types:NodeStatistics"
                    },
                    "cluster_name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "nodes": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/security._types:ClusterNode"
                      }
                    }
                  },
                  "required": [
                    "_nodes",
                    "cluster_name",
                    "nodes"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/api_key": {
      "get": {
        "description": "Retrieves information for one or more API keys.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html"
        },
        "operationId": "security.get_api_key#0",
        "parameters": [
          {
            "in": "query",
            "name": "id",
            "description": "An API key id.\nThis parameter cannot be used with any of `name`, `realm_name` or `username`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "name",
            "description": "An API key name.\nThis parameter cannot be used with any of `id`, `realm_name` or `username`.\nIt supports prefix search with wildcard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "owner",
            "description": "A boolean flag that can be used to query API keys owned by the currently authenticated user.\nThe `realm_name` or `username` parameters cannot be specified when this parameter is set to `true` as they are assumed to be the currently authenticated ones.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "realm_name",
            "description": "The name of an authentication realm.\nThis parameter cannot be used with either `id` or `name` or when `owner` flag is set to `true`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "username",
            "description": "The username of a user.\nThis parameter cannot be used with either `id` or `name` or when `owner` flag is set to `true`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Username"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "with_limited_by",
            "description": "Return the snapshot of the owner user's role descriptors\nassociated with the API key. An API key's actual\npermission is the intersection of its assigned role\ndescriptors and the owner user's role descriptors.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_keys": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:ApiKey"
                      }
                    }
                  },
                  "required": [
                    "api_keys"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates an API key for access without requiring basic authentication.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html"
        },
        "operationId": "security.create_api_key#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_api_key#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.create_api_key"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_api_key#200"
          }
        }
      },
      "post": {
        "description": "Creates an API key for access without requiring basic authentication.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html"
        },
        "operationId": "security.create_api_key#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_api_key#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.create_api_key"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_api_key#200"
          }
        }
      },
      "delete": {
        "description": "Invalidates one or more API keys.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html"
        },
        "operationId": "security.invalidate_api_key#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "id": {
                    "$ref": "#/components/schemas/_types:Id"
                  },
                  "ids": {
                    "description": "A list of API key ids.\nThis parameter cannot be used with any of `name`, `realm_name`, or `username`.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "name": {
                    "$ref": "#/components/schemas/_types:Name"
                  },
                  "owner": {
                    "description": "Can be used to query API keys owned by the currently authenticated user.\nThe `realm_name` or `username` parameters cannot be specified when this parameter is set to `true` as they are assumed to be the currently authenticated ones.",
                    "type": "boolean"
                  },
                  "realm_name": {
                    "description": "The name of an authentication realm.\nThis parameter cannot be used with either `ids` or `name`, or when `owner` flag is set to `true`.",
                    "type": "string"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error_count": {
                      "type": "number"
                    },
                    "error_details": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:ErrorCause"
                      }
                    },
                    "invalidated_api_keys": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "previously_invalidated_api_keys": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "error_count",
                    "invalidated_api_keys",
                    "previously_invalidated_api_keys"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}/credential/token/{name}": {
      "put": {
        "description": "Creates a service account token for access without requiring basic authentication.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-service-token.html"
        },
        "operationId": "security.create_service_token#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_service_token#namespace"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#service"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#name"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_service_token#200"
          }
        }
      },
      "post": {
        "description": "Creates a service account token for access without requiring basic authentication.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-service-token.html"
        },
        "operationId": "security.create_service_token#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_service_token#namespace"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#service"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#name"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_service_token#200"
          }
        }
      },
      "delete": {
        "description": "Deletes a service account token.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-service-token.html"
        },
        "operationId": "security.delete_service_token#0",
        "parameters": [
          {
            "in": "path",
            "name": "namespace",
            "description": "An identifier for the namespace",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Namespace"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "service",
            "description": "An identifier for the service name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Service"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "name",
            "description": "An identifier for the token name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` (the default) then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}/credential/token": {
      "post": {
        "description": "Creates a service account token for access without requiring basic authentication.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-service-token.html"
        },
        "operationId": "security.create_service_token#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.create_service_token#namespace"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#service"
          },
          {
            "$ref": "#/components/parameters/security.create_service_token#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.create_service_token#200"
          }
        }
      }
    },
    "/_security/privilege/{application}/{name}": {
      "get": {
        "description": "Retrieves application privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-privileges.html"
        },
        "operationId": "security.get_privileges#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_privileges#application"
          },
          {
            "$ref": "#/components/parameters/security.get_privileges#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_privileges#200"
          }
        }
      },
      "delete": {
        "description": "Removes application privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-privilege.html"
        },
        "operationId": "security.delete_privileges#0",
        "parameters": [
          {
            "in": "path",
            "name": "application",
            "description": "Application name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "name",
            "description": "Privilege name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/security.delete_privileges:FoundStatus"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_security/role/{name}": {
      "get": {
        "description": "Retrieves roles in the native realm.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html"
        },
        "operationId": "security.get_role#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_role#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role#200"
          }
        }
      },
      "put": {
        "description": "Adds and updates roles in the native realm.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html"
        },
        "operationId": "security.put_role#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role#200"
          }
        }
      },
      "post": {
        "description": "Adds and updates roles in the native realm.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html"
        },
        "operationId": "security.put_role#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role#200"
          }
        }
      },
      "delete": {
        "description": "Removes roles in the native realm.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role.html"
        },
        "operationId": "security.delete_role#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Role name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/role_mapping/{name}": {
      "get": {
        "description": "Retrieves role mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html"
        },
        "operationId": "security.get_role_mapping#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_role_mapping#name"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role_mapping#200"
          }
        }
      },
      "put": {
        "description": "Creates and updates role mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html"
        },
        "operationId": "security.put_role_mapping#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role_mapping#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role_mapping#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role_mapping#200"
          }
        }
      },
      "post": {
        "description": "Creates and updates role mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role-mapping.html"
        },
        "operationId": "security.put_role_mapping#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_role_mapping#name"
          },
          {
            "$ref": "#/components/parameters/security.put_role_mapping#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_role_mapping"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_role_mapping#200"
          }
        }
      },
      "delete": {
        "description": "Removes role mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-delete-role-mapping.html"
        },
        "operationId": "security.delete_role_mapping#0",
        "parameters": [
          {
            "in": "path",
            "name": "name",
            "description": "Role-mapping name",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "found": {
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "found"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/profile/{uid}/_disable": {
      "put": {
        "description": "Disables a user profile so it's not visible in user profile searches.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-disable-user-profile.html"
        },
        "operationId": "security.disable_user_profile#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.disable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.disable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.disable_user_profile#200"
          }
        }
      },
      "post": {
        "description": "Disables a user profile so it's not visible in user profile searches.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-disable-user-profile.html"
        },
        "operationId": "security.disable_user_profile#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.disable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.disable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.disable_user_profile#200"
          }
        }
      }
    },
    "/_security/profile/{uid}/_enable": {
      "put": {
        "description": "Enables a user profile so it's visible in user profile searches.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-enable-user-profile.html"
        },
        "operationId": "security.enable_user_profile#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.enable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.enable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.enable_user_profile#200"
          }
        }
      },
      "post": {
        "description": "Enables a user profile so it's visible in user profile searches.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-enable-user-profile.html"
        },
        "operationId": "security.enable_user_profile#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.enable_user_profile#uid"
          },
          {
            "$ref": "#/components/parameters/security.enable_user_profile#refresh"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.enable_user_profile#200"
          }
        }
      }
    },
    "/_security/privilege/_builtin": {
      "get": {
        "description": "Retrieves the list of cluster privileges and index privileges that are available in this version of Elasticsearch.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-builtin-privileges.html"
        },
        "operationId": "security.get_builtin_privileges#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cluster": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "index": {
                      "$ref": "#/components/schemas/_types:Indices"
                    }
                  },
                  "required": [
                    "cluster",
                    "index"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/privilege": {
      "get": {
        "description": "Retrieves application privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-privileges.html"
        },
        "operationId": "security.get_privileges#0",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_privileges#200"
          }
        }
      },
      "put": {
        "description": "Adds or updates application privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-privileges.html"
        },
        "operationId": "security.put_privileges#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_privileges#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_privileges#200"
          }
        }
      },
      "post": {
        "description": "Adds or updates application privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-privileges.html"
        },
        "operationId": "security.put_privileges#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.put_privileges#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.put_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.put_privileges#200"
          }
        }
      }
    },
    "/_security/privilege/{application}": {
      "get": {
        "description": "Retrieves application privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-privileges.html"
        },
        "operationId": "security.get_privileges#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_privileges#application"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_privileges#200"
          }
        }
      }
    },
    "/_security/role": {
      "get": {
        "description": "Retrieves roles in the native realm.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role.html"
        },
        "operationId": "security.get_role#1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role#200"
          }
        }
      }
    },
    "/_security/role_mapping": {
      "get": {
        "description": "Retrieves role mappings.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-role-mapping.html"
        },
        "operationId": "security.get_role_mapping#1",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_role_mapping#200"
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}": {
      "get": {
        "description": "Retrieves information about service accounts.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-service-accounts.html"
        },
        "operationId": "security.get_service_accounts#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_service_accounts#namespace"
          },
          {
            "$ref": "#/components/parameters/security.get_service_accounts#service"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_service_accounts#200"
          }
        }
      }
    },
    "/_security/service/{namespace}": {
      "get": {
        "description": "Retrieves information about service accounts.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-service-accounts.html"
        },
        "operationId": "security.get_service_accounts#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.get_service_accounts#namespace"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_service_accounts#200"
          }
        }
      }
    },
    "/_security/service": {
      "get": {
        "description": "Retrieves information about service accounts.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-service-accounts.html"
        },
        "operationId": "security.get_service_accounts#2",
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.get_service_accounts#200"
          }
        }
      }
    },
    "/_security/service/{namespace}/{service}/credential": {
      "get": {
        "description": "Retrieves information of all service credentials for a service account.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-service-credentials.html"
        },
        "operationId": "security.get_service_credentials#0",
        "parameters": [
          {
            "in": "path",
            "name": "namespace",
            "description": "Name of the namespace.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Namespace"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "service",
            "description": "Name of the service name.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "service_account": {
                      "type": "string"
                    },
                    "count": {
                      "type": "number"
                    },
                    "tokens": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types:Metadata"
                      }
                    },
                    "nodes_credentials": {
                      "$ref": "#/components/schemas/security.get_service_credentials:NodesCredentials"
                    }
                  },
                  "required": [
                    "service_account",
                    "count",
                    "tokens",
                    "nodes_credentials"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/oauth2/token": {
      "post": {
        "description": "Creates a bearer token for access without requiring basic authentication.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-token.html"
        },
        "operationId": "security.get_token#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "grant_type": {
                    "$ref": "#/components/schemas/security.get_token:AccessTokenGrantType"
                  },
                  "scope": {
                    "type": "string"
                  },
                  "password": {
                    "$ref": "#/components/schemas/_types:Password"
                  },
                  "kerberos_ticket": {
                    "type": "string"
                  },
                  "refresh_token": {
                    "type": "string"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "access_token": {
                      "type": "string"
                    },
                    "expires_in": {
                      "type": "number"
                    },
                    "scope": {
                      "type": "string"
                    },
                    "type": {
                      "type": "string"
                    },
                    "refresh_token": {
                      "type": "string"
                    },
                    "kerberos_authentication_response_token": {
                      "type": "string"
                    },
                    "authentication": {
                      "$ref": "#/components/schemas/security.get_token:AuthenticatedUser"
                    }
                  },
                  "required": [
                    "access_token",
                    "expires_in",
                    "type",
                    "authentication"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Invalidates one or more access tokens or refresh tokens.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-token.html"
        },
        "operationId": "security.invalidate_token#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "type": "string"
                  },
                  "refresh_token": {
                    "type": "string"
                  },
                  "realm_name": {
                    "$ref": "#/components/schemas/_types:Name"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error_count": {
                      "type": "number"
                    },
                    "error_details": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:ErrorCause"
                      }
                    },
                    "invalidated_tokens": {
                      "type": "number"
                    },
                    "previously_invalidated_tokens": {
                      "type": "number"
                    }
                  },
                  "required": [
                    "error_count",
                    "invalidated_tokens",
                    "previously_invalidated_tokens"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/user/_privileges": {
      "get": {
        "description": "Retrieves security privileges for the logged in user.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-privileges.html"
        },
        "operationId": "security.get_user_privileges#0",
        "parameters": [
          {
            "in": "query",
            "name": "application",
            "description": "The name of the application. Application privileges are always associated with exactly one application. If you do not specify this parameter, the API returns information about all privileges for all applications.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "priviledge",
            "description": "The name of the privilege. If you do not specify this parameter, the API returns information about all privileges for the requested application.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "username",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:Name"
                },
                {
                  "nullable": true,
                  "type": "string"
                }
              ]
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "applications": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
                      }
                    },
                    "cluster": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "global": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:GlobalPrivilege"
                      }
                    },
                    "indices": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:UserIndicesPrivileges"
                      }
                    },
                    "run_as": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "required": [
                    "applications",
                    "cluster",
                    "global",
                    "indices",
                    "run_as"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/profile/{uid}": {
      "get": {
        "description": "Retrieves user profiles for the given unique ID(s).",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-user-profile.html"
        },
        "operationId": "security.get_user_profile#0",
        "parameters": [
          {
            "in": "path",
            "name": "uid",
            "description": "A unique identifier for the user profile.",
            "required": true,
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/security._types:UserProfileId"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfileId"
                  }
                }
              ]
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "data",
            "description": "List of filters for the `data` field of the profile document.\nTo return all content use `data=*`. To return a subset of content\nuse `data=<key>` to retrieve content nested under the specified `<key>`.\nBy default returns no `data` content.",
            "deprecated": false,
            "schema": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "profiles": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/security._types:UserProfileWithMetadata"
                      }
                    },
                    "errors": {
                      "$ref": "#/components/schemas/security.get_user_profile:GetUserProfileErrors"
                    }
                  },
                  "required": [
                    "profiles"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/api_key/grant": {
      "post": {
        "description": "Creates an API key on behalf of another user.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-grant-api-key.html"
        },
        "operationId": "security.grant_api_key#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "api_key": {
                    "$ref": "#/components/schemas/security.grant_api_key:GrantApiKey"
                  },
                  "grant_type": {
                    "$ref": "#/components/schemas/security.grant_api_key:ApiKeyGrantType"
                  },
                  "access_token": {
                    "description": "The users access token.\nIf you specify the `access_token` grant type, this parameter is required.\nIt is not valid with other grant types.",
                    "type": "string"
                  },
                  "username": {
                    "$ref": "#/components/schemas/_types:Username"
                  },
                  "password": {
                    "$ref": "#/components/schemas/_types:Password"
                  },
                  "run_as": {
                    "$ref": "#/components/schemas/_types:Username"
                  }
                },
                "required": [
                  "api_key",
                  "grant_type"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "api_key": {
                      "type": "string"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "name": {
                      "$ref": "#/components/schemas/_types:Name"
                    },
                    "expiration": {
                      "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
                    },
                    "encoded": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "api_key",
                    "id",
                    "name",
                    "encoded"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/user/_has_privileges": {
      "get": {
        "description": "Determines whether the specified user has a specified list of privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html"
        },
        "operationId": "security.has_privileges#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        }
      },
      "post": {
        "description": "Determines whether the specified user has a specified list of privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html"
        },
        "operationId": "security.has_privileges#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        }
      }
    },
    "/_security/user/{user}/_has_privileges": {
      "get": {
        "description": "Determines whether the specified user has a specified list of privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html"
        },
        "operationId": "security.has_privileges#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.has_privileges#user"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        }
      },
      "post": {
        "description": "Determines whether the specified user has a specified list of privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges.html"
        },
        "operationId": "security.has_privileges#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.has_privileges#user"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges#200"
          }
        }
      }
    },
    "/_security/profile/_has_privileges": {
      "get": {
        "description": "Determines whether the users associated with the specified profile IDs have all the requested privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges-user-profile.html"
        },
        "operationId": "security.has_privileges_user_profile#0",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges_user_profile"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges_user_profile#200"
          }
        }
      },
      "post": {
        "description": "Determines whether the users associated with the specified profile IDs have all the requested privileges.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-has-privileges-user-profile.html"
        },
        "operationId": "security.has_privileges_user_profile#1",
        "requestBody": {
          "$ref": "#/components/requestBodies/security.has_privileges_user_profile"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.has_privileges_user_profile#200"
          }
        }
      }
    },
    "/_security/_query/api_key": {
      "get": {
        "description": "Retrieves information for API keys using a subset of query DSL",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-query-api-key.html"
        },
        "operationId": "security.query_api_keys#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.query_api_keys#with_limited_by"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_api_keys"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_api_keys#200"
          }
        }
      },
      "post": {
        "description": "Retrieves information for API keys using a subset of query DSL",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-query-api-key.html"
        },
        "operationId": "security.query_api_keys#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.query_api_keys#with_limited_by"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.query_api_keys"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.query_api_keys#200"
          }
        }
      }
    },
    "/_security/saml/authenticate": {
      "post": {
        "description": "Exchanges a SAML Response message for an Elasticsearch access token and refresh token pair",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-saml-authenticate.html"
        },
        "operationId": "security.saml_authenticate#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "content": {
                    "description": "The SAML response as it was sent by the users browser, usually a Base64 encoded XML document.",
                    "type": "string"
                  },
                  "ids": {
                    "$ref": "#/components/schemas/_types:Ids"
                  },
                  "realm": {
                    "description": "The name of the realm that should authenticate the SAML response. Useful in cases where many SAML realms are defined.",
                    "type": "string"
                  }
                },
                "required": [
                  "content",
                  "ids"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "access_token": {
                      "type": "string"
                    },
                    "username": {
                      "type": "string"
                    },
                    "expires_in": {
                      "type": "number"
                    },
                    "refresh_token": {
                      "type": "string"
                    },
                    "realm": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "access_token",
                    "username",
                    "expires_in",
                    "refresh_token",
                    "realm"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/saml/complete_logout": {
      "post": {
        "description": "Verifies the logout response sent from the SAML IdP",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-saml-complete-logout.html"
        },
        "operationId": "security.saml_complete_logout#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "realm": {
                    "description": "The name of the SAML realm in Elasticsearch for which the configuration is used to verify the logout response.",
                    "type": "string"
                  },
                  "ids": {
                    "$ref": "#/components/schemas/_types:Ids"
                  },
                  "query_string": {
                    "description": "If the SAML IdP sends the logout response with the HTTP-Redirect binding, this field must be set to the query string of the redirect URI.",
                    "type": "string"
                  },
                  "content": {
                    "description": "If the SAML IdP sends the logout response with the HTTP-Post binding, this field must be set to the value of the SAMLResponse form parameter from the logout response.",
                    "type": "string"
                  }
                },
                "required": [
                  "realm",
                  "ids"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {}
            }
          }
        }
      }
    },
    "/_security/saml/invalidate": {
      "post": {
        "description": "Consumes a SAML LogoutRequest",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-saml-invalidate.html"
        },
        "operationId": "security.saml_invalidate#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "acs": {
                    "description": "The Assertion Consumer Service URL that matches the one of the SAML realm in Elasticsearch that should be used. You must specify either this parameter or the realm parameter.",
                    "type": "string"
                  },
                  "query_string": {
                    "description": "The query part of the URL that the user was redirected to by the SAML IdP to initiate the Single Logout.\nThis query should include a single parameter named SAMLRequest that contains a SAML logout request that is deflated and Base64 encoded.\nIf the SAML IdP has signed the logout request, the URL should include two extra parameters named SigAlg and Signature that contain the algorithm used for the signature and the signature value itself.\nIn order for Elasticsearch to be able to verify the IdPs signature, the value of the query_string field must be an exact match to the string provided by the browser.\nThe client application must not attempt to parse or process the string in any way.",
                    "type": "string"
                  },
                  "realm": {
                    "description": "The name of the SAML realm in Elasticsearch the configuration. You must specify either this parameter or the acs parameter.",
                    "type": "string"
                  }
                },
                "required": [
                  "query_string"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "invalidated": {
                      "type": "number"
                    },
                    "realm": {
                      "type": "string"
                    },
                    "redirect": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "invalidated",
                    "realm",
                    "redirect"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/saml/logout": {
      "post": {
        "description": "Invalidates an access token and a refresh token that were generated via the SAML Authenticate API",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-saml-logout.html"
        },
        "operationId": "security.saml_logout#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "token": {
                    "description": "The access token that was returned as a response to calling the SAML authenticate API.\nAlternatively, the most recent token that was received after refreshing the original one by using a refresh_token.",
                    "type": "string"
                  },
                  "refresh_token": {
                    "description": "The refresh token that was returned as a response to calling the SAML authenticate API.\nAlternatively, the most recent refresh token that was received after refreshing the original access token.",
                    "type": "string"
                  }
                },
                "required": [
                  "token"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "redirect": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "redirect"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/saml/prepare": {
      "post": {
        "description": "Creates a SAML authentication request",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-saml-prepare-authentication.html"
        },
        "operationId": "security.saml_prepare_authentication#0",
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "acs": {
                    "description": "The Assertion Consumer Service URL that matches the one of the SAML realms in Elasticsearch.\nThe realm is used to generate the authentication request. You must specify either this parameter or the realm parameter.",
                    "type": "string"
                  },
                  "realm": {
                    "description": "The name of the SAML realm in Elasticsearch for which the configuration is used to generate the authentication request.\nYou must specify either this parameter or the acs parameter.",
                    "type": "string"
                  },
                  "relay_state": {
                    "description": "A string that will be included in the redirect URL that this API returns as the RelayState query parameter.\nIf the Authentication Request is signed, this value is used as part of the signature computation.",
                    "type": "string"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "realm": {
                      "type": "string"
                    },
                    "redirect": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "id",
                    "realm",
                    "redirect"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/saml/metadata/{realm_name}": {
      "get": {
        "description": "Generates SAML metadata for the Elastic stack SAML 2.0 Service Provider",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-saml-sp-metadata.html"
        },
        "operationId": "security.saml_service_provider_metadata#0",
        "parameters": [
          {
            "in": "path",
            "name": "realm_name",
            "description": "The name of the SAML realm in Elasticsearch.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "metadata": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "metadata"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/profile/_suggest": {
      "get": {
        "description": "Get suggestions for user profiles that match specified search criteria.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-suggest-user-profile.html"
        },
        "operationId": "security.suggest_user_profiles#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.suggest_user_profiles#data"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.suggest_user_profiles"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.suggest_user_profiles#200"
          }
        }
      },
      "post": {
        "description": "Get suggestions for user profiles that match specified search criteria.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/security-api-suggest-user-profile.html"
        },
        "operationId": "security.suggest_user_profiles#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.suggest_user_profiles#data"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.suggest_user_profiles"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.suggest_user_profiles#200"
          }
        }
      }
    },
    "/_security/api_key/{id}": {
      "put": {
        "description": "Updates attributes of an existing API key.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-api-key.html"
        },
        "operationId": "security.update_api_key#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The ID of the API key to update.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "role_descriptors": {
                    "externalDocs": {
                      "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html"
                    },
                    "description": "An array of role descriptors for this API key. This parameter is optional. When it is not specified or is an empty array, then the API key will have a point in time snapshot of permissions of the authenticated user. If you supply role descriptors then the resultant permissions would be an intersection of API keys permissions and authenticated users permissions thereby limiting the access scope for API keys. The structure of role descriptor is the same as the request for create role API. For more details, see create or update roles API.",
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/security._types:RoleDescriptor"
                    }
                  },
                  "metadata": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "updated": {
                      "description": "If `true`, the API key was updated.\nIf `false`, the API key didnt change because no change was detected.",
                      "type": "boolean"
                    }
                  },
                  "required": [
                    "updated"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_security/profile/{uid}/_data": {
      "put": {
        "description": "Update application specific data for the user profile of the given unique ID.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-user-profile-data.html"
        },
        "operationId": "security.update_user_profile_data#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#uid"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.update_user_profile_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.update_user_profile_data#200"
          }
        }
      },
      "post": {
        "description": "Update application specific data for the user profile of the given unique ID.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-update-user-profile-data.html"
        },
        "operationId": "security.update_user_profile_data#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#uid"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_seq_no"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#if_primary_term"
          },
          {
            "$ref": "#/components/parameters/security.update_user_profile_data#refresh"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/security.update_user_profile_data"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/security.update_user_profile_data#200"
          }
        }
      }
    },
    "/_ssl/certificates": {
      "get": {
        "description": "Retrieves information about the X.509 certificates used to encrypt communications in the cluster.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-ssl.html"
        },
        "operationId": "ssl.certificates#0",
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ssl.certificates:CertificateInformation"
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_synonyms/{id}": {
      "get": {
        "description": "Retrieves a synonym set",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/get-synonyms-set.html"
        },
        "operationId": "synonyms.get_synonym#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "\"The id of the synonyms set to be retrieved",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset for query rules to be retrieved",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "specifies a max number of query rules to retrieve",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "synonyms_set": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/synonyms._types:SynonymRuleRead"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "synonyms_set"
                  ]
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates or updates a synonyms set",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/put-synonyms-set.html"
        },
        "operationId": "synonyms.put_synonym#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The id of the synonyms set to be created or updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "synonyms_set": {
                    "description": "The synonym set information to update",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/synonyms._types:SynonymRule"
                    }
                  }
                },
                "required": [
                  "synonyms_set"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "result": {
                      "$ref": "#/components/schemas/_types:Result"
                    },
                    "reload_analyzers_details": {
                      "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadDetails"
                    }
                  },
                  "required": [
                    "result",
                    "reload_analyzers_details"
                  ]
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a synonym set",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-synonyms-set.html"
        },
        "operationId": "synonyms.delete_synonym#0",
        "parameters": [
          {
            "in": "path",
            "name": "id",
            "description": "The id of the synonyms set to be deleted",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_synonyms/{set_id}/{rule_id}": {
      "get": {
        "description": "Retrieves a synonym rule from a synonym set",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/get-synonym-rule.html"
        },
        "operationId": "synonyms.get_synonym_rule#0",
        "parameters": [
          {
            "in": "path",
            "name": "set_id",
            "description": "The id of the synonym set to retrieve the synonym rule from",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The id of the synonym rule to retrieve",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/synonyms._types:SynonymRuleRead"
                }
              }
            }
          }
        }
      },
      "put": {
        "description": "Creates or updates a synonym rule in a synonym set",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/put-synonym-rule.html"
        },
        "operationId": "synonyms.put_synonym_rule#0",
        "parameters": [
          {
            "in": "path",
            "name": "set_id",
            "description": "The id of the synonym set to be updated with the synonym rule",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The id of the synonym rule to be updated or created",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "synonyms": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/synonyms._types:SynonymString"
                    }
                  }
                },
                "required": [
                  "synonyms"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/synonyms._types:SynonymsUpdateResult"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes a synonym rule in a synonym set",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/delete-synonym-rule.html"
        },
        "operationId": "synonyms.delete_synonym_rule#0",
        "parameters": [
          {
            "in": "path",
            "name": "set_id",
            "description": "The id of the synonym set to be updated",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "rule_id",
            "description": "The id of the synonym rule to be deleted",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/synonyms._types:SynonymsUpdateResult"
                }
              }
            }
          }
        }
      }
    },
    "/_synonyms": {
      "get": {
        "description": "Retrieves a summary of all defined synonym sets",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/list-synonyms-sets.html"
        },
        "operationId": "synonyms.get_synonyms_sets#0",
        "parameters": [
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "specifies a max number of results to get",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "results": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/synonyms.get_synonyms_sets:SynonymsSetItem"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "results"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_terms_enum": {
      "get": {
        "description": "The terms enum API  can be used to discover terms in the index that begin with the provided string. It is designed for low-latency look-ups used in auto-complete scenarios.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-terms-enum.html"
        },
        "operationId": "terms_enum#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/terms_enum#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/terms_enum"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/terms_enum#200"
          }
        }
      },
      "post": {
        "description": "The terms enum API  can be used to discover terms in the index that begin with the provided string. It is designed for low-latency look-ups used in auto-complete scenarios.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-terms-enum.html"
        },
        "operationId": "terms_enum#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/terms_enum#index"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/terms_enum"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/terms_enum#200"
          }
        }
      }
    },
    "/{index}/_termvectors/{id}": {
      "get": {
        "description": "Returns information and statistics about terms in the fields of a particular document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html"
        },
        "operationId": "termvectors#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#id"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      },
      "post": {
        "description": "Returns information and statistics about terms in the fields of a particular document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html"
        },
        "operationId": "termvectors#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#id"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      }
    },
    "/{index}/_termvectors": {
      "get": {
        "description": "Returns information and statistics about terms in the fields of a particular document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html"
        },
        "operationId": "termvectors#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      },
      "post": {
        "description": "Returns information and statistics about terms in the fields of a particular document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-termvectors.html"
        },
        "operationId": "termvectors#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/termvectors#index"
          },
          {
            "$ref": "#/components/parameters/termvectors#fields"
          },
          {
            "$ref": "#/components/parameters/termvectors#field_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#offsets"
          },
          {
            "$ref": "#/components/parameters/termvectors#payloads"
          },
          {
            "$ref": "#/components/parameters/termvectors#positions"
          },
          {
            "$ref": "#/components/parameters/termvectors#preference"
          },
          {
            "$ref": "#/components/parameters/termvectors#realtime"
          },
          {
            "$ref": "#/components/parameters/termvectors#routing"
          },
          {
            "$ref": "#/components/parameters/termvectors#term_statistics"
          },
          {
            "$ref": "#/components/parameters/termvectors#version"
          },
          {
            "$ref": "#/components/parameters/termvectors#version_type"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/termvectors"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/termvectors#200"
          }
        }
      }
    },
    "/_text_structure/find_structure": {
      "post": {
        "description": "Finds the structure of a text file. The text file must contain data that is suitable to be ingested into Elasticsearch.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/find-structure.html"
        },
        "operationId": "text_structure.find_structure#0",
        "parameters": [
          {
            "in": "query",
            "name": "charset",
            "description": "The texts character set. It must be a character set that is supported by the JVM that Elasticsearch uses. For example, UTF-8, UTF-16LE, windows-1252, or EUC-JP. If this parameter is not specified, the structure finder chooses an appropriate character set.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "column_names",
            "description": "If you have set format to delimited, you can specify the column names in a comma-separated list. If this parameter is not specified, the structure finder uses the column names from the header row of the text. If the text does not have a header role, columns are named \"column1\", \"column2\", \"column3\", etc.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "delimiter",
            "description": "If you have set format to delimited, you can specify the character used to delimit the values in each row. Only a single character is supported; the delimiter cannot have multiple characters. By default, the API considers the following possibilities: comma, tab, semi-colon, and pipe (|). In this default scenario, all rows must have the same number of fields for the delimited format to be detected. If you specify a delimiter, up to 10% of the rows can have a different number of columns than the first row.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "explain",
            "description": "If this parameter is set to true, the response includes a field named explanation, which is an array of strings that indicate how the structure finder produced its result.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "format",
            "description": "The high level structure of the text. Valid values are ndjson, xml, delimited, and semi_structured_text. By default, the API chooses the format. In this default scenario, all rows must have the same number of fields for a delimited format to be detected. If the format is set to delimited and the delimiter is not set, however, the API tolerates up to 5% of rows that have a different number of columns than the first row.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "grok_pattern",
            "description": "If you have set format to semi_structured_text, you can specify a Grok pattern that is used to extract fields from every message in the text. The name of the timestamp field in the Grok pattern must match what is specified in the timestamp_field parameter. If that parameter is not specified, the name of the timestamp field in the Grok pattern must match \"timestamp\". If grok_pattern is not specified, the structure finder creates a Grok pattern.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "has_header_row",
            "description": "If you have set format to delimited, you can use this parameter to indicate whether the column names are in the first row of the text. If this parameter is not specified, the structure finder guesses based on the similarity of the first row of the text to other rows.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "line_merge_size_limit",
            "description": "The maximum number of characters in a message when lines are merged to form messages while analyzing semi-structured text. If you have extremely long messages you may need to increase this, but be aware that this may lead to very long processing times if the way to group lines into messages is misdetected.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:uint"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lines_to_sample",
            "description": "The number of lines to include in the structural analysis, starting from the beginning of the text. The minimum is 2; If the value of this parameter is greater than the number of lines in the text, the analysis proceeds (as long as there are at least two lines in the text) for all of the lines.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:uint"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "quote",
            "description": "If you have set format to delimited, you can specify the character used to quote the values in each row if they contain newlines or the delimiter character. Only a single character is supported. If this parameter is not specified, the default value is a double quote (\"). If your delimited text format does not use quoting, a workaround is to set this argument to a character that does not appear anywhere in the sample.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "should_trim_fields",
            "description": "If you have set format to delimited, you can specify whether values between delimiters should have whitespace trimmed from them. If this parameter is not specified and the delimiter is pipe (|), the default value is true. Otherwise, the default value is false.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Sets the maximum amount of time that the structure analysis make take. If the analysis is still running when the timeout expires then it will be aborted.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timestamp_field",
            "description": "Optional parameter to specify the timestamp field in the file",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Field"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timestamp_format",
            "description": "The Java time format of the timestamp field in the text.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "array",
                "items": {
                  "type": "object"
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "charset": {
                      "type": "string"
                    },
                    "has_header_row": {
                      "type": "boolean"
                    },
                    "has_byte_order_marker": {
                      "type": "boolean"
                    },
                    "format": {
                      "type": "string"
                    },
                    "field_stats": {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/text_structure.find_structure:FieldStat"
                      }
                    },
                    "sample_start": {
                      "type": "string"
                    },
                    "num_messages_analyzed": {
                      "type": "number"
                    },
                    "mappings": {
                      "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                    },
                    "quote": {
                      "type": "string"
                    },
                    "delimiter": {
                      "type": "string"
                    },
                    "need_client_timezone": {
                      "type": "boolean"
                    },
                    "num_lines_analyzed": {
                      "type": "number"
                    },
                    "column_names": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "explanation": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "grok_pattern": {
                      "type": "string"
                    },
                    "multiline_start_pattern": {
                      "type": "string"
                    },
                    "exclude_lines_pattern": {
                      "type": "string"
                    },
                    "java_timestamp_formats": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "joda_timestamp_formats": {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "timestamp_field": {
                      "$ref": "#/components/schemas/_types:Field"
                    },
                    "should_trim_fields": {
                      "type": "boolean"
                    },
                    "ingest_pipeline": {
                      "$ref": "#/components/schemas/ingest._types:PipelineConfig"
                    }
                  },
                  "required": [
                    "charset",
                    "has_byte_order_marker",
                    "format",
                    "field_stats",
                    "sample_start",
                    "num_messages_analyzed",
                    "mappings",
                    "need_client_timezone",
                    "num_lines_analyzed",
                    "ingest_pipeline"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_transform/{transform_id}": {
      "get": {
        "description": "Retrieves configuration information for transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform.html"
        },
        "operationId": "transform.get_transform#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.get_transform#transform_id"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#from"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#size"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.get_transform#200"
          }
        }
      },
      "put": {
        "description": "Instantiates a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/put-transform.html"
        },
        "operationId": "transform.put_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. This identifier can contain lowercase alphanumeric characters (a-z and 0-9),\nhyphens, and underscores. It has a 64 character limit and must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "defer_validation",
            "description": "When the transform is created, a series of validations occur to ensure its success. For example, there is a\ncheck for the existence of the source indices and a check that the destination index is not part of the source\nindex pattern. You can use this parameter to skip the checks, for example when the source index does not exist\nuntil after the transform is created. The validations are always run when you start the transform, however, with\nthe exception of privilege checks.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "dest": {
                    "$ref": "#/components/schemas/transform._types:Destination"
                  },
                  "description": {
                    "description": "Free text description of the transform.",
                    "type": "string"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "latest": {
                    "$ref": "#/components/schemas/transform._types:Latest"
                  },
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "pivot": {
                    "$ref": "#/components/schemas/transform._types:Pivot"
                  },
                  "retention_policy": {
                    "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                  },
                  "settings": {
                    "$ref": "#/components/schemas/transform._types:Settings"
                  },
                  "source": {
                    "$ref": "#/components/schemas/transform._types:Source"
                  },
                  "sync": {
                    "$ref": "#/components/schemas/transform._types:SyncContainer"
                  }
                },
                "required": [
                  "dest",
                  "source"
                ]
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      },
      "delete": {
        "description": "Deletes an existing transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/delete-transform.html"
        },
        "operationId": "transform.delete_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If this value is false, the transform must be stopped before it can be deleted. If true, the transform is\ndeleted regardless of its current state.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_transform": {
      "get": {
        "description": "Retrieves configuration information for transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform.html"
        },
        "operationId": "transform.get_transform#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.get_transform#allow_no_match"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#from"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#size"
          },
          {
            "$ref": "#/components/parameters/transform.get_transform#exclude_generated"
          }
        ],
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.get_transform#200"
          }
        }
      }
    },
    "/_transform/{transform_id}/_stats": {
      "get": {
        "description": "Retrieves usage information for transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/get-transform-stats.html"
        },
        "operationId": "transform.get_transform_stats#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. It can be a transform identifier or a\nwildcard expression. You can get information for all transforms by using\n`_all`, by specifying `*` as the `<transform_id>`, or by omitting the\n`<transform_id>`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Names"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Skips the specified number of transforms.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "size",
            "description": "Specifies the maximum number of transforms to obtain.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait for the stats",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "count": {
                      "type": "number"
                    },
                    "transforms": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/transform.get_transform_stats:TransformStats"
                      }
                    }
                  },
                  "required": [
                    "count",
                    "transforms"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_transform/{transform_id}/_preview": {
      "get": {
        "description": "Previews a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html"
        },
        "operationId": "transform.preview_transform#0",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#transform_id"
          },
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        }
      },
      "post": {
        "description": "Previews a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html"
        },
        "operationId": "transform.preview_transform#1",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#transform_id"
          },
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        }
      }
    },
    "/_transform/_preview": {
      "get": {
        "description": "Previews a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html"
        },
        "operationId": "transform.preview_transform#2",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        }
      },
      "post": {
        "description": "Previews a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/preview-transform.html"
        },
        "operationId": "transform.preview_transform#3",
        "parameters": [
          {
            "$ref": "#/components/parameters/transform.preview_transform#timeout"
          }
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/transform.preview_transform"
        },
        "responses": {
          "200": {
            "$ref": "#/components/responses/transform.preview_transform#200"
          }
        }
      }
    },
    "/_transform/{transform_id}/_reset": {
      "post": {
        "description": "Resets an existing transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/reset-transform.html"
        },
        "operationId": "transform.reset_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. This identifier can contain lowercase alphanumeric characters (a-z and 0-9),\nhyphens, and underscores. It has a 64 character limit and must start and end with alphanumeric characters.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If this value is `true`, the transform is reset regardless of its current state. If it's `false`, the transform\nmust be stopped before it can be reset.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_transform/{transform_id}/_schedule_now": {
      "post": {
        "description": "Schedules now a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/schedule-now-transform.html"
        },
        "operationId": "transform.schedule_now_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Controls the time to wait for the scheduling to take place",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_transform/{transform_id}/_start": {
      "post": {
        "description": "Starts one or more transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/start-transform.html"
        },
        "operationId": "transform.start_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Restricts the set of transformed entities to those changed after this time. Relative times like now-30d are supported. Only applicable for continuous transforms.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_transform/{transform_id}/_stop": {
      "post": {
        "description": "Stops one or more transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/stop-transform.html"
        },
        "operationId": "transform.stop_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform. To stop multiple transforms, use a comma-separated list or a wildcard expression.\nTo stop all transforms, use `_all` or `*` as the identifier.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Name"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_match",
            "description": "Specifies what to do when the request: contains wildcard expressions and there are no transforms that match;\ncontains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there\nare only partial matches.\n\nIf it is true, the API returns a successful acknowledgement message when there are no matches. When there are\nonly partial matches, the API stops the appropriate transforms.\n\nIf it is false, the request returns a 404 status code when there are no matches or only partial matches.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "force",
            "description": "If it is true, the API forcefully stops the transforms.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response when `wait_for_completion` is `true`. If no response is received before the\ntimeout expires, the request returns a timeout exception. However, the request continues processing and\neventually moves the transform to a STOPPED state.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_checkpoint",
            "description": "If it is true, the transform does not completely stop until the current checkpoint is completed. If it is false,\nthe transform stops as soon as possible.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If it is true, the API blocks until the indexer state completely stops. If it is false, the API returns\nimmediately and the indexer is stopped asynchronously in the background.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/_transform/{transform_id}/_update": {
      "post": {
        "description": "Updates certain properties of a transform.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/update-transform.html"
        },
        "operationId": "transform.update_transform#0",
        "parameters": [
          {
            "in": "path",
            "name": "transform_id",
            "description": "Identifier for the transform.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "defer_validation",
            "description": "When true, deferrable validations are not run. This behavior may be\ndesired if the source index does not exist until after the transform is\ncreated.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the\ntimeout expires, the request fails and returns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "dest": {
                    "$ref": "#/components/schemas/transform._types:Destination"
                  },
                  "description": {
                    "description": "Free text description of the transform.",
                    "type": "string"
                  },
                  "frequency": {
                    "$ref": "#/components/schemas/_types:Duration"
                  },
                  "_meta": {
                    "$ref": "#/components/schemas/_types:Metadata"
                  },
                  "source": {
                    "$ref": "#/components/schemas/transform._types:Source"
                  },
                  "settings": {
                    "$ref": "#/components/schemas/transform._types:Settings"
                  },
                  "sync": {
                    "$ref": "#/components/schemas/transform._types:SyncContainer"
                  },
                  "retention_policy": {
                    "description": "Defines a retention policy for the transform. Data that meets the defined\ncriteria is deleted from the destination index.",
                    "oneOf": [
                      {
                        "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                      },
                      {
                        "nullable": true,
                        "type": "string"
                      }
                    ]
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "authorization": {
                      "$ref": "#/components/schemas/ml._types:TransformAuthorization"
                    },
                    "create_time": {
                      "type": "number"
                    },
                    "description": {
                      "type": "string"
                    },
                    "dest": {
                      "$ref": "#/components/schemas/_global.reindex:Destination"
                    },
                    "frequency": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "id": {
                      "$ref": "#/components/schemas/_types:Id"
                    },
                    "latest": {
                      "$ref": "#/components/schemas/transform._types:Latest"
                    },
                    "pivot": {
                      "$ref": "#/components/schemas/transform._types:Pivot"
                    },
                    "retention_policy": {
                      "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                    },
                    "settings": {
                      "$ref": "#/components/schemas/transform._types:Settings"
                    },
                    "source": {
                      "$ref": "#/components/schemas/_global.reindex:Source"
                    },
                    "sync": {
                      "$ref": "#/components/schemas/transform._types:SyncContainer"
                    },
                    "version": {
                      "$ref": "#/components/schemas/_types:VersionString"
                    },
                    "_meta": {
                      "$ref": "#/components/schemas/_types:Metadata"
                    }
                  },
                  "required": [
                    "create_time",
                    "description",
                    "dest",
                    "id",
                    "settings",
                    "source",
                    "version"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/_transform/_upgrade": {
      "post": {
        "description": "Upgrades all transforms.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/upgrade-transforms.html"
        },
        "operationId": "transform.upgrade_transforms#0",
        "parameters": [
          {
            "in": "query",
            "name": "dry_run",
            "description": "When true, the request checks for updates but does not run them.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and\nreturns an error.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "needs_update": {
                      "description": "The number of transforms that need to be upgraded.",
                      "type": "number"
                    },
                    "no_action": {
                      "description": "The number of transforms that dont require upgrading.",
                      "type": "number"
                    },
                    "updated": {
                      "description": "The number of transforms that have been upgraded.",
                      "type": "number"
                    }
                  },
                  "required": [
                    "needs_update",
                    "no_action",
                    "updated"
                  ]
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_update/{id}": {
      "post": {
        "description": "Updates a document with a script or partial document.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update.html"
        },
        "operationId": "update#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "The name of the index",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            "style": "simple"
          },
          {
            "in": "path",
            "name": "id",
            "description": "Document ID",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Id"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "if_primary_term",
            "description": "Only perform the operation if the document has this primary term.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "if_seq_no",
            "description": "Only perform the operation if the document has this sequence number.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SequenceNumber"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lang",
            "description": "The script language.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation\nvisible to search, if 'wait_for' then wait for a refresh to make this operation\nvisible to search, if 'false' do nothing with refreshes.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Refresh"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "require_alias",
            "description": "If true, the destination must be an index alias.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "retry_on_conflict",
            "description": "Specify how many times should the operation be retried when a conflict occurs.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period to wait for dynamic mapping updates and active shards.\nThis guarantees Elasticsearch waits for at least the timeout before failing.\nThe actual wait time could be longer, particularly when multiple waits occur.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operations.\nSet to 'all' or any positive integer up to the total number of shards in the index\n(number_of_replicas+1). Defaults to 1 meaning the primary shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source",
            "description": "Set to false to disable source retrieval. You can also specify a comma-separated\nlist of the fields you want to retrieve.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_excludes",
            "description": "Specify the source fields you want to exclude.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "_source_includes",
            "description": "Specify the source fields you want to retrieve.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Fields"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "detect_noop": {
                    "description": "Set to false to disable setting 'result' in the response\nto 'noop' if no change to the document occurred.",
                    "type": "boolean"
                  },
                  "doc": {
                    "description": "A partial update to an existing document.",
                    "type": "object"
                  },
                  "doc_as_upsert": {
                    "description": "Set to true to use the contents of 'doc' as the value of 'upsert'",
                    "type": "boolean"
                  },
                  "script": {
                    "$ref": "#/components/schemas/_types:Script"
                  },
                  "scripted_upsert": {
                    "description": "Set to true to execute the script whether or not the document exists.",
                    "type": "boolean"
                  },
                  "_source": {
                    "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                  },
                  "upsert": {
                    "description": "If the document does not already exist, the contents of 'upsert' are inserted as a\nnew document. If the document exists, the 'script' is executed.",
                    "type": "object"
                  }
                }
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/_global.update:UpdateWriteResponseBase"
                }
              }
            }
          }
        }
      }
    },
    "/{index}/_update_by_query": {
      "post": {
        "description": "Performs an update on every document in the index without changing the source,\nfor example to pick up a mapping change.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/master/docs-update-by-query.html"
        },
        "operationId": "update_by_query#0",
        "parameters": [
          {
            "in": "path",
            "name": "index",
            "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams or indices, omit this parameter or use `*` or `_all`.",
            "required": true,
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Indices"
            },
            "style": "simple"
          },
          {
            "in": "query",
            "name": "allow_no_indices",
            "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyzer",
            "description": "Analyzer to use for the query string.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "analyze_wildcard",
            "description": "If `true`, wildcard and prefix queries are analyzed.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "conflicts",
            "description": "What to do if update by query hits version conflicts: `abort` or `proceed`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Conflicts"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "default_operator",
            "description": "The default operator for query string query: `AND` or `OR`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types.query_dsl:Operator"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "df",
            "description": "Field to use as default where no field prefix is given in the query string.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "expand_wildcards",
            "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:ExpandWildcards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "from",
            "description": "Starting offset (default: 0)",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "ignore_unavailable",
            "description": "If `false`, the request returns an error if it targets a missing or closed index.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "lenient",
            "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "max_docs",
            "description": "Maximum number of documents to process.\nDefaults to all documents.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "pipeline",
            "description": "ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "preference",
            "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
            "deprecated": false,
            "schema": {
              "type": "string"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "refresh",
            "description": "If `true`, Elasticsearch refreshes affected shards to make the operation visible to search.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "request_cache",
            "description": "If `true`, the request cache is used for this request.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "requests_per_second",
            "description": "The throttle for this request in sub-requests per second.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "routing",
            "description": "Custom value used to route operations to a specific shard.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Routing"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll",
            "description": "Period to retain the search context for scrolling.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "scroll_size",
            "description": "Size of the scroll request that powers the operation.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_timeout",
            "description": "Explicit timeout for each search request.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "search_type",
            "description": "The type of the search operation. Available options: `query_then_fetch`, `dfs_query_then_fetch`.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:SearchType"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "slices",
            "description": "The number of slices this task should be divided into.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Slices"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "sort",
            "description": "A comma-separated list of <field>:<direction> pairs.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "stats",
            "description": "Specific `tag` of the request for logging and statistical purposes.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "terminate_after",
            "description": "Maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\nUse with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.",
            "deprecated": false,
            "schema": {
              "type": "number"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "timeout",
            "description": "Period each update request waits for the following operations: dynamic mapping updates, waiting for active shards.",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:Duration"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version",
            "description": "If `true`, returns the document version as part of a hit.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "version_type",
            "description": "Should the document increment the version number (internal) on hit or not (reindex)",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_active_shards",
            "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
            "deprecated": false,
            "schema": {
              "$ref": "#/components/schemas/_types:WaitForActiveShards"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "wait_for_completion",
            "description": "If `true`, the request blocks until the operation is complete.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "requestBody": {
          "content": {
            "application/json": {
              "schema": {
                "type": "object",
                "properties": {
                  "max_docs": {
                    "description": "The maximum number of documents to update.",
                    "type": "number"
                  },
                  "query": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  "script": {
                    "$ref": "#/components/schemas/_types:Script"
                  },
                  "slice": {
                    "$ref": "#/components/schemas/_types:SlicedScroll"
                  },
                  "conflicts": {
                    "$ref": "#/components/schemas/_types:Conflicts"
                  }
                }
              }
            }
          }
        },
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "batches": {
                      "type": "number"
                    },
                    "failures": {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:BulkIndexByScrollFailure"
                      }
                    },
                    "noops": {
                      "type": "number"
                    },
                    "deleted": {
                      "type": "number"
                    },
                    "requests_per_second": {
                      "type": "number"
                    },
                    "retries": {
                      "$ref": "#/components/schemas/_types:Retries"
                    },
                    "task": {
                      "$ref": "#/components/schemas/_types:TaskId"
                    },
                    "timed_out": {
                      "type": "boolean"
                    },
                    "took": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "total": {
                      "type": "number"
                    },
                    "updated": {
                      "type": "number"
                    },
                    "version_conflicts": {
                      "type": "number"
                    },
                    "throttled": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    },
                    "throttled_until": {
                      "$ref": "#/components/schemas/_types:Duration"
                    },
                    "throttled_until_millis": {
                      "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/_xpack": {
      "get": {
        "description": "Retrieves information about the installed X-Pack features.",
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/info-api.html"
        },
        "operationId": "xpack.info#0",
        "parameters": [
          {
            "in": "query",
            "name": "categories",
            "description": "A comma-separated list of the information categories to include in the response. For example, `build,license,features`.",
            "deprecated": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "accept_enterprise",
            "description": "If this param is used it must be set to true",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          },
          {
            "in": "query",
            "name": "human",
            "description": "Defines whether additional human-readable information is included in the response. In particular, it adds descriptions and a tag line.",
            "deprecated": false,
            "schema": {
              "type": "boolean"
            },
            "style": "form"
          }
        ],
        "responses": {
          "200": {
            "description": "",
            "content": {
              "application/json": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "build": {
                      "$ref": "#/components/schemas/xpack.info:BuildInformation"
                    },
                    "features": {
                      "$ref": "#/components/schemas/xpack.info:Features"
                    },
                    "license": {
                      "$ref": "#/components/schemas/xpack.info:MinimalLicenseInformation"
                    },
                    "tagline": {
                      "type": "string"
                    }
                  },
                  "required": [
                    "build",
                    "features",
                    "license",
                    "tagline"
                  ]
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "responses": {
      "async_search.submit#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/async_search._types:AsyncSearchDocumentResponseBase"
            }
          }
        }
      },
      "bulk#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "errors": {
                  "type": "boolean"
                },
                "items": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_global.bulk:ResponseItem"
                    },
                    "minProperties": 1,
                    "maxProperties": 1
                  }
                },
                "took": {
                  "type": "number"
                },
                "ingest_took": {
                  "type": "number"
                }
              },
              "required": [
                "errors",
                "items",
                "took"
              ]
            }
          }
        }
      },
      "cat.aliases#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.aliases:AliasesRecord"
              }
            }
          }
        }
      },
      "cat.allocation#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.allocation:AllocationRecord"
              }
            }
          }
        }
      },
      "cat.component_templates#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.component_templates:ComponentTemplate"
              }
            }
          }
        }
      },
      "cat.count#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.count:CountRecord"
              }
            }
          }
        }
      },
      "cat.fielddata#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.fielddata:FielddataRecord"
              }
            }
          }
        }
      },
      "cat.indices#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.indices:IndicesRecord"
              }
            }
          }
        }
      },
      "cat.ml_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_data_frame_analytics:DataFrameAnalyticsRecord"
              }
            }
          }
        }
      },
      "cat.ml_datafeeds#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_datafeeds:DatafeedsRecord"
              }
            }
          }
        }
      },
      "cat.ml_jobs#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_jobs:JobsRecord"
              }
            }
          }
        }
      },
      "cat.ml_trained_models#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.ml_trained_models:TrainedModelsRecord"
              }
            }
          }
        }
      },
      "cat.segments#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.segments:SegmentsRecord"
              }
            }
          }
        }
      },
      "cat.shards#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.shards:ShardsRecord"
              }
            }
          }
        }
      },
      "cat.snapshots#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.snapshots:SnapshotsRecord"
              }
            }
          }
        }
      },
      "cat.templates#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.templates:TemplatesRecord"
              }
            }
          }
        }
      },
      "cat.thread_pool#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.thread_pool:ThreadPoolRecord"
              }
            }
          }
        }
      },
      "cat.transforms#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/cat.transforms:TransformsRecord"
              }
            }
          }
        }
      },
      "clear_scroll#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "succeeded": {
                  "type": "boolean"
                },
                "num_freed": {
                  "type": "number"
                }
              },
              "required": [
                "succeeded",
                "num_freed"
              ]
            }
          }
        }
      },
      "cluster.allocation_explain#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allocate_explanation": {
                  "type": "string"
                },
                "allocation_delay": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "allocation_delay_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "can_allocate": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_move_to_other_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_rebalance_cluster": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_rebalance_cluster_decisions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.allocation_explain:AllocationDecision"
                  }
                },
                "can_rebalance_to_other_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "can_remain_decisions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.allocation_explain:AllocationDecision"
                  }
                },
                "can_remain_on_current_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
                },
                "cluster_info": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:ClusterInfo"
                },
                "configured_delay": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "configured_delay_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "current_node": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:CurrentNode"
                },
                "current_state": {
                  "type": "string"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "move_explanation": {
                  "type": "string"
                },
                "node_allocation_decisions": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster.allocation_explain:NodeAllocationExplanation"
                  }
                },
                "primary": {
                  "type": "boolean"
                },
                "rebalance_explanation": {
                  "type": "string"
                },
                "remaining_delay": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "remaining_delay_in_millis": {
                  "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
                },
                "shard": {
                  "type": "number"
                },
                "unassigned_info": {
                  "$ref": "#/components/schemas/cluster.allocation_explain:UnassignedInformation"
                },
                "note": {
                  "type": "string"
                }
              },
              "required": [
                "current_state",
                "index",
                "primary",
                "shard"
              ]
            }
          }
        }
      },
      "cluster.get_component_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "component_templates": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/cluster._types:ComponentTemplate"
                  }
                }
              },
              "required": [
                "component_templates"
              ]
            }
          }
        }
      },
      "cluster.health#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/cluster.health:HealthResponseBody"
            }
          }
        }
      },
      "cluster.put_component_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "cluster.state#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        }
      },
      "cluster.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/cluster.stats:StatsResponseBase"
            }
          }
        }
      },
      "count#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                }
              },
              "required": [
                "count",
                "_shards"
              ]
            }
          }
        }
      },
      "create#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:WriteResponseBase"
            }
          }
        }
      },
      "enrich.get_policy#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "policies": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/enrich._types:Summary"
                  }
                }
              },
              "required": [
                "policies"
              ]
            }
          }
        }
      },
      "field_caps#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "indices": {
                  "$ref": "#/components/schemas/_types:Indices"
                },
                "fields": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object",
                    "additionalProperties": {
                      "$ref": "#/components/schemas/_global.field_caps:FieldCapability"
                    }
                  }
                }
              },
              "required": [
                "indices",
                "fields"
              ]
            }
          }
        }
      },
      "fleet.msearch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.msearch:ResponseItem"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "fleet.search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "took": {
                  "type": "number"
                },
                "timed_out": {
                  "type": "boolean"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "hits": {
                  "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
                },
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:Aggregate"
                  }
                },
                "_clusters": {
                  "$ref": "#/components/schemas/_types:ClusterStatistics"
                },
                "fields": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "max_score": {
                  "type": "number"
                },
                "num_reduce_phases": {
                  "type": "number"
                },
                "profile": {
                  "$ref": "#/components/schemas/_global.search._types:Profile"
                },
                "pit_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollId"
                },
                "suggest": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:Suggest"
                    }
                  }
                },
                "terminated_early": {
                  "type": "boolean"
                }
              },
              "required": [
                "took",
                "timed_out",
                "_shards",
                "hits"
              ]
            }
          }
        }
      },
      "graph.explore#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/graph._types:Connection"
                  }
                },
                "failures": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:ShardFailure"
                  }
                },
                "timed_out": {
                  "type": "boolean"
                },
                "took": {
                  "type": "number"
                },
                "vertices": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/graph._types:Vertex"
                  }
                }
              },
              "required": [
                "connections",
                "failures",
                "timed_out",
                "took",
                "vertices"
              ]
            }
          }
        }
      },
      "index#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:WriteResponseBase"
            }
          }
        }
      },
      "indices.analyze#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "detail": {
                  "$ref": "#/components/schemas/indices.analyze:AnalyzeDetail"
                },
                "tokens": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.analyze:AnalyzeToken"
                  }
                }
              }
            }
          }
        }
      },
      "indices.data_streams_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "backing_indices": {
                  "description": "Total number of backing indices for the selected data streams.",
                  "type": "number"
                },
                "data_stream_count": {
                  "description": "Total number of selected data streams.",
                  "type": "number"
                },
                "data_streams": {
                  "description": "Contains statistics for the selected data streams.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.data_streams_stats:DataStreamsStatsItem"
                  }
                },
                "total_store_sizes": {
                  "$ref": "#/components/schemas/_types:ByteSize"
                },
                "total_store_size_bytes": {
                  "description": "Total size, in bytes, of all shards for the selected data streams.",
                  "type": "number"
                }
              },
              "required": [
                "_shards",
                "backing_indices",
                "data_stream_count",
                "data_streams",
                "total_store_size_bytes"
              ]
            }
          }
        }
      },
      "indices.delete_alias#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.exists_alias#200": {
        "description": "",
        "content": {
          "application/json": {}
        }
      },
      "indices.get_alias#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.get_alias:IndexAliases"
              }
            }
          }
        }
      },
      "indices.get_data_stream#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "data_streams": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices._types:DataStream"
                  }
                }
              },
              "required": [
                "data_streams"
              ]
            }
          }
        }
      },
      "indices.get_index_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "index_templates": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.get_index_template:IndexTemplateItem"
                  }
                }
              },
              "required": [
                "index_templates"
              ]
            }
          }
        }
      },
      "indices.get_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.get_mapping:IndexMappingRecord"
              }
            }
          }
        }
      },
      "indices.get_settings#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices._types:IndexState"
              }
            }
          }
        }
      },
      "indices.get_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices._types:TemplateMapping"
              }
            }
          }
        }
      },
      "indices.put_alias#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.put_index_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.put_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:IndicesResponseBase"
            }
          }
        }
      },
      "indices.put_settings#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.put_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "indices.recovery#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/indices.recovery:RecoveryStatus"
              }
            }
          }
        }
      },
      "indices.rollover#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "acknowledged": {
                  "type": "boolean"
                },
                "conditions": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "boolean"
                  }
                },
                "dry_run": {
                  "type": "boolean"
                },
                "new_index": {
                  "type": "string"
                },
                "old_index": {
                  "type": "string"
                },
                "rolled_over": {
                  "type": "boolean"
                },
                "shards_acknowledged": {
                  "type": "boolean"
                }
              },
              "required": [
                "acknowledged",
                "conditions",
                "dry_run",
                "new_index",
                "old_index",
                "rolled_over",
                "shards_acknowledged"
              ]
            }
          }
        }
      },
      "indices.simulate_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "overlapping": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.simulate_template:Overlapping"
                  }
                },
                "template": {
                  "$ref": "#/components/schemas/indices.simulate_template:Template"
                }
              },
              "required": [
                "template"
              ]
            }
          }
        }
      },
      "indices.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "indices": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices.stats:IndicesStats"
                  }
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "_all": {
                  "$ref": "#/components/schemas/indices.stats:IndicesStats"
                }
              },
              "required": [
                "_shards",
                "_all"
              ]
            }
          }
        }
      },
      "indices.validate_query#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "explanations": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/indices.validate_query:IndicesValidationExplanation"
                  }
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "valid": {
                  "type": "boolean"
                },
                "error": {
                  "type": "string"
                }
              },
              "required": [
                "valid"
              ]
            }
          }
        }
      },
      "ingest.get_pipeline#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/ingest._types:Pipeline"
              }
            }
          }
        }
      },
      "ingest.simulate#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest.simulate:PipelineSimulation"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "logstash.get_pipeline#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/logstash._types:Pipeline"
              }
            }
          }
        }
      },
      "mget#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mget:ResponseItem"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "ml.delete_expired_data#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "deleted": {
                  "type": "boolean"
                }
              },
              "required": [
                "deleted"
              ]
            }
          }
        }
      },
      "ml.delete_forecast#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "ml.explain_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "field_selection": {
                  "description": "An array of objects that explain selection for each field, sorted by the field names.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsFieldSelection"
                  }
                },
                "memory_estimation": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalyticsMemoryEstimation"
                }
              },
              "required": [
                "field_selection",
                "memory_estimation"
              ]
            }
          }
        }
      },
      "ml.get_buckets#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "buckets": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:BucketSummary"
                  }
                },
                "count": {
                  "type": "number"
                }
              },
              "required": [
                "buckets",
                "count"
              ]
            }
          }
        }
      },
      "ml.get_calendars#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "calendars": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml.get_calendars:Calendar"
                  }
                },
                "count": {
                  "type": "number"
                }
              },
              "required": [
                "calendars",
                "count"
              ]
            }
          }
        }
      },
      "ml.get_categories#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "categories": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Category"
                  }
                },
                "count": {
                  "type": "number"
                }
              },
              "required": [
                "categories",
                "count"
              ]
            }
          }
        }
      },
      "ml.get_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "data_frame_analytics": {
                  "description": "An array of data frame analytics job resources, which are sorted by the id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSummary"
                  }
                }
              },
              "required": [
                "count",
                "data_frame_analytics"
              ]
            }
          }
        }
      },
      "ml.get_data_frame_analytics_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "data_frame_analytics": {
                  "description": "An array of objects that contain usage information for data frame analytics jobs, which are sorted by the id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DataframeAnalytics"
                  }
                }
              },
              "required": [
                "count",
                "data_frame_analytics"
              ]
            }
          }
        }
      },
      "ml.get_datafeed_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "datafeeds": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:DatafeedStats"
                  }
                }
              },
              "required": [
                "count",
                "datafeeds"
              ]
            }
          }
        }
      },
      "ml.get_datafeeds#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "datafeeds": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Datafeed"
                  }
                }
              },
              "required": [
                "count",
                "datafeeds"
              ]
            }
          }
        }
      },
      "ml.get_filters#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "filters": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Filter"
                  }
                }
              },
              "required": [
                "count",
                "filters"
              ]
            }
          }
        }
      },
      "ml.get_influencers#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "influencers": {
                  "description": "Array of influencer objects",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Influencer"
                  }
                }
              },
              "required": [
                "count",
                "influencers"
              ]
            }
          }
        }
      },
      "ml.get_job_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "jobs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:JobStats"
                  }
                }
              },
              "required": [
                "count",
                "jobs"
              ]
            }
          }
        }
      },
      "ml.get_jobs#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "jobs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Job"
                  }
                }
              },
              "required": [
                "count",
                "jobs"
              ]
            }
          }
        }
      },
      "ml.get_memory_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_nodes": {
                  "$ref": "#/components/schemas/_types:NodeStatistics"
                },
                "cluster_name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "nodes": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/ml.get_memory_stats:Memory"
                  }
                }
              },
              "required": [
                "_nodes",
                "cluster_name",
                "nodes"
              ]
            }
          }
        }
      },
      "ml.get_model_snapshots#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "model_snapshots": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:ModelSnapshot"
                  }
                }
              },
              "required": [
                "count",
                "model_snapshots"
              ]
            }
          }
        }
      },
      "ml.get_overall_buckets#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "overall_buckets": {
                  "description": "Array of overall bucket objects",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:OverallBucket"
                  }
                }
              },
              "required": [
                "count",
                "overall_buckets"
              ]
            }
          }
        }
      },
      "ml.get_records#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "records": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:Anomaly"
                  }
                }
              },
              "required": [
                "count",
                "records"
              ]
            }
          }
        }
      },
      "ml.get_trained_models#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "trained_model_configs": {
                  "description": "An array of trained model resources, which are sorted by the model_id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelConfig"
                  }
                }
              },
              "required": [
                "count",
                "trained_model_configs"
              ]
            }
          }
        }
      },
      "ml.get_trained_models_stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "description": "The total number of trained model statistics that matched the requested ID patterns. Could be higher than the number of items in the trained_model_stats array as the size of the array is restricted by the supplied size parameter.",
                  "type": "number"
                },
                "trained_model_stats": {
                  "description": "An array of trained model statistics, which are sorted by the model_id value in ascending order.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:TrainedModelStats"
                  }
                }
              },
              "required": [
                "count",
                "trained_model_stats"
              ]
            }
          }
        }
      },
      "ml.infer_trained_model#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "inference_results": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ml._types:InferenceResponseResult"
                  }
                }
              },
              "required": [
                "inference_results"
              ]
            }
          }
        }
      },
      "ml.preview_data_frame_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "feature_values": {
                  "description": "An array of objects that contain feature name and value pairs. The features have been processed and indicate what will be sent to the model for training.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "string"
                    }
                  }
                }
              },
              "required": [
                "feature_values"
              ]
            }
          }
        }
      },
      "ml.preview_datafeed#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "type": "object"
              }
            }
          }
        }
      },
      "msearch#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.msearch:MultiSearchResult"
            }
          }
        }
      },
      "msearch_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.msearch:MultiSearchResult"
            }
          }
        }
      },
      "mtermvectors#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mtermvectors:TermVectorsResult"
                  }
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        }
      },
      "nodes.hot_threads#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "hot_threads": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/nodes.hot_threads:HotThread"
                  }
                }
              },
              "required": [
                "hot_threads"
              ]
            }
          }
        }
      },
      "nodes.info#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.info:ResponseBase"
            }
          }
        }
      },
      "nodes.stats#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.stats:ResponseBase"
            }
          }
        }
      },
      "nodes.usage#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/nodes.usage:ResponseBase"
            }
          }
        }
      },
      "put_script#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "rank_eval#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "metric_score": {
                  "description": "The overall evaluation quality calculated by the defined metric",
                  "type": "number"
                },
                "details": {
                  "description": "The details section contains one entry for every query in the original requests section, keyed by the search request id",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricDetail"
                  }
                },
                "failures": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "metric_score",
                "details",
                "failures"
              ]
            }
          }
        }
      },
      "render_search_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "template_output": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "template_output"
              ]
            }
          }
        }
      },
      "scripts_painless_execute#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "result": {
                  "type": "object"
                }
              },
              "required": [
                "result"
              ]
            }
          }
        }
      },
      "scroll#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.search:ResponseBody"
            }
          }
        }
      },
      "search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.search:ResponseBody"
            }
          }
        }
      },
      "search_application.get_behavioral_analytics#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/search_application._types:AnalyticsCollection"
              }
            }
          }
        }
      },
      "search_application.search#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_global.search:ResponseBody"
            }
          }
        }
      },
      "search_mvt#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:MapboxVectorTiles"
            }
          }
        }
      },
      "search_template#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "took": {
                  "type": "number"
                },
                "timed_out": {
                  "type": "boolean"
                },
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "hits": {
                  "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
                },
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:Aggregate"
                  }
                },
                "_clusters": {
                  "$ref": "#/components/schemas/_types:ClusterStatistics"
                },
                "fields": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "max_score": {
                  "type": "number"
                },
                "num_reduce_phases": {
                  "type": "number"
                },
                "profile": {
                  "$ref": "#/components/schemas/_global.search._types:Profile"
                },
                "pit_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollId"
                },
                "suggest": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:Suggest"
                    }
                  }
                },
                "terminated_early": {
                  "type": "boolean"
                }
              },
              "required": [
                "took",
                "timed_out",
                "_shards",
                "hits"
              ]
            }
          }
        }
      },
      "security.create_api_key#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "api_key": {
                  "description": "Generated API key.",
                  "type": "string"
                },
                "expiration": {
                  "description": "Expiration in milliseconds for the API key.",
                  "type": "number"
                },
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "encoded": {
                  "description": "API key credentials which is the base64-encoding of\nthe UTF-8 representation of `id` and `api_key` joined\nby a colon (`:`).",
                  "type": "string"
                }
              },
              "required": [
                "api_key",
                "id",
                "name",
                "encoded"
              ]
            }
          }
        }
      },
      "security.create_service_token#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "created": {
                  "type": "boolean"
                },
                "token": {
                  "$ref": "#/components/schemas/security.create_service_token:Token"
                }
              },
              "required": [
                "created",
                "token"
              ]
            }
          }
        }
      },
      "security.disable_user_profile#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "security.enable_user_profile#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "security.get_privileges#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security.put_privileges:Actions"
                }
              }
            }
          }
        }
      },
      "security.get_role#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security.get_role:Role"
              }
            }
          }
        }
      },
      "security.get_role_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security._types:RoleMapping"
              }
            }
          }
        }
      },
      "security.get_service_accounts#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security.get_service_accounts:RoleDescriptorWrapper"
              }
            }
          }
        }
      },
      "security.has_privileges#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "application": {
                  "$ref": "#/components/schemas/security.has_privileges:ApplicationsPrivileges"
                },
                "cluster": {
                  "type": "object",
                  "additionalProperties": {
                    "type": "boolean"
                  }
                },
                "has_all_requested": {
                  "type": "boolean"
                },
                "index": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security.has_privileges:Privileges"
                  }
                },
                "username": {
                  "$ref": "#/components/schemas/_types:Username"
                }
              },
              "required": [
                "application",
                "cluster",
                "has_all_requested",
                "index",
                "username"
              ]
            }
          }
        }
      },
      "security.has_privileges_user_profile#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "has_privilege_uids": {
                  "description": "The subset of the requested profile IDs of the users that\nhave all the requested privileges.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfileId"
                  }
                },
                "errors": {
                  "$ref": "#/components/schemas/security.has_privileges_user_profile:HasPrivilegesUserProfileErrors"
                }
              },
              "required": [
                "has_privilege_uids"
              ]
            }
          }
        }
      },
      "security.put_privileges#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security._types:CreatedStatus"
                }
              }
            }
          }
        }
      },
      "security.put_role#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "role": {
                  "$ref": "#/components/schemas/security._types:CreatedStatus"
                }
              },
              "required": [
                "role"
              ]
            }
          }
        }
      },
      "security.put_role_mapping#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "created": {
                  "type": "boolean"
                },
                "role_mapping": {
                  "$ref": "#/components/schemas/security._types:CreatedStatus"
                }
              },
              "required": [
                "role_mapping"
              ]
            }
          }
        }
      },
      "security.query_api_keys#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "description": "The total number of API keys found.",
                  "type": "number"
                },
                "count": {
                  "description": "The number of API keys returned in the response.",
                  "type": "number"
                },
                "api_keys": {
                  "description": "A list of API key information.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ApiKey"
                  }
                }
              },
              "required": [
                "total",
                "count",
                "api_keys"
              ]
            }
          }
        }
      },
      "security.suggest_user_profiles#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "total": {
                  "$ref": "#/components/schemas/security.suggest_user_profiles:TotalUserProfiles"
                },
                "took": {
                  "type": "number"
                },
                "profiles": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfile"
                  }
                }
              },
              "required": [
                "total",
                "took",
                "profiles"
              ]
            }
          }
        }
      },
      "security.update_user_profile_data#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
            }
          }
        }
      },
      "terms_enum#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "_shards": {
                  "$ref": "#/components/schemas/_types:ShardStatistics"
                },
                "terms": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "complete": {
                  "type": "boolean"
                }
              },
              "required": [
                "_shards",
                "terms",
                "complete"
              ]
            }
          }
        }
      },
      "termvectors#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "found": {
                  "type": "boolean"
                },
                "_id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "_index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "term_vectors": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_global.termvectors:TermVector"
                  }
                },
                "took": {
                  "type": "number"
                },
                "_version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                }
              },
              "required": [
                "found",
                "_id",
                "_index",
                "took",
                "_version"
              ]
            }
          }
        }
      },
      "transform.get_transform#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "count": {
                  "type": "number"
                },
                "transforms": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/transform.get_transform:TransformSummary"
                  }
                }
              },
              "required": [
                "count",
                "transforms"
              ]
            }
          }
        }
      },
      "transform.preview_transform#200": {
        "description": "",
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "generated_dest_index": {
                  "$ref": "#/components/schemas/indices._types:IndexState"
                },
                "preview": {
                  "type": "array",
                  "items": {
                    "type": "object"
                  }
                }
              },
              "required": [
                "generated_dest_index",
                "preview"
              ]
            }
          }
        }
      }
    },
    "parameters": {
      "async_search.submit#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names to search; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "async_search.submit#wait_for_completion_timeout": {
        "in": "query",
        "name": "wait_for_completion_timeout",
        "description": "Blocks and waits until the search is completed up to a certain timeout.\nWhen the async search completes within the timeout, the response wont include the ID as the results are not stored in the cluster.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#keep_on_completion": {
        "in": "query",
        "name": "keep_on_completion",
        "description": "If `true`, results are stored for later retrieval when the search completes within the `wait_for_completion_timeout`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#keep_alive": {
        "in": "query",
        "name": "keep_alive",
        "description": "Specifies how long the async search needs to be available.\nOngoing async searches and any saved search results are deleted after this period.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "Indicate if an error should be returned if there is a partial search failure or timeout",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "The analyzer to use for the query string",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "Specify whether wildcard and prefix queries should be analyzed (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#batched_reduce_size": {
        "in": "query",
        "name": "batched_reduce_size",
        "description": "Affects how often partial results become available, which happens whenever shard results are reduced.\nA partial reduction is performed every time the coordinating node has received a certain number of new shard responses (5 by default).",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "The default value is the only supported value.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query (AND or OR)",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "async_search.submit#df": {
        "in": "query",
        "name": "df",
        "description": "The field to use as default where no field prefix is given in the query string",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#docvalue_fields": {
        "in": "query",
        "name": "docvalue_fields",
        "description": "A comma-separated list of fields to return as the docvalue representation of a field for each hit",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "async_search.submit#explain": {
        "in": "query",
        "name": "explain",
        "description": "Specify whether to return detailed information about score computation as part of a hit",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "Whether specified concrete, expanded or aliased indices should be ignored when throttled",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "Specify whether format-based query failures (such as providing text to a numeric field) should be ignored",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "The number of concurrent shard requests per node this search executes concurrently. This value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#min_compatible_shard_node": {
        "in": "query",
        "name": "min_compatible_shard_node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionString"
        },
        "style": "form"
      },
      "async_search.submit#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specify the node or shard the operation should be performed on (default: random)",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "The default value cannot be changed, which enforces the execution of a pre-filter roundtrip to retrieve statistics from each shard so that the ones that surely dont hold any document matching the query get skipped.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#request_cache": {
        "in": "query",
        "name": "request_cache",
        "description": "Specify if request cache should be used for this request or not, defaults to true",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#routing": {
        "in": "query",
        "name": "routing",
        "description": "A comma-separated list of specific routing values",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "async_search.submit#scroll": {
        "in": "query",
        "name": "scroll",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Search operation type",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "async_search.submit#stats": {
        "in": "query",
        "name": "stats",
        "description": "Specific 'tag' of the request for logging and statistical purposes",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "async_search.submit#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "A comma-separated list of stored fields to return as part of a hit",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#suggest_field": {
        "in": "query",
        "name": "suggest_field",
        "description": "Specifies which field to use for suggestions.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "async_search.submit#suggest_mode": {
        "in": "query",
        "name": "suggest_mode",
        "description": "Specify suggest mode",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SuggestMode"
        },
        "style": "form"
      },
      "async_search.submit#suggest_size": {
        "in": "query",
        "name": "suggest_size",
        "description": "How many suggestions to return in response",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#suggest_text": {
        "in": "query",
        "name": "suggest_text",
        "description": "The source text for which the suggestions should be returned.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "description": "The maximum number of documents to collect for each shard, upon reaching which the query execution will terminate early.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Explicit operation timeout",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "async_search.submit#track_total_hits": {
        "in": "query",
        "name": "track_total_hits",
        "description": "Indicate if the number of documents that match the query should be tracked. A number can also be specified, to accurately track the total hit count up to the number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:TrackHits"
        },
        "style": "form"
      },
      "async_search.submit#track_scores": {
        "in": "query",
        "name": "track_scores",
        "description": "Whether to calculate and return scores even if they are not used for sorting",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specify whether aggregation and suggester names should be prefixed by their respective types in the response",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#version": {
        "in": "query",
        "name": "version",
        "description": "Specify whether to return document version as part of a hit",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#_source": {
        "in": "query",
        "name": "_source",
        "description": "True or false to return the _source field or not, or a list of fields to return",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "async_search.submit#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A list of fields to exclude from the returned _source field",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A list of fields to extract and return from the _source field",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "async_search.submit#seq_no_primary_term": {
        "in": "query",
        "name": "seq_no_primary_term",
        "description": "Specify whether to return sequence number and primary term of the last modification of each hit",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "async_search.submit#q": {
        "in": "query",
        "name": "q",
        "description": "Query in the Lucene query string syntax",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "async_search.submit#size": {
        "in": "query",
        "name": "size",
        "description": "Number of hits to return (default: 10)",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#from": {
        "in": "query",
        "name": "from",
        "description": "Starting offset (default: 0)",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "async_search.submit#sort": {
        "in": "query",
        "name": "sort",
        "description": "A comma-separated list of <field>:<direction> pairs",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "bulk#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the data stream, index, or index alias to perform bulk actions on.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "bulk#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "bulk#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` do nothing with refreshes.\nValid values: `true`, `false`, `wait_for`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "bulk#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "bulk#_source": {
        "in": "query",
        "name": "_source",
        "description": "`true` or `false` to return the `_source` field or not, or a list of fields to return.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "bulk#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "bulk#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "bulk#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period each action waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "bulk#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "bulk#require_alias": {
        "in": "query",
        "name": "require_alias",
        "description": "If `true`, the requests actions must target an index alias.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.aliases#name": {
        "in": "path",
        "name": "name",
        "description": "A comma-separated list of aliases to retrieve. Supports wildcards (`*`).  To retrieve all aliases, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "cat.aliases#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cat.allocation#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node identifiers or names used to limit the returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "cat.allocation#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.component_templates#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the component template. Accepts wildcard expressions. If omitted, all component templates are returned.",
        "required": true,
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "simple"
      },
      "cat.count#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`). To target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.fielddata#fields": {
        "in": "path",
        "name": "fields",
        "description": "Comma-separated list of fields used to limit returned information.\nTo retrieve all fields, omit this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "simple"
      },
      "cat.fielddata#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.fielddata#fields_": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list of fields used to limit returned information.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "cat.indices#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`). To target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.indices#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.indices#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "The type of index that wildcard patterns can match.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cat.indices#health": {
        "in": "query",
        "name": "health",
        "description": "The health status used to limit returned indices. By default, the response includes indices of any health status.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:HealthStatus"
        },
        "style": "form"
      },
      "cat.indices#include_unloaded_segments": {
        "in": "query",
        "name": "include_unloaded_segments",
        "description": "If true, the response includes information from segments that are not loaded into memory.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.indices#pri": {
        "in": "query",
        "name": "pri",
        "description": "If true, the response only includes information from primary shards.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.indices#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "The ID of the data frame analytics to fetch",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_data_frame_analytics#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Whether to ignore if a wildcard expression matches no configs. (This includes `_all` string or when no configs have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit in which to display byte values",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDfaColumns"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the\nresponse.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDfaColumns"
        },
        "style": "form"
      },
      "cat.ml_data_frame_analytics#time": {
        "in": "query",
        "name": "time",
        "description": "Unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "A numerical character string that uniquely identifies the datafeed.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_datafeeds#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no datafeeds that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty datafeeds array when there are no matches and the subset of results when\nthere are partial matches. If `false`, the API returns a 404 status code when there are no matches or only\npartial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDatafeedColumns"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatDatafeedColumns"
        },
        "style": "form"
      },
      "cat.ml_datafeeds#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.ml_jobs#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_jobs#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n* Contains wildcard expressions and there are no jobs that match.\n* Contains the `_all` string or no identifiers and there are no matches.\n* Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty jobs array when there are no matches and the subset of results when there\nare partial matches. If `false`, the API returns a 404 status code when there are no matches or only partial\nmatches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_jobs#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.ml_jobs#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatAnonalyDetectorColumns"
        },
        "style": "form"
      },
      "cat.ml_jobs#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatAnonalyDetectorColumns"
        },
        "style": "form"
      },
      "cat.ml_jobs#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.ml_trained_models#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "A unique identifier for the trained model.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.ml_trained_models#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request: contains wildcard expressions and there are no models that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, the API returns an empty array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the API returns a 404 status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.ml_trained_models#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.ml_trained_models#h": {
        "in": "query",
        "name": "h",
        "description": "A comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumns"
        },
        "style": "form"
      },
      "cat.ml_trained_models#s": {
        "in": "query",
        "name": "s",
        "description": "A comma-separated list of column names or aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumns"
        },
        "style": "form"
      },
      "cat.ml_trained_models#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of transforms.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "cat.ml_trained_models#size": {
        "in": "query",
        "name": "size",
        "description": "The maximum number of transforms to display.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "cat.segments#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.segments#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.shards#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cat.shards#bytes": {
        "in": "query",
        "name": "bytes",
        "description": "The unit used to display byte values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Bytes"
        },
        "style": "form"
      },
      "cat.snapshots#repository": {
        "in": "path",
        "name": "repository",
        "description": "A comma-separated list of snapshot repositories used to limit the request.\nAccepts wildcard expressions.\n`_all` returns all repositories.\nIf any repository fails during the request, Elasticsearch returns an error.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "cat.snapshots#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, the response does not include information from unavailable snapshots.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.templates#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the template to return.\nAccepts wildcard expressions. If omitted, all templates are returned.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "cat.thread_pool#thread_pool_patterns": {
        "in": "path",
        "name": "thread_pool_patterns",
        "description": "A comma-separated list of thread pool names used to limit the request.\nAccepts wildcard expressions.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "cat.thread_pool#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.transforms#transform_id": {
        "in": "path",
        "name": "transform_id",
        "description": "A transform identifier or a wildcard expression.\nIf you do not specify one of these options, the API returns information for all transforms.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "cat.transforms#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request: contains wildcard expressions and there are no transforms that match; contains the `_all` string or no identifiers and there are no matches; contains wildcard expressions and there are only partial matches.\nIf `true`, it returns an empty transforms array when there are no matches and the subset of results when there are partial matches.\nIf `false`, the request returns a 404 status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cat.transforms#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of transforms.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "cat.transforms#h": {
        "in": "query",
        "name": "h",
        "description": "Comma-separated list of column names to display.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTransformColumns"
        },
        "style": "form"
      },
      "cat.transforms#s": {
        "in": "query",
        "name": "s",
        "description": "Comma-separated list of column names or column aliases used to sort the response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/cat._types:CatTransformColumns"
        },
        "style": "form"
      },
      "cat.transforms#time": {
        "in": "query",
        "name": "time",
        "description": "The unit used to display time values.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:TimeUnit"
        },
        "style": "form"
      },
      "cat.transforms#size": {
        "in": "query",
        "name": "size",
        "description": "The maximum number of transforms to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "clear_scroll#scroll_id": {
        "in": "path",
        "name": "scroll_id",
        "description": "Comma-separated list of scroll IDs to clear.\nTo clear all scroll IDs, use `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ScrollIds"
        },
        "style": "simple"
      },
      "cluster.allocation_explain#include_disk_info": {
        "in": "query",
        "name": "include_disk_info",
        "description": "If true, returns information about disk usage and shard sizes.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.allocation_explain#include_yes_decisions": {
        "in": "query",
        "name": "include_yes_decisions",
        "description": "If true, returns YES decisions in explanation.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of component template names used to limit the request.\nWildcard (`*`) expressions are supported.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "cluster.get_component_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "Return all default configurations for the component template (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.\nIf `false`, information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.get_component_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.health#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and index aliases used to limit the request. Wildcard expressions (*) are supported. To target all data streams and indices in a cluster, omit this parameter or use _all or *.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cluster.health#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cluster.health#level": {
        "in": "query",
        "name": "level",
        "description": "Can be one of cluster, indices or shards. Controls the details level of the health information returned.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Level"
        },
        "style": "form"
      },
      "cluster.health#local": {
        "in": "query",
        "name": "local",
        "description": "If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.health#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.health#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.health#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "A number controlling to how many active shards to wait for, all to wait for all shards in the cluster to be active, or 0 to not wait.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "cluster.health#wait_for_events": {
        "in": "query",
        "name": "wait_for_events",
        "description": "Can be one of immediate, urgent, high, normal, low, languid. Wait until all currently queued events with the given priority are processed.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForEvents"
        },
        "style": "form"
      },
      "cluster.health#wait_for_nodes": {
        "in": "query",
        "name": "wait_for_nodes",
        "description": "The request waits until the specified number N of nodes is available. It also accepts >=N, <=N, >N and <N. Alternatively, it is possible to use ge(N), le(N), gt(N) and lt(N) notation.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            }
          ]
        },
        "style": "form"
      },
      "cluster.health#wait_for_no_initializing_shards": {
        "in": "query",
        "name": "wait_for_no_initializing_shards",
        "description": "A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard initializations. Defaults to false, which means it will not wait for initializing shards.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.health#wait_for_no_relocating_shards": {
        "in": "query",
        "name": "wait_for_no_relocating_shards",
        "description": "A boolean value which controls whether to wait (until the timeout provided) for the cluster to have no shard relocations. Defaults to false, which means it will not wait for relocating shards.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.health#wait_for_status": {
        "in": "query",
        "name": "wait_for_status",
        "description": "One of green, yellow or red. Will wait (until the timeout provided) until the status of the cluster changes to the one provided or better, i.e. green > yellow > red. By default, will not wait for any status.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:HealthStatus"
        },
        "style": "form"
      },
      "cluster.put_component_template#name": {
        "in": "path",
        "name": "name",
        "description": "Name of the component template to create.\nElasticsearch includes the following built-in component templates: `logs-mappings`; 'logs-settings`; `metrics-mappings`; `metrics-settings`;`synthetics-mapping`; `synthetics-settings`.\nElastic Agent uses these templates to configure backing indices for its data streams.\nIf you use Elastic Agent and want to overwrite one of these templates, set the `version` for your replacement template higher than the current version.\nIf you dont use Elastic Agent and want to disable all built-in component and index templates, set `stack.templates.enabled` to `false` using the cluster update settings API.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "cluster.put_component_template#create": {
        "in": "query",
        "name": "create",
        "description": "If `true`, this request cannot replace or update existing component templates.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.put_component_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.state#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limit the information returned to the specified metrics",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "cluster.state#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "cluster.state#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "Whether to ignore if a wildcard indices expression resolves into no concrete indices. (This includes `_all` string or when no indices have been specified)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "cluster.state#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "Return settings in flat format (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "Whether specified concrete indices should be ignored when unavailable (missing or closed)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#local": {
        "in": "query",
        "name": "local",
        "description": "Return local information, do not retrieve the state from master node (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.state#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Specify timeout for connection to master",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.state#wait_for_metadata_version": {
        "in": "query",
        "name": "wait_for_metadata_version",
        "description": "Wait for the metadata version to be equal or greater than the specified metadata version",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "cluster.state#wait_for_timeout": {
        "in": "query",
        "name": "wait_for_timeout",
        "description": "The maximum time to wait for wait_for_metadata_version before timing out",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "cluster.stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node filters used to limit returned information. Defaults to all nodes in the cluster.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "cluster.stats#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "cluster.stats#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for each node to respond.\nIf a node does not respond before its timeout expires, the response does not include its stats.\nHowever, timed out nodes are included in the responses `_nodes.failed` property. Defaults to no timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "count#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "count#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "count#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If `true`, wildcard and prefix queries are analyzed.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query: `AND` or `OR`.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "count#df": {
        "in": "query",
        "name": "df",
        "description": "Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "count#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "count#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If `true`, concrete, expanded or aliased indices are ignored when frozen.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "count#min_score": {
        "in": "query",
        "name": "min_score",
        "description": "Sets the minimum `_score` value that documents must have to be included in the result.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "count#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "count#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "count#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "description": "Maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "count#q": {
        "in": "query",
        "name": "q",
        "description": "Query in the Lucene query string syntax.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "create#id": {
        "in": "path",
        "name": "id",
        "description": "Unique identifier for the document.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "create#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the data stream or index to target.\nIf the target doesnt exist and matches the name or wildcard (`*`) pattern of an index template with a `data_stream` definition, this request creates the data stream.\nIf the target doesnt exist and doesnt match a data stream template, this request creates the index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "create#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "create#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` do nothing with refreshes.\nValid values: `true`, `false`, `wait_for`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "create#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "create#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "create#version": {
        "in": "query",
        "name": "version",
        "description": "Explicit version number for concurrency control.\nThe specified version must match the current version of the document for the request to succeed.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "create#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "Specific version type: `external`, `external_gte`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "create#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to `all` or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "enrich.get_policy#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of enrich policy names used to limit the request.\nTo return information for all enrich policies, omit this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "field_caps#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request. Supports wildcards (*). To target all data streams and indices, omit this parameter or use * or _all.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "field_caps#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias,\nor `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request\ntargeting `foo*,bar*` returns an error if an index starts with foo but no index starts with bar.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "field_caps#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams. Supports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "field_caps#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list of fields to retrieve capabilities for. Wildcard (`*`) expressions are supported.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "field_caps#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "field_caps#include_unmapped": {
        "in": "query",
        "name": "include_unmapped",
        "description": "If true, unmapped fields are included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "field_caps#filters": {
        "in": "query",
        "name": "filters",
        "description": "An optional set of filters: can include +metadata,-metadata,-nested,-multifield,-parent",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "field_caps#types": {
        "in": "query",
        "name": "types",
        "description": "Only return results for fields that have one of the types in the list",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "fleet.msearch#index": {
        "in": "path",
        "name": "index",
        "description": "A single target to search. If the target is an index alias, it must resolve to a single index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            {
              "$ref": "#/components/schemas/_types:IndexAlias"
            }
          ]
        },
        "style": "simple"
      },
      "fleet.msearch#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "fleet.msearch#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If true, concrete, expanded or aliased indices are ignored when frozen.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If true, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#max_concurrent_searches": {
        "in": "query",
        "name": "max_concurrent_searches",
        "description": "Maximum number of concurrent searches the multi search API can execute.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.msearch#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "Maximum number of concurrent shard requests that each sub-search request executes per node.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.msearch#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.msearch#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Indicates whether global term and document frequencies should be used when scoring returned documents.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "fleet.msearch#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.msearch#wait_for_checkpoints": {
        "in": "query",
        "name": "wait_for_checkpoints",
        "description": "A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/fleet._types:Checkpoint"
          }
        },
        "style": "form"
      },
      "fleet.msearch#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "If true, returns partial results if there are shard request timeouts or [shard failures](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#shard-failures). If false, returns\nan error with no partial results. Defaults to the configured cluster setting `search.default_allow_partial_results`\nwhich is true by default.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#index": {
        "in": "path",
        "name": "index",
        "description": "A single target to search. If the target is an index alias, it must resolve to a single index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "$ref": "#/components/schemas/_types:IndexName"
            },
            {
              "$ref": "#/components/schemas/_types:IndexAlias"
            }
          ]
        },
        "style": "simple"
      },
      "fleet.search#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#analyzer": {
        "in": "query",
        "name": "analyzer",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#batched_reduce_size": {
        "in": "query",
        "name": "batched_reduce_size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#default_operator": {
        "in": "query",
        "name": "default_operator",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "fleet.search#df": {
        "in": "query",
        "name": "df",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#docvalue_fields": {
        "in": "query",
        "name": "docvalue_fields",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "fleet.search#explain": {
        "in": "query",
        "name": "explain",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#lenient": {
        "in": "query",
        "name": "lenient",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#min_compatible_shard_node": {
        "in": "query",
        "name": "min_compatible_shard_node",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionString"
        },
        "style": "form"
      },
      "fleet.search#preference": {
        "in": "query",
        "name": "preference",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#request_cache": {
        "in": "query",
        "name": "request_cache",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#routing": {
        "in": "query",
        "name": "routing",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "fleet.search#scroll": {
        "in": "query",
        "name": "scroll",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "fleet.search#search_type": {
        "in": "query",
        "name": "search_type",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "fleet.search#stats": {
        "in": "query",
        "name": "stats",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "fleet.search#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#suggest_field": {
        "in": "query",
        "name": "suggest_field",
        "description": "Specifies which field to use for suggestions.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "fleet.search#suggest_mode": {
        "in": "query",
        "name": "suggest_mode",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SuggestMode"
        },
        "style": "form"
      },
      "fleet.search#suggest_size": {
        "in": "query",
        "name": "suggest_size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#suggest_text": {
        "in": "query",
        "name": "suggest_text",
        "description": "The source text for which the suggestions should be returned.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#timeout": {
        "in": "query",
        "name": "timeout",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "fleet.search#track_total_hits": {
        "in": "query",
        "name": "track_total_hits",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:TrackHits"
        },
        "style": "form"
      },
      "fleet.search#track_scores": {
        "in": "query",
        "name": "track_scores",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#version": {
        "in": "query",
        "name": "version",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#_source": {
        "in": "query",
        "name": "_source",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "fleet.search#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "fleet.search#seq_no_primary_term": {
        "in": "query",
        "name": "seq_no_primary_term",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "fleet.search#q": {
        "in": "query",
        "name": "q",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "fleet.search#size": {
        "in": "query",
        "name": "size",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#from": {
        "in": "query",
        "name": "from",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "fleet.search#sort": {
        "in": "query",
        "name": "sort",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "fleet.search#wait_for_checkpoints": {
        "in": "query",
        "name": "wait_for_checkpoints",
        "description": "A comma separated list of checkpoints. When configured, the search API will only be executed on a shard\nafter the relevant checkpoint has become visible for search. Defaults to an empty list which will cause\nElasticsearch to immediately execute the search.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/fleet._types:Checkpoint"
          }
        },
        "style": "form"
      },
      "fleet.search#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "If true, returns partial results if there are shard request timeouts or [shard failures](https://www.elastic.co/guide/en/elasticsearch/reference/current/docs-replication.html#shard-failures). If false, returns\nan error with no partial results. Defaults to the configured cluster setting `search.default_allow_partial_results`\nwhich is true by default.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "graph.explore#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "graph.explore#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "graph.explore#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Specifies the period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "index#id": {
        "in": "path",
        "name": "id",
        "description": "Unique identifier for the document.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "index#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the data stream or index to target.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "index#if_primary_term": {
        "in": "query",
        "name": "if_primary_term",
        "description": "Only perform the operation if the document has this primary term.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "index#if_seq_no": {
        "in": "query",
        "name": "if_seq_no",
        "description": "Only perform the operation if the document has this sequence number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SequenceNumber"
        },
        "style": "form"
      },
      "index#op_type": {
        "in": "query",
        "name": "op_type",
        "description": "Set to create to only index the document if it does not already exist (put if absent).\nIf a document with the specified `_id` already exists, the indexing operation will fail.\nSame as using the `<index>/_create` endpoint.\nValid values: `index`, `create`.\nIf document id is specified, it defaults to `index`.\nOtherwise, it defaults to `create`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:OpType"
        },
        "style": "form"
      },
      "index#pipeline": {
        "in": "query",
        "name": "pipeline",
        "description": "ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "index#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, Elasticsearch refreshes the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` do nothing with refreshes.\nValid values: `true`, `false`, `wait_for`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "index#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "index#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period the request waits for the following operations: automatic index creation, dynamic mapping updates, waiting for active shards.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "index#version": {
        "in": "query",
        "name": "version",
        "description": "Explicit version number for concurrency control.\nThe specified version must match the current version of the document for the request to succeed.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "index#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "Specific version type: `external`, `external_gte`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "index#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "index#require_alias": {
        "in": "query",
        "name": "require_alias",
        "description": "If `true`, the destination must be an index alias.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.analyze#index": {
        "in": "path",
        "name": "index",
        "description": "Index used to derive the analyzer.\nIf specified, the `analyzer` or field parameter overrides this value.\nIf no index is specified or the index does not have a default analyzer, the analyze API uses the standard analyzer.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.data_streams_stats#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of data streams used to limit the request.\nWildcard expressions (`*`) are supported.\nTo target all data streams in a cluster, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.data_streams_stats#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.delete_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices used to limit the request.\nSupports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.delete_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of aliases to remove.\nSupports wildcards (`*`). To remove all aliases, use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.delete_alias#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.delete_alias#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.exists_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of aliases to check. Supports wildcards (`*`).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.exists_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices used to limit the request. Supports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.exists_alias#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.exists_alias#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.exists_alias#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, requests that include a missing data stream or index in the target indices or data streams return an error.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.exists_alias#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of aliases to retrieve.\nSupports wildcards (`*`).\nTo retrieve all aliases, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.get_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_alias#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_alias#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_alias#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_alias#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_data_stream#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of data stream names used to limit the request.\nWildcard (`*`) expressions are supported. If omitted, all data streams are returned.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DataStreamNames"
        },
        "style": "simple"
      },
      "indices.get_data_stream#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of data stream that wildcard patterns can match.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_data_stream#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If true, returns all relevant default configurations for the index template.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_index_template#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of index template names used to limit the request. Wildcard (*) expressions are supported.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.get_index_template#local": {
        "in": "query",
        "name": "local",
        "description": "If true, the request retrieves information from the local node only. Defaults to false, which means information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_index_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If true, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_index_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_index_template#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If true, returns all relevant default configurations for the index template.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_mapping#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_mapping#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_mapping#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_settings#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit\nthe request. Supports wildcards (`*`). To target all data streams and\nindices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.get_settings#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list or wildcard expression of settings to retrieve.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.get_settings#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with foo but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.get_settings#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If `true`, return all default settings in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only. If\n`false`, information is retrieved from the master node.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_settings#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.get_template#name": {
        "in": "path",
        "name": "name",
        "description": "Comma-separated list of index template names used to limit the request.\nWildcard (`*`) expressions are supported.\nTo return all index templates, omit this parameter or use a value of `_all` or `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "indices.get_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_template#local": {
        "in": "query",
        "name": "local",
        "description": "If `true`, the request retrieves information from the local node only.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.get_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_alias#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams or indices to add.\nSupports wildcards (`*`).\nWildcard patterns that match both data streams and indices return an error.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.put_alias#name": {
        "in": "path",
        "name": "name",
        "description": "Alias to update.\nIf the alias doesnt exist, the request creates it.\nIndex alias names support date math.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.put_alias#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_alias#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_index_template#name": {
        "in": "path",
        "name": "name",
        "description": "Index or template name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.put_index_template#create": {
        "in": "query",
        "name": "create",
        "description": "If `true`, this request cannot replace or update existing index templates.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_mapping#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names the mapping should be added to (supports wildcards); use `_all` or omit to add the mapping on all indices.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.put_mapping#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_mapping#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.put_mapping#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_mapping#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_mapping#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_mapping#write_index_only": {
        "in": "query",
        "name": "write_index_only",
        "description": "If `true`, the mappings are applied only to the current write index for the target.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit\nthe request. Supports wildcards (`*`). To target all data streams and\nindices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.put_settings#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index\nalias, or `_all` value targets only missing or closed indices. This\nbehavior applies even if the request targets other open indices. For\nexample, a request targeting `foo*,bar*` returns an error if an index\nstarts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match. If the request can target\ndata streams, this argument determines whether wildcard expressions match\nhidden data streams. Supports comma-separated values, such as\n`open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.put_settings#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an\nerror.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_settings#preserve_existing": {
        "in": "query",
        "name": "preserve_existing",
        "description": "If `true`, existing index settings remain unchanged.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_settings#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the\n timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_template#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the template",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.put_template#create": {
        "in": "query",
        "name": "create",
        "description": "If true, this request cannot replace or update existing index templates.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_template#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If `true`, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.put_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is\nreceived before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_template#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.put_template#order": {
        "in": "query",
        "name": "order",
        "description": "Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower 'order' values are merged first. Templates with higher\n'order' values are merged later, overriding templates with lower values.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "indices.recovery#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases used to limit the request.\nSupports wildcards (`*`).\nTo target all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.recovery#active_only": {
        "in": "query",
        "name": "active_only",
        "description": "If `true`, the response only includes ongoing shard recoveries.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.recovery#detailed": {
        "in": "query",
        "name": "detailed",
        "description": "If `true`, the response includes detailed information about shard recoveries.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.rollover#alias": {
        "in": "path",
        "name": "alias",
        "description": "Name of the data stream or index alias to roll over.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexAlias"
        },
        "style": "simple"
      },
      "indices.rollover#new_index": {
        "in": "path",
        "name": "new_index",
        "description": "Name of the index to create.\nSupports date math.\nData streams do not support this parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "indices.rollover#dry_run": {
        "in": "query",
        "name": "dry_run",
        "description": "If `true`, checks whether the current index satisfies the specified conditions but does not perform a rollover.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.rollover#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.rollover#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.rollover#wait_for_active_shards": {
        "in": "query",
        "name": "wait_for_active_shards",
        "description": "The number of shard copies that must be active before proceeding with the operation.\nSet to all or any positive integer up to the total number of shards in the index (`number_of_replicas+1`).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:WaitForActiveShards"
        },
        "style": "form"
      },
      "indices.simulate_template#name": {
        "in": "path",
        "name": "name",
        "description": "Name of the index template to simulate. To test a template configuration before you add it to the cluster, omit\nthis parameter and specify the template configuration in the request body.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "indices.simulate_template#create": {
        "in": "query",
        "name": "create",
        "description": "If true, the template passed in the body is only used if no existing templates match the same index patterns. If false, the simulation uses the template with the highest priority. Note that the template is not permanently added or updated in either case; it is only used for the simulation.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.simulate_template#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "indices.simulate_template#include_defaults": {
        "in": "query",
        "name": "include_defaults",
        "description": "If true, returns all relevant default configurations for the index template.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limit the information returned the specific metrics.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "indices.stats#index": {
        "in": "path",
        "name": "index",
        "description": "A comma-separated list of index names; use `_all` or empty string to perform the operation on all indices",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.stats#completion_fields": {
        "in": "query",
        "name": "completion_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata and suggest statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.stats#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match. If the request can target data streams, this argument\ndetermines whether wildcard expressions match hidden data streams. Supports comma-separated values,\nsuch as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.stats#fielddata_fields": {
        "in": "query",
        "name": "fielddata_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.stats#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "indices.stats#forbid_closed_indices": {
        "in": "query",
        "name": "forbid_closed_indices",
        "description": "If true, statistics are not collected from closed indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#groups": {
        "in": "query",
        "name": "groups",
        "description": "Comma-separated list of search groups to include in the search statistics.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "indices.stats#include_segment_file_sizes": {
        "in": "query",
        "name": "include_segment_file_sizes",
        "description": "If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#include_unloaded_segments": {
        "in": "query",
        "name": "include_unloaded_segments",
        "description": "If true, the response includes information from segments that are not loaded into memory.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.stats#level": {
        "in": "query",
        "name": "level",
        "description": "Indicates whether statistics are aggregated at the cluster, index, or shard level.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Level"
        },
        "style": "form"
      },
      "indices.validate_query#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams or indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "indices.validate_query#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#all_shards": {
        "in": "query",
        "name": "all_shards",
        "description": "If `true`, the validation is executed on all shards instead of one random shard per index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "Analyzer to use for the query string.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "indices.validate_query#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If `true`, wildcard and prefix queries are analyzed.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query: `AND` or `OR`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "indices.validate_query#df": {
        "in": "query",
        "name": "df",
        "description": "Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "indices.validate_query#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "indices.validate_query#explain": {
        "in": "query",
        "name": "explain",
        "description": "If `true`, the response returns detailed information if an error has occurred.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#rewrite": {
        "in": "query",
        "name": "rewrite",
        "description": "If `true`, returns a more detailed explanation showing the actual Lucene query that will be executed.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "indices.validate_query#q": {
        "in": "query",
        "name": "q",
        "description": "Query in the Lucene query string syntax.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "ingest.get_pipeline#id": {
        "in": "path",
        "name": "id",
        "description": "Comma-separated list of pipeline IDs to retrieve.\nWildcard (`*`) expressions are supported.\nTo get all ingest pipelines, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ingest.get_pipeline#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ingest.get_pipeline#summary": {
        "in": "query",
        "name": "summary",
        "description": "Return pipelines without their definitions (default: false)",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ingest.simulate#id": {
        "in": "path",
        "name": "id",
        "description": "Pipeline to test.\nIf you dont specify a `pipeline` in the request body, this parameter is required.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ingest.simulate#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "If `true`, the response includes output data for each processor in the executed pipeline.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "logstash.get_pipeline#id": {
        "in": "path",
        "name": "id",
        "description": "Comma-separated list of pipeline identifiers.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "mget#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the index to retrieve documents from when `ids` are specified, or when a document in the `docs` array does not specify an index.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "mget#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specifies the node or shard the operation should be performed on. Random by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "mget#realtime": {
        "in": "query",
        "name": "realtime",
        "description": "If `true`, the request is real-time as opposed to near-real-time.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mget#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true`, the request refreshes relevant shards before retrieving documents.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mget#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "mget#_source": {
        "in": "query",
        "name": "_source",
        "description": "True or false to return the `_source` field or not, or a list of fields to return.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "mget#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "mget#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned. You can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "mget#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "If `true`, retrieves the document fields stored in the index rather than the document `_source`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "ml.delete_expired_data#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for an anomaly detection job. It can be a job identifier, a\ngroup name, or a wildcard expression.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.delete_expired_data#requests_per_second": {
        "in": "query",
        "name": "requests_per_second",
        "description": "The desired requests per second for the deletion processes. The default\nbehavior is no throttling.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.delete_expired_data#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "How long can the underlying delete processes run until they are canceled.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.delete_forecast#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.delete_forecast#forecast_id": {
        "in": "path",
        "name": "forecast_id",
        "description": "A comma-separated list of forecast identifiers. If you do not specify\nthis optional parameter or if you specify `_all` or `*` the API deletes\nall forecasts from the job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.delete_forecast#allow_no_forecasts": {
        "in": "query",
        "name": "allow_no_forecasts",
        "description": "Specifies whether an error occurs when there are no forecasts. In\nparticular, if this parameter is set to `false` and there are no\nforecasts associated with the job, attempts to delete all forecasts\nreturn an error.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.delete_forecast#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Specifies the period of time to wait for the completion of the delete\noperation. When this period of time elapses, the API fails and returns an\nerror.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.explain_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job. This identifier can contain\nlowercase alphanumeric characters (a-z and 0-9), hyphens, and\nunderscores. It must start and end with alphanumeric characters.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_buckets#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_buckets#timestamp": {
        "in": "path",
        "name": "timestamp",
        "description": "The timestamp of a single bucket result. If you do not specify this\nparameter, the API returns information about all buckets.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "simple"
      },
      "ml.get_buckets#anomaly_score": {
        "in": "query",
        "name": "anomaly_score",
        "description": "Returns buckets with anomaly scores greater or equal than this value.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_buckets#desc": {
        "in": "query",
        "name": "desc",
        "description": "If `true`, the buckets are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_buckets#end": {
        "in": "query",
        "name": "end",
        "description": "Returns buckets with timestamps earlier than this time. `-1` means it is\nunset and results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_buckets#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If `true`, the output excludes interim results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_buckets#expand": {
        "in": "query",
        "name": "expand",
        "description": "If true, the output includes anomaly records.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_buckets#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of buckets.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_buckets#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of buckets to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_buckets#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested buckets.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_buckets#start": {
        "in": "query",
        "name": "start",
        "description": "Returns buckets with timestamps after this time. `-1` means it is unset\nand results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_calendars#calendar_id": {
        "in": "path",
        "name": "calendar_id",
        "description": "A string that uniquely identifies a calendar. You can get information for multiple calendars by using a comma-separated list of ids or a wildcard expression. You can get information for all calendars by using `_all` or `*` or by omitting the calendar identifier.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_calendars#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of calendars. This parameter is supported only when you omit the calendar identifier.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_calendars#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of calendars to obtain. This parameter is supported only when you omit the calendar identifier.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_categories#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_categories#category_id": {
        "in": "path",
        "name": "category_id",
        "description": "Identifier for the category, which is unique in the job. If you specify\nneither the category ID nor the partition_field_value, the API returns\ninformation about all categories. If you specify only the\npartition_field_value, it returns information about all categories for\nthe specified partition.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:CategoryId"
        },
        "style": "simple"
      },
      "ml.get_categories#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of categories.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_categories#partition_field_value": {
        "in": "query",
        "name": "partition_field_value",
        "description": "Only return categories for the specified partition.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "ml.get_categories#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of categories to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job. If you do not specify this\noption, the API returns information for the first hundred data frame\nanalytics jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_data_frame_analytics#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of data frame analytics jobs.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of data frame analytics jobs to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job. If you do not specify this\noption, the API returns information for the first hundred data frame\nanalytics jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_data_frame_analytics_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no data frame analytics\njobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value returns an empty data_frame_analytics array when there\nare no matches and the subset of results when there are partial matches.\nIf this parameter is `false`, the request returns a 404 status code when\nthere are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of data frame analytics jobs.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of data frame analytics jobs to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_data_frame_analytics_stats#verbose": {
        "in": "query",
        "name": "verbose",
        "description": "Defines whether the stats response should be verbose.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_datafeed_stats#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "Identifier for the datafeed. It can be a datafeed identifier or a\nwildcard expression. If you do not specify one of these options, the API\nreturns information about all datafeeds.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_datafeed_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_datafeeds#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "Identifier for the datafeed. It can be a datafeed identifier or a\nwildcard expression. If you do not specify one of these options, the API\nreturns information about all datafeeds.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_datafeeds#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no datafeeds that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `datafeeds` array\nwhen there are no matches and the subset of results when there are\npartial matches. If this parameter is `false`, the request returns a\n`404` status code when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_datafeeds#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_filters#filter_id": {
        "in": "path",
        "name": "filter_id",
        "description": "A string that uniquely identifies a filter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_filters#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of filters.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_filters#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of filters to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_influencers#desc": {
        "in": "query",
        "name": "desc",
        "description": "If true, the results are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_influencers#end": {
        "in": "query",
        "name": "end",
        "description": "Returns influencers with timestamps earlier than this time.\nThe default value means it is unset and results are not limited to\nspecific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_influencers#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If true, the output excludes interim results. By default, interim results\nare included.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_influencers#influencer_score": {
        "in": "query",
        "name": "influencer_score",
        "description": "Returns influencers with anomaly scores greater than or equal to this\nvalue.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of influencers.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of influencers to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_influencers#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested influencers. By default, the\ninfluencers are sorted by the `influencer_score` value.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_influencers#start": {
        "in": "query",
        "name": "start",
        "description": "Returns influencers with timestamps after this time. The default value\nmeans it is unset and results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_job_stats#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job. It can be a job identifier, a\ngroup name, a comma-separated list of jobs, or a wildcard expression. If\nyou do not specify one of these options, the API returns information for\nall anomaly detection jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_job_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the API returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If `false`, the API returns a `404` status\ncode when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_jobs#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job. It can be a job identifier, a\ngroup name, or a wildcard expression. If you do not specify one of these\noptions, the API returns information for all anomaly detection jobs.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_jobs#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nThe default value is `true`, which returns an empty `jobs` array when\nthere are no matches and the subset of results when there are partial\nmatches. If this parameter is `false`, the request returns a `404` status\ncode when there are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_jobs#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_memory_stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "The names of particular nodes in the cluster to target. For example, `nodeId1,nodeId2` or\n`ml:true`",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_memory_stats#human": {
        "in": "query",
        "name": "human",
        "description": "Specify this query parameter to include the fields with units in the response. Otherwise only\nthe `_in_bytes` sizes are returned in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_memory_stats#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout\nexpires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.get_memory_stats#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request\nfails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_model_snapshots#snapshot_id": {
        "in": "path",
        "name": "snapshot_id",
        "description": "A numerical character string that uniquely identifies the model snapshot. You can get information for multiple\nsnapshots by using a comma-separated list or a wildcard expression. You can get all snapshots by using `_all`,\nby specifying `*` as the snapshot ID, or by omitting the snapshot ID.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_model_snapshots#desc": {
        "in": "query",
        "name": "desc",
        "description": "If true, the results are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#end": {
        "in": "query",
        "name": "end",
        "description": "Returns snapshots with timestamps earlier than this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of snapshots.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of snapshots to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested snapshots. By default, the\nsnapshots are sorted by their timestamp.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_model_snapshots#start": {
        "in": "query",
        "name": "start",
        "description": "Returns snapshots with timestamps after this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job. It can be a job identifier, a\ngroup name, a comma-separated list of jobs or groups, or a wildcard\nexpression.\n\nYou can summarize the bucket results for all anomaly detection jobs by\nusing `_all` or by specifying `*` as the `<job_id>`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_overall_buckets#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no jobs that match.\n2. Contains the `_all` string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf `true`, the request returns an empty `jobs` array when there are no\nmatches and the subset of results when there are partial matches. If this\nparameter is `false`, the request returns a `404` status code when there\nare no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#bucket_span": {
        "in": "query",
        "name": "bucket_span",
        "description": "The span of the overall buckets. Must be greater or equal to the largest\nbucket span of the specified anomaly detection jobs, which is the default\nvalue.\n\nBy default, an overall bucket has a span equal to the largest bucket span\nof the specified anomaly detection jobs. To override that behavior, use\nthe optional `bucket_span` parameter.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#end": {
        "in": "query",
        "name": "end",
        "description": "Returns overall buckets with timestamps earlier than this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If `true`, the output excludes interim results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#overall_score": {
        "in": "query",
        "name": "overall_score",
        "description": "Returns overall buckets with overall scores greater than or equal to this\nvalue.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "number"
            },
            {
              "type": "string"
            }
          ]
        },
        "style": "form"
      },
      "ml.get_overall_buckets#start": {
        "in": "query",
        "name": "start",
        "description": "Returns overall buckets with timestamps after this time.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_overall_buckets#top_n": {
        "in": "query",
        "name": "top_n",
        "description": "The number of top anomaly detection job bucket scores to be used in the\n`overall_score` calculation.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#job_id": {
        "in": "path",
        "name": "job_id",
        "description": "Identifier for the anomaly detection job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_records#desc": {
        "in": "query",
        "name": "desc",
        "description": "If true, the results are sorted in descending order.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_records#end": {
        "in": "query",
        "name": "end",
        "description": "Returns records with timestamps earlier than this time. The default value\nmeans results are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_records#exclude_interim": {
        "in": "query",
        "name": "exclude_interim",
        "description": "If `true`, the output excludes interim results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_records#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of records.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#record_score": {
        "in": "query",
        "name": "record_score",
        "description": "Returns records with anomaly scores greater or equal than this value.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of records to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_records#sort": {
        "in": "query",
        "name": "sort",
        "description": "Specifies the sort field for the requested records.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "ml.get_records#start": {
        "in": "query",
        "name": "start",
        "description": "Returns records with timestamps after this time. The default value means\nresults are not limited to specific timestamps.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.get_trained_models#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "The unique identifier of the trained model.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.get_trained_models#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#decompress_definition": {
        "in": "query",
        "name": "decompress_definition",
        "description": "Specifies whether the included model definition should be returned as a\nJSON map (true) or in a custom compressed format (false).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Indicates if certain fields should be removed from the configuration on\nretrieval. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of models.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_trained_models#include": {
        "in": "query",
        "name": "include",
        "description": "A comma delimited string of optional fields to include in the response\nbody.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/ml._types:Include"
        },
        "style": "form"
      },
      "ml.get_trained_models#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of models to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_trained_models#tags": {
        "in": "query",
        "name": "tags",
        "description": "A comma delimited string of tags. A trained model can have many tags, or\nnone. When supplied, only trained models that contain all the supplied\ntags are returned.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "ml.get_trained_models_stats#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "The unique identifier of the trained model or a model alias. It can be a\ncomma-separated list or a wildcard expression.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Ids"
        },
        "style": "simple"
      },
      "ml.get_trained_models_stats#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n- Contains wildcard expressions and there are no models that match.\n- Contains the _all string or no identifiers and there are no matches.\n- Contains wildcard expressions and there are only partial matches.\n\nIf true, it returns an empty array when there are no matches and the\nsubset of results when there are partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "ml.get_trained_models_stats#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of models.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.get_trained_models_stats#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of models to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "ml.infer_trained_model#model_id": {
        "in": "path",
        "name": "model_id",
        "description": "The unique identifier of the trained model.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.infer_trained_model#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Controls the amount of time to wait for inference results.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "ml.preview_data_frame_analytics#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the data frame analytics job.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.preview_datafeed#datafeed_id": {
        "in": "path",
        "name": "datafeed_id",
        "description": "A numerical character string that uniquely identifies the datafeed. This identifier can contain lowercase\nalphanumeric characters (a-z and 0-9), hyphens, and underscores. It must start and end with alphanumeric\ncharacters. NOTE: If you use this path parameter, you cannot provide datafeed or anomaly detection job\nconfiguration details in the request body.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "ml.preview_datafeed#start": {
        "in": "query",
        "name": "start",
        "description": "The start time from where the datafeed preview should begin",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "ml.preview_datafeed#end": {
        "in": "query",
        "name": "end",
        "description": "The end time when the datafeed preview should stop",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:DateTime"
        },
        "style": "form"
      },
      "msearch#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and index aliases to search.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "msearch#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If false, the request returns an error if any wildcard expression, index alias, or _all value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting foo*,bar* returns an error if an index starts with foo but no index starts with bar.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If true, network roundtrips between the coordinating node and remote clusters are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard expressions can match. If the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "msearch#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If true, concrete, expanded or aliased indices are ignored when frozen.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If true, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#max_concurrent_searches": {
        "in": "query",
        "name": "max_concurrent_searches",
        "description": "Maximum number of concurrent searches the multi search API can execute.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "Maximum number of concurrent shard requests that each sub-search request executes per node.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold. This filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method i.e., if date filters are mandatory to match but the shard bounds and the query are disjoint.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, hits.total are returned as an integer in the response. Defaults to false, which returns an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom routing value used to route search operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "msearch#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Indicates whether global term and document frequencies should be used when scoring returned documents.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "msearch#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "Specifies whether aggregation and suggester names should be prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch_template#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "msearch_template#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If `true`, network round-trips are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch_template#max_concurrent_searches": {
        "in": "query",
        "name": "max_concurrent_searches",
        "description": "Maximum number of concurrent searches the API can run.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "msearch_template#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "The type of the search operation.\nAvailable options: `query_then_fetch`, `dfs_query_then_fetch`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "msearch_template#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If `true`, the response returns `hits.total` as an integer.\nIf `false`, it returns `hits.total` as an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "msearch_template#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "If `true`, the response prefixes aggregation and suggester names with their respective types.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the index that contains the documents.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "mtermvectors#ids": {
        "in": "query",
        "name": "ids",
        "description": "A comma-separated list of documents ids. You must define ids as parameter or set \"ids\" or \"docs\" in the request body",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "style": "form"
      },
      "mtermvectors#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.\nUsed as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "mtermvectors#field_statistics": {
        "in": "query",
        "name": "field_statistics",
        "description": "If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#offsets": {
        "in": "query",
        "name": "offsets",
        "description": "If `true`, the response includes term offsets.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#payloads": {
        "in": "query",
        "name": "payloads",
        "description": "If `true`, the response includes term payloads.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#positions": {
        "in": "query",
        "name": "positions",
        "description": "If `true`, the response includes term positions.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "mtermvectors#realtime": {
        "in": "query",
        "name": "realtime",
        "description": "If true, the request is real-time as opposed to near-real-time.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "mtermvectors#term_statistics": {
        "in": "query",
        "name": "term_statistics",
        "description": "If true, the response includes term frequency and document frequency.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "mtermvectors#version": {
        "in": "query",
        "name": "version",
        "description": "If `true`, returns the document version as part of a hit.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "mtermvectors#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "Specific version type.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "nodes.hot_threads#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "List of node IDs or names used to limit returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.hot_threads#ignore_idle_threads": {
        "in": "query",
        "name": "ignore_idle_threads",
        "description": "If true, known idle threads (e.g. waiting in a socket select, or to get\na task from an empty queue) are filtered out.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.hot_threads#interval": {
        "in": "query",
        "name": "interval",
        "description": "The interval to do the second sampling of threads.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.hot_threads#snapshots": {
        "in": "query",
        "name": "snapshots",
        "description": "Number of samples of thread stacktrace.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "nodes.hot_threads#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response\nis received before the timeout expires, the request fails and\nreturns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.hot_threads#threads": {
        "in": "query",
        "name": "threads",
        "description": "Specifies the number of hot threads to provide information for.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "nodes.hot_threads#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received\nbefore the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.hot_threads#type": {
        "in": "query",
        "name": "type",
        "description": "The type to sample.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ThreadType"
        },
        "style": "form"
      },
      "nodes.hot_threads#sort": {
        "in": "query",
        "name": "sort",
        "description": "The sort order for 'cpu' type (default: total)",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ThreadType"
        },
        "style": "form"
      },
      "nodes.info#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node IDs or names used to limit returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.info#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limits the information returned to the specific metrics. Supports a comma-separated list, such as http,ingest.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.info#flat_settings": {
        "in": "query",
        "name": "flat_settings",
        "description": "If true, returns settings in flat format.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.info#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.info#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.stats#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "Comma-separated list of node IDs or names used to limit returned information.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.stats#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limit the information returned to the specified metrics",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.stats#index_metric": {
        "in": "path",
        "name": "index_metric",
        "description": "Limit the information returned for indices metric to the specific index metrics. It can be used only if indices (or all) metric is specified.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.stats#completion_fields": {
        "in": "query",
        "name": "completion_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata and suggest statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "nodes.stats#fielddata_fields": {
        "in": "query",
        "name": "fielddata_fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in fielddata statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "nodes.stats#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "nodes.stats#groups": {
        "in": "query",
        "name": "groups",
        "description": "Comma-separated list of search groups to include in the search statistics.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.stats#include_segment_file_sizes": {
        "in": "query",
        "name": "include_segment_file_sizes",
        "description": "If true, the call reports the aggregated disk usage of each one of the Lucene index files (only applies if segment stats are requested).",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.stats#level": {
        "in": "query",
        "name": "level",
        "description": "Indicates whether statistics are aggregated at the cluster, index, or shard level.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Level"
        },
        "style": "form"
      },
      "nodes.stats#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.stats#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "nodes.stats#types": {
        "in": "query",
        "name": "types",
        "description": "A comma-separated list of document types for the indexing index metric.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "nodes.stats#include_unloaded_segments": {
        "in": "query",
        "name": "include_unloaded_segments",
        "description": "If `true`, the response includes information from segments that are not loaded into memory.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "nodes.usage#node_id": {
        "in": "path",
        "name": "node_id",
        "description": "A comma-separated list of node IDs or names to limit the returned information; use `_local` to return information from the node you're connecting to, leave empty to get information from all nodes",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:NodeIds"
        },
        "style": "simple"
      },
      "nodes.usage#metric": {
        "in": "path",
        "name": "metric",
        "description": "Limits the information returned to the specific metrics.\nA comma-separated list of the following options: `_all`, `rest_actions`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Metrics"
        },
        "style": "simple"
      },
      "nodes.usage#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "put_script#id": {
        "in": "path",
        "name": "id",
        "description": "Identifier for the stored script or search template.\nMust be unique within the cluster.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "put_script#context": {
        "in": "path",
        "name": "context",
        "description": "Context in which the script or search template should run.\nTo prevent errors, the API immediately compiles the script or template in this context.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "put_script#master_timeout": {
        "in": "query",
        "name": "master_timeout",
        "description": "Period to wait for a connection to the master node.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "put_script#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "rank_eval#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and index aliases used to limit the request. Wildcard (`*`) expressions are supported.\nTo target all data streams and indices in a cluster, omit this parameter or use `_all` or `*`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "rank_eval#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices. This behavior applies even if the request targets other open indices. For example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "rank_eval#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Whether to expand wildcard expression to concrete indices that are open, closed or both.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "rank_eval#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `true`, missing or closed indices are not included in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "rank_eval#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "Search operation type",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "render_search_template#id": {
        "in": "path",
        "name": "id",
        "description": "ID of the search template to render.\nIf no `source` is specified, this or the `id` request body parameter is required.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "scroll#scroll_id": {
        "in": "path",
        "name": "scroll_id",
        "description": "The scroll ID",
        "required": true,
        "deprecated": true,
        "schema": {
          "$ref": "#/components/schemas/_types:ScrollId"
        },
        "style": "simple"
      },
      "scroll#scroll": {
        "in": "query",
        "name": "scroll",
        "description": "Period to retain the search context for scrolling.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "scroll#scroll_id_": {
        "in": "query",
        "name": "scroll_id",
        "description": "The scroll ID for scrolled search",
        "deprecated": true,
        "schema": {
          "$ref": "#/components/schemas/_types:ScrollId"
        },
        "style": "form"
      },
      "scroll#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, the API responses hit.total property is returned as an integer. If false, the API responses hit.total property is returned as an object.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and aliases to search.\nSupports wildcards (`*`).\nTo search all data streams and indices, omit this parameter or use `*` or `_all`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#allow_partial_search_results": {
        "in": "query",
        "name": "allow_partial_search_results",
        "description": "If true, returns partial results if there are shard request timeouts or shard failures. If false, returns an error with no partial results.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#analyzer": {
        "in": "query",
        "name": "analyzer",
        "description": "Analyzer to use for the query string.\nThis parameter can only be used when the q query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#analyze_wildcard": {
        "in": "query",
        "name": "analyze_wildcard",
        "description": "If true, wildcard and prefix queries are analyzed.\nThis parameter can only be used when the q query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#batched_reduce_size": {
        "in": "query",
        "name": "batched_reduce_size",
        "description": "The number of shard results that should be reduced at once on the coordinating node.\nThis value should be used as a protection mechanism to reduce the memory overhead per search request if the potential number of shards in the request can be large.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If true, network round-trips between the coordinating node and the remote clusters are minimized when executing cross-cluster search (CCS) requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#default_operator": {
        "in": "query",
        "name": "default_operator",
        "description": "The default operator for query string query: AND or OR.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types.query_dsl:Operator"
        },
        "style": "form"
      },
      "search#df": {
        "in": "query",
        "name": "df",
        "description": "Field to use as default where no field prefix is given in the query string.\nThis parameter can only be used when the q query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#docvalue_fields": {
        "in": "query",
        "name": "docvalue_fields",
        "description": "A comma-separated list of fields to return as the docvalue representation for each hit.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "search#explain": {
        "in": "query",
        "name": "explain",
        "description": "If `true`, returns detailed information about score computation as part of a hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If `true`, concrete, expanded or aliased indices will be ignored when frozen.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#lenient": {
        "in": "query",
        "name": "lenient",
        "description": "If `true`, format-based query failures (such as providing text to a numeric field) in the query string will be ignored.\nThis parameter can only be used when the `q` query string parameter is specified.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#max_concurrent_shard_requests": {
        "in": "query",
        "name": "max_concurrent_shard_requests",
        "description": "Defines the number of concurrent shard requests per node this search executes concurrently.\nThis value should be used to limit the impact of the search on the cluster in order to limit the number of concurrent shard requests.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#min_compatible_shard_node": {
        "in": "query",
        "name": "min_compatible_shard_node",
        "description": "The minimum version of the node that can handle the request\nAny handling node with a lower version will fail the request.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionString"
        },
        "style": "form"
      },
      "search#preference": {
        "in": "query",
        "name": "preference",
        "description": "Nodes and shards used for the search.\nBy default, Elasticsearch selects from eligible nodes and shards using adaptive replica selection, accounting for allocation awareness. Valid values are:\n`_only_local` to run the search only on shards on the local node;\n`_local` to, if possible, run the search on shards on the local node, or if not, select shards using the default method;\n`_only_nodes:<node-id>,<node-id>` to run the search on only the specified nodes IDs, where, if suitable shards exist on more than one selected node, use shards on those nodes using the default method, or if none of the specified nodes are available, select shards from any available node using the default method;\n`_prefer_nodes:<node-id>,<node-id>` to if possible, run the search on the specified nodes IDs, or if not, select shards using the default method;\n`_shards:<shard>,<shard>` to run the search only on the specified shards;\n`<custom-string>` (any string that does not start with `_`) to route searches with the same `<custom-string>` to the same shards in the same order.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#pre_filter_shard_size": {
        "in": "query",
        "name": "pre_filter_shard_size",
        "description": "Defines a threshold that enforces a pre-filter roundtrip to prefilter search shards based on query rewriting if the number of shards the search request expands to exceeds the threshold.\nThis filter roundtrip can limit the number of shards significantly if for instance a shard can not match any documents based on its rewrite method (if date filters are mandatory to match but the shard bounds and the query are disjoint).\nWhen unspecified, the pre-filter phase is executed if any of these conditions is met:\nthe request targets more than 128 shards;\nthe request targets one or more read-only index;\nthe primary sort of the query targets an indexed field.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#request_cache": {
        "in": "query",
        "name": "request_cache",
        "description": "If `true`, the caching of search results is enabled for requests where `size` is `0`.\nDefaults to index level settings.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "search#scroll": {
        "in": "query",
        "name": "scroll",
        "description": "Period to retain the search context for scrolling. See Scroll search results.\nBy default, this value cannot exceed `1d` (24 hours).\nYou can change this limit using the `search.max_keep_alive` cluster-level setting.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "search#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "How distributed term frequencies are calculated for relevance scoring.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "search#stats": {
        "in": "query",
        "name": "stats",
        "description": "Specific `tag` of the request for logging and statistical purposes.",
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "style": "form"
      },
      "search#stored_fields": {
        "in": "query",
        "name": "stored_fields",
        "description": "A comma-separated list of stored fields to return as part of a hit.\nIf no fields are specified, no stored fields are included in the response.\nIf this field is specified, the `_source` parameter defaults to `false`.\nYou can pass `_source: true` to return both source fields and stored fields in the search response.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#suggest_field": {
        "in": "query",
        "name": "suggest_field",
        "description": "Specifies which field to use for suggestions.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "form"
      },
      "search#suggest_mode": {
        "in": "query",
        "name": "suggest_mode",
        "description": "Specifies the suggest mode.\nThis parameter can only be used when the `suggest_field` and `suggest_text` query string parameters are specified.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SuggestMode"
        },
        "style": "form"
      },
      "search#suggest_size": {
        "in": "query",
        "name": "suggest_size",
        "description": "Number of suggestions to return.\nThis parameter can only be used when the `suggest_field` and `suggest_text` query string parameters are specified.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#suggest_text": {
        "in": "query",
        "name": "suggest_text",
        "description": "The source text for which the suggestions should be returned.\nThis parameter can only be used when the `suggest_field` and `suggest_text` query string parameters are specified.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#terminate_after": {
        "in": "query",
        "name": "terminate_after",
        "description": "Maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\nUse with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Specifies the period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "search#track_total_hits": {
        "in": "query",
        "name": "track_total_hits",
        "description": "Number of hits matching the query to count accurately.\nIf `true`, the exact number of hits is returned at the cost of some performance.\nIf `false`, the response does not include the total number of hits matching the query.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:TrackHits"
        },
        "style": "form"
      },
      "search#track_scores": {
        "in": "query",
        "name": "track_scores",
        "description": "If `true`, calculate and return document scores, even if the scores are not used for sorting.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "If `true`, aggregation and suggester names are be prefixed by their respective types in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "Indicates whether `hits.total` should be rendered as an integer or an object in the rest search response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#version": {
        "in": "query",
        "name": "version",
        "description": "If `true`, returns document version as part of a hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#_source": {
        "in": "query",
        "name": "_source",
        "description": "Indicates which source fields are returned for matching documents.\nThese fields are returned in the `hits._source` property of the search response.\nValid values are:\n`true` to return the entire document source;\n`false` to not return the document source;\n`<string>` to return the source fields that are specified as a comma-separated list (supports wildcard (`*`) patterns).",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search._types:SourceConfigParam"
        },
        "style": "form"
      },
      "search#_source_excludes": {
        "in": "query",
        "name": "_source_excludes",
        "description": "A comma-separated list of source fields to exclude from the response.\nYou can also use this parameter to exclude fields from the subset specified in `_source_includes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#_source_includes": {
        "in": "query",
        "name": "_source_includes",
        "description": "A comma-separated list of source fields to include in the response.\nIf this parameter is specified, only these source fields are returned.\nYou can exclude fields from this subset using the `_source_excludes` query parameter.\nIf the `_source` parameter is `false`, this parameter is ignored.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "search#seq_no_primary_term": {
        "in": "query",
        "name": "seq_no_primary_term",
        "description": "If `true`, returns sequence number and primary term of the last modification of each hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search#q": {
        "in": "query",
        "name": "q",
        "description": "Query in the Lucene query string syntax using query parameter search.\nQuery parameter searches do not support the full Elasticsearch Query DSL but are handy for testing.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search#size": {
        "in": "query",
        "name": "size",
        "description": "Defines the number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#from": {
        "in": "query",
        "name": "from",
        "description": "Starting document offset.\nNeeds to be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search#sort": {
        "in": "query",
        "name": "sort",
        "description": "A comma-separated list of <field>:<direction> pairs.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "search_application.get_behavioral_analytics#name": {
        "in": "path",
        "name": "name",
        "description": "A list of analytics collections to limit the returned information",
        "required": true,
        "deprecated": false,
        "schema": {
          "type": "array",
          "items": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "style": "simple"
      },
      "search_application.search#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the search application to be searched.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "search_mvt#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, or aliases to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search_mvt#field": {
        "in": "path",
        "name": "field",
        "description": "Field containing geospatial data to return",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Field"
        },
        "style": "simple"
      },
      "search_mvt#zoom": {
        "in": "path",
        "name": "zoom",
        "description": "Zoom level for the vector tile to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:ZoomLevel"
        },
        "style": "simple"
      },
      "search_mvt#x": {
        "in": "path",
        "name": "x",
        "description": "X coordinate for the vector tile to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:Coordinate"
        },
        "style": "simple"
      },
      "search_mvt#y": {
        "in": "path",
        "name": "y",
        "description": "Y coordinate for the vector tile to search",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:Coordinate"
        },
        "style": "simple"
      },
      "search_mvt#exact_bounds": {
        "in": "query",
        "name": "exact_bounds",
        "description": "If false, the meta layers feature is the bounding box of the tile.\nIf true, the meta layers feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_mvt#extent": {
        "in": "query",
        "name": "extent",
        "description": "Size, in pixels, of a side of the tile. Vector tiles are square with equal sides.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search_mvt#grid_agg": {
        "in": "query",
        "name": "grid_agg",
        "description": "Aggregation used to create a grid for `field`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:GridAggregationType"
        },
        "style": "form"
      },
      "search_mvt#grid_precision": {
        "in": "query",
        "name": "grid_precision",
        "description": "Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndont include the aggs layer.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search_mvt#grid_type": {
        "in": "query",
        "name": "grid_type",
        "description": "Determines the geometry type for features in the aggs layer. In the aggs layer,\neach feature represents a geotile_grid cell. If 'grid' each feature is a Polygon\nof the cells bounding box. If 'point' each feature is a Point that is the centroid\nof the cell.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_global.search_mvt._types:GridType"
        },
        "style": "form"
      },
      "search_mvt#size": {
        "in": "query",
        "name": "size",
        "description": "Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results dont include the hits layer.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "search_mvt#with_labels": {
        "in": "query",
        "name": "with_labels",
        "description": "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices,\nand aliases to search. Supports wildcards (*).",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Indices"
        },
        "style": "simple"
      },
      "search_template#allow_no_indices": {
        "in": "query",
        "name": "allow_no_indices",
        "description": "If `false`, the request returns an error if any wildcard expression, index alias, or `_all` value targets only missing or closed indices.\nThis behavior applies even if the request targets other open indices.\nFor example, a request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#ccs_minimize_roundtrips": {
        "in": "query",
        "name": "ccs_minimize_roundtrips",
        "description": "If `true`, network round-trips are minimized for cross-cluster search requests.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#expand_wildcards": {
        "in": "query",
        "name": "expand_wildcards",
        "description": "Type of index that wildcard patterns can match.\nIf the request can target data streams, this argument determines whether wildcard expressions match hidden data streams.\nSupports comma-separated values, such as `open,hidden`.\nValid values are: `all`, `open`, `closed`, `hidden`, `none`.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:ExpandWildcards"
        },
        "style": "form"
      },
      "search_template#explain": {
        "in": "query",
        "name": "explain",
        "description": "If `true`, the response includes additional details about score computation as part of a hit.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#ignore_throttled": {
        "in": "query",
        "name": "ignore_throttled",
        "description": "If `true`, specified concrete, expanded, or aliased indices are not included in the response when throttled.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#ignore_unavailable": {
        "in": "query",
        "name": "ignore_unavailable",
        "description": "If `false`, the request returns an error if it targets a missing or closed index.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "search_template#profile": {
        "in": "query",
        "name": "profile",
        "description": "If `true`, the query execution is profiled.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "search_template#scroll": {
        "in": "query",
        "name": "scroll",
        "description": "Specifies how long a consistent view of the index\nshould be maintained for scrolled search.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      },
      "search_template#search_type": {
        "in": "query",
        "name": "search_type",
        "description": "The type of the search operation.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SearchType"
        },
        "style": "form"
      },
      "search_template#rest_total_hits_as_int": {
        "in": "query",
        "name": "rest_total_hits_as_int",
        "description": "If true, hits.total are rendered as an integer in the response.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "search_template#typed_keys": {
        "in": "query",
        "name": "typed_keys",
        "description": "If `true`, the response prefixes aggregation and suggester names with their respective types.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.create_api_key#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.create_service_token#namespace": {
        "in": "path",
        "name": "namespace",
        "description": "An identifier for the namespace",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Namespace"
        },
        "style": "simple"
      },
      "security.create_service_token#service": {
        "in": "path",
        "name": "service",
        "description": "An identifier for the service name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Service"
        },
        "style": "simple"
      },
      "security.create_service_token#name": {
        "in": "path",
        "name": "name",
        "description": "An identifier for the token name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.create_service_token#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` then refresh the affected shards to make this operation visible to search, if `wait_for` (the default) then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.disable_user_profile#uid": {
        "in": "path",
        "name": "uid",
        "description": "Unique identifier for the user profile.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/security._types:UserProfileId"
        },
        "style": "simple"
      },
      "security.disable_user_profile#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation\nvisible to search, if 'wait_for' then wait for a refresh to make this operation\nvisible to search, if 'false' do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.enable_user_profile#uid": {
        "in": "path",
        "name": "uid",
        "description": "Unique identifier for the user profile.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/security._types:UserProfileId"
        },
        "style": "simple"
      },
      "security.enable_user_profile#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation\nvisible to search, if 'wait_for' then wait for a refresh to make this operation\nvisible to search, if 'false' do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.get_privileges#application": {
        "in": "path",
        "name": "application",
        "description": "Application name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.get_privileges#name": {
        "in": "path",
        "name": "name",
        "description": "Privilege name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "security.get_role#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the role. You can specify multiple roles as a comma-separated list. If you do not specify this parameter, the API returns information about all roles.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "security.get_role_mapping#name": {
        "in": "path",
        "name": "name",
        "description": "The distinct name that identifies the role mapping. The name is used solely as an identifier to facilitate interaction via the API; it does not affect the behavior of the mapping in any way. You can specify multiple mapping names as a comma-separated list. If you do not specify this parameter, the API returns information about all role mappings.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "security.get_service_accounts#namespace": {
        "in": "path",
        "name": "namespace",
        "description": "Name of the namespace. Omit this parameter to retrieve information about all service accounts. If you omit this parameter, you must also omit the `service` parameter.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Namespace"
        },
        "style": "simple"
      },
      "security.get_service_accounts#service": {
        "in": "path",
        "name": "service",
        "description": "Name of the service name. Omit this parameter to retrieve information about all service accounts that belong to the specified `namespace`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Service"
        },
        "style": "simple"
      },
      "security.has_privileges#user": {
        "in": "path",
        "name": "user",
        "description": "Username",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.put_privileges#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.put_role#name": {
        "in": "path",
        "name": "name",
        "description": "The name of the role.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.put_role#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.put_role_mapping#name": {
        "in": "path",
        "name": "name",
        "description": "Role-mapping name",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Name"
        },
        "style": "simple"
      },
      "security.put_role_mapping#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "security.query_api_keys#with_limited_by": {
        "in": "query",
        "name": "with_limited_by",
        "description": "Return the snapshot of the owner user's role descriptors associated with the API key. \nAn API key's actual permission is the intersection of its assigned role descriptors and the owner user's role descriptors.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "security.suggest_user_profiles#data": {
        "in": "query",
        "name": "data",
        "description": "List of filters for the `data` field of the profile document.\nTo return all content use `data=*`. To return a subset of content\nuse `data=<key>` to retrieve content nested under the specified `<key>`.\nBy default returns no `data` content.",
        "deprecated": false,
        "schema": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        },
        "style": "form"
      },
      "security.update_user_profile_data#uid": {
        "in": "path",
        "name": "uid",
        "description": "A unique identifier for the user profile.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/security._types:UserProfileId"
        },
        "style": "simple"
      },
      "security.update_user_profile_data#if_seq_no": {
        "in": "query",
        "name": "if_seq_no",
        "description": "Only perform the operation if the document has this sequence number.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:SequenceNumber"
        },
        "style": "form"
      },
      "security.update_user_profile_data#if_primary_term": {
        "in": "query",
        "name": "if_primary_term",
        "description": "Only perform the operation if the document has this primary term.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "security.update_user_profile_data#refresh": {
        "in": "query",
        "name": "refresh",
        "description": "If 'true', Elasticsearch refreshes the affected shards to make this operation\nvisible to search, if 'wait_for' then wait for a refresh to make this operation\nvisible to search, if 'false' do nothing with refreshes.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Refresh"
        },
        "style": "form"
      },
      "terms_enum#index": {
        "in": "path",
        "name": "index",
        "description": "Comma-separated list of data streams, indices, and index aliases to search. Wildcard (*) expressions are supported.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "termvectors#index": {
        "in": "path",
        "name": "index",
        "description": "Name of the index that contains the document.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:IndexName"
        },
        "style": "simple"
      },
      "termvectors#id": {
        "in": "path",
        "name": "id",
        "description": "Unique identifier of the document.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "termvectors#fields": {
        "in": "query",
        "name": "fields",
        "description": "Comma-separated list or wildcard expressions of fields to include in the statistics.\nUsed as the default list unless a specific field list is provided in the `completion_fields` or `fielddata_fields` parameters.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Fields"
        },
        "style": "form"
      },
      "termvectors#field_statistics": {
        "in": "query",
        "name": "field_statistics",
        "description": "If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#offsets": {
        "in": "query",
        "name": "offsets",
        "description": "If `true`, the response includes term offsets.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#payloads": {
        "in": "query",
        "name": "payloads",
        "description": "If `true`, the response includes term payloads.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#positions": {
        "in": "query",
        "name": "positions",
        "description": "If `true`, the response includes term positions.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#preference": {
        "in": "query",
        "name": "preference",
        "description": "Specifies the node or shard the operation should be performed on.\nRandom by default.",
        "deprecated": false,
        "schema": {
          "type": "string"
        },
        "style": "form"
      },
      "termvectors#realtime": {
        "in": "query",
        "name": "realtime",
        "description": "If true, the request is real-time as opposed to near-real-time.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#routing": {
        "in": "query",
        "name": "routing",
        "description": "Custom value used to route operations to a specific shard.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Routing"
        },
        "style": "form"
      },
      "termvectors#term_statistics": {
        "in": "query",
        "name": "term_statistics",
        "description": "If `true`, the response includes term frequency and document frequency.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "termvectors#version": {
        "in": "query",
        "name": "version",
        "description": "If `true`, returns the document version as part of a hit.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionNumber"
        },
        "style": "form"
      },
      "termvectors#version_type": {
        "in": "query",
        "name": "version_type",
        "description": "Specific version type.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:VersionType"
        },
        "style": "form"
      },
      "transform.get_transform#transform_id": {
        "in": "path",
        "name": "transform_id",
        "description": "Identifier for the transform. It can be a transform identifier or a\nwildcard expression. You can get information for all transforms by using\n`_all`, by specifying `*` as the `<transform_id>`, or by omitting the\n`<transform_id>`.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Names"
        },
        "style": "simple"
      },
      "transform.get_transform#allow_no_match": {
        "in": "query",
        "name": "allow_no_match",
        "description": "Specifies what to do when the request:\n\n1. Contains wildcard expressions and there are no transforms that match.\n2. Contains the _all string or no identifiers and there are no matches.\n3. Contains wildcard expressions and there are only partial matches.\n\nIf this parameter is false, the request returns a 404 status code when\nthere are no matches or only partial matches.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "transform.get_transform#from": {
        "in": "query",
        "name": "from",
        "description": "Skips the specified number of transforms.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "transform.get_transform#size": {
        "in": "query",
        "name": "size",
        "description": "Specifies the maximum number of transforms to obtain.",
        "deprecated": false,
        "schema": {
          "type": "number"
        },
        "style": "form"
      },
      "transform.get_transform#exclude_generated": {
        "in": "query",
        "name": "exclude_generated",
        "description": "Excludes fields that were automatically added when creating the\ntransform. This allows the configuration to be in an acceptable format to\nbe retrieved and then added to another cluster.",
        "deprecated": false,
        "schema": {
          "type": "boolean"
        },
        "style": "form"
      },
      "transform.preview_transform#transform_id": {
        "in": "path",
        "name": "transform_id",
        "description": "Identifier for the transform to preview. If you specify this path parameter, you cannot provide transform\nconfiguration details in the request body.",
        "required": true,
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Id"
        },
        "style": "simple"
      },
      "transform.preview_transform#timeout": {
        "in": "query",
        "name": "timeout",
        "description": "Period to wait for a response. If no response is received before the\ntimeout expires, the request fails and returns an error.",
        "deprecated": false,
        "schema": {
          "$ref": "#/components/schemas/_types:Duration"
        },
        "style": "form"
      }
    },
    "requestBodies": {
      "async_search.submit": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "collapse": {
                  "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
                },
                "explain": {
                  "description": "If true, returns detailed information about score computation as part of a hit.",
                  "type": "boolean"
                },
                "ext": {
                  "description": "Configuration of search extensions defined by Elasticsearch plugins.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "from": {
                  "description": "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.",
                  "type": "number"
                },
                "highlight": {
                  "$ref": "#/components/schemas/_global.search._types:Highlight"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "indices_boost": {
                  "description": "Boosts the _score of documents from specified indices.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                "docvalue_fields": {
                  "description": "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "knn": {
                  "description": "Defines the approximate kNN search to run.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types:KnnQuery"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:KnnQuery"
                      }
                    }
                  ]
                },
                "min_score": {
                  "description": "Minimum _score for matching documents. Documents with a lower _score are\nnot included in the search results.",
                  "type": "number"
                },
                "post_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "profile": {
                  "type": "boolean"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "rescore": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_global.search._types:Rescore"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.search._types:Rescore"
                      }
                    }
                  ]
                },
                "script_fields": {
                  "description": "Retrieve a script evaluation (based on different fields) for each hit.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types:ScriptField"
                  }
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                },
                "size": {
                  "description": "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.",
                  "type": "number"
                },
                "slice": {
                  "$ref": "#/components/schemas/_types:SlicedScroll"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "suggest": {
                  "$ref": "#/components/schemas/_global.search._types:Suggester"
                },
                "terminate_after": {
                  "description": "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.",
                  "type": "number"
                },
                "timeout": {
                  "description": "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
                  "type": "string"
                },
                "track_scores": {
                  "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
                  "type": "boolean"
                },
                "version": {
                  "description": "If true, returns document version as part of a hit.",
                  "type": "boolean"
                },
                "seq_no_primary_term": {
                  "description": "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.",
                  "type": "boolean"
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "pit": {
                  "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "stats": {
                  "description": "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "bulk": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.bulk:OperationContainer"
                  },
                  {
                    "$ref": "#/components/schemas/_global.bulk:UpdateAction"
                  },
                  {
                    "type": "object"
                  }
                ]
              }
            }
          }
        },
        "required": true
      },
      "clear_scroll": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollIds"
                }
              }
            }
          }
        }
      },
      "cluster.allocation_explain": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "current_node": {
                  "description": "Specifies the node ID or the name of the node to only explain a shard that is currently located on the specified node.",
                  "type": "string"
                },
                "index": {
                  "$ref": "#/components/schemas/_types:IndexName"
                },
                "primary": {
                  "description": "If true, returns explanation for the primary shard for the given shard ID.",
                  "type": "boolean"
                },
                "shard": {
                  "description": "Specifies the ID of the shard that you would like an explanation for.",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "cluster.put_component_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allow_auto_create": {
                  "description": "This setting overrides the value of the `action.auto_create_index` cluster setting.\nIf set to `true` in a template, then indices can be automatically created using that\ntemplate even if auto-creation of indices is disabled via `actions.auto_create_index`.\nIf set to `false` then data streams matching the template must always be explicitly created.",
                  "type": "boolean"
                },
                "template": {
                  "$ref": "#/components/schemas/indices._types:IndexState"
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                }
              },
              "required": [
                "template"
              ]
            }
          }
        },
        "required": true
      },
      "count": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            }
          }
        }
      },
      "create": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        },
        "required": true
      },
      "field_caps": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "index_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                }
              }
            }
          }
        }
      },
      "fleet.msearch": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.msearch:RequestItem"
              }
            }
          }
        },
        "required": true
      },
      "fleet.search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "collapse": {
                  "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
                },
                "explain": {
                  "description": "If true, returns detailed information about score computation as part of a hit.",
                  "type": "boolean"
                },
                "ext": {
                  "description": "Configuration of search extensions defined by Elasticsearch plugins.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "from": {
                  "description": "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.",
                  "type": "number"
                },
                "highlight": {
                  "$ref": "#/components/schemas/_global.search._types:Highlight"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "indices_boost": {
                  "description": "Boosts the _score of documents from specified indices.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                "docvalue_fields": {
                  "description": "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "min_score": {
                  "description": "Minimum _score for matching documents. Documents with a lower _score are\nnot included in the search results.",
                  "type": "number"
                },
                "post_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "profile": {
                  "type": "boolean"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "rescore": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_global.search._types:Rescore"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.search._types:Rescore"
                      }
                    }
                  ]
                },
                "script_fields": {
                  "description": "Retrieve a script evaluation (based on different fields) for each hit.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types:ScriptField"
                  }
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                },
                "size": {
                  "description": "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.",
                  "type": "number"
                },
                "slice": {
                  "$ref": "#/components/schemas/_types:SlicedScroll"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "suggest": {
                  "$ref": "#/components/schemas/_global.search._types:Suggester"
                },
                "terminate_after": {
                  "description": "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.",
                  "type": "number"
                },
                "timeout": {
                  "description": "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
                  "type": "string"
                },
                "track_scores": {
                  "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
                  "type": "boolean"
                },
                "version": {
                  "description": "If true, returns document version as part of a hit.",
                  "type": "boolean"
                },
                "seq_no_primary_term": {
                  "description": "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.",
                  "type": "boolean"
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "pit": {
                  "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "stats": {
                  "description": "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "graph.explore": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "connections": {
                  "$ref": "#/components/schemas/graph._types:Hop"
                },
                "controls": {
                  "$ref": "#/components/schemas/graph._types:ExploreControls"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "vertices": {
                  "description": "Specifies one or more fields that contain the terms you want to include in the graph as vertices.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/graph._types:VertexDefinition"
                  }
                }
              }
            }
          }
        }
      },
      "index": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object"
            }
          }
        },
        "required": true
      },
      "indices.analyze": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "analyzer": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-analyzers.html"
                  },
                  "description": "The name of the analyzer that should be applied to the provided `text`.\nThis could be a built-in analyzer, or an analyzer thats been configured in the index.",
                  "type": "string"
                },
                "attributes": {
                  "description": "Array of token attributes used to filter the output of the `explain` parameter.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "char_filter": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-charfilters.html"
                  },
                  "description": "Array of character filters used to preprocess characters before the tokenizer.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.analysis:CharFilter"
                  }
                },
                "explain": {
                  "description": "If `true`, the response includes token attributes and additional details.",
                  "type": "boolean"
                },
                "field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "filter": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-tokenfilters.html"
                  },
                  "description": "Array of token filters used to apply after the tokenizer.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.analysis:TokenFilter"
                  }
                },
                "normalizer": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-normalizers.html"
                  },
                  "description": "Normalizer to use to convert text into a single token.",
                  "type": "string"
                },
                "text": {
                  "$ref": "#/components/schemas/indices.analyze:TextToAnalyze"
                },
                "tokenizer": {
                  "$ref": "#/components/schemas/_types.analysis:Tokenizer"
                }
              }
            }
          }
        }
      },
      "indices.put_alias": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "index_routing": {
                  "$ref": "#/components/schemas/_types:Routing"
                },
                "is_write_index": {
                  "description": "If `true`, sets the write index or data stream for the alias.\nIf an alias points to multiple indices or data streams and `is_write_index` isnt set, the alias rejects write requests.\nIf an index alias points to one index and `is_write_index` isnt set, the index automatically acts as the write index.\nData stream aliases dont automatically set a write data stream, even if the alias points to one data stream.",
                  "type": "boolean"
                },
                "routing": {
                  "$ref": "#/components/schemas/_types:Routing"
                },
                "search_routing": {
                  "$ref": "#/components/schemas/_types:Routing"
                }
              }
            }
          }
        }
      },
      "indices.put_index_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "index_patterns": {
                  "$ref": "#/components/schemas/_types:Indices"
                },
                "composed_of": {
                  "description": "An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:Name"
                  }
                },
                "template": {
                  "$ref": "#/components/schemas/indices.put_index_template:IndexTemplateMapping"
                },
                "data_stream": {
                  "$ref": "#/components/schemas/indices._types:DataStreamVisibility"
                },
                "priority": {
                  "description": "Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
                  "type": "number"
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                }
              }
            }
          }
        },
        "required": true
      },
      "indices.put_mapping": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "date_detection": {
                  "description": "Controls whether dynamic date detection is enabled.",
                  "type": "boolean"
                },
                "dynamic": {
                  "$ref": "#/components/schemas/_types.mapping:DynamicMapping"
                },
                "dynamic_date_formats": {
                  "description": "If date detection is enabled then new string fields are checked\nagainst 'dynamic_date_formats' and if the value matches then\na new date field is added instead of string.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "dynamic_templates": {
                  "description": "Specify dynamic templates for the mapping.",
                  "oneOf": [
                    {
                      "type": "object",
                      "additionalProperties": {
                        "$ref": "#/components/schemas/_types.mapping:DynamicTemplate"
                      }
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "additionalProperties": {
                          "$ref": "#/components/schemas/_types.mapping:DynamicTemplate"
                        }
                      }
                    }
                  ]
                },
                "_field_names": {
                  "$ref": "#/components/schemas/_types.mapping:FieldNamesField"
                },
                "_meta": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "numeric_detection": {
                  "description": "Automatically map strings into numeric data types for all fields.",
                  "type": "boolean"
                },
                "properties": {
                  "description": "Mapping for a field. For new fields, this mapping can include:\n\n- Field name\n- Field data type\n- Mapping parameters",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.mapping:Property"
                  }
                },
                "_routing": {
                  "$ref": "#/components/schemas/_types.mapping:RoutingField"
                },
                "_source": {
                  "$ref": "#/components/schemas/_types.mapping:SourceField"
                },
                "runtime": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                }
              }
            }
          }
        },
        "required": true
      },
      "indices.put_settings": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/indices._types:IndexSettings"
            }
          }
        },
        "required": true
      },
      "indices.put_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "Aliases for the index.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "index_patterns": {
                  "description": "Array of wildcard expressions used to match the names\nof indices during creation.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                },
                "mappings": {
                  "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                },
                "order": {
                  "description": "Order in which Elasticsearch applies this template if index\nmatches multiple templates.\n\nTemplates with lower 'order' values are merged first. Templates with higher\n'order' values are merged later, overriding templates with lower values.",
                  "type": "number"
                },
                "settings": {
                  "description": "Configuration options for the index.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "version": {
                  "$ref": "#/components/schemas/_types:VersionNumber"
                }
              }
            }
          }
        },
        "required": true
      },
      "indices.rollover": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aliases": {
                  "description": "Aliases for the target index.\nData streams do not support this parameter.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/indices._types:Alias"
                  }
                },
                "conditions": {
                  "$ref": "#/components/schemas/indices.rollover:RolloverConditions"
                },
                "mappings": {
                  "$ref": "#/components/schemas/_types.mapping:TypeMapping"
                },
                "settings": {
                  "description": "Configuration options for the index.\nData streams do not support this parameter.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "indices.simulate_template": {
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/indices._types:IndexTemplate"
            }
          }
        }
      },
      "indices.validate_query": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            }
          }
        }
      },
      "ingest.simulate": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "Sample documents to test in the pipeline.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/ingest.simulate:Document"
                  }
                },
                "pipeline": {
                  "$ref": "#/components/schemas/ingest._types:Pipeline"
                }
              }
            }
          }
        },
        "required": true
      },
      "mget": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "The documents you want to retrieve. Required if no index is specified in the request URI.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mget:Operation"
                  }
                },
                "ids": {
                  "$ref": "#/components/schemas/_types:Ids"
                }
              }
            }
          }
        },
        "required": true
      },
      "ml.delete_expired_data": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "requests_per_second": {
                  "description": "The desired requests per second for the deletion processes. The default\nbehavior is no throttling.",
                  "type": "number"
                },
                "timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                }
              }
            }
          }
        }
      },
      "ml.explain_data_frame_analytics": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "source": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
                },
                "dest": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
                },
                "analysis": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
                },
                "description": {
                  "description": "A description of the job.",
                  "type": "string"
                },
                "model_memory_limit": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
                  },
                  "description": "The approximate maximum amount of memory resources that are permitted for\nanalytical processing. If your `elasticsearch.yml` file contains an\n`xpack.ml.max_model_memory_limit` setting, an error occurs when you try to\ncreate data frame analytics jobs that have `model_memory_limit` values\ngreater than that setting.",
                  "type": "string"
                },
                "max_num_threads": {
                  "description": "The maximum number of threads to be used by the analysis. Using more\nthreads may decrease the time necessary to complete the analysis at the\ncost of using more CPU. Note that the process may use additional threads\nfor operational functionality other than the analysis itself.",
                  "type": "number"
                },
                "analyzed_fields": {
                  "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
                },
                "allow_lazy_start": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
                  },
                  "description": "Specifies whether this job can start when there is insufficient machine\nlearning node capacity for it to be immediately assigned to a node.",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "ml.get_buckets": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "anomaly_score": {
                  "description": "Refer to the description for the `anomaly_score` query parameter.",
                  "type": "number"
                },
                "desc": {
                  "description": "Refer to the description for the `desc` query parameter.",
                  "type": "boolean"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "exclude_interim": {
                  "description": "Refer to the description for the `exclude_interim` query parameter.",
                  "type": "boolean"
                },
                "expand": {
                  "description": "Refer to the description for the `expand` query parameter.",
                  "type": "boolean"
                },
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                }
              }
            }
          }
        }
      },
      "ml.get_calendars": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                }
              }
            }
          }
        }
      },
      "ml.get_categories": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                }
              }
            }
          }
        }
      },
      "ml.get_influencers": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                }
              }
            }
          }
        }
      },
      "ml.get_model_snapshots": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "desc": {
                  "description": "Refer to the description for the `desc` query parameter.",
                  "type": "boolean"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                }
              }
            }
          }
        }
      },
      "ml.get_overall_buckets": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "allow_no_match": {
                  "description": "Refer to the description for the `allow_no_match` query parameter.",
                  "type": "boolean"
                },
                "bucket_span": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "exclude_interim": {
                  "description": "Refer to the description for the `exclude_interim` query parameter.",
                  "type": "boolean"
                },
                "overall_score": {
                  "description": "Refer to the description for the `overall_score` query parameter.",
                  "oneOf": [
                    {
                      "type": "number"
                    },
                    {
                      "type": "string"
                    }
                  ]
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "top_n": {
                  "description": "Refer to the description for the `top_n` query parameter.",
                  "type": "number"
                }
              }
            }
          }
        }
      },
      "ml.get_records": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "desc": {
                  "description": "Refer to the description for the `desc` query parameter.",
                  "type": "boolean"
                },
                "end": {
                  "$ref": "#/components/schemas/_types:DateTime"
                },
                "exclude_interim": {
                  "description": "Refer to the description for the `exclude_interim` query parameter.",
                  "type": "boolean"
                },
                "page": {
                  "$ref": "#/components/schemas/ml._types:Page"
                },
                "record_score": {
                  "description": "Refer to the description for the `record_score` query parameter.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "start": {
                  "$ref": "#/components/schemas/_types:DateTime"
                }
              }
            }
          }
        }
      },
      "ml.infer_trained_model": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "An array of objects to pass to the model for inference. The objects should contain a fields matching your\nconfigured trained model input. Typically, for NLP models, the field name is `text_field`.\nCurrently, for NLP models, only a single value is allowed.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "object"
                    }
                  }
                },
                "inference_config": {
                  "$ref": "#/components/schemas/ml._types:InferenceConfigUpdateContainer"
                }
              },
              "required": [
                "docs"
              ]
            }
          }
        },
        "required": true
      },
      "ml.preview_data_frame_analytics": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "config": {
                  "$ref": "#/components/schemas/ml.preview_data_frame_analytics:DataframePreviewConfig"
                }
              }
            }
          }
        }
      },
      "ml.preview_datafeed": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "datafeed_config": {
                  "$ref": "#/components/schemas/ml._types:DatafeedConfig"
                },
                "job_config": {
                  "$ref": "#/components/schemas/ml._types:JobConfig"
                }
              }
            }
          }
        }
      },
      "msearch": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.msearch:RequestItem"
              }
            }
          }
        },
        "required": true
      },
      "msearch_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.msearch_template:RequestItem"
              }
            }
          }
        },
        "required": true
      },
      "mtermvectors": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "docs": {
                  "description": "Array of existing or artificial documents.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.mtermvectors:Operation"
                  }
                },
                "ids": {
                  "description": "Simplified syntax to specify documents by their ID if they're in the same index.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types:Id"
                  }
                }
              }
            }
          }
        }
      },
      "put_script": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "script": {
                  "$ref": "#/components/schemas/_types:StoredScript"
                }
              },
              "required": [
                "script"
              ]
            }
          }
        },
        "required": true
      },
      "rank_eval": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "requests": {
                  "description": "A set of typical search requests, together with their provided ratings.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_global.rank_eval:RankEvalRequestItem"
                  }
                },
                "metric": {
                  "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetric"
                }
              },
              "required": [
                "requests"
              ]
            }
          }
        },
        "required": true
      },
      "render_search_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "file": {
                  "type": "string"
                },
                "params": {
                  "description": "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "source": {
                  "description": "An inline search template.\nSupports the same parameters as the search API's request body.\nThese parameters also support Mustache variables.\nIf no `id` or `<templated-id>` is specified, this parameter is required.",
                  "type": "string"
                }
              }
            }
          }
        }
      },
      "scripts_painless_execute": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "context": {
                  "description": "The context that the script should run in.",
                  "type": "string"
                },
                "context_setup": {
                  "$ref": "#/components/schemas/_global.scripts_painless_execute:PainlessContextSetup"
                },
                "script": {
                  "$ref": "#/components/schemas/_types:InlineScript"
                }
              }
            }
          }
        }
      },
      "scroll": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "scroll": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "scroll_id": {
                  "$ref": "#/components/schemas/_types:ScrollId"
                }
              },
              "required": [
                "scroll_id"
              ]
            }
          }
        }
      },
      "search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggregations": {
                  "description": "Defines the aggregations that are run as part of the search request.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "collapse": {
                  "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
                },
                "explain": {
                  "description": "If true, returns detailed information about score computation as part of a hit.",
                  "type": "boolean"
                },
                "ext": {
                  "description": "Configuration of search extensions defined by Elasticsearch plugins.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "from": {
                  "description": "Starting document offset.\nNeeds to be non-negative.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "highlight": {
                  "$ref": "#/components/schemas/_global.search._types:Highlight"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "indices_boost": {
                  "description": "Boosts the _score of documents from specified indices.",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  }
                },
                "docvalue_fields": {
                  "description": "Array of wildcard (`*`) patterns.\nThe request returns doc values for field names matching these patterns in the `hits.fields` property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "knn": {
                  "description": "Defines the approximate kNN search to run.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types:KnnQuery"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:KnnQuery"
                      }
                    }
                  ]
                },
                "rank": {
                  "$ref": "#/components/schemas/_types:RankContainer"
                },
                "min_score": {
                  "description": "Minimum `_score` for matching documents.\nDocuments with a lower `_score` are not included in the search results.",
                  "type": "number"
                },
                "post_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "profile": {
                  "description": "Set to `true` to return detailed timing information about the execution of individual components in a search request.\nNOTE: This is a debugging tool and adds significant overhead to search execution.",
                  "type": "boolean"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "rescore": {
                  "description": "Can be used to improve precision by reordering just the top (for example 100 - 500) documents returned by the `query` and `post_filter` phases.",
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_global.search._types:Rescore"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_global.search._types:Rescore"
                      }
                    }
                  ]
                },
                "script_fields": {
                  "description": "Retrieve a script evaluation (based on different fields) for each hit.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types:ScriptField"
                  }
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                },
                "size": {
                  "description": "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "slice": {
                  "$ref": "#/components/schemas/_types:SlicedScroll"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "_source": {
                  "$ref": "#/components/schemas/_global.search._types:SourceConfig"
                },
                "fields": {
                  "description": "Array of wildcard (`*`) patterns.\nThe request returns values for field names matching these patterns in the `hits.fields` property of the response.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
                  }
                },
                "suggest": {
                  "$ref": "#/components/schemas/_global.search._types:Suggester"
                },
                "terminate_after": {
                  "description": "Maximum number of documents to collect for each shard.\nIf a query reaches this limit, Elasticsearch terminates the query early.\nElasticsearch collects documents before sorting.\nUse with caution.\nElasticsearch applies this parameter to each shard handling the request.\nWhen possible, let Elasticsearch perform early termination automatically.\nAvoid specifying this parameter for requests that target data streams with backing indices across multiple data tiers.\nIf set to `0` (default), the query does not terminate early.",
                  "type": "number"
                },
                "timeout": {
                  "description": "Specifies the period of time to wait for a response from each shard.\nIf no response is received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
                  "type": "string"
                },
                "track_scores": {
                  "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
                  "type": "boolean"
                },
                "version": {
                  "description": "If true, returns document version as part of a hit.",
                  "type": "boolean"
                },
                "seq_no_primary_term": {
                  "description": "If `true`, returns sequence number and primary term of the last modification of each hit.",
                  "type": "boolean"
                },
                "stored_fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "pit": {
                  "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "stats": {
                  "description": "Stats groups to associate with the search.\nEach group maintains a statistics aggregation for its associated searches.\nYou can retrieve these stats using the indices stats API.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "search_application.search": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "params": {
                  "description": "Query parameters specific to this request, which will override any defaults specified in the template.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        }
      },
      "search_mvt": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "aggs": {
                  "description": "Sub-aggregations for the geotile_grid.\n\nSupports the following aggregation types:\n- avg\n- cardinality\n- max\n- min\n- sum",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                  }
                },
                "buffer": {
                  "description": "Size, in pixels, of a clipping buffer outside the tile. This allows renderers\nto avoid outline artifacts from geometries that extend past the extent of the tile.",
                  "type": "number"
                },
                "exact_bounds": {
                  "description": "If false, the meta layers feature is the bounding box of the tile.\nIf true, the meta layers feature is a bounding box resulting from a\ngeo_bounds aggregation. The aggregation runs on <field> values that intersect\nthe <zoom>/<x>/<y> tile with wrap_longitude set to false. The resulting\nbounding box may be larger than the vector tile.",
                  "type": "boolean"
                },
                "extent": {
                  "description": "Size, in pixels, of a side of the tile. Vector tiles are square with equal sides.",
                  "type": "number"
                },
                "fields": {
                  "$ref": "#/components/schemas/_types:Fields"
                },
                "grid_agg": {
                  "$ref": "#/components/schemas/_global.search_mvt._types:GridAggregationType"
                },
                "grid_precision": {
                  "description": "Additional zoom levels available through the aggs layer. For example, if <zoom> is 7\nand grid_precision is 8, you can zoom in up to level 15. Accepts 0-8. If 0, results\ndont include the aggs layer.",
                  "type": "number"
                },
                "grid_type": {
                  "$ref": "#/components/schemas/_global.search_mvt._types:GridType"
                },
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "runtime_mappings": {
                  "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
                },
                "size": {
                  "description": "Maximum number of features to return in the hits layer. Accepts 0-10000.\nIf 0, results dont include the hits layer.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "track_total_hits": {
                  "$ref": "#/components/schemas/_global.search._types:TrackHits"
                },
                "with_labels": {
                  "description": "If `true`, the hits and aggs layers will contain additional point features representing\nsuggested label positions for the original features.",
                  "type": "boolean"
                }
              }
            }
          }
        }
      },
      "search_template": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "explain": {
                  "description": "If `true`, returns detailed information about score calculation as part of each hit.",
                  "type": "boolean"
                },
                "id": {
                  "$ref": "#/components/schemas/_types:Id"
                },
                "params": {
                  "description": "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "profile": {
                  "description": "If `true`, the query execution is profiled.",
                  "type": "boolean"
                },
                "source": {
                  "description": "An inline search template. Supports the same parameters as the search API's\nrequest body. Also supports Mustache variables. If no id is specified, this\nparameter is required.",
                  "type": "string"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.create_api_key": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "expiration": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "name": {
                  "$ref": "#/components/schemas/_types:Name"
                },
                "role_descriptors": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-put-role.html"
                  },
                  "description": "An array of role descriptors for this API key. This parameter is optional. When it is not specified or is an empty array, then the API key will have a point in time snapshot of permissions of the authenticated user. If you supply role descriptors then the resultant permissions would be an intersection of API keys permissions and authenticated users permissions thereby limiting the access scope for API keys. The structure of role descriptor is the same as the request for create role API. For more details, see create or update roles API.",
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security._types:RoleDescriptor"
                  }
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.has_privileges": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "application": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security.has_privileges:ApplicationPrivilegesCheck"
                  }
                },
                "cluster": {
                  "description": "A list of the cluster privileges that you want to check.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ClusterPrivilege"
                  }
                },
                "index": {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security.has_privileges:IndexPrivilegesCheck"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "security.has_privileges_user_profile": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "uids": {
                  "description": "A list of profile IDs. The privileges are checked for associated users of the profiles.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:UserProfileId"
                  }
                },
                "privileges": {
                  "$ref": "#/components/schemas/security.has_privileges_user_profile:PrivilegesCheck"
                }
              },
              "required": [
                "uids",
                "privileges"
              ]
            }
          }
        },
        "required": true
      },
      "security.put_privileges": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security.put_privileges:Actions"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.put_role": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "applications": {
                  "description": "A list of application privilege entries.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
                  }
                },
                "cluster": {
                  "description": "A list of cluster privileges. These privileges define the cluster-level actions for users with this role.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:ClusterPrivilege"
                  }
                },
                "global": {
                  "description": "An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "indices": {
                  "description": "A list of indices permissions entries.",
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/security._types:IndicesPrivileges"
                  }
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "run_as": {
                  "externalDocs": {
                    "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/run-as-privilege.html"
                  },
                  "description": "A list of users that the owners of this role can impersonate.",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "transient_metadata": {
                  "$ref": "#/components/schemas/security._types:TransientMetadataConfig"
                }
              }
            }
          }
        },
        "required": true
      },
      "security.put_role_mapping": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "enabled": {
                  "type": "boolean"
                },
                "metadata": {
                  "$ref": "#/components/schemas/_types:Metadata"
                },
                "roles": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "rules": {
                  "$ref": "#/components/schemas/security._types:RoleMappingRule"
                },
                "run_as": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "security.query_api_keys": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "query": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "from": {
                  "description": "Starting document offset.\nBy default, you cannot page through more than 10,000 hits using the from and size parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "sort": {
                  "$ref": "#/components/schemas/_types:Sort"
                },
                "size": {
                  "description": "The number of hits to return.\nBy default, you cannot page through more than 10,000 hits using the `from` and `size` parameters.\nTo page through more hits, use the `search_after` parameter.",
                  "type": "number"
                },
                "search_after": {
                  "$ref": "#/components/schemas/_types:SortResults"
                }
              }
            }
          }
        }
      },
      "security.suggest_user_profiles": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "name": {
                  "description": "Query string used to match name-related fields in user profile documents.\nName-related fields are the user's `username`, `full_name`, and `email`.",
                  "type": "string"
                },
                "size": {
                  "description": "Number of profiles to return.",
                  "type": "number"
                },
                "data": {
                  "description": "List of filters for the `data` field of the profile document.\nTo return all content use `data=*`. To return a subset of content\nuse `data=<key>` to retrieve content nested under the specified `<key>`.\nBy default returns no `data` content.",
                  "oneOf": [
                    {
                      "type": "string"
                    },
                    {
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  ]
                },
                "hint": {
                  "$ref": "#/components/schemas/security.suggest_user_profiles:Hint"
                }
              }
            }
          }
        }
      },
      "security.update_user_profile_data": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "labels": {
                  "description": "Searchable data that you want to associate with the user profile. This\nfield supports a nested data structure.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                },
                "data": {
                  "description": "Non-searchable data that you want to associate with the user profile.\nThis field supports a nested data structure.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "object"
                  }
                }
              }
            }
          }
        },
        "required": true
      },
      "terms_enum": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "field": {
                  "$ref": "#/components/schemas/_types:Field"
                },
                "size": {
                  "description": "How many matching terms to return.",
                  "type": "number"
                },
                "timeout": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "case_insensitive": {
                  "description": "When true the provided search string is matched against index terms without case sensitivity.",
                  "type": "boolean"
                },
                "index_filter": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                },
                "string": {
                  "description": "The string after which terms in the index should be returned. Allows for a form of pagination if the last result from one request is passed as the search_after parameter for a subsequent request.",
                  "type": "string"
                },
                "search_after": {
                  "type": "string"
                }
              },
              "required": [
                "field"
              ]
            }
          }
        }
      },
      "termvectors": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "doc": {
                  "description": "An artificial document (a document not present in the index) for which you want to retrieve term vectors.",
                  "type": "object"
                },
                "filter": {
                  "$ref": "#/components/schemas/_global.termvectors:Filter"
                },
                "per_field_analyzer": {
                  "description": "Overrides the default per-field analyzer.",
                  "type": "object",
                  "additionalProperties": {
                    "type": "string"
                  }
                }
              }
            }
          }
        }
      },
      "transform.preview_transform": {
        "content": {
          "application/json": {
            "schema": {
              "type": "object",
              "properties": {
                "dest": {
                  "$ref": "#/components/schemas/transform._types:Destination"
                },
                "description": {
                  "description": "Free text description of the transform.",
                  "type": "string"
                },
                "frequency": {
                  "$ref": "#/components/schemas/_types:Duration"
                },
                "pivot": {
                  "$ref": "#/components/schemas/transform._types:Pivot"
                },
                "source": {
                  "$ref": "#/components/schemas/transform._types:Source"
                },
                "settings": {
                  "$ref": "#/components/schemas/transform._types:Settings"
                },
                "sync": {
                  "$ref": "#/components/schemas/transform._types:SyncContainer"
                },
                "retention_policy": {
                  "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
                },
                "latest": {
                  "$ref": "#/components/schemas/transform._types:Latest"
                }
              }
            }
          }
        }
      }
    },
    "schemas": {
      "_types:Id": {
        "type": "string"
      },
      "_types:AcknowledgedResponseBase": {
        "type": "object",
        "properties": {
          "acknowledged": {
            "description": "For a successful response, this value is always true. On failure, an exception is returned instead.",
            "type": "boolean"
          }
        },
        "required": [
          "acknowledged"
        ]
      },
      "_types:Duration": {
        "externalDocs": {
          "url": "https://github.com/elastic/elasticsearch/blob/current/libs/core/src/main/java/org/elasticsearch/core/TimeValue.java"
        },
        "description": "A duration. Units can be `nanos`, `micros`, `ms` (milliseconds), `s` (seconds), `m` (minutes), `h` (hours) and\n`d` (days). Also accepts \"0\" without a unit and \"-1\" to indicate an unspecified value.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "string",
            "enum": [
              "-1"
            ]
          },
          {
            "type": "string",
            "enum": [
              "0"
            ]
          }
        ]
      },
      "async_search._types:AsyncSearchDocumentResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/async_search._types:AsyncSearchResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "response": {
                "$ref": "#/components/schemas/async_search._types:AsyncSearch"
              }
            },
            "required": [
              "response"
            ]
          }
        ]
      },
      "async_search._types:AsyncSearch": {
        "type": "object",
        "properties": {
          "aggregations": {
            "description": "Partial aggregations results, coming from the shards that have already completed the execution of the query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:Aggregate"
            }
          },
          "_clusters": {
            "$ref": "#/components/schemas/_types:ClusterStatistics"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "hits": {
            "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
          },
          "max_score": {
            "type": "number"
          },
          "num_reduce_phases": {
            "description": "Indicates how many reductions of the results have been performed.\nIf this number increases compared to the last retrieved results for a get asynch search request, you can expect additional results included in the search response.",
            "type": "number"
          },
          "profile": {
            "$ref": "#/components/schemas/_global.search._types:Profile"
          },
          "pit_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_scroll_id": {
            "$ref": "#/components/schemas/_types:ScrollId"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "suggest": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.search._types:Suggest"
              }
            }
          },
          "terminated_early": {
            "type": "boolean"
          },
          "timed_out": {
            "type": "boolean"
          },
          "took": {
            "type": "number"
          }
        },
        "required": [
          "hits",
          "_shards",
          "timed_out",
          "took"
        ]
      },
      "_types.aggregations:Aggregate": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CardinalityAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HdrPercentilesAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HdrPercentileRanksAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TDigestPercentilesAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TDigestPercentileRanksAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesBucketAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MedianAbsoluteDeviationAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MinAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MaxAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SumAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:AvgAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:WeightedAvgAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ValueCountAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SimpleValueAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DerivativeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketMetricValueAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsBucketAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsBucketAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoBoundsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoCentroidAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DateHistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:AutoDateHistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:LongTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DoubleTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:LongRareTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringRareTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedRareTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MissingAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:NestedAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ReverseNestedAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GlobalAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FilterAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ChildrenAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ParentAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SamplerAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedSamplerAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoHashGridAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoTileGridAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoHexGridAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:DateRangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoDistanceAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:IpRangeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:IpPrefixAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FiltersAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantLongTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantStringTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:UnmappedSignificantTermsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:ScriptedMetricAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TopHitsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:InferenceAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:StringStatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:BoxPlotAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TopMetricsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TTestAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:RateAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CumulativeCardinalityAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:MatrixStatsAggregate"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:GeoLineAggregate"
          }
        ]
      },
      "_types.aggregations:CardinalityAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:AggregateBase": {
        "type": "object",
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        }
      },
      "_types:Metadata": {
        "type": "object",
        "additionalProperties": {
          "type": "object"
        }
      },
      "_types.aggregations:HdrPercentilesAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:PercentilesAggregateBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/_types.aggregations:Percentiles"
              }
            },
            "required": [
              "values"
            ]
          }
        ]
      },
      "_types.aggregations:Percentiles": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:KeyedPercentiles"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:ArrayPercentilesItem"
            }
          }
        ]
      },
      "_types.aggregations:KeyedPercentiles": {
        "type": "object",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "number"
            },
            {
              "nullable": true,
              "type": "string"
            }
          ]
        }
      },
      "_types.aggregations:ArrayPercentilesItem": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "value_as_string": {
            "type": "string"
          }
        },
        "required": [
          "key",
          "value"
        ]
      },
      "_types.aggregations:HdrPercentileRanksAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TDigestPercentilesAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TDigestPercentileRanksAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:PercentilesBucketAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MedianAbsoluteDeviationAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SingleMetricAggregateBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "description": "The metric value. A missing value generally means that there was no data to aggregate,\nunless specified otherwise.",
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:MinAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MaxAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SumAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:AvgAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:WeightedAvgAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ValueCountAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SimpleValueAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:DerivativeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "normalized_value": {
                "type": "number"
              },
              "normalized_value_as_string": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketMetricValueAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleMetricAggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "keys": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "keys"
            ]
          }
        ]
      },
      "_types.aggregations:StatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "min": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "max": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "avg": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "sum": {
                "type": "number"
              },
              "min_as_string": {
                "type": "string"
              },
              "max_as_string": {
                "type": "string"
              },
              "avg_as_string": {
                "type": "string"
              },
              "sum_as_string": {
                "type": "string"
              }
            },
            "required": [
              "count",
              "min",
              "max",
              "avg",
              "sum"
            ]
          }
        ]
      },
      "_types.aggregations:StatsBucketAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ExtendedStatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:StatsAggregate"
          },
          {
            "type": "object",
            "properties": {
              "sum_of_squares": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "variance": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "variance_population": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "variance_sampling": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation_population": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation_sampling": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "std_deviation_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:StandardDeviationBounds"
              },
              "sum_of_squares_as_string": {
                "type": "string"
              },
              "variance_as_string": {
                "type": "string"
              },
              "variance_population_as_string": {
                "type": "string"
              },
              "variance_sampling_as_string": {
                "type": "string"
              },
              "std_deviation_as_string": {
                "type": "string"
              },
              "std_deviation_bounds_as_string": {
                "$ref": "#/components/schemas/_types.aggregations:StandardDeviationBoundsAsString"
              }
            },
            "required": [
              "sum_of_squares",
              "variance",
              "variance_population",
              "variance_sampling",
              "std_deviation",
              "std_deviation_population",
              "std_deviation_sampling"
            ]
          }
        ]
      },
      "_types.aggregations:StandardDeviationBounds": {
        "type": "object",
        "properties": {
          "upper": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "lower": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "upper_population": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "lower_population": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "upper_sampling": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "lower_sampling": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "upper",
          "lower",
          "upper_population",
          "lower_population",
          "upper_sampling",
          "lower_sampling"
        ]
      },
      "_types.aggregations:StandardDeviationBoundsAsString": {
        "type": "object",
        "properties": {
          "upper": {
            "type": "string"
          },
          "lower": {
            "type": "string"
          },
          "upper_population": {
            "type": "string"
          },
          "lower_population": {
            "type": "string"
          },
          "upper_sampling": {
            "type": "string"
          },
          "lower_sampling": {
            "type": "string"
          }
        },
        "required": [
          "upper",
          "lower",
          "upper_population",
          "lower_population",
          "upper_sampling",
          "lower_sampling"
        ]
      },
      "_types.aggregations:ExtendedStatsBucketAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GeoBoundsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              }
            }
          }
        ]
      },
      "_types:GeoBounds": {
        "description": "A geo bounding box. It can be represented in various ways:\n- as 4 top/bottom/left/right coordinates\n- as 2 top_left / bottom_right points\n- as 2 top_right / bottom_left points\n- as a WKT bounding box",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:CoordsGeoBounds"
          },
          {
            "$ref": "#/components/schemas/_types:TopLeftBottomRightGeoBounds"
          },
          {
            "$ref": "#/components/schemas/_types:TopRightBottomLeftGeoBounds"
          },
          {
            "$ref": "#/components/schemas/_types:WktGeoBounds"
          }
        ]
      },
      "_types:CoordsGeoBounds": {
        "type": "object",
        "properties": {
          "top": {
            "type": "number"
          },
          "bottom": {
            "type": "number"
          },
          "left": {
            "type": "number"
          },
          "right": {
            "type": "number"
          }
        },
        "required": [
          "top",
          "bottom",
          "left",
          "right"
        ]
      },
      "_types:TopLeftBottomRightGeoBounds": {
        "type": "object",
        "properties": {
          "top_left": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          },
          "bottom_right": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          }
        },
        "required": [
          "top_left",
          "bottom_right"
        ]
      },
      "_types:GeoLocation": {
        "description": "A latitude/longitude as a 2 dimensional point. It can be represented in various ways:\n- as a `{lat, long}` object\n- as a geo hash value\n- as a `[lon, lat]` array\n- as a string in `\"<lat>, <lon>\"` or WKT point formats",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:LatLonGeoLocation"
          },
          {
            "$ref": "#/components/schemas/_types:GeoHashLocation"
          },
          {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:LatLonGeoLocation": {
        "type": "object",
        "properties": {
          "lat": {
            "description": "Latitude",
            "type": "number"
          },
          "lon": {
            "description": "Longitude",
            "type": "number"
          }
        },
        "required": [
          "lat",
          "lon"
        ]
      },
      "_types:GeoHashLocation": {
        "type": "object",
        "properties": {
          "geohash": {
            "$ref": "#/components/schemas/_types:GeoHash"
          }
        },
        "required": [
          "geohash"
        ]
      },
      "_types:GeoHash": {
        "type": "string"
      },
      "_types:TopRightBottomLeftGeoBounds": {
        "type": "object",
        "properties": {
          "top_right": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          },
          "bottom_left": {
            "$ref": "#/components/schemas/_types:GeoLocation"
          }
        },
        "required": [
          "top_right",
          "bottom_left"
        ]
      },
      "_types:WktGeoBounds": {
        "type": "object",
        "properties": {
          "wkt": {
            "type": "string"
          }
        },
        "required": [
          "wkt"
        ]
      },
      "_types.aggregations:GeoCentroidAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "location": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              }
            },
            "required": [
              "count"
            ]
          }
        ]
      },
      "_types.aggregations:HistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseHistogramBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsHistogramBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsHistogramBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:HistogramBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:HistogramBucket"
            }
          }
        ]
      },
      "_types.aggregations:HistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key_as_string": {
                "type": "string"
              },
              "key": {
                "type": "number"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:MultiBucketBase": {
        "type": "object",
        "properties": {
          "doc_count": {
            "type": "number"
          }
        },
        "required": [
          "doc_count"
        ]
      },
      "_types.aggregations:DateHistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseDateHistogramBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseDateHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsDateHistogramBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsDateHistogramBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:DateHistogramBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:DateHistogramBucket"
            }
          }
        ]
      },
      "_types.aggregations:DateHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key_as_string": {
                "type": "string"
              },
              "key": {
                "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:EpochTimeUnitMillis": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitMillis"
          }
        ]
      },
      "_types:UnitMillis": {
        "description": "Time unit for milliseconds",
        "type": "number"
      },
      "_types.aggregations:AutoDateHistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseDateHistogramBucket"
          },
          {
            "type": "object",
            "properties": {
              "interval": {
                "$ref": "#/components/schemas/_types:DurationLarge"
              }
            },
            "required": [
              "interval"
            ]
          }
        ]
      },
      "_types:DurationLarge": {
        "description": "A date histogram interval. Similar to `Duration` with additional units: `w` (week), `M` (month), `q` (quarter) and\n`y` (year)",
        "type": "string"
      },
      "_types.aggregations:VariableWidthHistogramAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVariableWidthHistogramBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseVariableWidthHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsVariableWidthHistogramBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsVariableWidthHistogramBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramBucket"
            }
          }
        ]
      },
      "_types.aggregations:VariableWidthHistogramBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "min": {
                "type": "number"
              },
              "key": {
                "type": "number"
              },
              "max": {
                "type": "number"
              },
              "min_as_string": {
                "type": "string"
              },
              "key_as_string": {
                "type": "string"
              },
              "max_as_string": {
                "type": "string"
              }
            },
            "required": [
              "min",
              "key",
              "max"
            ]
          }
        ]
      },
      "_types.aggregations:StringTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseStringTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseStringTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsStringTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsStringTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:StringTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:StringTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:StringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:FieldValue"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:FieldValue": {
        "description": "A field value.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "number"
          },
          {
            "type": "string"
          },
          {
            "type": "boolean"
          },
          {
            "nullable": true,
            "type": "string"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsBucketBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:LongTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseLongTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseLongTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsLongTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsLongTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:LongTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:LongTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:LongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:DoubleTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseDoubleTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseDoubleTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseDoubleTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseDoubleTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsDoubleTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsDoubleTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:DoubleTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:DoubleTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:DoubleTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:UnmappedTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseVoid"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseVoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVoid"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseVoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsVoid"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsVoid": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_spec_utils:Void"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_spec_utils:Void"
            }
          }
        ]
      },
      "_spec_utils:Void": {
        "description": "The absence of any type. This is commonly used in APIs that don't return a body.\n\nAlthough \"void\" is generally used for the unit type that has only one value, this is to be interpreted as\nthe bottom type that has no value at all. Most languages have a unit type, but few have a bottom type.\n\nSee https://en.m.wikipedia.org/wiki/Unit_type and https://en.m.wikipedia.org/wiki/Bottom_type",
        "type": "object"
      },
      "_types.aggregations:LongRareTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseLongRareTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseLongRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsLongRareTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsLongRareTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:LongRareTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:LongRareTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:LongRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:StringRareTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseStringRareTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseStringRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsStringRareTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsStringRareTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:StringRareTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:StringRareTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:StringRareTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:UnmappedRareTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVoid"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregateBaseMultiTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregateBaseMultiTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseMultiTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "doc_count_error_upper_bound": {
                "type": "number"
              },
              "sum_other_doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseMultiTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsMultiTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsMultiTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:MultiTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:MultiTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:MultiTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:FieldValue"
                }
              },
              "key_as_string": {
                "type": "string"
              },
              "doc_count_error_upper_bound": {
                "type": "number"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:MissingAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SingleBucketAggregateBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_count": {
                "type": "number"
              }
            },
            "required": [
              "doc_count"
            ]
          }
        ]
      },
      "_types.aggregations:NestedAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ReverseNestedAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GlobalAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:FilterAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ChildrenAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:ParentAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SamplerAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:UnmappedSamplerAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SingleBucketAggregateBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GeoHashGridAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseGeoHashGridBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseGeoHashGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsGeoHashGridBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsGeoHashGridBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHashGridBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHashGridBucket"
            }
          }
        ]
      },
      "_types.aggregations:GeoHashGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:GeoHash"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:GeoTileGridAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseGeoTileGridBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseGeoTileGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsGeoTileGridBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsGeoTileGridBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:GeoTileGridBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:GeoTileGridBucket"
            }
          }
        ]
      },
      "_types.aggregations:GeoTileGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:GeoTile"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:GeoTile": {
        "description": "A map tile reference, represented as `{zoom}/{x}/{y}`",
        "type": "string"
      },
      "_types.aggregations:GeoHexGridAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseGeoHexGridBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseGeoHexGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsGeoHexGridBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsGeoHexGridBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHexGridBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:GeoHexGridBucket"
            }
          }
        ]
      },
      "_types.aggregations:GeoHexGridBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types:GeoHexCell"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types:GeoHexCell": {
        "description": "A map hex cell (H3) reference",
        "type": "string"
      },
      "_types.aggregations:RangeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseRangeBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseRangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsRangeBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsRangeBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:RangeBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:RangeBucket"
            }
          }
        ]
      },
      "_types.aggregations:RangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "from": {
                "type": "number"
              },
              "to": {
                "type": "number"
              },
              "from_as_string": {
                "type": "string"
              },
              "to_as_string": {
                "type": "string"
              },
              "key": {
                "description": "The bucket key. Present if the aggregation is _not_ keyed",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:DateRangeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:GeoDistanceAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:RangeAggregate"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:IpRangeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseIpRangeBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseIpRangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsIpRangeBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsIpRangeBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:IpRangeBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:IpRangeBucket"
            }
          }
        ]
      },
      "_types.aggregations:IpRangeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              },
              "from": {
                "type": "string"
              },
              "to": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:IpPrefixAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseIpPrefixBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseIpPrefixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsIpPrefixBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsIpPrefixBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:IpPrefixBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:IpPrefixBucket"
            }
          }
        ]
      },
      "_types.aggregations:IpPrefixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "is_ipv6": {
                "type": "boolean"
              },
              "key": {
                "type": "string"
              },
              "prefix_length": {
                "type": "number"
              },
              "netmask": {
                "type": "string"
              }
            },
            "required": [
              "is_ipv6",
              "key",
              "prefix_length"
            ]
          }
        ]
      },
      "_types.aggregations:FiltersAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseFiltersBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseFiltersBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsFiltersBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsFiltersBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:FiltersBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:FiltersBucket"
            }
          }
        ]
      },
      "_types.aggregations:FiltersBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:AdjacencyMatrixAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseAdjacencyMatrixBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseAdjacencyMatrixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsAdjacencyMatrixBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsAdjacencyMatrixBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixBucket"
            }
          }
        ]
      },
      "_types.aggregations:AdjacencyMatrixBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:SignificantLongTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregateBaseSignificantLongTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregateBaseSignificantLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseSignificantLongTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "bg_count": {
                "type": "number"
              },
              "doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseSignificantLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsSignificantLongTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsSignificantLongTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantLongTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantLongTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:SignificantLongTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "number"
              },
              "key_as_string": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:SignificantTermsBucketBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "score": {
                "type": "number"
              },
              "bg_count": {
                "type": "number"
              }
            },
            "required": [
              "score",
              "bg_count"
            ]
          }
        ]
      },
      "_types.aggregations:SignificantStringTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregateBaseSignificantStringTermsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregateBaseSignificantStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseSignificantStringTermsBucket"
          },
          {
            "type": "object",
            "properties": {
              "bg_count": {
                "type": "number"
              },
              "doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseSignificantStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsSignificantStringTermsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsSignificantStringTermsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantStringTermsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:SignificantStringTermsBucket"
            }
          }
        ]
      },
      "_types.aggregations:SignificantStringTermsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "string"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:UnmappedSignificantTermsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregateBaseVoid"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregateBaseVoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseVoid"
          },
          {
            "type": "object",
            "properties": {
              "bg_count": {
                "type": "number"
              },
              "doc_count": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseCompositeBucket"
          },
          {
            "type": "object",
            "properties": {
              "after_key": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregateKey"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregateKey": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/_types:FieldValue"
        }
      },
      "_types.aggregations:MultiBucketAggregateBaseCompositeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsCompositeBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsCompositeBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:CompositeBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:CompositeBucket"
            }
          }
        ]
      },
      "_types.aggregations:CompositeBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregateKey"
              }
            },
            "required": [
              "key"
            ]
          }
        ]
      },
      "_types.aggregations:FrequentItemSetsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketAggregateBaseFrequentItemSetsBucket"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MultiBucketAggregateBaseFrequentItemSetsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsFrequentItemSetsBucket"
              }
            },
            "required": [
              "buckets"
            ]
          }
        ]
      },
      "_types.aggregations:BucketsFrequentItemSetsBucket": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsBucket"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsBucket"
            }
          }
        ]
      },
      "_types.aggregations:FrequentItemSetsBucket": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MultiBucketBase"
          },
          {
            "type": "object",
            "properties": {
              "key": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "support": {
                "type": "number"
              }
            },
            "required": [
              "key",
              "support"
            ]
          }
        ]
      },
      "_types.aggregations:ScriptedMetricAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "object"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:TopHitsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "hits": {
                "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
              }
            },
            "required": [
              "hits"
            ]
          }
        ]
      },
      "_global.search._types:HitsMetadata": {
        "type": "object",
        "properties": {
          "total": {
            "description": "Total hit count information, present only if `track_total_hits` wasn't `false` in the search request.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_global.search._types:TotalHits"
              },
              {
                "type": "number"
              }
            ]
          },
          "hits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:Hit"
            }
          },
          "max_score": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "hits"
        ]
      },
      "_global.search._types:TotalHits": {
        "type": "object",
        "properties": {
          "relation": {
            "$ref": "#/components/schemas/_global.search._types:TotalHitsRelation"
          },
          "value": {
            "type": "number"
          }
        },
        "required": [
          "relation",
          "value"
        ]
      },
      "_global.search._types:TotalHitsRelation": {
        "type": "string",
        "enum": [
          "eq",
          "gte"
        ]
      },
      "_global.search._types:Hit": {
        "type": "object",
        "properties": {
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_score": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "_explanation": {
            "$ref": "#/components/schemas/_global.explain:Explanation"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "highlight": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "inner_hits": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_global.search._types:InnerHitsResult"
            }
          },
          "matched_queries": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "_nested": {
            "$ref": "#/components/schemas/_global.search._types:NestedIdentity"
          },
          "_ignored": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "ignored_field_values": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          "_shard": {
            "type": "string"
          },
          "_node": {
            "type": "string"
          },
          "_routing": {
            "type": "string"
          },
          "_source": {
            "type": "object"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_primary_term": {
            "type": "number"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:SortResults"
          }
        },
        "required": [
          "_index",
          "_id"
        ]
      },
      "_types:IndexName": {
        "type": "string"
      },
      "_global.explain:Explanation": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.explain:ExplanationDetail"
            }
          },
          "value": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "details",
          "value"
        ]
      },
      "_global.explain:ExplanationDetail": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.explain:ExplanationDetail"
            }
          },
          "value": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "value"
        ]
      },
      "_global.search._types:InnerHitsResult": {
        "type": "object",
        "properties": {
          "hits": {
            "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
          }
        },
        "required": [
          "hits"
        ]
      },
      "_global.search._types:NestedIdentity": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "offset": {
            "type": "number"
          },
          "_nested": {
            "$ref": "#/components/schemas/_global.search._types:NestedIdentity"
          }
        },
        "required": [
          "field",
          "offset"
        ]
      },
      "_types:Field": {
        "description": "Path to field or array of paths. Some API's support wildcards in the path to select multiple fields.",
        "type": "string"
      },
      "_types:SequenceNumber": {
        "type": "number"
      },
      "_types:VersionNumber": {
        "type": "number"
      },
      "_types:SortResults": {
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/_types:FieldValue"
        }
      },
      "_types.aggregations:InferenceAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "feature_importance": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:InferenceFeatureImportance"
                }
              },
              "top_classes": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:InferenceTopClassEntry"
                }
              },
              "warning": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:InferenceFeatureImportance": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          },
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:InferenceClassImportance"
            }
          }
        },
        "required": [
          "feature_name"
        ]
      },
      "_types.aggregations:InferenceClassImportance": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "importance"
        ]
      },
      "_types.aggregations:InferenceTopClassEntry": {
        "type": "object",
        "properties": {
          "class_name": {
            "$ref": "#/components/schemas/_types:FieldValue"
          },
          "class_probability": {
            "type": "number"
          },
          "class_score": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "class_probability",
          "class_score"
        ]
      },
      "_types.aggregations:StringStatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "min_length": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "max_length": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "avg_length": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "entropy": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "distribution": {
                "oneOf": [
                  {
                    "type": "object",
                    "additionalProperties": {
                      "type": "number"
                    }
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "min_length_as_string": {
                "type": "string"
              },
              "max_length_as_string": {
                "type": "string"
              },
              "avg_length_as_string": {
                "type": "string"
              }
            },
            "required": [
              "count",
              "min_length",
              "max_length",
              "avg_length",
              "entropy"
            ]
          }
        ]
      },
      "_types.aggregations:BoxPlotAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "min": {
                "type": "number"
              },
              "max": {
                "type": "number"
              },
              "q1": {
                "type": "number"
              },
              "q2": {
                "type": "number"
              },
              "q3": {
                "type": "number"
              },
              "lower": {
                "type": "number"
              },
              "upper": {
                "type": "number"
              },
              "min_as_string": {
                "type": "string"
              },
              "max_as_string": {
                "type": "string"
              },
              "q1_as_string": {
                "type": "string"
              },
              "q2_as_string": {
                "type": "string"
              },
              "q3_as_string": {
                "type": "string"
              },
              "lower_as_string": {
                "type": "string"
              },
              "upper_as_string": {
                "type": "string"
              }
            },
            "required": [
              "min",
              "max",
              "q1",
              "q2",
              "q3",
              "lower",
              "upper"
            ]
          }
        ]
      },
      "_types.aggregations:TopMetricsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "top": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:TopMetrics"
                }
              }
            },
            "required": [
              "top"
            ]
          }
        ]
      },
      "_types.aggregations:TopMetrics": {
        "type": "object",
        "properties": {
          "sort": {
            "type": "array",
            "items": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:FieldValue"
                },
                {
                  "nullable": true,
                  "type": "string"
                }
              ]
            }
          },
          "metrics": {
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/_types:FieldValue"
                },
                {
                  "nullable": true,
                  "type": "string"
                }
              ]
            }
          }
        },
        "required": [
          "sort",
          "metrics"
        ]
      },
      "_types.aggregations:TTestAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:RateAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:CumulativeCardinalityAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "number"
              },
              "value_as_string": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:MatrixStatsAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_count": {
                "type": "number"
              },
              "fields": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:MatrixStatsFields"
                }
              }
            },
            "required": [
              "doc_count"
            ]
          }
        ]
      },
      "_types.aggregations:MatrixStatsFields": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "count": {
            "type": "number"
          },
          "mean": {
            "type": "number"
          },
          "variance": {
            "type": "number"
          },
          "skewness": {
            "type": "number"
          },
          "kurtosis": {
            "type": "number"
          },
          "covariance": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "correlation": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "name",
          "count",
          "mean",
          "variance",
          "skewness",
          "kurtosis",
          "covariance",
          "correlation"
        ]
      },
      "_types.aggregations:GeoLineAggregate": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:AggregateBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string"
              },
              "geometry": {
                "$ref": "#/components/schemas/_types:GeoLine"
              },
              "properties": {
                "type": "object"
              }
            },
            "required": [
              "type",
              "geometry",
              "properties"
            ]
          }
        ]
      },
      "_types:GeoLine": {
        "type": "object",
        "properties": {
          "type": {
            "description": "Always `\"LineString\"`",
            "type": "string"
          },
          "coordinates": {
            "description": "Array of `[lon, lat]` coordinates",
            "type": "array",
            "items": {
              "type": "array",
              "items": {
                "type": "number"
              }
            }
          }
        },
        "required": [
          "type",
          "coordinates"
        ]
      },
      "_types:ClusterStatistics": {
        "type": "object",
        "properties": {
          "skipped": {
            "type": "number"
          },
          "successful": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ClusterDetails"
            }
          }
        },
        "required": [
          "skipped",
          "successful",
          "total"
        ]
      },
      "_types:ClusterDetails": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/_types:ClusterSearchStatus"
          },
          "indices": {
            "type": "string"
          },
          "took": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "timed_out": {
            "type": "boolean"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ShardFailure"
            }
          }
        },
        "required": [
          "status",
          "indices",
          "timed_out"
        ]
      },
      "_types:ClusterSearchStatus": {
        "type": "string",
        "enum": [
          "running",
          "successful",
          "partial",
          "skipped",
          "failed"
        ]
      },
      "_types:DurationValueUnitMillis": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitMillis"
          }
        ]
      },
      "_types:ShardStatistics": {
        "type": "object",
        "properties": {
          "failed": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "successful": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "total": {
            "$ref": "#/components/schemas/_types:uint"
          },
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ShardFailure"
            }
          },
          "skipped": {
            "$ref": "#/components/schemas/_types:uint"
          }
        },
        "required": [
          "failed",
          "successful",
          "total"
        ]
      },
      "_types:uint": {
        "type": "number"
      },
      "_types:ShardFailure": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "node": {
            "type": "string"
          },
          "reason": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "shard": {
            "type": "number"
          },
          "status": {
            "type": "string"
          }
        },
        "required": [
          "reason",
          "shard"
        ]
      },
      "_types:ErrorCause": {
        "type": "object",
        "properties": {
          "type": {
            "description": "The type of error",
            "type": "string"
          },
          "reason": {
            "description": "A human-readable explanation of the error, in english",
            "type": "string"
          },
          "stack_trace": {
            "description": "The server stack trace. Present only if the `error_trace=true` parameter was sent with the request.",
            "type": "string"
          },
          "caused_by": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "root_cause": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          },
          "suppressed": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_global.search._types:Profile": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:ShardProfile"
            }
          }
        },
        "required": [
          "shards"
        ]
      },
      "_global.search._types:ShardProfile": {
        "type": "object",
        "properties": {
          "aggregations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:AggregationProfile"
            }
          },
          "id": {
            "type": "string"
          },
          "searches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:SearchProfile"
            }
          },
          "fetch": {
            "$ref": "#/components/schemas/_global.search._types:FetchProfile"
          }
        },
        "required": [
          "aggregations",
          "id",
          "searches"
        ]
      },
      "_global.search._types:AggregationProfile": {
        "type": "object",
        "properties": {
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:AggregationBreakdown"
          },
          "description": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "type": {
            "type": "string"
          },
          "debug": {
            "$ref": "#/components/schemas/_global.search._types:AggregationProfileDebug"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:AggregationProfile"
            }
          }
        },
        "required": [
          "breakdown",
          "description",
          "time_in_nanos",
          "type"
        ]
      },
      "_global.search._types:AggregationBreakdown": {
        "type": "object",
        "properties": {
          "build_aggregation": {
            "type": "number"
          },
          "build_aggregation_count": {
            "type": "number"
          },
          "build_leaf_collector": {
            "type": "number"
          },
          "build_leaf_collector_count": {
            "type": "number"
          },
          "collect": {
            "type": "number"
          },
          "collect_count": {
            "type": "number"
          },
          "initialize": {
            "type": "number"
          },
          "initialize_count": {
            "type": "number"
          },
          "post_collection": {
            "type": "number"
          },
          "post_collection_count": {
            "type": "number"
          },
          "reduce": {
            "type": "number"
          },
          "reduce_count": {
            "type": "number"
          }
        },
        "required": [
          "build_aggregation",
          "build_aggregation_count",
          "build_leaf_collector",
          "build_leaf_collector_count",
          "collect",
          "collect_count",
          "initialize",
          "initialize_count",
          "reduce",
          "reduce_count"
        ]
      },
      "_types:DurationValueUnitNanos": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitNanos"
          }
        ]
      },
      "_types:UnitNanos": {
        "description": "Time unit for nanoseconds",
        "type": "number"
      },
      "_global.search._types:AggregationProfileDebug": {
        "type": "object",
        "properties": {
          "segments_with_multi_valued_ords": {
            "type": "number"
          },
          "collection_strategy": {
            "type": "string"
          },
          "segments_with_single_valued_ords": {
            "type": "number"
          },
          "total_buckets": {
            "type": "number"
          },
          "built_buckets": {
            "type": "number"
          },
          "result_strategy": {
            "type": "string"
          },
          "has_filter": {
            "type": "boolean"
          },
          "delegate": {
            "type": "string"
          },
          "delegate_debug": {
            "$ref": "#/components/schemas/_global.search._types:AggregationProfileDebug"
          },
          "chars_fetched": {
            "type": "number"
          },
          "extract_count": {
            "type": "number"
          },
          "extract_ns": {
            "type": "number"
          },
          "values_fetched": {
            "type": "number"
          },
          "collect_analyzed_ns": {
            "type": "number"
          },
          "collect_analyzed_count": {
            "type": "number"
          },
          "surviving_buckets": {
            "type": "number"
          },
          "ordinals_collectors_used": {
            "type": "number"
          },
          "ordinals_collectors_overhead_too_high": {
            "type": "number"
          },
          "string_hashing_collectors_used": {
            "type": "number"
          },
          "numeric_collectors_used": {
            "type": "number"
          },
          "empty_collectors_used": {
            "type": "number"
          },
          "deferred_aggregators": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "segments_with_doc_count_field": {
            "type": "number"
          },
          "segments_with_deleted_docs": {
            "type": "number"
          },
          "filters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:AggregationProfileDelegateDebugFilter"
            }
          },
          "segments_counted": {
            "type": "number"
          },
          "segments_collected": {
            "type": "number"
          },
          "map_reducer": {
            "type": "string"
          }
        }
      },
      "_global.search._types:AggregationProfileDelegateDebugFilter": {
        "type": "object",
        "properties": {
          "results_from_metadata": {
            "type": "number"
          },
          "query": {
            "type": "string"
          },
          "specialized_for": {
            "type": "string"
          },
          "segments_counted_in_constant_time": {
            "type": "number"
          }
        }
      },
      "_global.search._types:SearchProfile": {
        "type": "object",
        "properties": {
          "collector": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:Collector"
            }
          },
          "query": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:QueryProfile"
            }
          },
          "rewrite_time": {
            "type": "number"
          }
        },
        "required": [
          "collector",
          "query",
          "rewrite_time"
        ]
      },
      "_global.search._types:Collector": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "reason": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:Collector"
            }
          }
        },
        "required": [
          "name",
          "reason",
          "time_in_nanos"
        ]
      },
      "_global.search._types:QueryProfile": {
        "type": "object",
        "properties": {
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:QueryBreakdown"
          },
          "description": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "type": {
            "type": "string"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:QueryProfile"
            }
          }
        },
        "required": [
          "breakdown",
          "description",
          "time_in_nanos",
          "type"
        ]
      },
      "_global.search._types:QueryBreakdown": {
        "type": "object",
        "properties": {
          "advance": {
            "type": "number"
          },
          "advance_count": {
            "type": "number"
          },
          "build_scorer": {
            "type": "number"
          },
          "build_scorer_count": {
            "type": "number"
          },
          "create_weight": {
            "type": "number"
          },
          "create_weight_count": {
            "type": "number"
          },
          "match": {
            "type": "number"
          },
          "match_count": {
            "type": "number"
          },
          "shallow_advance": {
            "type": "number"
          },
          "shallow_advance_count": {
            "type": "number"
          },
          "next_doc": {
            "type": "number"
          },
          "next_doc_count": {
            "type": "number"
          },
          "score": {
            "type": "number"
          },
          "score_count": {
            "type": "number"
          },
          "compute_max_score": {
            "type": "number"
          },
          "compute_max_score_count": {
            "type": "number"
          },
          "set_min_competitive_score": {
            "type": "number"
          },
          "set_min_competitive_score_count": {
            "type": "number"
          }
        },
        "required": [
          "advance",
          "advance_count",
          "build_scorer",
          "build_scorer_count",
          "create_weight",
          "create_weight_count",
          "match",
          "match_count",
          "shallow_advance",
          "shallow_advance_count",
          "next_doc",
          "next_doc_count",
          "score",
          "score_count",
          "compute_max_score",
          "compute_max_score_count",
          "set_min_competitive_score",
          "set_min_competitive_score_count"
        ]
      },
      "_global.search._types:FetchProfile": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "breakdown": {
            "$ref": "#/components/schemas/_global.search._types:FetchProfileBreakdown"
          },
          "debug": {
            "$ref": "#/components/schemas/_global.search._types:FetchProfileDebug"
          },
          "children": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.search._types:FetchProfile"
            }
          }
        },
        "required": [
          "type",
          "description",
          "time_in_nanos",
          "breakdown"
        ]
      },
      "_global.search._types:FetchProfileBreakdown": {
        "type": "object",
        "properties": {
          "load_source": {
            "type": "number"
          },
          "load_source_count": {
            "type": "number"
          },
          "load_stored_fields": {
            "type": "number"
          },
          "load_stored_fields_count": {
            "type": "number"
          },
          "next_reader": {
            "type": "number"
          },
          "next_reader_count": {
            "type": "number"
          },
          "process_count": {
            "type": "number"
          },
          "process": {
            "type": "number"
          }
        }
      },
      "_global.search._types:FetchProfileDebug": {
        "type": "object",
        "properties": {
          "stored_fields": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "fast_path": {
            "type": "number"
          }
        }
      },
      "_types:ScrollId": {
        "type": "string"
      },
      "_global.search._types:Suggest": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:CompletionSuggest"
          },
          {
            "$ref": "#/components/schemas/_global.search._types:PhraseSuggest"
          },
          {
            "$ref": "#/components/schemas/_global.search._types:TermSuggest"
          }
        ]
      },
      "_global.search._types:CompletionSuggest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:SuggestBase"
          },
          {
            "type": "object",
            "properties": {
              "options": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.search._types:CompletionSuggestOption"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:CompletionSuggestOption"
                    }
                  }
                ]
              }
            },
            "required": [
              "options"
            ]
          }
        ]
      },
      "_global.search._types:CompletionSuggestOption": {
        "type": "object",
        "properties": {
          "collate_match": {
            "type": "boolean"
          },
          "contexts": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.search._types:Context"
              }
            }
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "_id": {
            "type": "string"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_score": {
            "type": "number"
          },
          "_source": {
            "type": "object"
          },
          "text": {
            "type": "string"
          },
          "score": {
            "type": "number"
          }
        },
        "required": [
          "text"
        ]
      },
      "_global.search._types:Context": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html#_document_input_parameters"
        },
        "description": "Text or location that we want similar documents for or a lookup to a document's field for the text.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types:GeoLocation"
          }
        ]
      },
      "_types:Routing": {
        "type": "string"
      },
      "_global.search._types:SuggestBase": {
        "type": "object",
        "properties": {
          "length": {
            "type": "number"
          },
          "offset": {
            "type": "number"
          },
          "text": {
            "type": "string"
          }
        },
        "required": [
          "length",
          "offset",
          "text"
        ]
      },
      "_global.search._types:PhraseSuggest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:SuggestBase"
          },
          {
            "type": "object",
            "properties": {
              "options": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.search._types:PhraseSuggestOption"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:PhraseSuggestOption"
                    }
                  }
                ]
              }
            },
            "required": [
              "options"
            ]
          }
        ]
      },
      "_global.search._types:PhraseSuggestOption": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "score": {
            "type": "number"
          },
          "highlighted": {
            "type": "string"
          },
          "collate_match": {
            "type": "boolean"
          }
        },
        "required": [
          "text",
          "score"
        ]
      },
      "_global.search._types:TermSuggest": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:SuggestBase"
          },
          {
            "type": "object",
            "properties": {
              "options": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_global.search._types:TermSuggestOption"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_global.search._types:TermSuggestOption"
                    }
                  }
                ]
              }
            },
            "required": [
              "options"
            ]
          }
        ]
      },
      "_global.search._types:TermSuggestOption": {
        "type": "object",
        "properties": {
          "text": {
            "type": "string"
          },
          "score": {
            "type": "number"
          },
          "freq": {
            "type": "number"
          },
          "highlighted": {
            "type": "string"
          },
          "collate_match": {
            "type": "boolean"
          }
        },
        "required": [
          "text",
          "score",
          "freq"
        ]
      },
      "async_search._types:AsyncSearchResponseBase": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "is_partial": {
            "description": "When the query is no longer running, this property indicates whether the search failed or was successfully completed on all shards.\nWhile the query is running, `is_partial` is always set to `true`.",
            "type": "boolean"
          },
          "is_running": {
            "description": "Indicates whether the search is still running or has completed.\nNOTE: If the search failed after some shards returned their results or the node that is coordinating the async search dies, results may be partial even though `is_running` is `false`.",
            "type": "boolean"
          },
          "expiration_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "expiration_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "completion_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "completion_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "is_partial",
          "is_running",
          "expiration_time_in_millis",
          "start_time_in_millis"
        ]
      },
      "_types:DateTime": {
        "description": "A date and time, either as a string whose format can depend on the context (defaulting to ISO 8601), or a\nnumber of milliseconds since the Epoch. Elasticsearch accepts both as input, but will generally output a string\nrepresentation.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        ]
      },
      "async_search.status:StatusResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/async_search._types:AsyncSearchResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "_shards": {
                "$ref": "#/components/schemas/_types:ShardStatistics"
              },
              "_clusters": {
                "$ref": "#/components/schemas/_types:ClusterStatistics"
              },
              "completion_status": {
                "description": "If the async search completed, this field shows the status code of the search.\nFor example, 200 indicates that the async search was successfully completed.\n503 indicates that the async search was completed with an error.",
                "type": "number"
              }
            },
            "required": [
              "_shards"
            ]
          }
        ]
      },
      "_types:Indices": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          }
        ]
      },
      "_types.query_dsl:Operator": {
        "type": "string",
        "enum": [
          "and",
          "or"
        ]
      },
      "_types:Fields": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Field"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          }
        ]
      },
      "_types:ExpandWildcards": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ExpandWildcard"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ExpandWildcard"
            }
          }
        ]
      },
      "_types:ExpandWildcard": {
        "type": "string",
        "enum": [
          "all",
          "open",
          "closed",
          "hidden",
          "none"
        ]
      },
      "_types:VersionString": {
        "type": "string"
      },
      "_types:SearchType": {
        "type": "string",
        "enum": [
          "query_then_fetch",
          "dfs_query_then_fetch"
        ]
      },
      "_types:SuggestMode": {
        "type": "string",
        "enum": [
          "missing",
          "popular",
          "always"
        ]
      },
      "_global.search._types:TrackHits": {
        "description": "Number of hits matching the query to count accurately. If true, the exact\nnumber of hits is returned at the cost of some performance. If false, the\nresponse does not include the total number of hits matching the query.\nDefaults to 10,000 hits.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "type": "number"
          }
        ]
      },
      "_global.search._types:SourceConfigParam": {
        "description": "Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.\nUsed as a query parameter along with the `_source_includes` and `_source_excludes` parameters.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "$ref": "#/components/schemas/_types:Fields"
          }
        ]
      },
      "_types.aggregations:AggregationContainer": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "aggregations": {
                "description": "Sub-aggregations for this aggregation.\nOnly applies to bucket aggregations.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
                }
              },
              "meta": {
                "$ref": "#/components/schemas/_types:Metadata"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "adjacency_matrix": {
                "$ref": "#/components/schemas/_types.aggregations:AdjacencyMatrixAggregation"
              },
              "auto_date_histogram": {
                "$ref": "#/components/schemas/_types.aggregations:AutoDateHistogramAggregation"
              },
              "avg": {
                "$ref": "#/components/schemas/_types.aggregations:AverageAggregation"
              },
              "avg_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:AverageBucketAggregation"
              },
              "boxplot": {
                "$ref": "#/components/schemas/_types.aggregations:BoxplotAggregation"
              },
              "bucket_script": {
                "$ref": "#/components/schemas/_types.aggregations:BucketScriptAggregation"
              },
              "bucket_selector": {
                "$ref": "#/components/schemas/_types.aggregations:BucketSelectorAggregation"
              },
              "bucket_sort": {
                "$ref": "#/components/schemas/_types.aggregations:BucketSortAggregation"
              },
              "bucket_count_ks_test": {
                "$ref": "#/components/schemas/_types.aggregations:BucketKsAggregation"
              },
              "bucket_correlation": {
                "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationAggregation"
              },
              "cardinality": {
                "$ref": "#/components/schemas/_types.aggregations:CardinalityAggregation"
              },
              "categorize_text": {
                "$ref": "#/components/schemas/_types.aggregations:CategorizeTextAggregation"
              },
              "children": {
                "$ref": "#/components/schemas/_types.aggregations:ChildrenAggregation"
              },
              "composite": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregation"
              },
              "cumulative_cardinality": {
                "$ref": "#/components/schemas/_types.aggregations:CumulativeCardinalityAggregation"
              },
              "cumulative_sum": {
                "$ref": "#/components/schemas/_types.aggregations:CumulativeSumAggregation"
              },
              "date_histogram": {
                "$ref": "#/components/schemas/_types.aggregations:DateHistogramAggregation"
              },
              "date_range": {
                "$ref": "#/components/schemas/_types.aggregations:DateRangeAggregation"
              },
              "derivative": {
                "$ref": "#/components/schemas/_types.aggregations:DerivativeAggregation"
              },
              "diversified_sampler": {
                "$ref": "#/components/schemas/_types.aggregations:DiversifiedSamplerAggregation"
              },
              "extended_stats": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsAggregation"
              },
              "extended_stats_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedStatsBucketAggregation"
              },
              "frequent_item_sets": {
                "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsAggregation"
              },
              "filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "filters": {
                "$ref": "#/components/schemas/_types.aggregations:FiltersAggregation"
              },
              "geo_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:GeoBoundsAggregation"
              },
              "geo_centroid": {
                "$ref": "#/components/schemas/_types.aggregations:GeoCentroidAggregation"
              },
              "geo_distance": {
                "$ref": "#/components/schemas/_types.aggregations:GeoDistanceAggregation"
              },
              "geohash_grid": {
                "$ref": "#/components/schemas/_types.aggregations:GeoHashGridAggregation"
              },
              "geo_line": {
                "$ref": "#/components/schemas/_types.aggregations:GeoLineAggregation"
              },
              "geotile_grid": {
                "$ref": "#/components/schemas/_types.aggregations:GeoTileGridAggregation"
              },
              "geohex_grid": {
                "$ref": "#/components/schemas/_types.aggregations:GeohexGridAggregation"
              },
              "global": {
                "$ref": "#/components/schemas/_types.aggregations:GlobalAggregation"
              },
              "histogram": {
                "$ref": "#/components/schemas/_types.aggregations:HistogramAggregation"
              },
              "ip_range": {
                "$ref": "#/components/schemas/_types.aggregations:IpRangeAggregation"
              },
              "ip_prefix": {
                "$ref": "#/components/schemas/_types.aggregations:IpPrefixAggregation"
              },
              "inference": {
                "$ref": "#/components/schemas/_types.aggregations:InferenceAggregation"
              },
              "line": {
                "$ref": "#/components/schemas/_types.aggregations:GeoLineAggregation"
              },
              "matrix_stats": {
                "$ref": "#/components/schemas/_types.aggregations:MatrixStatsAggregation"
              },
              "max": {
                "$ref": "#/components/schemas/_types.aggregations:MaxAggregation"
              },
              "max_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:MaxBucketAggregation"
              },
              "median_absolute_deviation": {
                "$ref": "#/components/schemas/_types.aggregations:MedianAbsoluteDeviationAggregation"
              },
              "min": {
                "$ref": "#/components/schemas/_types.aggregations:MinAggregation"
              },
              "min_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:MinBucketAggregation"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:MissingAggregation"
              },
              "moving_avg": {
                "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregation"
              },
              "moving_percentiles": {
                "$ref": "#/components/schemas/_types.aggregations:MovingPercentilesAggregation"
              },
              "moving_fn": {
                "$ref": "#/components/schemas/_types.aggregations:MovingFunctionAggregation"
              },
              "multi_terms": {
                "$ref": "#/components/schemas/_types.aggregations:MultiTermsAggregation"
              },
              "nested": {
                "$ref": "#/components/schemas/_types.aggregations:NestedAggregation"
              },
              "normalize": {
                "$ref": "#/components/schemas/_types.aggregations:NormalizeAggregation"
              },
              "parent": {
                "$ref": "#/components/schemas/_types.aggregations:ParentAggregation"
              },
              "percentile_ranks": {
                "$ref": "#/components/schemas/_types.aggregations:PercentileRanksAggregation"
              },
              "percentiles": {
                "$ref": "#/components/schemas/_types.aggregations:PercentilesAggregation"
              },
              "percentiles_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:PercentilesBucketAggregation"
              },
              "range": {
                "$ref": "#/components/schemas/_types.aggregations:RangeAggregation"
              },
              "rare_terms": {
                "$ref": "#/components/schemas/_types.aggregations:RareTermsAggregation"
              },
              "rate": {
                "$ref": "#/components/schemas/_types.aggregations:RateAggregation"
              },
              "reverse_nested": {
                "$ref": "#/components/schemas/_types.aggregations:ReverseNestedAggregation"
              },
              "sampler": {
                "$ref": "#/components/schemas/_types.aggregations:SamplerAggregation"
              },
              "scripted_metric": {
                "$ref": "#/components/schemas/_types.aggregations:ScriptedMetricAggregation"
              },
              "serial_diff": {
                "$ref": "#/components/schemas/_types.aggregations:SerialDifferencingAggregation"
              },
              "significant_terms": {
                "$ref": "#/components/schemas/_types.aggregations:SignificantTermsAggregation"
              },
              "significant_text": {
                "$ref": "#/components/schemas/_types.aggregations:SignificantTextAggregation"
              },
              "stats": {
                "$ref": "#/components/schemas/_types.aggregations:StatsAggregation"
              },
              "stats_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:StatsBucketAggregation"
              },
              "string_stats": {
                "$ref": "#/components/schemas/_types.aggregations:StringStatsAggregation"
              },
              "sum": {
                "$ref": "#/components/schemas/_types.aggregations:SumAggregation"
              },
              "sum_bucket": {
                "$ref": "#/components/schemas/_types.aggregations:SumBucketAggregation"
              },
              "terms": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregation"
              },
              "top_hits": {
                "$ref": "#/components/schemas/_types.aggregations:TopHitsAggregation"
              },
              "t_test": {
                "$ref": "#/components/schemas/_types.aggregations:TTestAggregation"
              },
              "top_metrics": {
                "$ref": "#/components/schemas/_types.aggregations:TopMetricsAggregation"
              },
              "value_count": {
                "$ref": "#/components/schemas/_types.aggregations:ValueCountAggregation"
              },
              "weighted_avg": {
                "$ref": "#/components/schemas/_types.aggregations:WeightedAverageAggregation"
              },
              "variable_width_histogram": {
                "$ref": "#/components/schemas/_types.aggregations:VariableWidthHistogramAggregation"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.aggregations:AdjacencyMatrixAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "filters": {
                "description": "Filters used to create buckets.\nAt least one filter is required.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            }
          }
        ]
      },
      "_types.query_dsl:QueryContainer": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl.html"
        },
        "type": "object",
        "properties": {
          "bool": {
            "$ref": "#/components/schemas/_types.query_dsl:BoolQuery"
          },
          "boosting": {
            "$ref": "#/components/schemas/_types.query_dsl:BoostingQuery"
          },
          "common": {
            "deprecated": true,
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:CommonTermsQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "combined_fields": {
            "$ref": "#/components/schemas/_types.query_dsl:CombinedFieldsQuery"
          },
          "constant_score": {
            "$ref": "#/components/schemas/_types.query_dsl:ConstantScoreQuery"
          },
          "dis_max": {
            "$ref": "#/components/schemas/_types.query_dsl:DisMaxQuery"
          },
          "distance_feature": {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQuery"
          },
          "exists": {
            "$ref": "#/components/schemas/_types.query_dsl:ExistsQuery"
          },
          "function_score": {
            "$ref": "#/components/schemas/_types.query_dsl:FunctionScoreQuery"
          },
          "fuzzy": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-fuzzy-query.html"
            },
            "description": "Returns documents that contain terms similar to the search term, as measured by a Levenshtein edit distance.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:FuzzyQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "geo_bounding_box": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoBoundingBoxQuery"
          },
          "geo_distance": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoDistanceQuery"
          },
          "geo_polygon": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoPolygonQuery"
          },
          "geo_shape": {
            "$ref": "#/components/schemas/_types.query_dsl:GeoShapeQuery"
          },
          "has_child": {
            "$ref": "#/components/schemas/_types.query_dsl:HasChildQuery"
          },
          "has_parent": {
            "$ref": "#/components/schemas/_types.query_dsl:HasParentQuery"
          },
          "ids": {
            "$ref": "#/components/schemas/_types.query_dsl:IdsQuery"
          },
          "intervals": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-intervals-query.html"
            },
            "description": "Returns documents based on the order and proximity of matching terms.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:IntervalsQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query.html"
            },
            "description": "Returns documents that match a provided text, number, date or boolean value.\nThe provided text is analyzed before matching.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_all": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchAllQuery"
          },
          "match_bool_prefix": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-bool-prefix-query.html"
            },
            "description": "Analyzes its input and constructs a `bool` query from the terms.\nEach term except the last is used in a `term` query.\nThe last term is used in a prefix query.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchBoolPrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_none": {
            "$ref": "#/components/schemas/_types.query_dsl:MatchNoneQuery"
          },
          "match_phrase": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase.html"
            },
            "description": "Analyzes the text and creates a phrase query out of the analyzed text.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchPhraseQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "match_phrase_prefix": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-match-query-phrase-prefix.html"
            },
            "description": "Returns documents that contain the words of a provided text, in the same order as provided.\nThe last term of the provided text is treated as a prefix, matching any words that begin with that term.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:MatchPhrasePrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "more_like_this": {
            "$ref": "#/components/schemas/_types.query_dsl:MoreLikeThisQuery"
          },
          "multi_match": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiMatchQuery"
          },
          "nested": {
            "$ref": "#/components/schemas/_types.query_dsl:NestedQuery"
          },
          "parent_id": {
            "$ref": "#/components/schemas/_types.query_dsl:ParentIdQuery"
          },
          "percolate": {
            "$ref": "#/components/schemas/_types.query_dsl:PercolateQuery"
          },
          "pinned": {
            "$ref": "#/components/schemas/_types.query_dsl:PinnedQuery"
          },
          "prefix": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-prefix-query.html"
            },
            "description": "Returns documents that contain a specific prefix in a provided field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:PrefixQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryStringQuery"
          },
          "range": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html"
            },
            "description": "Returns documents that contain terms within a provided range.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RangeQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "rank_feature": {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureQuery"
          },
          "regexp": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-regexp-query.html"
            },
            "description": "Returns documents that contain terms matching a regular expression.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:RegexpQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "rule_query": {
            "$ref": "#/components/schemas/_types.query_dsl:RuleQuery"
          },
          "script": {
            "$ref": "#/components/schemas/_types.query_dsl:ScriptQuery"
          },
          "script_score": {
            "$ref": "#/components/schemas/_types.query_dsl:ScriptScoreQuery"
          },
          "shape": {
            "$ref": "#/components/schemas/_types.query_dsl:ShapeQuery"
          },
          "simple_query_string": {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringQuery"
          },
          "span_containing": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanContainingQuery"
          },
          "field_masking_span": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFieldMaskingQuery"
          },
          "span_first": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFirstQuery"
          },
          "span_multi": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanMultiTermQuery"
          },
          "span_near": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNearQuery"
          },
          "span_not": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNotQuery"
          },
          "span_or": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanOrQuery"
          },
          "span_term": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-span-term-query.html"
            },
            "description": "Matches spans containing a term.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:SpanTermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "span_within": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanWithinQuery"
          },
          "term": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-term-query.html"
            },
            "description": "Returns documents that contain an exact term in a provided field.\nTo return a document, the query term must exactly match the queried field's value, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "terms": {
            "$ref": "#/components/schemas/_types.query_dsl:TermsQuery"
          },
          "terms_set": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-terms-set-query.html"
            },
            "description": "Returns documents that contain a minimum number of exact terms in a provided field.\nTo return a document, a required number of terms must exactly match the field values, including whitespace and capitalization.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TermsSetQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "text_expansion": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-text-expansion-query.html"
            },
            "description": "Uses a natural language processing model to convert the query text into a list of token-weight pairs which are then used in a query against a rank features field.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:TextExpansionQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "wildcard": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-wildcard-query.html"
            },
            "description": "Returns documents that contain terms matching a wildcard pattern.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:WildcardQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "wrapper": {
            "$ref": "#/components/schemas/_types.query_dsl:WrapperQuery"
          },
          "type": {
            "$ref": "#/components/schemas/_types.query_dsl:TypeQuery"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:BoolQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "description": "The clause (query) must appear in matching documents.\nHowever, unlike `must`, the score of the query will be ignored.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "must": {
                "description": "The clause (query) must appear in matching documents and will contribute to the score.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "must_not": {
                "description": "The clause (query) must not appear in the matching documents.\nBecause scoring is ignored, a score of `0` is returned for all documents.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              },
              "should": {
                "description": "The clause (query) should appear in the matching document.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                    }
                  }
                ]
              }
            }
          }
        ]
      },
      "_types:MinimumShouldMatch": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-minimum-should-match.html"
        },
        "description": "The minimum number of terms that should match as integer, percentage or range",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.query_dsl:QueryBase": {
        "type": "object",
        "properties": {
          "boost": {
            "description": "Floating point number used to decrease or increase the relevance scores of the query.\nBoost values are relative to the default value of 1.0.\nA boost value between 0 and 1.0 decreases the relevance score.\nA value greater than 1.0 increases the relevance score.",
            "type": "number"
          },
          "_name": {
            "type": "string"
          }
        }
      },
      "_types.query_dsl:BoostingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "negative_boost": {
                "description": "Floating point number between 0 and 1.0 used to decrease the relevance scores of documents matching the `negative` query.",
                "type": "number"
              },
              "negative": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "positive": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              }
            },
            "required": [
              "negative_boost",
              "negative",
              "positive"
            ]
          }
        ]
      },
      "_types.query_dsl:CommonTermsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "cutoff_frequency": {
                "type": "number"
              },
              "high_freq_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "low_freq_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "query": {
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:CombinedFieldsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "fields": {
                "description": "List of fields to search. Field wildcard patterns are allowed. Only `text` fields are supported, and they must all have the same search `analyzer`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "query": {
                "description": "Text to search for in the provided `fields`.\nThe `combined_fields` query analyzes the provided text before performing a search.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If true, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:CombinedFieldsOperator"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:CombinedFieldsZeroTerms"
              }
            },
            "required": [
              "fields",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:CombinedFieldsOperator": {
        "type": "string",
        "enum": [
          "or",
          "and"
        ]
      },
      "_types.query_dsl:CombinedFieldsZeroTerms": {
        "type": "string",
        "enum": [
          "none",
          "all"
        ]
      },
      "_types.query_dsl:ConstantScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              }
            },
            "required": [
              "filter"
            ]
          }
        ]
      },
      "_types.query_dsl:DisMaxQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "queries": {
                "description": "One or more query clauses.\nReturned documents must match one or more of these queries.\nIf a document matches multiple queries, Elasticsearch uses the highest relevance score.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              },
              "tie_breaker": {
                "description": "Floating point number between 0 and 1.0 used to increase the relevance scores of documents matching multiple query clauses.",
                "type": "number"
              }
            },
            "required": [
              "queries"
            ]
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQuery": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:GeoDistanceFeatureQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:DateDistanceFeatureQuery"
          }
        ]
      },
      "_types.query_dsl:GeoDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQueryBaseGeoLocationDistance"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQueryBaseGeoLocationDistance": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              },
              "pivot": {
                "$ref": "#/components/schemas/_types:Distance"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "_types:Distance": {
        "type": "string"
      },
      "_types.query_dsl:DateDistanceFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DistanceFeatureQueryBaseDateMathDuration"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DistanceFeatureQueryBaseDateMathDuration": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "origin": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "pivot": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "origin",
              "pivot",
              "field"
            ]
          }
        ]
      },
      "_types:DateMath": {
        "type": "string"
      },
      "_types.query_dsl:ExistsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:FunctionScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "boost_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:FunctionBoostMode"
              },
              "functions": {
                "description": "One or more functions that compute a new score for each document returned by the query.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:FunctionScoreContainer"
                }
              },
              "max_boost": {
                "description": "Restricts the new score to not exceed the provided limit.",
                "type": "number"
              },
              "min_score": {
                "description": "Excludes documents that do not meet the provided score threshold.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:FunctionScoreMode"
              }
            }
          }
        ]
      },
      "_types.query_dsl:FunctionBoostMode": {
        "type": "string",
        "enum": [
          "multiply",
          "replace",
          "sum",
          "avg",
          "max",
          "min"
        ]
      },
      "_types.query_dsl:FunctionScoreContainer": {
        "allOf": [
          {
            "type": "object",
            "properties": {
              "filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "weight": {
                "type": "number"
              }
            }
          },
          {
            "type": "object",
            "properties": {
              "exp": {
                "$ref": "#/components/schemas/_types.query_dsl:DecayFunction"
              },
              "gauss": {
                "$ref": "#/components/schemas/_types.query_dsl:DecayFunction"
              },
              "linear": {
                "$ref": "#/components/schemas/_types.query_dsl:DecayFunction"
              },
              "field_value_factor": {
                "$ref": "#/components/schemas/_types.query_dsl:FieldValueFactorScoreFunction"
              },
              "random_score": {
                "$ref": "#/components/schemas/_types.query_dsl:RandomScoreFunction"
              },
              "script_score": {
                "$ref": "#/components/schemas/_types.query_dsl:ScriptScoreFunction"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.query_dsl:DecayFunction": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DateDecayFunction"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:NumericDecayFunction"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:GeoDecayFunction"
          }
        ]
      },
      "_types.query_dsl:DateDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:DecayFunctionBase": {
        "type": "object",
        "properties": {
          "multi_value_mode": {
            "$ref": "#/components/schemas/_types.query_dsl:MultiValueMode"
          }
        }
      },
      "_types.query_dsl:MultiValueMode": {
        "type": "string",
        "enum": [
          "min",
          "max",
          "avg",
          "sum"
        ]
      },
      "_types.query_dsl:NumericDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:GeoDecayFunction": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DecayFunctionBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:FieldValueFactorScoreFunction": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "factor": {
            "description": "Optional factor to multiply the field value with.",
            "type": "number"
          },
          "missing": {
            "description": "Value used if the document doesnt have that field.\nThe modifier and factor are still applied to it as though it were read from the document.",
            "type": "number"
          },
          "modifier": {
            "$ref": "#/components/schemas/_types.query_dsl:FieldValueFactorModifier"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.query_dsl:FieldValueFactorModifier": {
        "type": "string",
        "enum": [
          "none",
          "log",
          "log1p",
          "log2p",
          "ln",
          "ln1p",
          "ln2p",
          "square",
          "sqrt",
          "reciprocal"
        ]
      },
      "_types.query_dsl:RandomScoreFunction": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "seed": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "_types.query_dsl:ScriptScoreFunction": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types:Script": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:InlineScript"
          },
          {
            "$ref": "#/components/schemas/_types:StoredScriptId"
          }
        ]
      },
      "_types:InlineScript": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:ScriptBase"
          },
          {
            "type": "object",
            "properties": {
              "lang": {
                "$ref": "#/components/schemas/_types:ScriptLanguage"
              },
              "options": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "source": {
                "description": "The script source.",
                "type": "string"
              }
            },
            "required": [
              "source"
            ]
          }
        ]
      },
      "_types:ScriptLanguage": {
        "type": "string",
        "enum": [
          "painless",
          "expression",
          "mustache",
          "java"
        ]
      },
      "_types:ScriptBase": {
        "type": "object",
        "properties": {
          "params": {
            "description": "Specifies any named parameters that are passed into the script as variables.\nUse parameters instead of hard-coded values to decrease compile time.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        }
      },
      "_types:StoredScriptId": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:ScriptBase"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/_types:Id"
              }
            },
            "required": [
              "id"
            ]
          }
        ]
      },
      "_types.query_dsl:FunctionScoreMode": {
        "type": "string",
        "enum": [
          "multiply",
          "sum",
          "avg",
          "first",
          "max",
          "min"
        ]
      },
      "_types.query_dsl:FuzzyQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "max_expansions": {
                "description": "Maximum number of variations created.",
                "type": "number"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged when creating expansions.",
                "type": "number"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "transpositions": {
                "description": "Indicates whether edits include transpositions of two adjacent characters (for example `ab` to `ba`).",
                "type": "boolean"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "value": {
                "description": "Term you wish to find in the provided field.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types:MultiTermQueryRewrite": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-multi-term-rewrite.html"
        },
        "type": "string"
      },
      "_types:Fuzziness": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/common-options.html#fuzziness"
        },
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "_types.query_dsl:GeoBoundingBoxQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoExecution"
              },
              "validation_method": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoValidationMethod"
              },
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:GeoExecution": {
        "type": "string",
        "enum": [
          "memory",
          "indexed"
        ]
      },
      "_types.query_dsl:GeoValidationMethod": {
        "type": "string",
        "enum": [
          "coerce",
          "ignore_malformed",
          "strict"
        ]
      },
      "_types.query_dsl:GeoDistanceQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "distance": {
                "$ref": "#/components/schemas/_types:Distance"
              },
              "distance_type": {
                "$ref": "#/components/schemas/_types:GeoDistanceType"
              },
              "validation_method": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoValidationMethod"
              }
            },
            "required": [
              "distance"
            ]
          }
        ]
      },
      "_types:GeoDistanceType": {
        "type": "string",
        "enum": [
          "arc",
          "plane"
        ]
      },
      "_types.query_dsl:GeoPolygonQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "validation_method": {
                "$ref": "#/components/schemas/_types.query_dsl:GeoValidationMethod"
              },
              "ignore_unmapped": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:GeoShapeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Set to `true` to ignore an unmapped field and not match any documents for this query.\nSet to `false` to throw an exception if the field is not mapped.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:HasChildQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              "max_children": {
                "description": "Maximum number of child documents that match the query allowed for a returned parent document.\nIf the parent document exceeds this limit, it is excluded from the search results.",
                "type": "number"
              },
              "min_children": {
                "description": "Minimum number of child documents that match the query required to match the query for a returned parent document.\nIf the parent document does not meet this limit, it is excluded from the search results.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:ChildScoreMode"
              },
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            },
            "required": [
              "query",
              "type"
            ]
          }
        ]
      },
      "_global.search._types:InnerHits": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "size": {
            "description": "The maximum number of hits to return per `inner_hits`.",
            "type": "number"
          },
          "from": {
            "description": "Inner hit starting document offset.",
            "type": "number"
          },
          "collapse": {
            "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
          },
          "docvalue_fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
            }
          },
          "explain": {
            "type": "boolean"
          },
          "highlight": {
            "$ref": "#/components/schemas/_global.search._types:Highlight"
          },
          "ignore_unmapped": {
            "type": "boolean"
          },
          "script_fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "seq_no_primary_term": {
            "type": "boolean"
          },
          "fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:Sort"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "stored_field": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "track_scores": {
            "type": "boolean"
          },
          "version": {
            "type": "boolean"
          }
        }
      },
      "_types:Name": {
        "type": "string"
      },
      "_global.search._types:FieldCollapse": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "inner_hits": {
            "description": "The number of inner hits and their sort order",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_global.search._types:InnerHits"
                }
              }
            ]
          },
          "max_concurrent_group_searches": {
            "description": "The number of concurrent requests allowed to retrieve the inner_hits per group",
            "type": "number"
          },
          "collapse": {
            "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.query_dsl:FieldAndFormat": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "format": {
            "description": "Format in which the values are returned.",
            "type": "string"
          },
          "include_unmapped": {
            "type": "boolean"
          }
        },
        "required": [
          "field"
        ]
      },
      "_global.search._types:Highlight": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:HighlightBase"
          },
          {
            "type": "object",
            "properties": {
              "encoder": {
                "$ref": "#/components/schemas/_global.search._types:HighlighterEncoder"
              },
              "fields": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_global.search._types:HighlightField"
                }
              }
            },
            "required": [
              "fields"
            ]
          }
        ]
      },
      "_global.search._types:HighlighterEncoder": {
        "type": "string",
        "enum": [
          "default",
          "html"
        ]
      },
      "_global.search._types:HighlightField": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search._types:HighlightBase"
          },
          {
            "type": "object",
            "properties": {
              "fragment_offset": {
                "type": "number"
              },
              "matched_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "analyzer": {
                "$ref": "#/components/schemas/_types.analysis:Analyzer"
              }
            }
          }
        ]
      },
      "_types.analysis:Analyzer": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CustomAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:FingerprintAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeywordAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LanguageAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NoriAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SimpleAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StandardAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StopAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WhitespaceAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SnowballAnalyzer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DutchAnalyzer"
          }
        ]
      },
      "_types.analysis:CustomAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "custom"
            ]
          },
          "char_filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "position_increment_gap": {
            "type": "number"
          },
          "position_offset_gap": {
            "type": "number"
          },
          "tokenizer": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "tokenizer"
        ]
      },
      "_types.analysis:FingerprintAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "fingerprint"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "max_output_size": {
            "type": "number"
          },
          "preserve_original": {
            "type": "boolean"
          },
          "separator": {
            "type": "string"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "max_output_size",
          "preserve_original",
          "separator"
        ]
      },
      "_types.analysis:StopWords": {
        "description": "Language value, such as _arabic_ or _thai_. Defaults to _english_.\nEach language value corresponds to a predefined list of stop words in Lucene. See Stop words by language for supported language values and their stop words.\nAlso accepts an array of stop words.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "_types.analysis:KeywordAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "keyword"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:LanguageAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "language"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "language": {
            "$ref": "#/components/schemas/_types.analysis:Language"
          },
          "stem_exclusion": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "language",
          "stem_exclusion"
        ]
      },
      "_types.analysis:Language": {
        "type": "string",
        "enum": [
          "Arabic",
          "Armenian",
          "Basque",
          "Brazilian",
          "Bulgarian",
          "Catalan",
          "Chinese",
          "Cjk",
          "Czech",
          "Danish",
          "Dutch",
          "English",
          "Estonian",
          "Finnish",
          "French",
          "Galician",
          "German",
          "Greek",
          "Hindi",
          "Hungarian",
          "Indonesian",
          "Irish",
          "Italian",
          "Latvian",
          "Norwegian",
          "Persian",
          "Portuguese",
          "Romanian",
          "Russian",
          "Sorani",
          "Spanish",
          "Swedish",
          "Turkish",
          "Thai"
        ]
      },
      "_types.analysis:NoriAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "nori"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "decompound_mode": {
            "$ref": "#/components/schemas/_types.analysis:NoriDecompoundMode"
          },
          "stoptags": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "user_dictionary": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:NoriDecompoundMode": {
        "type": "string",
        "enum": [
          "discard",
          "none",
          "mixed"
        ]
      },
      "_types.analysis:PatternAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "pattern"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "flags": {
            "type": "string"
          },
          "lowercase": {
            "type": "boolean"
          },
          "pattern": {
            "type": "string"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type",
          "pattern"
        ]
      },
      "_types.analysis:SimpleAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "simple"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:StandardAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "standard"
            ]
          },
          "max_token_length": {
            "type": "number"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:StopAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "stop"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          },
          "stopwords_path": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:WhitespaceAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "whitespace"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:IcuAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "icu_analyzer"
            ]
          },
          "method": {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationType"
          },
          "mode": {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationMode"
          }
        },
        "required": [
          "type",
          "method",
          "mode"
        ]
      },
      "_types.analysis:IcuNormalizationType": {
        "type": "string",
        "enum": [
          "nfc",
          "nfkc",
          "nfkc_cf"
        ]
      },
      "_types.analysis:IcuNormalizationMode": {
        "type": "string",
        "enum": [
          "decompose",
          "compose"
        ]
      },
      "_types.analysis:KuromojiAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "kuromoji"
            ]
          },
          "mode": {
            "$ref": "#/components/schemas/_types.analysis:KuromojiTokenizationMode"
          },
          "user_dictionary": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "mode"
        ]
      },
      "_types.analysis:KuromojiTokenizationMode": {
        "type": "string",
        "enum": [
          "normal",
          "search",
          "extended"
        ]
      },
      "_types.analysis:SnowballAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "snowball"
            ]
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "language": {
            "$ref": "#/components/schemas/_types.analysis:SnowballLanguage"
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type",
          "language"
        ]
      },
      "_types.analysis:SnowballLanguage": {
        "type": "string",
        "enum": [
          "Armenian",
          "Basque",
          "Catalan",
          "Danish",
          "Dutch",
          "English",
          "Finnish",
          "French",
          "German",
          "German2",
          "Hungarian",
          "Italian",
          "Kp",
          "Lovins",
          "Norwegian",
          "Porter",
          "Portuguese",
          "Romanian",
          "Russian",
          "Spanish",
          "Swedish",
          "Turkish"
        ]
      },
      "_types.analysis:DutchAnalyzer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "dutch"
            ]
          },
          "stopwords": {
            "$ref": "#/components/schemas/_types.analysis:StopWords"
          }
        },
        "required": [
          "type"
        ]
      },
      "_global.search._types:HighlightBase": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterType"
          },
          "boundary_chars": {
            "description": "A string that contains each boundary character.",
            "type": "string"
          },
          "boundary_max_scan": {
            "description": "How far to scan for boundary characters.",
            "type": "number"
          },
          "boundary_scanner": {
            "$ref": "#/components/schemas/_global.search._types:BoundaryScanner"
          },
          "boundary_scanner_locale": {
            "description": "Controls which locale is used to search for sentence and word boundaries.\nThis parameter takes a form of a language tag, for example: `\"en-US\"`, `\"fr-FR\"`, `\"ja-JP\"`.",
            "type": "string"
          },
          "force_source": {
            "deprecated": true,
            "type": "boolean"
          },
          "fragmenter": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterFragmenter"
          },
          "fragment_size": {
            "description": "The size of the highlighted fragment in characters.",
            "type": "number"
          },
          "highlight_filter": {
            "type": "boolean"
          },
          "highlight_query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "max_fragment_length": {
            "type": "number"
          },
          "max_analyzed_offset": {
            "description": "If set to a non-negative value, highlighting stops at this defined maximum limit.\nThe rest of the text is not processed, thus not highlighted and no error is returned\nThe `max_analyzed_offset` query setting does not override the `index.highlight.max_analyzed_offset` setting, which prevails when its set to lower value than the query setting.",
            "type": "number"
          },
          "no_match_size": {
            "description": "The amount of text you want to return from the beginning of the field if there are no matching fragments to highlight.",
            "type": "number"
          },
          "number_of_fragments": {
            "description": "The maximum number of fragments to return.\nIf the number of fragments is set to `0`, no fragments are returned.\nInstead, the entire field contents are highlighted and returned.\nThis can be handy when you need to highlight short texts such as a title or address, but fragmentation is not required.\nIf `number_of_fragments` is `0`, `fragment_size` is ignored.",
            "type": "number"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "order": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterOrder"
          },
          "phrase_limit": {
            "description": "Controls the number of matching phrases in a document that are considered.\nPrevents the `fvh` highlighter from analyzing too many phrases and consuming too much memory.\nWhen using `matched_fields`, `phrase_limit` phrases per matched field are considered. Raising the limit increases query time and consumes more memory.\nOnly supported by the `fvh` highlighter.",
            "type": "number"
          },
          "post_tags": {
            "description": "Use in conjunction with `pre_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "pre_tags": {
            "description": "Use in conjunction with `post_tags` to define the HTML tags to use for the highlighted text.\nBy default, highlighted text is wrapped in `<em>` and `</em>` tags.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "require_field_match": {
            "description": "By default, only fields that contains a query match are highlighted.\nSet to `false` to highlight all fields.",
            "type": "boolean"
          },
          "tags_schema": {
            "$ref": "#/components/schemas/_global.search._types:HighlighterTagsSchema"
          }
        }
      },
      "_global.search._types:HighlighterType": {
        "type": "string",
        "enum": [
          "plain",
          "fvh",
          "unified"
        ]
      },
      "_global.search._types:BoundaryScanner": {
        "type": "string",
        "enum": [
          "chars",
          "sentence",
          "word"
        ]
      },
      "_global.search._types:HighlighterFragmenter": {
        "type": "string",
        "enum": [
          "simple",
          "span"
        ]
      },
      "_global.search._types:HighlighterOrder": {
        "type": "string",
        "enum": [
          "score"
        ]
      },
      "_global.search._types:HighlighterTagsSchema": {
        "type": "string",
        "enum": [
          "styled"
        ]
      },
      "_types:ScriptField": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "ignore_failure": {
            "type": "boolean"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types:Sort": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:SortCombinations"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:SortCombinations"
            }
          }
        ]
      },
      "_types:SortCombinations": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Field"
          },
          {
            "$ref": "#/components/schemas/_types:SortOptions"
          }
        ]
      },
      "_types:SortOptions": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/sort-search-results.html"
        },
        "type": "object",
        "properties": {
          "_score": {
            "$ref": "#/components/schemas/_types:ScoreSort"
          },
          "_doc": {
            "$ref": "#/components/schemas/_types:ScoreSort"
          },
          "_geo_distance": {
            "$ref": "#/components/schemas/_types:GeoDistanceSort"
          },
          "_script": {
            "$ref": "#/components/schemas/_types:ScriptSort"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:ScoreSort": {
        "type": "object",
        "properties": {
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          }
        }
      },
      "_types:SortOrder": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ]
      },
      "_types:GeoDistanceSort": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/_types:SortMode"
          },
          "distance_type": {
            "$ref": "#/components/schemas/_types:GeoDistanceType"
          },
          "ignore_unmapped": {
            "type": "boolean"
          },
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          },
          "unit": {
            "$ref": "#/components/schemas/_types:DistanceUnit"
          }
        }
      },
      "_types:SortMode": {
        "type": "string",
        "enum": [
          "min",
          "max",
          "sum",
          "avg",
          "median"
        ]
      },
      "_types:DistanceUnit": {
        "type": "string",
        "enum": [
          "in",
          "ft",
          "yd",
          "mi",
          "nmi",
          "km",
          "m",
          "cm",
          "mm"
        ]
      },
      "_types:ScriptSort": {
        "type": "object",
        "properties": {
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "type": {
            "$ref": "#/components/schemas/_types:ScriptSortType"
          },
          "mode": {
            "$ref": "#/components/schemas/_types:SortMode"
          },
          "nested": {
            "$ref": "#/components/schemas/_types:NestedSortValue"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types:ScriptSortType": {
        "type": "string",
        "enum": [
          "string",
          "number",
          "version"
        ]
      },
      "_types:NestedSortValue": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "max_children": {
            "type": "number"
          },
          "nested": {
            "$ref": "#/components/schemas/_types:NestedSortValue"
          },
          "path": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "path"
        ]
      },
      "_global.search._types:SourceConfig": {
        "description": "Defines how to fetch a source. Fetching can be disabled entirely, or the source can be filtered.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "$ref": "#/components/schemas/_global.search._types:SourceFilter"
          }
        ]
      },
      "_global.search._types:SourceFilter": {
        "type": "object",
        "properties": {
          "excludes": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "includes": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        }
      },
      "_types.query_dsl:ChildScoreMode": {
        "type": "string",
        "enum": [
          "none",
          "avg",
          "sum",
          "max",
          "min"
        ]
      },
      "_types:RelationName": {
        "type": "string"
      },
      "_types.query_dsl:HasParentQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `parent_type` and not return any documents instead of an error.\nYou can use this parameter to query multiple indices that may not contain the `parent_type`.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              "parent_type": {
                "$ref": "#/components/schemas/_types:RelationName"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score": {
                "description": "Indicates whether the relevance score of a matching parent document is aggregated into its child documents.",
                "type": "boolean"
              }
            },
            "required": [
              "parent_type",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:IdsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "values": {
                "$ref": "#/components/schemas/_types:Ids"
              }
            }
          }
        ]
      },
      "_types:Ids": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Id"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          }
        ]
      },
      "_types.query_dsl:IntervalsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "all_of": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsAllOf"
              },
              "any_of": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsAnyOf"
              },
              "fuzzy": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsFuzzy"
              },
              "match": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsMatch"
              },
              "prefix": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsPrefix"
              },
              "wildcard": {
                "$ref": "#/components/schemas/_types.query_dsl:IntervalsWildcard"
              }
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        ]
      },
      "_types.query_dsl:IntervalsAllOf": {
        "type": "object",
        "properties": {
          "intervals": {
            "description": "An array of rules to combine. All rules must produce a match in a document for the overall source to match.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
            }
          },
          "max_gaps": {
            "description": "Maximum number of positions between the matching terms.\nIntervals produced by the rules further apart than this are not considered matches.",
            "type": "number"
          },
          "ordered": {
            "description": "If `true`, intervals produced by the rules should appear in the order in which they are specified.",
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFilter"
          }
        },
        "required": [
          "intervals"
        ]
      },
      "_types.query_dsl:IntervalsContainer": {
        "type": "object",
        "properties": {
          "all_of": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsAllOf"
          },
          "any_of": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsAnyOf"
          },
          "fuzzy": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFuzzy"
          },
          "match": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsMatch"
          },
          "prefix": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsPrefix"
          },
          "wildcard": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsWildcard"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:IntervalsAnyOf": {
        "type": "object",
        "properties": {
          "intervals": {
            "description": "An array of rules to match.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
            }
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFilter"
          }
        },
        "required": [
          "intervals"
        ]
      },
      "_types.query_dsl:IntervalsFilter": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "before": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "contained_by": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "containing": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "not_contained_by": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "not_containing": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "not_overlapping": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "overlapping": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsContainer"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:IntervalsFuzzy": {
        "type": "object",
        "properties": {
          "analyzer": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
            },
            "description": "Analyzer used to normalize the term.",
            "type": "string"
          },
          "fuzziness": {
            "$ref": "#/components/schemas/_types:Fuzziness"
          },
          "prefix_length": {
            "description": "Number of beginning characters left unchanged when creating expansions.",
            "type": "number"
          },
          "term": {
            "description": "The term to match.",
            "type": "string"
          },
          "transpositions": {
            "description": "Indicates whether edits include transpositions of two adjacent characters (for example, `ab` to `ba`).",
            "type": "boolean"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "term"
        ]
      },
      "_types.query_dsl:IntervalsMatch": {
        "type": "object",
        "properties": {
          "analyzer": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
            },
            "description": "Analyzer used to analyze terms in the query.",
            "type": "string"
          },
          "max_gaps": {
            "description": "Maximum number of positions between the matching terms.\nTerms further apart than this are not considered matches.",
            "type": "number"
          },
          "ordered": {
            "description": "If `true`, matching terms must appear in their specified order.",
            "type": "boolean"
          },
          "query": {
            "description": "Text you wish to find in the provided field.",
            "type": "string"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:IntervalsFilter"
          }
        },
        "required": [
          "query"
        ]
      },
      "_types.query_dsl:IntervalsPrefix": {
        "type": "object",
        "properties": {
          "analyzer": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
            },
            "description": "Analyzer used to analyze the `prefix`.",
            "type": "string"
          },
          "prefix": {
            "description": "Beginning characters of terms you wish to find in the top-level field.",
            "type": "string"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "prefix"
        ]
      },
      "_types.query_dsl:IntervalsWildcard": {
        "type": "object",
        "properties": {
          "analyzer": {
            "description": "Analyzer used to analyze the `pattern`.\nDefaults to the top-level field's analyzer.",
            "type": "string"
          },
          "pattern": {
            "description": "Wildcard pattern used to find matching terms.",
            "type": "string"
          },
          "use_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "pattern"
        ]
      },
      "_types.query_dsl:MatchQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "cutoff_frequency": {
                "deprecated": true,
                "type": "number"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "query": {
                "description": "Text, number, boolean value or date you wish to find in the provided field.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "number"
                  },
                  {
                    "type": "boolean"
                  }
                ]
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:ZeroTermsQuery": {
        "type": "string",
        "enum": [
          "all",
          "none"
        ]
      },
      "_types.query_dsl:MatchAllQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:MatchBoolPrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "number"
              },
              "query": {
                "description": "Terms you wish to find in the provided field.\nThe last term is used in a prefix query.",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:MatchNoneQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:MatchPhraseQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "query": {
                "description": "Query terms that are analyzed and turned into a phrase query.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:MatchPhrasePrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert text in the query value into tokens.",
                "type": "string"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the last provided term of the query value will expand.",
                "type": "number"
              },
              "query": {
                "description": "Text you wish to find in the provided field.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:MoreLikeThisQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "The analyzer that is used to analyze the free form text.\nDefaults to the analyzer associated with the first field in fields.",
                "type": "string"
              },
              "boost_terms": {
                "description": "Each term in the formed query could be further boosted by their tf-idf score.\nThis sets the boost factor to use when using this feature.\nDefaults to deactivated (0).",
                "type": "number"
              },
              "fail_on_unsupported_field": {
                "description": "Controls whether the query should fail (throw an exception) if any of the specified fields are not of the supported types (`text` or `keyword`).",
                "type": "boolean"
              },
              "fields": {
                "description": "A list of fields to fetch and analyze the text from.\nDefaults to the `index.query.default_field` index setting, which has a default value of `*`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "include": {
                "description": "Specifies whether the input documents should also be included in the search results returned.",
                "type": "boolean"
              },
              "like": {
                "description": "Specifies free form text and/or a single or multiple documents for which you want to find similar documents.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:Like"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:Like"
                    }
                  }
                ]
              },
              "max_doc_freq": {
                "description": "The maximum document frequency above which the terms are ignored from the input document.",
                "type": "number"
              },
              "max_query_terms": {
                "description": "The maximum number of query terms that can be selected.",
                "type": "number"
              },
              "max_word_length": {
                "description": "The maximum word length above which the terms are ignored.\nDefaults to unbounded (`0`).",
                "type": "number"
              },
              "min_doc_freq": {
                "description": "The minimum document frequency below which the terms are ignored from the input document.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "min_term_freq": {
                "description": "The minimum term frequency below which the terms are ignored from the input document.",
                "type": "number"
              },
              "min_word_length": {
                "description": "The minimum word length below which the terms are ignored.",
                "type": "number"
              },
              "per_field_analyzer": {
                "description": "Overrides the default analyzer.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "routing": {
                "$ref": "#/components/schemas/_types:Routing"
              },
              "stop_words": {
                "$ref": "#/components/schemas/_types.analysis:StopWords"
              },
              "unlike": {
                "description": "Used in combination with `like` to exclude documents that match a set of terms.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.query_dsl:Like"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:Like"
                    }
                  }
                ]
              },
              "version": {
                "$ref": "#/components/schemas/_types:VersionNumber"
              },
              "version_type": {
                "$ref": "#/components/schemas/_types:VersionType"
              }
            },
            "required": [
              "like"
            ]
          }
        ]
      },
      "_types.query_dsl:Like": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-mlt-query.html#_document_input_parameters"
        },
        "description": "Text that we want similar documents for or a lookup to a document's field for the text.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:LikeDocument"
          }
        ]
      },
      "_types.query_dsl:LikeDocument": {
        "type": "object",
        "properties": {
          "doc": {
            "description": "A document not present in the index.",
            "type": "object"
          },
          "fields": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "per_field_analyzer": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        }
      },
      "_types:VersionType": {
        "type": "string",
        "enum": [
          "internal",
          "external",
          "external_gte",
          "force"
        ]
      },
      "_types.query_dsl:MultiMatchQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert the text in the query value into tokens.",
                "type": "string"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "cutoff_frequency": {
                "deprecated": true,
                "type": "number"
              },
              "fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).\nCan be applied to the term subqueries constructed for all terms but the final term.",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text query value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_expansions": {
                "description": "Maximum number of terms to which the query will expand.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "query": {
                "description": "Text, number, boolean value or date you wish to find in the provided field.",
                "type": "string"
              },
              "slop": {
                "description": "Maximum number of positions allowed between matching tokens.",
                "type": "number"
              },
              "tie_breaker": {
                "description": "Determines how scores for each per-term blended query and scores across groups are combined.",
                "type": "number"
              },
              "type": {
                "$ref": "#/components/schemas/_types.query_dsl:TextQueryType"
              },
              "zero_terms_query": {
                "$ref": "#/components/schemas/_types.query_dsl:ZeroTermsQuery"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:TextQueryType": {
        "type": "string",
        "enum": [
          "best_fields",
          "most_fields",
          "cross_fields",
          "phrase",
          "phrase_prefix",
          "bool_prefix"
        ]
      },
      "_types.query_dsl:NestedQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped path and not return any documents instead of an error.",
                "type": "boolean"
              },
              "inner_hits": {
                "$ref": "#/components/schemas/_global.search._types:InnerHits"
              },
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "score_mode": {
                "$ref": "#/components/schemas/_types.query_dsl:ChildScoreMode"
              }
            },
            "required": [
              "path",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:ParentIdQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "ignore_unmapped": {
                "description": "Indicates whether to ignore an unmapped `type` and not return any documents instead of an error.",
                "type": "boolean"
              },
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            }
          }
        ]
      },
      "_types.query_dsl:PercolateQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "document": {
                "description": "The source of the document being percolated.",
                "type": "object"
              },
              "documents": {
                "description": "An array of sources of the documents being percolated.",
                "type": "array",
                "items": {
                  "type": "object"
                }
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "index": {
                "$ref": "#/components/schemas/_types:IndexName"
              },
              "name": {
                "description": "The suffix used for the `_percolator_document_slot` field when multiple `percolate` queries are specified.",
                "type": "string"
              },
              "preference": {
                "description": "Preference used to fetch document to percolate.",
                "type": "string"
              },
              "routing": {
                "$ref": "#/components/schemas/_types:Routing"
              },
              "version": {
                "$ref": "#/components/schemas/_types:VersionNumber"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:PinnedQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "allOf": [
              {
                "type": "object",
                "properties": {
                  "organic": {
                    "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                  }
                },
                "required": [
                  "organic"
                ]
              },
              {
                "type": "object",
                "properties": {
                  "ids": {
                    "description": "Document IDs listed in the order they are to appear in results.\nRequired if `docs` is not specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types:Id"
                    }
                  },
                  "docs": {
                    "description": "Documents listed in the order they are to appear in results.\nRequired if `ids` is not specified.",
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.query_dsl:PinnedDoc"
                    }
                  }
                },
                "minProperties": 1,
                "maxProperties": 1
              }
            ]
          }
        ]
      },
      "_types.query_dsl:PinnedDoc": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "_id",
          "_index"
        ]
      },
      "_types.query_dsl:PrefixQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "value": {
                "description": "Beginning characters of terms you wish to find in the provided field.",
                "type": "string"
              },
              "case_insensitive": {
                "description": "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nDefault is `false` which means the case sensitivity of matching depends on the underlying fields mapping.",
                "type": "boolean"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:QueryStringQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "allow_leading_wildcard": {
                "description": "If `true`, the wildcard characters `*` and `?` are allowed as the first character of the query string.",
                "type": "boolean"
              },
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert text in the query string into tokens.",
                "type": "string"
              },
              "analyze_wildcard": {
                "description": "If `true`, the query attempts to analyze wildcard terms in the query string.",
                "type": "boolean"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, match phrase queries are automatically created for multi-term synonyms.",
                "type": "boolean"
              },
              "default_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "default_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "enable_position_increments": {
                "description": "If `true`, enable position increments in queries constructed from a `query_string` search.",
                "type": "boolean"
              },
              "escape": {
                "type": "boolean"
              },
              "fields": {
                "description": "Array of fields to search. Supports wildcards (`*`).",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "fuzziness": {
                "$ref": "#/components/schemas/_types:Fuzziness"
              },
              "fuzzy_max_expansions": {
                "description": "Maximum number of terms to which the query expands for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "max_determinized_states": {
                "description": "Maximum number of automaton states required for the query.",
                "type": "number"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "phrase_slop": {
                "description": "Maximum number of positions allowed between matching tokens for phrases.",
                "type": "number"
              },
              "query": {
                "description": "Query string you wish to parse and use for search.",
                "type": "string"
              },
              "quote_analyzer": {
                "description": "Analyzer used to convert quoted text in the query string into tokens.\nFor quoted text, this parameter overrides the analyzer specified in the `analyzer` parameter.",
                "type": "string"
              },
              "quote_field_suffix": {
                "description": "Suffix appended to quoted text in the query string.\nYou can use this suffix to use a different analysis method for exact matches.",
                "type": "string"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "tie_breaker": {
                "description": "How to combine the queries generated from the individual search terms in the resulting `dis_max` query.",
                "type": "number"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              },
              "type": {
                "$ref": "#/components/schemas/_types.query_dsl:TextQueryType"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types:TimeZone": {
        "type": "string"
      },
      "_types.query_dsl:RangeQuery": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:DateRangeQuery"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:NumberRangeQuery"
          }
        ]
      },
      "_types.query_dsl:DateRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RangeQueryBase"
          },
          {
            "type": "object",
            "properties": {
              "gt": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "gte": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "lt": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "lte": {
                "$ref": "#/components/schemas/_types:DateMath"
              },
              "from": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types:DateMath"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types:DateMath"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "format": {
                "$ref": "#/components/schemas/_types:DateFormat"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types:DateFormat": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html"
        },
        "type": "string"
      },
      "_types.query_dsl:RangeQueryBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "relation": {
                "$ref": "#/components/schemas/_types.query_dsl:RangeRelation"
              }
            }
          }
        ]
      },
      "_types.query_dsl:RangeRelation": {
        "type": "string",
        "enum": [
          "within",
          "contains",
          "intersects"
        ]
      },
      "_types.query_dsl:NumberRangeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RangeQueryBase"
          },
          {
            "type": "object",
            "properties": {
              "gt": {
                "description": "Greater than.",
                "type": "number"
              },
              "gte": {
                "description": "Greater than or equal to.",
                "type": "number"
              },
              "lt": {
                "description": "Less than.",
                "type": "number"
              },
              "lte": {
                "description": "Less than or equal to.",
                "type": "number"
              },
              "from": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "to": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              }
            }
          }
        ]
      },
      "_types.query_dsl:RankFeatureQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "saturation": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionSaturation"
              },
              "log": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionLogarithm"
              },
              "linear": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionLinear"
              },
              "sigmoid": {
                "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunctionSigmoid"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunctionSaturation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "pivot": {
                "description": "Configurable pivot value so that the result will be less than 0.5.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunction": {
        "type": "object"
      },
      "_types.query_dsl:RankFeatureFunctionLogarithm": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "scaling_factor": {
                "description": "Configurable scaling factor.",
                "type": "number"
              }
            },
            "required": [
              "scaling_factor"
            ]
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunctionLinear": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:RankFeatureFunctionSigmoid": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:RankFeatureFunction"
          },
          {
            "type": "object",
            "properties": {
              "pivot": {
                "description": "Configurable pivot value so that the result will be less than 0.5.",
                "type": "number"
              },
              "exponent": {
                "description": "Configurable Exponent.",
                "type": "number"
              }
            },
            "required": [
              "pivot",
              "exponent"
            ]
          }
        ]
      },
      "_types.query_dsl:RegexpQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "case_insensitive": {
                "description": "Allows case insensitive matching of the regular expression value with the indexed field values when set to `true`.\nWhen `false`, case sensitivity of matching depends on the underlying fields mapping.",
                "type": "boolean"
              },
              "flags": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/regexp-syntax.html"
                },
                "description": "Enables optional operators for the regular expression.",
                "type": "string"
              },
              "max_determinized_states": {
                "description": "Maximum number of automaton states required for the query.",
                "type": "number"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "value": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/regexp-syntax.html"
                },
                "description": "Regular expression for terms you wish to find in the provided field.",
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:RuleQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "organic": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "ruleset_id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "match_criteria": {
                "type": "object"
              }
            },
            "required": [
              "organic",
              "ruleset_id",
              "match_criteria"
            ]
          }
        ]
      },
      "_types.query_dsl:ScriptQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "script"
            ]
          }
        ]
      },
      "_types.query_dsl:ScriptScoreQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "min_score": {
                "description": "Documents with a score lower than this floating point number are excluded from the search results.",
                "type": "number"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "query",
              "script"
            ]
          }
        ]
      },
      "_types.query_dsl:ShapeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unmapped": {
                "description": "When set to `true` the query ignores an unmapped field and will not match any documents.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.query_dsl:SimpleQueryStringQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "externalDocs": {
                  "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html"
                },
                "description": "Analyzer used to convert text in the query string into tokens.",
                "type": "string"
              },
              "analyze_wildcard": {
                "description": "If `true`, the query attempts to analyze wildcard terms in the query string.",
                "type": "boolean"
              },
              "auto_generate_synonyms_phrase_query": {
                "description": "If `true`, the parser creates a match_phrase query for each multi-position token.",
                "type": "boolean"
              },
              "default_operator": {
                "$ref": "#/components/schemas/_types.query_dsl:Operator"
              },
              "fields": {
                "description": "Array of fields you wish to search.\nAccepts wildcard expressions.\nYou also can boost relevance scores for matches to particular fields using a caret (`^`) notation.\nDefaults to the `index.query.default_field index` setting, which has a default value of `*`.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Field"
                }
              },
              "flags": {
                "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringFlags"
              },
              "fuzzy_max_expansions": {
                "description": "Maximum number of terms to which the query expands for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_prefix_length": {
                "description": "Number of beginning characters left unchanged for fuzzy matching.",
                "type": "number"
              },
              "fuzzy_transpositions": {
                "description": "If `true`, edits for fuzzy matching include transpositions of two adjacent characters (for example, `ab` to `ba`).",
                "type": "boolean"
              },
              "lenient": {
                "description": "If `true`, format-based errors, such as providing a text value for a numeric field, are ignored.",
                "type": "boolean"
              },
              "minimum_should_match": {
                "$ref": "#/components/schemas/_types:MinimumShouldMatch"
              },
              "query": {
                "description": "Query string in the simple query string syntax you wish to parse and use for search.",
                "type": "string"
              },
              "quote_field_suffix": {
                "description": "Suffix appended to quoted text in the query string.",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:SimpleQueryStringFlags": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-simple-query-string-query.html#supported-flags"
        },
        "description": "Query flags can be either a single flag or a combination of flags, e.g. `OR|AND|PREFIX`",
        "allOf": [
          {
            "$ref": "#/components/schemas/_spec_utils:PipeSeparatedFlagsSimpleQueryStringFlag"
          }
        ]
      },
      "_spec_utils:PipeSeparatedFlagsSimpleQueryStringFlag": {
        "description": "A set of flags that can be represented as a single enum value or a set of values that are encoded\nas a pipe-separated string\n\nDepending on the target language, code generators can use this hint to generate language specific\nflags enum constructs and the corresponding (de-)serialization code.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:SimpleQueryStringFlag"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.query_dsl:SimpleQueryStringFlag": {
        "type": "string",
        "enum": [
          "NONE",
          "AND",
          "NOT",
          "OR",
          "PREFIX",
          "PHRASE",
          "PRECEDENCE",
          "ESCAPE",
          "WHITESPACE",
          "FUZZY",
          "NEAR",
          "SLOP",
          "ALL"
        ]
      },
      "_types.query_dsl:SpanContainingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "big": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "little": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "big",
              "little"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanQuery": {
        "type": "object",
        "properties": {
          "span_containing": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanContainingQuery"
          },
          "field_masking_span": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFieldMaskingQuery"
          },
          "span_first": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanFirstQuery"
          },
          "span_gap": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanGapQuery"
          },
          "span_multi": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanMultiTermQuery"
          },
          "span_near": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNearQuery"
          },
          "span_not": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanNotQuery"
          },
          "span_or": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanOrQuery"
          },
          "span_term": {
            "description": "The equivalent of the `term` query but for use with other span queries.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:SpanTermQuery"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          "span_within": {
            "$ref": "#/components/schemas/_types.query_dsl:SpanWithinQuery"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:SpanFieldMaskingQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "query": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "field",
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanFirstQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "end": {
                "description": "Controls the maximum end position permitted in a match.",
                "type": "number"
              },
              "match": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "end",
              "match"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanGapQuery": {
        "description": "Can only be used as a clause in a span_near query.",
        "type": "object",
        "additionalProperties": {
          "type": "number"
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types.query_dsl:SpanMultiTermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "match": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              }
            },
            "required": [
              "match"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanNearQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "clauses": {
                "description": "Array of one or more other span type queries.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
                }
              },
              "in_order": {
                "description": "Controls whether matches are required to be in-order.",
                "type": "boolean"
              },
              "slop": {
                "description": "Controls the maximum number of intervening unmatched positions permitted.",
                "type": "number"
              }
            },
            "required": [
              "clauses"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanNotQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "dist": {
                "description": "The number of tokens from within the include span that cant have overlap with the exclude span.\nEquivalent to setting both `pre` and `post`.",
                "type": "number"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "include": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "post": {
                "description": "The number of tokens after the include span that cant have overlap with the exclude span.",
                "type": "number"
              },
              "pre": {
                "description": "The number of tokens before the include span that cant have overlap with the exclude span.",
                "type": "number"
              }
            },
            "required": [
              "exclude",
              "include"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanOrQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "clauses": {
                "description": "Array of one or more other span type queries.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
                }
              }
            },
            "required": [
              "clauses"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanTermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:SpanWithinQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "big": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              },
              "little": {
                "$ref": "#/components/schemas/_types.query_dsl:SpanQuery"
              }
            },
            "required": [
              "big",
              "little"
            ]
          }
        ]
      },
      "_types.query_dsl:TermQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "case_insensitive": {
                "description": "Allows ASCII case insensitive matching of the value with the indexed field values when set to `true`.\nWhen `false`, the case sensitivity of matching depends on the underlying fields mapping.",
                "type": "boolean"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.query_dsl:TermsQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.query_dsl:TermsSetQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "minimum_should_match_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "minimum_should_match_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "terms": {
                "description": "Array of terms you wish to find in the provided field.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "terms"
            ]
          }
        ]
      },
      "_types.query_dsl:TextExpansionQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "description": "The text expansion NLP model to use",
                "type": "string"
              },
              "model_text": {
                "description": "The query text",
                "type": "string"
              }
            },
            "required": [
              "model_id",
              "model_text"
            ]
          }
        ]
      },
      "_types.query_dsl:WildcardQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "case_insensitive": {
                "description": "Allows case insensitive matching of the pattern with the indexed field values when set to true. Default is false which means the case sensitivity of matching depends on the underlying fields mapping.",
                "type": "boolean"
              },
              "rewrite": {
                "$ref": "#/components/schemas/_types:MultiTermQueryRewrite"
              },
              "value": {
                "description": "Wildcard pattern for terms you wish to find in the provided field. Required, when wildcard is not set.",
                "type": "string"
              },
              "wildcard": {
                "description": "Wildcard pattern for terms you wish to find in the provided field. Required, when value is not set.",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.query_dsl:WrapperQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "query": {
                "description": "A base64 encoded query.\nThe binary data format can be any of JSON, YAML, CBOR or SMILE encodings",
                "type": "string"
              }
            },
            "required": [
              "query"
            ]
          }
        ]
      },
      "_types.query_dsl:TypeQuery": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "string"
              }
            },
            "required": [
              "value"
            ]
          }
        ]
      },
      "_types.aggregations:BucketAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:Aggregation": {
        "type": "object",
        "properties": {
          "meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "name": {
            "type": "string"
          }
        }
      },
      "_types.aggregations:AutoDateHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "buckets": {
                "description": "The target number of buckets.",
                "type": "number"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "format": {
                "description": "The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.",
                "type": "string"
              },
              "minimum_interval": {
                "$ref": "#/components/schemas/_types.aggregations:MinimumInterval"
              },
              "missing": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "offset": {
                "description": "Time zone specified as a ISO 8601 UTC offset.",
                "type": "string"
              },
              "params": {
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types.aggregations:MinimumInterval": {
        "type": "string",
        "enum": [
          "second",
          "minute",
          "hour",
          "day",
          "month",
          "year"
        ]
      },
      "_types.aggregations:AverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:FormatMetricAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:MetricAggregationBase": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing": {
            "$ref": "#/components/schemas/_types.aggregations:Missing"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        }
      },
      "_types.aggregations:Missing": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          }
        ]
      },
      "_types.aggregations:AverageBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:PipelineAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketPathAggregation"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "description": "`DecimalFormat` pattern for the output value.\nIf specified, the formatted value is returned in the aggregations `value_as_string` property.",
                "type": "string"
              },
              "gap_policy": {
                "$ref": "#/components/schemas/_types.aggregations:GapPolicy"
              }
            }
          }
        ]
      },
      "_types.aggregations:GapPolicy": {
        "type": "string",
        "enum": [
          "skip",
          "insert_zeros",
          "keep_values"
        ]
      },
      "_types.aggregations:BucketPathAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "buckets_path": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsPath"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketsPath": {
        "description": "Buckets path can be expressed in different ways, and an aggregation may accept some or all of these\nforms depending on its type. Please refer to each aggregation's documentation to know what buckets\npath forms they accept.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        ]
      },
      "_types.aggregations:BoxplotAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "compression": {
                "description": "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketScriptAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketSelectorAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketSortAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "from": {
                "description": "Buckets in positions prior to `from` will be truncated.",
                "type": "number"
              },
              "gap_policy": {
                "$ref": "#/components/schemas/_types.aggregations:GapPolicy"
              },
              "size": {
                "description": "The number of buckets to return.\nDefaults to all buckets of the parent aggregation.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketKsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketPathAggregation"
          },
          {
            "type": "object",
            "properties": {
              "alternative": {
                "description": "A list of string values indicating which K-S test alternative to calculate. The valid values\nare: \"greater\", \"less\", \"two_sided\". This parameter is key for determining the K-S statistic used\nwhen calculating the K-S test. Default value is all possible alternative hypotheses.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "fractions": {
                "description": "A list of doubles indicating the distribution of the samples with which to compare to the `buckets_path` results.\nIn typical usage this is the overall proportion of documents in each bucket, which is compared with the actual\ndocument proportions in each bucket from the sibling aggregation counts. The default is to assume that overall\ndocuments are uniformly distributed on these buckets, which they would be if one used equal percentiles of a\nmetric to define the bucket end points.",
                "type": "array",
                "items": {
                  "type": "number"
                }
              },
              "sampling_method": {
                "description": "Indicates the sampling methodology when calculating the K-S test. Note, this is sampling of the returned values.\nThis determines the cumulative distribution function (CDF) points used comparing the two samples. Default is\n`upper_tail`, which emphasizes the upper end of the CDF points. Valid options are: `upper_tail`, `uniform`,\nand `lower_tail`.",
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketCorrelationAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketPathAggregation"
          },
          {
            "type": "object",
            "properties": {
              "function": {
                "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationFunction"
              }
            },
            "required": [
              "function"
            ]
          }
        ]
      },
      "_types.aggregations:BucketCorrelationFunction": {
        "type": "object",
        "properties": {
          "count_correlation": {
            "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationFunctionCountCorrelation"
          }
        },
        "required": [
          "count_correlation"
        ]
      },
      "_types.aggregations:BucketCorrelationFunctionCountCorrelation": {
        "type": "object",
        "properties": {
          "indicator": {
            "$ref": "#/components/schemas/_types.aggregations:BucketCorrelationFunctionCountCorrelationIndicator"
          }
        },
        "required": [
          "indicator"
        ]
      },
      "_types.aggregations:BucketCorrelationFunctionCountCorrelationIndicator": {
        "type": "object",
        "properties": {
          "doc_count": {
            "description": "The total number of documents that initially created the expectations. Its required to be greater\nthan or equal to the sum of all values in the buckets_path as this is the originating superset of data\nto which the term values are correlated.",
            "type": "number"
          },
          "expectations": {
            "description": "An array of numbers with which to correlate the configured `bucket_path` values.\nThe length of this value must always equal the number of buckets returned by the `bucket_path`.",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "fractions": {
            "description": "An array of fractions to use when averaging and calculating variance. This should be used if\nthe pre-calculated data and the buckets_path have known gaps. The length of fractions, if provided,\nmust equal expectations.",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "doc_count",
          "expectations"
        ]
      },
      "_types.aggregations:CardinalityAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "precision_threshold": {
                "description": "A unique count below which counts are expected to be close to accurate.\nThis allows to trade memory for accuracy.",
                "type": "number"
              },
              "rehash": {
                "type": "boolean"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:CardinalityExecutionMode"
              }
            }
          }
        ]
      },
      "_types.aggregations:CardinalityExecutionMode": {
        "type": "string",
        "enum": [
          "global_ordinals",
          "segment_ordinals",
          "direct",
          "save_memory_heuristic",
          "save_time_heuristic"
        ]
      },
      "_types.aggregations:CategorizeTextAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "max_unique_tokens": {
                "description": "The maximum number of unique tokens at any position up to max_matched_tokens. Must be larger than 1.\nSmaller values use less memory and create fewer categories. Larger values will use more memory and\ncreate narrower categories. Max allowed value is 100.",
                "type": "number"
              },
              "max_matched_tokens": {
                "description": "The maximum number of token positions to match on before attempting to merge categories. Larger\nvalues will use more memory and create narrower categories. Max allowed value is 100.",
                "type": "number"
              },
              "similarity_threshold": {
                "description": "The minimum percentage of tokens that must match for text to be added to the category bucket. Must\nbe between 1 and 100. The larger the value the narrower the categories. Larger values will increase memory\nusage and create narrower categories.",
                "type": "number"
              },
              "categorization_filters": {
                "description": "This property expects an array of regular expressions. The expressions are used to filter out matching\nsequences from the categorization field values. You can use this functionality to fine tune the categorization\nby excluding sequences from consideration when categories are defined. For example, you can exclude SQL\nstatements that appear in your log files. This property cannot be used at the same time as categorization_analyzer.\nIf you only want to define simple regular expression filters that are applied prior to tokenization, setting\nthis property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering,\nuse the categorization_analyzer property instead and include the filters as pattern_replace character filters.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "categorization_analyzer": {
                "$ref": "#/components/schemas/_types.aggregations:CategorizeTextAnalyzer"
              },
              "shard_size": {
                "description": "The number of categorization buckets to return from each shard before merging all the results.",
                "type": "number"
              },
              "size": {
                "description": "The number of buckets to return.",
                "type": "number"
              },
              "min_doc_count": {
                "description": "The minimum number of documents in a bucket to be returned to the results.",
                "type": "number"
              },
              "shard_min_doc_count": {
                "description": "The minimum number of documents in a bucket to be returned from the shard before merging.",
                "type": "number"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.aggregations:CategorizeTextAnalyzer": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:CustomCategorizeTextAnalyzer"
          }
        ]
      },
      "_types.aggregations:CustomCategorizeTextAnalyzer": {
        "type": "object",
        "properties": {
          "char_filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "tokenizer": {
            "type": "string"
          },
          "filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "_types.aggregations:ChildrenAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "after": {
                "$ref": "#/components/schemas/_types.aggregations:CompositeAggregateKey"
              },
              "size": {
                "description": "The number of composite buckets that should be returned.",
                "type": "number"
              },
              "sources": {
                "description": "The value sources used to build composite buckets.\nKeys are returned in the order of the `sources` definition.",
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationSource"
                  }
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeAggregationSource": {
        "type": "object",
        "properties": {
          "terms": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeTermsAggregation"
          },
          "histogram": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeHistogramAggregation"
          },
          "date_histogram": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeDateHistogramAggregation"
          },
          "geotile_grid": {
            "$ref": "#/components/schemas/_types.aggregations:CompositeGeoTileGridAggregation"
          }
        }
      },
      "_types.aggregations:CompositeTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:CompositeAggregationBase": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing_bucket": {
            "type": "boolean"
          },
          "missing_order": {
            "$ref": "#/components/schemas/_types.aggregations:MissingOrder"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "value_type": {
            "$ref": "#/components/schemas/_types.aggregations:ValueType"
          },
          "order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          }
        }
      },
      "_types.aggregations:MissingOrder": {
        "type": "string",
        "enum": [
          "first",
          "last",
          "default"
        ]
      },
      "_types.aggregations:ValueType": {
        "type": "string",
        "enum": [
          "string",
          "long",
          "double",
          "number",
          "date",
          "date_nanos",
          "ip",
          "numeric",
          "geo_point",
          "boolean"
        ]
      },
      "_types.aggregations:CompositeHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "interval": {
                "type": "number"
              }
            },
            "required": [
              "interval"
            ]
          }
        ]
      },
      "_types.aggregations:CompositeDateHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              },
              "calendar_interval": {
                "$ref": "#/components/schemas/_types:DurationLarge"
              },
              "fixed_interval": {
                "$ref": "#/components/schemas/_types:DurationLarge"
              },
              "offset": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              }
            }
          }
        ]
      },
      "_types.aggregations:CompositeGeoTileGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:CompositeAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "precision": {
                "type": "number"
              },
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              }
            }
          }
        ]
      },
      "_types.aggregations:CumulativeCardinalityAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:CumulativeSumAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:DateHistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "calendar_interval": {
                "$ref": "#/components/schemas/_types.aggregations:CalendarInterval"
              },
              "extended_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsFieldDateMath"
              },
              "hard_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsFieldDateMath"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "fixed_interval": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "format": {
                "description": "The date format used to format `key_as_string` in the response.\nIf no `format` is specified, the first date format specified in the field mapping is used.",
                "type": "string"
              },
              "interval": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "min_doc_count": {
                "description": "Only returns buckets that have `min_doc_count` number of documents.\nBy default, all buckets between the first bucket that matches documents and the last one are returned.",
                "type": "number"
              },
              "missing": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "offset": {
                "$ref": "#/components/schemas/_types:Duration"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "params": {
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:CalendarInterval": {
        "type": "string",
        "enum": [
          "second",
          "minute",
          "hour",
          "day",
          "week",
          "month",
          "quarter",
          "year"
        ]
      },
      "_types.aggregations:ExtendedBoundsFieldDateMath": {
        "type": "object",
        "properties": {
          "max": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          },
          "min": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          }
        },
        "required": [
          "max",
          "min"
        ]
      },
      "_types.aggregations:FieldDateMath": {
        "description": "A date range limit, represented either as a DateMath expression or a number expressed\naccording to the target field's precision.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:DateMath"
          },
          {
            "type": "number"
          }
        ]
      },
      "_types.aggregations:AggregateOrder": {
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:SortOrder"
            },
            "minProperties": 1,
            "maxProperties": 1
          },
          {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/_types:SortOrder"
              },
              "minProperties": 1,
              "maxProperties": 1
            }
          }
        ]
      },
      "_types.aggregations:DateRangeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "format": {
                "description": "The date format used to format `from` and `to` in the response.",
                "type": "string"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              },
              "ranges": {
                "description": "Array of date ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:DateRangeExpression"
                }
              },
              "time_zone": {
                "$ref": "#/components/schemas/_types:TimeZone"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and returns the ranges as a hash rather than an array.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:DateRangeExpression": {
        "type": "object",
        "properties": {
          "from": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          },
          "key": {
            "description": "Custom key to return the range with.",
            "type": "string"
          },
          "to": {
            "$ref": "#/components/schemas/_types.aggregations:FieldDateMath"
          }
        }
      },
      "_types.aggregations:DerivativeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:DiversifiedSamplerAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:SamplerAggregationExecutionHint"
              },
              "max_docs_per_value": {
                "description": "Limits how many documents are permitted per choice of de-duplicating value.",
                "type": "number"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "shard_size": {
                "description": "Limits how many top-scoring documents are collected in the sample processed on each shard.",
                "type": "number"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            }
          }
        ]
      },
      "_types.aggregations:SamplerAggregationExecutionHint": {
        "type": "string",
        "enum": [
          "map",
          "global_ordinals",
          "bytes_hash"
        ]
      },
      "_types.aggregations:ExtendedStatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "sigma": {
                "description": "The number of standard deviations above/below the mean to display.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:ExtendedStatsBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "sigma": {
                "description": "The number of standard deviations above/below the mean to display.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:FrequentItemSetsAggregation": {
        "type": "object",
        "properties": {
          "fields": {
            "description": "Fields to analyze.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.aggregations:FrequentItemSetsField"
            }
          },
          "minimum_set_size": {
            "description": "The minimum size of one item set.",
            "type": "number"
          },
          "minimum_support": {
            "description": "The minimum support of one item set.",
            "type": "number"
          },
          "size": {
            "description": "The number of top item sets to return.",
            "type": "number"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "fields"
        ]
      },
      "_types.aggregations:FrequentItemSetsField": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "exclude": {
            "description": "Values to exclude.\nCan be regular expression strings or arrays of strings of exact terms.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "include": {
            "description": "Values to include.\nCan be regular expression strings or arrays of strings of exact terms.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:FiltersAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "filters": {
                "$ref": "#/components/schemas/_types.aggregations:BucketsQueryContainer"
              },
              "other_bucket": {
                "description": "Set to `true` to add a bucket to the response which will contain all documents that do not match any of the given filters.",
                "type": "boolean"
              },
              "other_bucket_key": {
                "description": "The key with which the other bucket is returned.",
                "type": "string"
              },
              "keyed": {
                "description": "By default, the named filters aggregation returns the buckets as an object.\nSet to `false` to return the buckets as an array of objects.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:BucketsQueryContainer": {
        "description": "Aggregation buckets. By default they are returned as an array, but if the aggregation has keys configured for\nthe different buckets, the result is a dictionary.",
        "oneOf": [
          {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
            }
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
            }
          }
        ]
      },
      "_types.aggregations:GeoBoundsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "wrap_longitude": {
                "description": "Specifies whether the bounding box should be allowed to overlap the international date line.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:GeoCentroidAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "count": {
                "type": "number"
              },
              "location": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              }
            }
          }
        ]
      },
      "_types.aggregations:GeoDistanceAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "distance_type": {
                "$ref": "#/components/schemas/_types:GeoDistanceType"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "origin": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              },
              "ranges": {
                "description": "An array of ranges used to bucket documents.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:AggregationRange"
                }
              },
              "unit": {
                "$ref": "#/components/schemas/_types:DistanceUnit"
              }
            }
          }
        ]
      },
      "_types.aggregations:AggregationRange": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Start of the range (inclusive).",
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "key": {
            "description": "Custom key to return the range with.",
            "type": "string"
          },
          "to": {
            "description": "End of the range (exclusive).",
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "_types.aggregations:GeoHashGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision": {
                "$ref": "#/components/schemas/_types:GeoHashPrecision"
              },
              "shard_size": {
                "description": "Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.",
                "type": "number"
              },
              "size": {
                "description": "The maximum number of geohash buckets to return.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types:GeoHashPrecision": {
        "description": "A precision that can be expressed as a geohash length between 1 and 12, or a distance measure like \"1km\", \"10m\".",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types.aggregations:GeoLineAggregation": {
        "type": "object",
        "properties": {
          "point": {
            "$ref": "#/components/schemas/_types.aggregations:GeoLinePoint"
          },
          "sort": {
            "$ref": "#/components/schemas/_types.aggregations:GeoLineSort"
          },
          "include_sort": {
            "description": "When `true`, returns an additional array of the sort values in the feature properties.",
            "type": "boolean"
          },
          "sort_order": {
            "$ref": "#/components/schemas/_types:SortOrder"
          },
          "size": {
            "description": "The maximum length of the line represented in the aggregation.\nValid sizes are between 1 and 10000.",
            "type": "number"
          }
        },
        "required": [
          "point",
          "sort"
        ]
      },
      "_types.aggregations:GeoLinePoint": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:GeoLineSort": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:GeoTileGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision": {
                "$ref": "#/components/schemas/_types:GeoTilePrecision"
              },
              "shard_size": {
                "description": "Allows for more accurate counting of the top cells returned in the final result the aggregation.\nDefaults to returning `max(10,(size x number-of-shards))` buckets from each shard.",
                "type": "number"
              },
              "size": {
                "description": "The maximum number of buckets to return.",
                "type": "number"
              },
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              }
            }
          }
        ]
      },
      "_types:GeoTilePrecision": {
        "type": "number"
      },
      "_types.aggregations:GeohexGridAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "precision": {
                "description": "Integer zoom of the key used to defined cells or buckets\nin the results. Value should be between 0-15.",
                "type": "number"
              },
              "bounds": {
                "$ref": "#/components/schemas/_types:GeoBounds"
              },
              "size": {
                "description": "Maximum number of buckets to return.",
                "type": "number"
              },
              "shard_size": {
                "description": "Number of buckets returned from each shard.",
                "type": "number"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "_types.aggregations:GlobalAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:HistogramAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "extended_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsdouble"
              },
              "hard_bounds": {
                "$ref": "#/components/schemas/_types.aggregations:ExtendedBoundsdouble"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "interval": {
                "description": "The interval for the buckets.\nMust be a positive decimal.",
                "type": "number"
              },
              "min_doc_count": {
                "description": "Only returns buckets that have `min_doc_count` number of documents.\nBy default, the response will fill gaps in the histogram with empty buckets.",
                "type": "number"
              },
              "missing": {
                "description": "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.",
                "type": "number"
              },
              "offset": {
                "description": "By default, the bucket keys start with 0 and then continue in even spaced steps of `interval`.\nThe bucket boundaries can be shifted by using the `offset` option.",
                "type": "number"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "format": {
                "type": "string"
              },
              "keyed": {
                "description": "If `true`, returns buckets as a hash instead of an array, keyed by the bucket keys.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:ExtendedBoundsdouble": {
        "type": "object",
        "properties": {
          "max": {
            "description": "Maximum value for the bound.",
            "type": "number"
          },
          "min": {
            "description": "Minimum value for the bound.",
            "type": "number"
          }
        },
        "required": [
          "max",
          "min"
        ]
      },
      "_types.aggregations:IpRangeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ranges": {
                "description": "Array of IP ranges.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:IpRangeAggregationRange"
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:IpRangeAggregationRange": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Start of the range.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "mask": {
            "description": "IP range defined as a CIDR mask.",
            "type": "string"
          },
          "to": {
            "description": "End of the range.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "_types.aggregations:IpPrefixAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "prefix_length": {
                "description": "Length of the network prefix. For IPv4 addresses the accepted range is [0, 32].\nFor IPv6 addresses the accepted range is [0, 128].",
                "type": "number"
              },
              "is_ipv6": {
                "description": "Defines whether the prefix applies to IPv6 addresses.",
                "type": "boolean"
              },
              "append_prefix_length": {
                "description": "Defines whether the prefix length is appended to IP address keys in the response.",
                "type": "boolean"
              },
              "keyed": {
                "description": "Defines whether buckets are returned as a hash rather than an array in the response.",
                "type": "boolean"
              },
              "min_doc_count": {
                "description": "Minimum number of documents in a bucket for it to be included in the response.",
                "type": "number"
              }
            },
            "required": [
              "field",
              "prefix_length"
            ]
          }
        ]
      },
      "_types.aggregations:InferenceAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "inference_config": {
                "$ref": "#/components/schemas/_types.aggregations:InferenceConfigContainer"
              }
            },
            "required": [
              "model_id"
            ]
          }
        ]
      },
      "_types.aggregations:InferenceConfigContainer": {
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ml._types:RegressionInferenceOptions"
          },
          "classification": {
            "$ref": "#/components/schemas/ml._types:ClassificationInferenceOptions"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:RegressionInferenceOptions": {
        "type": "object",
        "properties": {
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "num_top_feature_importance_values": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-feature-importance.html"
            },
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          }
        }
      },
      "ml._types:ClassificationInferenceOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "num_top_feature_importance_values": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-feature-importance.html"
            },
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          },
          "prediction_field_type": {
            "description": "Specifies the type of the predicted field to write. Acceptable values are: string, number, boolean. When boolean is provided 1.0 is transformed to true and 0.0 to false.",
            "type": "string"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "top_classes_results_field": {
            "description": "Specifies the field to which the top classes are written. Defaults to top_classes.",
            "type": "string"
          }
        }
      },
      "_types.aggregations:MatrixStatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MatrixAggregation"
          },
          {
            "type": "object",
            "properties": {
              "mode": {
                "$ref": "#/components/schemas/_types:SortMode"
              }
            }
          }
        ]
      },
      "_types.aggregations:MatrixAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "missing": {
                "description": "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.",
                "type": "object",
                "additionalProperties": {
                  "type": "number"
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:MaxAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MaxBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MedianAbsoluteDeviationAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "compression": {
                "description": "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MinAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MinBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:MissingAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              }
            }
          }
        ]
      },
      "_types.aggregations:MovingAverageAggregation": {
        "discriminator": {
          "propertyName": "model"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:LinearMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:SimpleMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:EwmaMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HoltMovingAverageAggregation"
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:HoltWintersMovingAverageAggregation"
          }
        ]
      },
      "_types.aggregations:LinearMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "linear"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types:EmptyObject": {
        "type": "object"
      },
      "_types.aggregations:MovingAverageAggregationBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "minimize": {
                "type": "boolean"
              },
              "predict": {
                "type": "number"
              },
              "window": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:SimpleMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "simple"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:EwmaMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "ewma"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types.aggregations:EwmaModelSettings"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:EwmaModelSettings": {
        "type": "object",
        "properties": {
          "alpha": {
            "type": "number"
          }
        }
      },
      "_types.aggregations:HoltMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "holt"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types.aggregations:HoltLinearModelSettings"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:HoltLinearModelSettings": {
        "type": "object",
        "properties": {
          "alpha": {
            "type": "number"
          },
          "beta": {
            "type": "number"
          }
        }
      },
      "_types.aggregations:HoltWintersMovingAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MovingAverageAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "model": {
                "type": "string",
                "enum": [
                  "holt_winters"
                ]
              },
              "settings": {
                "$ref": "#/components/schemas/_types.aggregations:HoltWintersModelSettings"
              }
            },
            "required": [
              "model",
              "settings"
            ]
          }
        ]
      },
      "_types.aggregations:HoltWintersModelSettings": {
        "type": "object",
        "properties": {
          "alpha": {
            "type": "number"
          },
          "beta": {
            "type": "number"
          },
          "gamma": {
            "type": "number"
          },
          "pad": {
            "type": "boolean"
          },
          "period": {
            "type": "number"
          },
          "type": {
            "$ref": "#/components/schemas/_types.aggregations:HoltWintersType"
          }
        }
      },
      "_types.aggregations:HoltWintersType": {
        "type": "string",
        "enum": [
          "add",
          "mult"
        ]
      },
      "_types.aggregations:MovingPercentilesAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "window": {
                "description": "The size of window to \"slide\" across the histogram.",
                "type": "number"
              },
              "shift": {
                "description": "By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.",
                "type": "number"
              },
              "keyed": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:MovingFunctionAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "script": {
                "description": "The script that should be executed on each window of data.",
                "type": "string"
              },
              "shift": {
                "description": "By default, the window consists of the last n values excluding the current bucket.\nIncreasing `shift` by 1, moves the starting window position by 1 to the right.",
                "type": "number"
              },
              "window": {
                "description": "The size of window to \"slide\" across the histogram.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:MultiTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "collect_mode": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationCollectMode"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "min_doc_count": {
                "description": "The minimum number of documents in a bucket for it to be returned.",
                "type": "number"
              },
              "shard_min_doc_count": {
                "description": "The minimum number of documents in a bucket on each shard for it to be returned.",
                "type": "number"
              },
              "shard_size": {
                "description": "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "show_term_doc_count_error": {
                "description": "Calculates the doc count error on per term basis.",
                "type": "boolean"
              },
              "size": {
                "description": "The number of term buckets should be returned out of the overall terms list.",
                "type": "number"
              },
              "terms": {
                "description": "The field from which to generate sets of terms.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:MultiTermLookup"
                }
              }
            },
            "required": [
              "terms"
            ]
          }
        ]
      },
      "_types.aggregations:TermsAggregationCollectMode": {
        "type": "string",
        "enum": [
          "depth_first",
          "breadth_first"
        ]
      },
      "_types.aggregations:MultiTermLookup": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing": {
            "$ref": "#/components/schemas/_types.aggregations:Missing"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:NestedAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              }
            }
          }
        ]
      },
      "_types.aggregations:NormalizeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "method": {
                "$ref": "#/components/schemas/_types.aggregations:NormalizeMethod"
              }
            }
          }
        ]
      },
      "_types.aggregations:NormalizeMethod": {
        "type": "string",
        "enum": [
          "rescale_0_1",
          "rescale_0_100",
          "percent_of_sum",
          "mean",
          "z-score",
          "softmax"
        ]
      },
      "_types.aggregations:ParentAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "$ref": "#/components/schemas/_types:RelationName"
              }
            }
          }
        ]
      },
      "_types.aggregations:PercentileRanksAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "keyed": {
                "description": "By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.",
                "type": "boolean"
              },
              "values": {
                "description": "An array of values for which to calculate the percentile ranks.",
                "oneOf": [
                  {
                    "type": "array",
                    "items": {
                      "type": "number"
                    }
                  },
                  {
                    "nullable": true,
                    "type": "string"
                  }
                ]
              },
              "hdr": {
                "$ref": "#/components/schemas/_types.aggregations:HdrMethod"
              },
              "tdigest": {
                "$ref": "#/components/schemas/_types.aggregations:TDigest"
              }
            }
          }
        ]
      },
      "_types.aggregations:HdrMethod": {
        "type": "object",
        "properties": {
          "number_of_significant_value_digits": {
            "description": "Specifies the resolution of values for the histogram in number of significant digits.",
            "type": "number"
          }
        }
      },
      "_types.aggregations:TDigest": {
        "type": "object",
        "properties": {
          "compression": {
            "description": "Limits the maximum number of nodes used by the underlying TDigest algorithm to `20 * compression`, enabling control of memory usage and approximation error.",
            "type": "number"
          }
        }
      },
      "_types.aggregations:PercentilesAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "keyed": {
                "description": "By default, the aggregation associates a unique string key with each bucket and returns the ranges as a hash rather than an array.\nSet to `false` to disable this behavior.",
                "type": "boolean"
              },
              "percents": {
                "description": "The percentiles to calculate.",
                "type": "array",
                "items": {
                  "type": "number"
                }
              },
              "hdr": {
                "$ref": "#/components/schemas/_types.aggregations:HdrMethod"
              },
              "tdigest": {
                "$ref": "#/components/schemas/_types.aggregations:TDigest"
              }
            }
          }
        ]
      },
      "_types.aggregations:PercentilesBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "percents": {
                "description": "The list of percentiles to calculate.",
                "type": "array",
                "items": {
                  "type": "number"
                }
              }
            }
          }
        ]
      },
      "_types.aggregations:RangeAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "missing": {
                "description": "The value to apply to documents that do not have a value.\nBy default, documents without a value are ignored.",
                "type": "number"
              },
              "ranges": {
                "description": "An array of ranges used to bucket documents.",
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.aggregations:AggregationRange"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "keyed": {
                "description": "Set to `true` to associate a unique string key with each bucket and return the ranges as a hash rather than an array.",
                "type": "boolean"
              },
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:RareTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "max_doc_count": {
                "description": "The maximum number of documents a term should appear in.",
                "type": "number"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              },
              "precision": {
                "description": "The precision of the internal CuckooFilters.\nSmaller precision leads to better approximation, but higher memory usage.",
                "type": "number"
              },
              "value_type": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:TermsExclude": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "_types.aggregations:TermsInclude": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          {
            "$ref": "#/components/schemas/_types.aggregations:TermsPartition"
          }
        ]
      },
      "_types.aggregations:TermsPartition": {
        "type": "object",
        "properties": {
          "num_partitions": {
            "description": "The number of partitions.",
            "type": "number"
          },
          "partition": {
            "description": "The partition number for this request.",
            "type": "number"
          }
        },
        "required": [
          "num_partitions",
          "partition"
        ]
      },
      "_types.aggregations:RateAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "unit": {
                "$ref": "#/components/schemas/_types.aggregations:CalendarInterval"
              },
              "mode": {
                "$ref": "#/components/schemas/_types.aggregations:RateMode"
              }
            }
          }
        ]
      },
      "_types.aggregations:RateMode": {
        "type": "string",
        "enum": [
          "sum",
          "value_count"
        ]
      },
      "_types.aggregations:ReverseNestedAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              }
            }
          }
        ]
      },
      "_types.aggregations:SamplerAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "shard_size": {
                "description": "Limits how many top-scoring documents are collected in the sample processed on each shard.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:ScriptedMetricAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "combine_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "init_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "map_script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "params": {
                "description": "A global object with script parameters for `init`, `map` and `combine` scripts.\nIt is shared between the scripts.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "reduce_script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            }
          }
        ]
      },
      "_types.aggregations:SerialDifferencingAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "lag": {
                "description": "The historical bucket to subtract from the current value.\nMust be a positive, non-zero integer.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:SignificantTermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "background_filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "chi_square": {
                "$ref": "#/components/schemas/_types.aggregations:ChiSquareHeuristic"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationExecutionHint"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "gnd": {
                "$ref": "#/components/schemas/_types.aggregations:GoogleNormalizedDistanceHeuristic"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "jlh": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              },
              "min_doc_count": {
                "description": "Only return terms that are found in more than `min_doc_count` hits.",
                "type": "number"
              },
              "mutual_information": {
                "$ref": "#/components/schemas/_types.aggregations:MutualInformationHeuristic"
              },
              "percentage": {
                "$ref": "#/components/schemas/_types.aggregations:PercentageScoreHeuristic"
              },
              "script_heuristic": {
                "$ref": "#/components/schemas/_types.aggregations:ScriptedHeuristic"
              },
              "shard_min_doc_count": {
                "description": "Regulates the certainty a shard has if the term should actually be added to the candidate list or not with respect to the `min_doc_count`.\nTerms will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.",
                "type": "number"
              },
              "shard_size": {
                "description": "Can be used to control the volumes of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "size": {
                "description": "The number of buckets returned out of the overall terms list.",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types.aggregations:ChiSquareHeuristic": {
        "type": "object",
        "properties": {
          "background_is_superset": {
            "description": "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.",
            "type": "boolean"
          },
          "include_negatives": {
            "description": "Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.",
            "type": "boolean"
          }
        },
        "required": [
          "background_is_superset",
          "include_negatives"
        ]
      },
      "_types.aggregations:TermsAggregationExecutionHint": {
        "type": "string",
        "enum": [
          "map",
          "global_ordinals",
          "global_ordinals_hash",
          "global_ordinals_low_cardinality"
        ]
      },
      "_types.aggregations:GoogleNormalizedDistanceHeuristic": {
        "type": "object",
        "properties": {
          "background_is_superset": {
            "description": "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.",
            "type": "boolean"
          }
        }
      },
      "_types.aggregations:MutualInformationHeuristic": {
        "type": "object",
        "properties": {
          "background_is_superset": {
            "description": "Set to `false` if you defined a custom background filter that represents a different set of documents that you want to compare to.",
            "type": "boolean"
          },
          "include_negatives": {
            "description": "Set to `false` to filter out the terms that appear less often in the subset than in documents outside the subset.",
            "type": "boolean"
          }
        }
      },
      "_types.aggregations:PercentageScoreHeuristic": {
        "type": "object"
      },
      "_types.aggregations:ScriptedHeuristic": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "script"
        ]
      },
      "_types.aggregations:SignificantTextAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "background_filter": {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              "chi_square": {
                "$ref": "#/components/schemas/_types.aggregations:ChiSquareHeuristic"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationExecutionHint"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "filter_duplicate_text": {
                "description": "Whether to out duplicate text to deal with noisy data.",
                "type": "boolean"
              },
              "gnd": {
                "$ref": "#/components/schemas/_types.aggregations:GoogleNormalizedDistanceHeuristic"
              },
              "include": {
                "description": "Values to include.",
                "oneOf": [
                  {
                    "type": "string"
                  },
                  {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                ]
              },
              "jlh": {
                "$ref": "#/components/schemas/_types:EmptyObject"
              },
              "min_doc_count": {
                "description": "Only return values that are found in more than `min_doc_count` hits.",
                "type": "number"
              },
              "mutual_information": {
                "$ref": "#/components/schemas/_types.aggregations:MutualInformationHeuristic"
              },
              "percentage": {
                "$ref": "#/components/schemas/_types.aggregations:PercentageScoreHeuristic"
              },
              "script_heuristic": {
                "$ref": "#/components/schemas/_types.aggregations:ScriptedHeuristic"
              },
              "shard_min_doc_count": {
                "description": "Regulates the certainty a shard has if the values should actually be added to the candidate list or not with respect to the min_doc_count.\nValues will only be considered if their local shard frequency within the set is higher than the `shard_min_doc_count`.",
                "type": "number"
              },
              "shard_size": {
                "description": "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "size": {
                "description": "The number of buckets returned out of the overall terms list.",
                "type": "number"
              },
              "source_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              }
            }
          }
        ]
      },
      "_types.aggregations:StatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:StatsBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:StringStatsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "show_distribution": {
                "description": "Shows the probability distribution for all characters.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:SumAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormatMetricAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:SumBucketAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:PipelineAggregationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:TermsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:BucketAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "collect_mode": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationCollectMode"
              },
              "exclude": {
                "$ref": "#/components/schemas/_types.aggregations:TermsExclude"
              },
              "execution_hint": {
                "$ref": "#/components/schemas/_types.aggregations:TermsAggregationExecutionHint"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "include": {
                "$ref": "#/components/schemas/_types.aggregations:TermsInclude"
              },
              "min_doc_count": {
                "description": "Only return values that are found in more than `min_doc_count` hits.",
                "type": "number"
              },
              "missing": {
                "$ref": "#/components/schemas/_types.aggregations:Missing"
              },
              "missing_order": {
                "$ref": "#/components/schemas/_types.aggregations:MissingOrder"
              },
              "missing_bucket": {
                "type": "boolean"
              },
              "value_type": {
                "description": "Coerced unmapped fields into the specified type.",
                "type": "string"
              },
              "order": {
                "$ref": "#/components/schemas/_types.aggregations:AggregateOrder"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "shard_size": {
                "description": "The number of candidate terms produced by each shard.\nBy default, `shard_size` will be automatically estimated based on the number of shards and the `size` parameter.",
                "type": "number"
              },
              "show_term_doc_count_error": {
                "description": "Set to `true` to return the `doc_count_error_upper_bound`, which is an upper bound to the error on the `doc_count` returned by each shard.",
                "type": "boolean"
              },
              "size": {
                "description": "The number of buckets returned out of the overall terms list.",
                "type": "number"
              },
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:TopHitsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "docvalue_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "explain": {
                "description": "If `true`, returns detailed information about score computation as part of a hit.",
                "type": "boolean"
              },
              "from": {
                "description": "Starting document offset.",
                "type": "number"
              },
              "highlight": {
                "$ref": "#/components/schemas/_global.search._types:Highlight"
              },
              "script_fields": {
                "description": "Returns the result of one or more script evaluations for each hit.",
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/_types:ScriptField"
                }
              },
              "size": {
                "description": "The maximum number of top matching hits to return per bucket.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              },
              "_source": {
                "$ref": "#/components/schemas/_global.search._types:SourceConfig"
              },
              "stored_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "track_scores": {
                "description": "If `true`, calculates and returns document scores, even if the scores are not used for sorting.",
                "type": "boolean"
              },
              "version": {
                "description": "If `true`, returns document version as part of a hit.",
                "type": "boolean"
              },
              "seq_no_primary_term": {
                "description": "If `true`, returns sequence number and primary term of the last modification of each hit.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.aggregations:TTestAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "a": {
                "$ref": "#/components/schemas/_types.aggregations:TestPopulation"
              },
              "b": {
                "$ref": "#/components/schemas/_types.aggregations:TestPopulation"
              },
              "type": {
                "$ref": "#/components/schemas/_types.aggregations:TTestType"
              }
            }
          }
        ]
      },
      "_types.aggregations:TestPopulation": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:TTestType": {
        "type": "string",
        "enum": [
          "paired",
          "homoscedastic",
          "heteroscedastic"
        ]
      },
      "_types.aggregations:TopMetricsAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "metrics": {
                "description": "The fields of the top document to return.",
                "oneOf": [
                  {
                    "$ref": "#/components/schemas/_types.aggregations:TopMetricsValue"
                  },
                  {
                    "type": "array",
                    "items": {
                      "$ref": "#/components/schemas/_types.aggregations:TopMetricsValue"
                    }
                  }
                ]
              },
              "size": {
                "description": "The number of top documents from which to return metrics.",
                "type": "number"
              },
              "sort": {
                "$ref": "#/components/schemas/_types:Sort"
              }
            }
          }
        ]
      },
      "_types.aggregations:TopMetricsValue": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.aggregations:ValueCountAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:FormattableMetricAggregation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_types.aggregations:FormattableMetricAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:MetricAggregationBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.aggregations:WeightedAverageAggregation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.aggregations:Aggregation"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "description": "A numeric response formatter.",
                "type": "string"
              },
              "value": {
                "$ref": "#/components/schemas/_types.aggregations:WeightedAverageValue"
              },
              "value_type": {
                "$ref": "#/components/schemas/_types.aggregations:ValueType"
              },
              "weight": {
                "$ref": "#/components/schemas/_types.aggregations:WeightedAverageValue"
              }
            }
          }
        ]
      },
      "_types.aggregations:WeightedAverageValue": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "missing": {
            "description": "A value or weight to use if the field is missing.",
            "type": "number"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          }
        }
      },
      "_types.aggregations:VariableWidthHistogramAggregation": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "buckets": {
            "description": "The target number of buckets.",
            "type": "number"
          },
          "shard_size": {
            "description": "The number of buckets that the coordinating node will request from each shard.\nDefaults to `buckets * 50`.",
            "type": "number"
          },
          "initial_buffer": {
            "description": "Specifies the number of individual documents that will be stored in memory on a shard before the initial bucketing algorithm is run.\nDefaults to `min(10 * shard_size, 50000)`.",
            "type": "number"
          }
        }
      },
      "_types:KnnQuery": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "query_vector": {
            "$ref": "#/components/schemas/_types:QueryVector"
          },
          "query_vector_builder": {
            "$ref": "#/components/schemas/_types:QueryVectorBuilder"
          },
          "k": {
            "description": "The final number of nearest neighbors to return as top hits",
            "type": "number"
          },
          "num_candidates": {
            "description": "The number of nearest neighbor candidates to consider per shard",
            "type": "number"
          },
          "boost": {
            "description": "Boost value to apply to kNN scores",
            "type": "number"
          },
          "filter": {
            "description": "Filters for the kNN search query",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
                }
              }
            ]
          }
        },
        "required": [
          "field",
          "k",
          "num_candidates"
        ]
      },
      "_types:QueryVector": {
        "type": "array",
        "items": {
          "type": "number"
        }
      },
      "_types:QueryVectorBuilder": {
        "type": "object",
        "properties": {
          "text_embedding": {
            "$ref": "#/components/schemas/_types:TextEmbedding"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:TextEmbedding": {
        "type": "object",
        "properties": {
          "model_id": {
            "type": "string"
          },
          "model_text": {
            "type": "string"
          }
        },
        "required": [
          "model_id",
          "model_text"
        ]
      },
      "_global.search._types:Rescore": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/_global.search._types:RescoreQuery"
          },
          "window_size": {
            "type": "number"
          }
        },
        "required": [
          "query"
        ]
      },
      "_global.search._types:RescoreQuery": {
        "type": "object",
        "properties": {
          "rescore_query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "query_weight": {
            "description": "Relative importance of the original query versus the rescore query.",
            "type": "number"
          },
          "rescore_query_weight": {
            "description": "Relative importance of the rescore query versus the original query.",
            "type": "number"
          },
          "score_mode": {
            "$ref": "#/components/schemas/_global.search._types:ScoreMode"
          }
        },
        "required": [
          "rescore_query"
        ]
      },
      "_global.search._types:ScoreMode": {
        "type": "string",
        "enum": [
          "avg",
          "max",
          "min",
          "multiply",
          "total"
        ]
      },
      "_types:SlicedScroll": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "max"
        ]
      },
      "_global.search._types:Suggester": {
        "type": "object",
        "properties": {
          "text": {
            "description": "Global suggest text, to avoid repetition when the same text is used in several suggesters",
            "type": "string"
          }
        }
      },
      "_global.search._types:PointInTimeReference": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "keep_alive": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "id"
        ]
      },
      "_types.mapping:RuntimeFields": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/_types.mapping:RuntimeField"
        }
      },
      "_types.mapping:RuntimeField": {
        "type": "object",
        "properties": {
          "fetch_fields": {
            "description": "For type `lookup`",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.mapping:RuntimeFieldFetchFields"
            }
          },
          "format": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-date-format.html"
            },
            "description": "A custom format for `date` type runtime fields.",
            "type": "string"
          },
          "input_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "target_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "target_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "type": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFieldType"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:RuntimeFieldFetchFields": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "format": {
            "type": "string"
          }
        },
        "required": [
          "field"
        ]
      },
      "_types.mapping:RuntimeFieldType": {
        "type": "string",
        "enum": [
          "boolean",
          "date",
          "double",
          "geo_point",
          "ip",
          "keyword",
          "long",
          "lookup"
        ]
      },
      "_types:Refresh": {
        "type": "string",
        "enum": [
          "true",
          "false",
          "wait_for"
        ]
      },
      "_types:WaitForActiveShards": {
        "oneOf": [
          {
            "type": "number"
          },
          {
            "$ref": "#/components/schemas/_types:WaitForActiveShardOptions"
          }
        ]
      },
      "_types:WaitForActiveShardOptions": {
        "type": "string",
        "enum": [
          "all",
          "index-setting"
        ]
      },
      "_global.bulk:OperationContainer": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_global.bulk:IndexOperation"
          },
          "create": {
            "$ref": "#/components/schemas/_global.bulk:CreateOperation"
          },
          "update": {
            "$ref": "#/components/schemas/_global.bulk:UpdateOperation"
          },
          "delete": {
            "$ref": "#/components/schemas/_global.bulk:DeleteOperation"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_global.bulk:IndexOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:WriteOperation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.bulk:WriteOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:OperationBase"
          },
          {
            "type": "object",
            "properties": {
              "dynamic_templates": {
                "description": "A map from the full name of fields to the name of dynamic templates.\nDefaults to an empty map.\nIf a name matches a dynamic template, then that template will be applied regardless of other match predicates defined in the template.\nIf a field is already defined in the mapping, then this parameter wont be used.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "pipeline": {
                "description": "ID of the pipeline to use to preprocess incoming documents.\nIf the index has a default ingest pipeline specified, then setting the value to `_none` disables the default ingest pipeline for this request.\nIf a final pipeline is configured it will always run, regardless of the value of this parameter.",
                "type": "string"
              },
              "require_alias": {
                "description": "If `true`, the requests actions must target an index alias.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_global.bulk:OperationBase": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "if_primary_term": {
            "type": "number"
          },
          "if_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        }
      },
      "_global.bulk:CreateOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:WriteOperation"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.bulk:UpdateOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:OperationBase"
          },
          {
            "type": "object",
            "properties": {
              "require_alias": {
                "description": "If `true`, the requests actions must target an index alias.",
                "type": "boolean"
              },
              "retry_on_conflict": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_global.bulk:DeleteOperation": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.bulk:OperationBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.bulk:UpdateAction": {
        "type": "object",
        "properties": {
          "detect_noop": {
            "description": "Set to false to disable setting 'result' in the response\nto 'noop' if no change to the document occurred.",
            "type": "boolean"
          },
          "doc": {
            "description": "A partial update to an existing document.",
            "type": "object"
          },
          "doc_as_upsert": {
            "description": "Set to true to use the contents of 'doc' as the value of 'upsert'",
            "type": "boolean"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "scripted_upsert": {
            "description": "Set to true to execute the script whether or not the document exists.",
            "type": "boolean"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "upsert": {
            "description": "If the document does not already exist, the contents of 'upsert' are inserted as a\nnew document. If the document exists, the 'script' is executed.",
            "type": "object"
          }
        }
      },
      "_global.bulk:ResponseItem": {
        "type": "object",
        "properties": {
          "_id": {
            "description": "The document ID associated with the operation.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "_index": {
            "description": "Name of the index associated with the operation.\nIf the operation targeted a data stream, this is the backing index into which the document was written.",
            "type": "string"
          },
          "status": {
            "description": "HTTP status code returned for the operation.",
            "type": "number"
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "_primary_term": {
            "description": "The primary term assigned to the document for the operation.",
            "type": "number"
          },
          "result": {
            "description": "Result of the operation.\nSuccessful values are `created`, `deleted`, and `updated`.",
            "type": "string"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "forced_refresh": {
            "type": "boolean"
          },
          "get": {
            "$ref": "#/components/schemas/_types:InlineGetDictUserDefined"
          }
        },
        "required": [
          "_index",
          "status"
        ]
      },
      "_types:InlineGetDictUserDefined": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "found": {
            "type": "boolean"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_primary_term": {
            "type": "number"
          },
          "_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_source": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "found",
          "_source"
        ]
      },
      "_types:Names": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:Name"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          }
        ]
      },
      "cat.aliases:AliasesRecord": {
        "type": "object",
        "properties": {
          "alias": {
            "description": "alias name",
            "type": "string"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "filter": {
            "description": "filter",
            "type": "string"
          },
          "routing.index": {
            "description": "index routing",
            "type": "string"
          },
          "routing.search": {
            "description": "search routing",
            "type": "string"
          },
          "is_write_index": {
            "description": "write index",
            "type": "string"
          }
        }
      },
      "_types:NodeIds": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:NodeId"
            }
          }
        ]
      },
      "_types:NodeId": {
        "type": "string"
      },
      "_types:Bytes": {
        "type": "string",
        "enum": [
          "b",
          "kb",
          "mb",
          "gb",
          "tb",
          "pb"
        ]
      },
      "cat.allocation:AllocationRecord": {
        "type": "object",
        "properties": {
          "shards": {
            "description": "Number of primary and replica shards assigned to the node.",
            "type": "string"
          },
          "disk.indices": {
            "description": "Disk space used by the nodes shards. Does not include disk space for the translog or unassigned shards.\nIMPORTANT: This metric double-counts disk space for hard-linked files, such as those created when shrinking, splitting, or cloning an index.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.used": {
            "description": "Total disk space in use.\nElasticsearch retrieves this metric from the nodes operating system (OS).\nThe metric includes disk space for: Elasticsearch, including the translog and unassigned shards; the nodes operating system; any other applications or files on the node.\nUnlike `disk.indices`, this metric does not double-count disk space for hard-linked files.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.avail": {
            "description": "Free disk space available to Elasticsearch.\nElasticsearch retrieves this metric from the nodes operating system.\nDisk-based shard allocation uses this metric to assign shards to nodes based on available disk space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.total": {
            "description": "Total disk space for the node, including in-use and available space.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:ByteSize"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "disk.percent": {
            "description": "Total percentage of disk space in use. Calculated as `disk.used / disk.total`.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Percentage"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "host": {
            "description": "Network host for the node. Set using the `network.host` setting.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Host"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "ip": {
            "description": "IP address and port for the node.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Ip"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "node": {
            "description": "Name for the node. Set using the `node.name` setting.",
            "type": "string"
          }
        }
      },
      "_types:ByteSize": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/api-conventions.html#byte-units"
        },
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:Percentage": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "_types:Host": {
        "type": "string"
      },
      "_types:Ip": {
        "type": "string"
      },
      "cat.component_templates:ComponentTemplate": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "alias_count": {
            "type": "string"
          },
          "mapping_count": {
            "type": "string"
          },
          "settings_count": {
            "type": "string"
          },
          "metadata_count": {
            "type": "string"
          },
          "included_in": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "version",
          "alias_count",
          "mapping_count",
          "settings_count",
          "metadata_count",
          "included_in"
        ]
      },
      "cat.count:CountRecord": {
        "type": "object",
        "properties": {
          "epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:TimeOfDay"
          },
          "count": {
            "description": "the document count",
            "type": "string"
          }
        }
      },
      "_spec_utils:StringifiedEpochTimeUnitSeconds": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:EpochTimeUnitSeconds"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:EpochTimeUnitSeconds": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitSeconds"
          }
        ]
      },
      "_types:UnitSeconds": {
        "description": "Time unit for seconds",
        "type": "number"
      },
      "_types:TimeOfDay": {
        "description": "Time of day, expressed as HH:MM:SS",
        "type": "string"
      },
      "cat.fielddata:FielddataRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "node id",
            "type": "string"
          },
          "host": {
            "description": "host name",
            "type": "string"
          },
          "ip": {
            "description": "ip address",
            "type": "string"
          },
          "node": {
            "description": "node name",
            "type": "string"
          },
          "field": {
            "description": "field name",
            "type": "string"
          },
          "size": {
            "description": "field data usage",
            "type": "string"
          }
        }
      },
      "cat.help:HelpRecord": {
        "type": "object",
        "properties": {
          "endpoint": {
            "type": "string"
          }
        },
        "required": [
          "endpoint"
        ]
      },
      "_types:HealthStatus": {
        "type": "string",
        "enum": [
          "green",
          "yellow",
          "red"
        ]
      },
      "_types:TimeUnit": {
        "type": "string",
        "enum": [
          "nanos",
          "micros",
          "ms",
          "s",
          "m",
          "h",
          "d"
        ]
      },
      "cat.indices:IndicesRecord": {
        "type": "object",
        "properties": {
          "health": {
            "description": "current health status",
            "type": "string"
          },
          "status": {
            "description": "open/close status",
            "type": "string"
          },
          "index": {
            "description": "index name",
            "type": "string"
          },
          "uuid": {
            "description": "index uuid",
            "type": "string"
          },
          "pri": {
            "description": "number of primary shards",
            "type": "string"
          },
          "rep": {
            "description": "number of replica shards",
            "type": "string"
          },
          "docs.count": {
            "description": "available docs",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "docs.deleted": {
            "description": "deleted docs",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "creation.date": {
            "description": "index creation date (millisecond value)",
            "type": "string"
          },
          "creation.date.string": {
            "description": "index creation date (as string)",
            "type": "string"
          },
          "store.size": {
            "description": "store size of primaries & replicas",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "pri.store.size": {
            "description": "store size of primaries",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "completion.size": {
            "description": "size of completion",
            "type": "string"
          },
          "pri.completion.size": {
            "description": "size of completion",
            "type": "string"
          },
          "fielddata.memory_size": {
            "description": "used fielddata cache",
            "type": "string"
          },
          "pri.fielddata.memory_size": {
            "description": "used fielddata cache",
            "type": "string"
          },
          "fielddata.evictions": {
            "description": "fielddata evictions",
            "type": "string"
          },
          "pri.fielddata.evictions": {
            "description": "fielddata evictions",
            "type": "string"
          },
          "query_cache.memory_size": {
            "description": "used query cache",
            "type": "string"
          },
          "pri.query_cache.memory_size": {
            "description": "used query cache",
            "type": "string"
          },
          "query_cache.evictions": {
            "description": "query cache evictions",
            "type": "string"
          },
          "pri.query_cache.evictions": {
            "description": "query cache evictions",
            "type": "string"
          },
          "request_cache.memory_size": {
            "description": "used request cache",
            "type": "string"
          },
          "pri.request_cache.memory_size": {
            "description": "used request cache",
            "type": "string"
          },
          "request_cache.evictions": {
            "description": "request cache evictions",
            "type": "string"
          },
          "pri.request_cache.evictions": {
            "description": "request cache evictions",
            "type": "string"
          },
          "request_cache.hit_count": {
            "description": "request cache hit count",
            "type": "string"
          },
          "pri.request_cache.hit_count": {
            "description": "request cache hit count",
            "type": "string"
          },
          "request_cache.miss_count": {
            "description": "request cache miss count",
            "type": "string"
          },
          "pri.request_cache.miss_count": {
            "description": "request cache miss count",
            "type": "string"
          },
          "flush.total": {
            "description": "number of flushes",
            "type": "string"
          },
          "pri.flush.total": {
            "description": "number of flushes",
            "type": "string"
          },
          "flush.total_time": {
            "description": "time spent in flush",
            "type": "string"
          },
          "pri.flush.total_time": {
            "description": "time spent in flush",
            "type": "string"
          },
          "get.current": {
            "description": "number of current get ops",
            "type": "string"
          },
          "pri.get.current": {
            "description": "number of current get ops",
            "type": "string"
          },
          "get.time": {
            "description": "time spent in get",
            "type": "string"
          },
          "pri.get.time": {
            "description": "time spent in get",
            "type": "string"
          },
          "get.total": {
            "description": "number of get ops",
            "type": "string"
          },
          "pri.get.total": {
            "description": "number of get ops",
            "type": "string"
          },
          "get.exists_time": {
            "description": "time spent in successful gets",
            "type": "string"
          },
          "pri.get.exists_time": {
            "description": "time spent in successful gets",
            "type": "string"
          },
          "get.exists_total": {
            "description": "number of successful gets",
            "type": "string"
          },
          "pri.get.exists_total": {
            "description": "number of successful gets",
            "type": "string"
          },
          "get.missing_time": {
            "description": "time spent in failed gets",
            "type": "string"
          },
          "pri.get.missing_time": {
            "description": "time spent in failed gets",
            "type": "string"
          },
          "get.missing_total": {
            "description": "number of failed gets",
            "type": "string"
          },
          "pri.get.missing_total": {
            "description": "number of failed gets",
            "type": "string"
          },
          "indexing.delete_current": {
            "description": "number of current deletions",
            "type": "string"
          },
          "pri.indexing.delete_current": {
            "description": "number of current deletions",
            "type": "string"
          },
          "indexing.delete_time": {
            "description": "time spent in deletions",
            "type": "string"
          },
          "pri.indexing.delete_time": {
            "description": "time spent in deletions",
            "type": "string"
          },
          "indexing.delete_total": {
            "description": "number of delete ops",
            "type": "string"
          },
          "pri.indexing.delete_total": {
            "description": "number of delete ops",
            "type": "string"
          },
          "indexing.index_current": {
            "description": "number of current indexing ops",
            "type": "string"
          },
          "pri.indexing.index_current": {
            "description": "number of current indexing ops",
            "type": "string"
          },
          "indexing.index_time": {
            "description": "time spent in indexing",
            "type": "string"
          },
          "pri.indexing.index_time": {
            "description": "time spent in indexing",
            "type": "string"
          },
          "indexing.index_total": {
            "description": "number of indexing ops",
            "type": "string"
          },
          "pri.indexing.index_total": {
            "description": "number of indexing ops",
            "type": "string"
          },
          "indexing.index_failed": {
            "description": "number of failed indexing ops",
            "type": "string"
          },
          "pri.indexing.index_failed": {
            "description": "number of failed indexing ops",
            "type": "string"
          },
          "merges.current": {
            "description": "number of current merges",
            "type": "string"
          },
          "pri.merges.current": {
            "description": "number of current merges",
            "type": "string"
          },
          "merges.current_docs": {
            "description": "number of current merging docs",
            "type": "string"
          },
          "pri.merges.current_docs": {
            "description": "number of current merging docs",
            "type": "string"
          },
          "merges.current_size": {
            "description": "size of current merges",
            "type": "string"
          },
          "pri.merges.current_size": {
            "description": "size of current merges",
            "type": "string"
          },
          "merges.total": {
            "description": "number of completed merge ops",
            "type": "string"
          },
          "pri.merges.total": {
            "description": "number of completed merge ops",
            "type": "string"
          },
          "merges.total_docs": {
            "description": "docs merged",
            "type": "string"
          },
          "pri.merges.total_docs": {
            "description": "docs merged",
            "type": "string"
          },
          "merges.total_size": {
            "description": "size merged",
            "type": "string"
          },
          "pri.merges.total_size": {
            "description": "size merged",
            "type": "string"
          },
          "merges.total_time": {
            "description": "time spent in merges",
            "type": "string"
          },
          "pri.merges.total_time": {
            "description": "time spent in merges",
            "type": "string"
          },
          "refresh.total": {
            "description": "total refreshes",
            "type": "string"
          },
          "pri.refresh.total": {
            "description": "total refreshes",
            "type": "string"
          },
          "refresh.time": {
            "description": "time spent in refreshes",
            "type": "string"
          },
          "pri.refresh.time": {
            "description": "time spent in refreshes",
            "type": "string"
          },
          "refresh.external_total": {
            "description": "total external refreshes",
            "type": "string"
          },
          "pri.refresh.external_total": {
            "description": "total external refreshes",
            "type": "string"
          },
          "refresh.external_time": {
            "description": "time spent in external refreshes",
            "type": "string"
          },
          "pri.refresh.external_time": {
            "description": "time spent in external refreshes",
            "type": "string"
          },
          "refresh.listeners": {
            "description": "number of pending refresh listeners",
            "type": "string"
          },
          "pri.refresh.listeners": {
            "description": "number of pending refresh listeners",
            "type": "string"
          },
          "search.fetch_current": {
            "description": "current fetch phase ops",
            "type": "string"
          },
          "pri.search.fetch_current": {
            "description": "current fetch phase ops",
            "type": "string"
          },
          "search.fetch_time": {
            "description": "time spent in fetch phase",
            "type": "string"
          },
          "pri.search.fetch_time": {
            "description": "time spent in fetch phase",
            "type": "string"
          },
          "search.fetch_total": {
            "description": "total fetch ops",
            "type": "string"
          },
          "pri.search.fetch_total": {
            "description": "total fetch ops",
            "type": "string"
          },
          "search.open_contexts": {
            "description": "open search contexts",
            "type": "string"
          },
          "pri.search.open_contexts": {
            "description": "open search contexts",
            "type": "string"
          },
          "search.query_current": {
            "description": "current query phase ops",
            "type": "string"
          },
          "pri.search.query_current": {
            "description": "current query phase ops",
            "type": "string"
          },
          "search.query_time": {
            "description": "time spent in query phase",
            "type": "string"
          },
          "pri.search.query_time": {
            "description": "time spent in query phase",
            "type": "string"
          },
          "search.query_total": {
            "description": "total query phase ops",
            "type": "string"
          },
          "pri.search.query_total": {
            "description": "total query phase ops",
            "type": "string"
          },
          "search.scroll_current": {
            "description": "open scroll contexts",
            "type": "string"
          },
          "pri.search.scroll_current": {
            "description": "open scroll contexts",
            "type": "string"
          },
          "search.scroll_time": {
            "description": "time scroll contexts held open",
            "type": "string"
          },
          "pri.search.scroll_time": {
            "description": "time scroll contexts held open",
            "type": "string"
          },
          "search.scroll_total": {
            "description": "completed scroll contexts",
            "type": "string"
          },
          "pri.search.scroll_total": {
            "description": "completed scroll contexts",
            "type": "string"
          },
          "segments.count": {
            "description": "number of segments",
            "type": "string"
          },
          "pri.segments.count": {
            "description": "number of segments",
            "type": "string"
          },
          "segments.memory": {
            "description": "memory used by segments",
            "type": "string"
          },
          "pri.segments.memory": {
            "description": "memory used by segments",
            "type": "string"
          },
          "segments.index_writer_memory": {
            "description": "memory used by index writer",
            "type": "string"
          },
          "pri.segments.index_writer_memory": {
            "description": "memory used by index writer",
            "type": "string"
          },
          "segments.version_map_memory": {
            "description": "memory used by version map",
            "type": "string"
          },
          "pri.segments.version_map_memory": {
            "description": "memory used by version map",
            "type": "string"
          },
          "segments.fixed_bitset_memory": {
            "description": "memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields",
            "type": "string"
          },
          "pri.segments.fixed_bitset_memory": {
            "description": "memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields",
            "type": "string"
          },
          "warmer.current": {
            "description": "current warmer ops",
            "type": "string"
          },
          "pri.warmer.current": {
            "description": "current warmer ops",
            "type": "string"
          },
          "warmer.total": {
            "description": "total warmer ops",
            "type": "string"
          },
          "pri.warmer.total": {
            "description": "total warmer ops",
            "type": "string"
          },
          "warmer.total_time": {
            "description": "time spent in warmers",
            "type": "string"
          },
          "pri.warmer.total_time": {
            "description": "time spent in warmers",
            "type": "string"
          },
          "suggest.current": {
            "description": "number of current suggest ops",
            "type": "string"
          },
          "pri.suggest.current": {
            "description": "number of current suggest ops",
            "type": "string"
          },
          "suggest.time": {
            "description": "time spend in suggest",
            "type": "string"
          },
          "pri.suggest.time": {
            "description": "time spend in suggest",
            "type": "string"
          },
          "suggest.total": {
            "description": "number of suggest ops",
            "type": "string"
          },
          "pri.suggest.total": {
            "description": "number of suggest ops",
            "type": "string"
          },
          "memory.total": {
            "description": "total used memory",
            "type": "string"
          },
          "pri.memory.total": {
            "description": "total user memory",
            "type": "string"
          },
          "search.throttled": {
            "description": "indicates if the index is search throttled",
            "type": "string"
          },
          "bulk.total_operations": {
            "description": "number of bulk shard ops",
            "type": "string"
          },
          "pri.bulk.total_operations": {
            "description": "number of bulk shard ops",
            "type": "string"
          },
          "bulk.total_time": {
            "description": "time spend in shard bulk",
            "type": "string"
          },
          "pri.bulk.total_time": {
            "description": "time spend in shard bulk",
            "type": "string"
          },
          "bulk.total_size_in_bytes": {
            "description": "total size in bytes of shard bulk",
            "type": "string"
          },
          "pri.bulk.total_size_in_bytes": {
            "description": "total size in bytes of shard bulk",
            "type": "string"
          },
          "bulk.avg_time": {
            "description": "average time spend in shard bulk",
            "type": "string"
          },
          "pri.bulk.avg_time": {
            "description": "average time spend in shard bulk",
            "type": "string"
          },
          "bulk.avg_size_in_bytes": {
            "description": "average size in bytes of shard bulk",
            "type": "string"
          },
          "pri.bulk.avg_size_in_bytes": {
            "description": "average size in bytes of shard bulk",
            "type": "string"
          }
        }
      },
      "cat.master:MasterRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "node id",
            "type": "string"
          },
          "host": {
            "description": "host name",
            "type": "string"
          },
          "ip": {
            "description": "ip address",
            "type": "string"
          },
          "node": {
            "description": "node name",
            "type": "string"
          }
        }
      },
      "cat._types:CatDfaColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatDfaColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatDfaColumn"
            }
          }
        ]
      },
      "cat._types:CatDfaColumn": {
        "type": "string",
        "enum": [
          "assignment_explanation",
          "create_time",
          "description",
          "dest_index",
          "failure_reason",
          "id",
          "model_memory_limit",
          "node.address",
          "node.ephemeral_id",
          "node.id",
          "node.name",
          "progress",
          "source_index",
          "state",
          "type",
          "version"
        ]
      },
      "cat.ml_data_frame_analytics:DataFrameAnalyticsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "type": {
            "description": "The type of analysis that the job performs.",
            "type": "string"
          },
          "create_time": {
            "description": "The time when the job was created.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "source_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "dest_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "description": {
            "description": "A description of the job.",
            "type": "string"
          },
          "model_memory_limit": {
            "description": "The approximate maximum amount of memory resources that are permitted for the job.",
            "type": "string"
          },
          "state": {
            "description": "The current status of the job.",
            "type": "string"
          },
          "failure_reason": {
            "description": "Messages about the reason why the job failed.",
            "type": "string"
          },
          "progress": {
            "description": "The progress report for the job by phase.",
            "type": "string"
          },
          "assignment_explanation": {
            "description": "Messages related to the selection of a node.",
            "type": "string"
          },
          "node.id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node.name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "node.ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node.address": {
            "description": "The network address of the assigned node.",
            "type": "string"
          }
        }
      },
      "cat._types:CatDatafeedColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatDatafeedColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatDatafeedColumn"
            }
          }
        ]
      },
      "cat._types:CatDatafeedColumn": {
        "type": "string",
        "enum": [
          "ae",
          "bc",
          "id",
          "na",
          "ne",
          "ni",
          "nn",
          "sba",
          "sc",
          "seah",
          "st",
          "s"
        ]
      },
      "cat.ml_datafeeds:DatafeedsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The datafeed identifier.",
            "type": "string"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DatafeedState"
          },
          "assignment_explanation": {
            "description": "For started datafeeds only, contains messages relating to the selection of a node.",
            "type": "string"
          },
          "buckets.count": {
            "description": "The number of buckets processed.",
            "type": "string"
          },
          "search.count": {
            "description": "The number of searches run by the datafeed.",
            "type": "string"
          },
          "search.time": {
            "description": "The total time the datafeed spent searching, in milliseconds.",
            "type": "string"
          },
          "search.bucket_avg": {
            "description": "The average search time per bucket, in milliseconds.",
            "type": "string"
          },
          "search.exp_avg_hour": {
            "description": "The exponential average search time per hour, in milliseconds.",
            "type": "string"
          },
          "node.id": {
            "description": "The unique identifier of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          },
          "node.name": {
            "description": "The name of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          },
          "node.ephemeral_id": {
            "description": "The ephemeral identifier of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          },
          "node.address": {
            "description": "The network address of the assigned node.\nFor started datafeeds only, this information pertains to the node upon which the datafeed is started.",
            "type": "string"
          }
        }
      },
      "ml._types:DatafeedState": {
        "type": "string",
        "enum": [
          "started",
          "stopped",
          "starting",
          "stopping"
        ]
      },
      "cat._types:CatAnonalyDetectorColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatAnomalyDetectorColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatAnomalyDetectorColumn"
            }
          }
        ]
      },
      "cat._types:CatAnomalyDetectorColumn": {
        "type": "string",
        "enum": [
          "assignment_explanation",
          "buckets.count",
          "buckets.time.exp_avg",
          "buckets.time.exp_avg_hour",
          "buckets.time.max",
          "buckets.time.min",
          "buckets.time.total",
          "data.buckets",
          "data.earliest_record",
          "data.empty_buckets",
          "data.input_bytes",
          "data.input_fields",
          "data.input_records",
          "data.invalid_dates",
          "data.last",
          "data.last_empty_bucket",
          "data.last_sparse_bucket",
          "data.latest_record",
          "data.missing_fields",
          "data.out_of_order_timestamps",
          "data.processed_fields",
          "data.processed_records",
          "data.sparse_buckets",
          "forecasts.memory.avg",
          "forecasts.memory.max",
          "forecasts.memory.min",
          "forecasts.memory.total",
          "forecasts.records.avg",
          "forecasts.records.max",
          "forecasts.records.min",
          "forecasts.records.total",
          "forecasts.time.avg",
          "forecasts.time.max",
          "forecasts.time.min",
          "forecasts.time.total",
          "forecasts.total",
          "id",
          "model.bucket_allocation_failures",
          "model.by_fields",
          "model.bytes",
          "model.bytes_exceeded",
          "model.categorization_status",
          "model.categorized_doc_count",
          "model.dead_category_count",
          "model.failed_category_count",
          "model.frequent_category_count",
          "model.log_time",
          "model.memory_limit",
          "model.memory_status",
          "model.over_fields",
          "model.partition_fields",
          "model.rare_category_count",
          "model.timestamp",
          "model.total_category_count",
          "node.address",
          "node.ephemeral_id",
          "node.id",
          "node.name",
          "opened_time",
          "state"
        ]
      },
      "cat.ml_jobs:JobsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:JobState"
          },
          "opened_time": {
            "description": "For open jobs only, the amount of time the job has been opened.",
            "type": "string"
          },
          "assignment_explanation": {
            "description": "For open anomaly detection jobs only, contains messages relating to the selection of a node to run the job.",
            "type": "string"
          },
          "data.processed_records": {
            "description": "The number of input documents that have been processed by the anomaly detection job.\nThis value includes documents with missing fields, since they are nonetheless analyzed.\nIf you use datafeeds and have aggregations in your search query, the `processed_record_count` is the number of aggregation results processed, not the number of Elasticsearch documents.",
            "type": "string"
          },
          "data.processed_fields": {
            "description": "The total number of fields in all the documents that have been processed by the anomaly detection job.\nOnly fields that are specified in the detector configuration object contribute to this count.\nThe timestamp is not included in this count.",
            "type": "string"
          },
          "data.input_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "data.input_records": {
            "description": "The number of input documents posted to the anomaly detection job.",
            "type": "string"
          },
          "data.input_fields": {
            "description": "The total number of fields in input documents posted to the anomaly detection job.\nThis count includes fields that are not used in the analysis.\nHowever, be aware that if you are using a datafeed, it extracts only the required fields from the documents it retrieves before posting them to the job.",
            "type": "string"
          },
          "data.invalid_dates": {
            "description": "The number of input documents with either a missing date field or a date that could not be parsed.",
            "type": "string"
          },
          "data.missing_fields": {
            "description": "The number of input documents that are missing a field that the anomaly detection job is configured to analyze.\nInput documents with missing fields are still processed because it is possible that not all fields are missing.\nIf you are using datafeeds or posting data to the job in JSON format, a high `missing_field_count` is often not an indication of data issues.\nIt is not necessarily a cause for concern.",
            "type": "string"
          },
          "data.out_of_order_timestamps": {
            "description": "The number of input documents that have a timestamp chronologically preceding the start of the current anomaly detection bucket offset by the latency window.\nThis information is applicable only when you provide data to the anomaly detection job by using the post data API.\nThese out of order documents are discarded, since jobs require time series data to be in ascending chronological order.",
            "type": "string"
          },
          "data.empty_buckets": {
            "description": "The number of buckets which did not contain any data.\nIf your data contains many empty buckets, consider increasing your `bucket_span` or using functions that are tolerant to gaps in data such as mean, `non_null_sum` or `non_zero_count`.",
            "type": "string"
          },
          "data.sparse_buckets": {
            "description": "The number of buckets that contained few data points compared to the expected number of data points.\nIf your data contains many sparse buckets, consider using a longer `bucket_span`.",
            "type": "string"
          },
          "data.buckets": {
            "description": "The total number of buckets processed.",
            "type": "string"
          },
          "data.earliest_record": {
            "description": "The timestamp of the earliest chronologically input document.",
            "type": "string"
          },
          "data.latest_record": {
            "description": "The timestamp of the latest chronologically input document.",
            "type": "string"
          },
          "data.last": {
            "description": "The timestamp at which data was last analyzed, according to server time.",
            "type": "string"
          },
          "data.last_empty_bucket": {
            "description": "The timestamp of the last bucket that did not contain any data.",
            "type": "string"
          },
          "data.last_sparse_bucket": {
            "description": "The timestamp of the last bucket that was considered sparse.",
            "type": "string"
          },
          "model.bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model.memory_status": {
            "$ref": "#/components/schemas/ml._types:MemoryStatus"
          },
          "model.bytes_exceeded": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model.memory_limit": {
            "description": "The upper limit for model memory usage, checked on increasing values.",
            "type": "string"
          },
          "model.by_fields": {
            "description": "The number of `by` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.",
            "type": "string"
          },
          "model.over_fields": {
            "description": "The number of `over` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.",
            "type": "string"
          },
          "model.partition_fields": {
            "description": "The number of `partition` field values that were analyzed by the models.\nThis value is cumulative for all detectors in the job.",
            "type": "string"
          },
          "model.bucket_allocation_failures": {
            "description": "The number of buckets for which new entities in incoming data were not processed due to insufficient model memory.\nThis situation is also signified by a `hard_limit: memory_status` property value.",
            "type": "string"
          },
          "model.categorization_status": {
            "$ref": "#/components/schemas/ml._types:CategorizationStatus"
          },
          "model.categorized_doc_count": {
            "description": "The number of documents that have had a field categorized.",
            "type": "string"
          },
          "model.total_category_count": {
            "description": "The number of categories created by categorization.",
            "type": "string"
          },
          "model.frequent_category_count": {
            "description": "The number of categories that match more than 1% of categorized documents.",
            "type": "string"
          },
          "model.rare_category_count": {
            "description": "The number of categories that match just one categorized document.",
            "type": "string"
          },
          "model.dead_category_count": {
            "description": "The number of categories created by categorization that will never be assigned again because another categorys definition makes it a superset of the dead category.\nDead categories are a side effect of the way categorization has no prior training.",
            "type": "string"
          },
          "model.failed_category_count": {
            "description": "The number of times that categorization wanted to create a new category but couldnt because the job had hit its `model_memory_limit`.\nThis count does not track which specific categories failed to be created.\nTherefore you cannot use this value to determine the number of unique categories that were missed.",
            "type": "string"
          },
          "model.log_time": {
            "description": "The timestamp when the model stats were gathered, according to server time.",
            "type": "string"
          },
          "model.timestamp": {
            "description": "The timestamp of the last record when the model stats were gathered.",
            "type": "string"
          },
          "forecasts.total": {
            "description": "The number of individual forecasts currently available for the job.\nA value of one or more indicates that forecasts exist.",
            "type": "string"
          },
          "forecasts.memory.min": {
            "description": "The minimum memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.memory.max": {
            "description": "The maximum memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.memory.avg": {
            "description": "The average memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.memory.total": {
            "description": "The total memory usage in bytes for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.min": {
            "description": "The minimum number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.max": {
            "description": "The maximum number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.avg": {
            "description": "The average number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.records.total": {
            "description": "The total number of `model_forecast` documents written for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.min": {
            "description": "The minimum runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.max": {
            "description": "The maximum runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.avg": {
            "description": "The average runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "forecasts.time.total": {
            "description": "The total runtime in milliseconds for forecasts related to the anomaly detection job.",
            "type": "string"
          },
          "node.id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "node.name": {
            "description": "The name of the assigned node.",
            "type": "string"
          },
          "node.ephemeral_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "node.address": {
            "description": "The network address of the assigned node.",
            "type": "string"
          },
          "buckets.count": {
            "description": "The number of bucket results produced by the job.",
            "type": "string"
          },
          "buckets.time.total": {
            "description": "The sum of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.min": {
            "description": "The minimum of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.max": {
            "description": "The maximum of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.exp_avg": {
            "description": "The exponential moving average of all bucket processing times, in milliseconds.",
            "type": "string"
          },
          "buckets.time.exp_avg_hour": {
            "description": "The exponential moving average of bucket processing times calculated in a one hour time window, in milliseconds.",
            "type": "string"
          }
        }
      },
      "ml._types:JobState": {
        "type": "string",
        "enum": [
          "closing",
          "closed",
          "opened",
          "failed",
          "opening"
        ]
      },
      "ml._types:MemoryStatus": {
        "type": "string",
        "enum": [
          "ok",
          "soft_limit",
          "hard_limit"
        ]
      },
      "ml._types:CategorizationStatus": {
        "type": "string",
        "enum": [
          "ok",
          "warn"
        ]
      },
      "cat._types:CatTrainedModelsColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatTrainedModelsColumn"
            }
          }
        ]
      },
      "cat._types:CatTrainedModelsColumn": {
        "type": "string",
        "enum": [
          "create_time",
          "created_by",
          "data_frame_analytics_id",
          "description",
          "heap_size",
          "id",
          "ingest.count",
          "ingest.current",
          "ingest.failed",
          "ingest.pipelines",
          "ingest.time",
          "license",
          "operations",
          "version"
        ]
      },
      "cat.ml_trained_models:TrainedModelsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "created_by": {
            "description": "Information about the creator of the model.",
            "type": "string"
          },
          "heap_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "operations": {
            "description": "The estimated number of operations to use the model.\nThis number helps to measure the computational complexity of the model.",
            "type": "string"
          },
          "license": {
            "description": "The license level of the model.",
            "type": "string"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "description": {
            "description": "A description of the model.",
            "type": "string"
          },
          "ingest.pipelines": {
            "description": "The number of pipelines that are referencing the model.",
            "type": "string"
          },
          "ingest.count": {
            "description": "The total number of documents that are processed by the model.",
            "type": "string"
          },
          "ingest.time": {
            "description": "The total time spent processing documents with thie model.",
            "type": "string"
          },
          "ingest.current": {
            "description": "The total number of documents that are currently being handled by the model.",
            "type": "string"
          },
          "ingest.failed": {
            "description": "The total number of failed ingest attempts with the model.",
            "type": "string"
          },
          "data_frame.id": {
            "description": "The identifier for the data frame analytics job that created the model.\nOnly displayed if the job is still available.",
            "type": "string"
          },
          "data_frame.create_time": {
            "description": "The time the data frame analytics job was created.",
            "type": "string"
          },
          "data_frame.source_index": {
            "description": "The source index used to train in the data frame analysis.",
            "type": "string"
          },
          "data_frame.analysis": {
            "description": "The analysis used by the data frame to build the model.",
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        }
      },
      "cat.nodeattrs:NodeAttributesRecord": {
        "type": "object",
        "properties": {
          "node": {
            "description": "The node name.",
            "type": "string"
          },
          "id": {
            "description": "The unique node identifier.",
            "type": "string"
          },
          "pid": {
            "description": "The process identifier.",
            "type": "string"
          },
          "host": {
            "description": "The host name.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port.",
            "type": "string"
          },
          "attr": {
            "description": "The attribute name.",
            "type": "string"
          },
          "value": {
            "description": "The attribute value.",
            "type": "string"
          }
        }
      },
      "cat.nodes:NodesRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "pid": {
            "description": "The process identifier.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port.",
            "type": "string"
          },
          "http_address": {
            "description": "The bound HTTP address.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "flavor": {
            "description": "The Elasticsearch distribution flavor.",
            "type": "string"
          },
          "type": {
            "description": "The Elasticsearch distribution type.",
            "type": "string"
          },
          "build": {
            "description": "The Elasticsearch build hash.",
            "type": "string"
          },
          "jdk": {
            "description": "The Java version.",
            "type": "string"
          },
          "disk.total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "disk.used": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "disk.avail": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "disk.used_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "heap.current": {
            "description": "The used heap.",
            "type": "string"
          },
          "heap.percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "heap.max": {
            "description": "The maximum configured heap.",
            "type": "string"
          },
          "ram.current": {
            "description": "The used machine memory.",
            "type": "string"
          },
          "ram.percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "ram.max": {
            "description": "The total machine memory.",
            "type": "string"
          },
          "file_desc.current": {
            "description": "The used file descriptors.",
            "type": "string"
          },
          "file_desc.percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "file_desc.max": {
            "description": "The maximum number of file descriptors.",
            "type": "string"
          },
          "cpu": {
            "description": "The recent system CPU usage as a percentage.",
            "type": "string"
          },
          "load_1m": {
            "description": "The load average for the most recent minute.",
            "type": "string"
          },
          "load_5m": {
            "description": "The load average for the last five minutes.",
            "type": "string"
          },
          "load_15m": {
            "description": "The load average for the last fifteen minutes.",
            "type": "string"
          },
          "uptime": {
            "description": "The node uptime.",
            "type": "string"
          },
          "node.role": {
            "description": "The roles of the node.\nReturned values include `c`(cold node), `d`(data node), `f`(frozen node), `h`(hot node), `i`(ingest node), `l`(machine learning node), `m` (master eligible node), `r`(remote cluster client node), `s`(content node), `t`(transform node), `v`(voting-only node), `w`(warm node),and `-`(coordinating node only).",
            "type": "string"
          },
          "master": {
            "description": "Indicates whether the node is the elected master node.\nReturned values include `*`(elected master) and `-`(not elected master).",
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "completion.size": {
            "description": "The size of completion.",
            "type": "string"
          },
          "fielddata.memory_size": {
            "description": "The used fielddata cache.",
            "type": "string"
          },
          "fielddata.evictions": {
            "description": "The fielddata evictions.",
            "type": "string"
          },
          "query_cache.memory_size": {
            "description": "The used query cache.",
            "type": "string"
          },
          "query_cache.evictions": {
            "description": "The query cache evictions.",
            "type": "string"
          },
          "query_cache.hit_count": {
            "description": "The query cache hit counts.",
            "type": "string"
          },
          "query_cache.miss_count": {
            "description": "The query cache miss counts.",
            "type": "string"
          },
          "request_cache.memory_size": {
            "description": "The used request cache.",
            "type": "string"
          },
          "request_cache.evictions": {
            "description": "The request cache evictions.",
            "type": "string"
          },
          "request_cache.hit_count": {
            "description": "The request cache hit counts.",
            "type": "string"
          },
          "request_cache.miss_count": {
            "description": "The request cache miss counts.",
            "type": "string"
          },
          "flush.total": {
            "description": "The number of flushes.",
            "type": "string"
          },
          "flush.total_time": {
            "description": "The time spent in flush.",
            "type": "string"
          },
          "get.current": {
            "description": "The number of current get ops.",
            "type": "string"
          },
          "get.time": {
            "description": "The time spent in get.",
            "type": "string"
          },
          "get.total": {
            "description": "The number of get ops.",
            "type": "string"
          },
          "get.exists_time": {
            "description": "The time spent in successful gets.",
            "type": "string"
          },
          "get.exists_total": {
            "description": "The number of successful get operations.",
            "type": "string"
          },
          "get.missing_time": {
            "description": "The time spent in failed gets.",
            "type": "string"
          },
          "get.missing_total": {
            "description": "The number of failed gets.",
            "type": "string"
          },
          "indexing.delete_current": {
            "description": "The number of current deletions.",
            "type": "string"
          },
          "indexing.delete_time": {
            "description": "The time spent in deletions.",
            "type": "string"
          },
          "indexing.delete_total": {
            "description": "The number of delete operations.",
            "type": "string"
          },
          "indexing.index_current": {
            "description": "The number of current indexing operations.",
            "type": "string"
          },
          "indexing.index_time": {
            "description": "The time spent in indexing.",
            "type": "string"
          },
          "indexing.index_total": {
            "description": "The number of indexing operations.",
            "type": "string"
          },
          "indexing.index_failed": {
            "description": "The number of failed indexing operations.",
            "type": "string"
          },
          "merges.current": {
            "description": "The number of current merges.",
            "type": "string"
          },
          "merges.current_docs": {
            "description": "The number of current merging docs.",
            "type": "string"
          },
          "merges.current_size": {
            "description": "The size of current merges.",
            "type": "string"
          },
          "merges.total": {
            "description": "The number of completed merge operations.",
            "type": "string"
          },
          "merges.total_docs": {
            "description": "The docs merged.",
            "type": "string"
          },
          "merges.total_size": {
            "description": "The size merged.",
            "type": "string"
          },
          "merges.total_time": {
            "description": "The time spent in merges.",
            "type": "string"
          },
          "refresh.total": {
            "description": "The total refreshes.",
            "type": "string"
          },
          "refresh.time": {
            "description": "The time spent in refreshes.",
            "type": "string"
          },
          "refresh.external_total": {
            "description": "The total external refreshes.",
            "type": "string"
          },
          "refresh.external_time": {
            "description": "The time spent in external refreshes.",
            "type": "string"
          },
          "refresh.listeners": {
            "description": "The number of pending refresh listeners.",
            "type": "string"
          },
          "script.compilations": {
            "description": "The total script compilations.",
            "type": "string"
          },
          "script.cache_evictions": {
            "description": "The total compiled scripts evicted from the cache.",
            "type": "string"
          },
          "script.compilation_limit_triggered": {
            "description": "The script cache compilation limit triggered.",
            "type": "string"
          },
          "search.fetch_current": {
            "description": "The current fetch phase operations.",
            "type": "string"
          },
          "search.fetch_time": {
            "description": "The time spent in fetch phase.",
            "type": "string"
          },
          "search.fetch_total": {
            "description": "The total fetch operations.",
            "type": "string"
          },
          "search.open_contexts": {
            "description": "The open search contexts.",
            "type": "string"
          },
          "search.query_current": {
            "description": "The current query phase operations.",
            "type": "string"
          },
          "search.query_time": {
            "description": "The time spent in query phase.",
            "type": "string"
          },
          "search.query_total": {
            "description": "The total query phase operations.",
            "type": "string"
          },
          "search.scroll_current": {
            "description": "The open scroll contexts.",
            "type": "string"
          },
          "search.scroll_time": {
            "description": "The time scroll contexts held open.",
            "type": "string"
          },
          "search.scroll_total": {
            "description": "The completed scroll contexts.",
            "type": "string"
          },
          "segments.count": {
            "description": "The number of segments.",
            "type": "string"
          },
          "segments.memory": {
            "description": "The memory used by segments.",
            "type": "string"
          },
          "segments.index_writer_memory": {
            "description": "The memory used by the index writer.",
            "type": "string"
          },
          "segments.version_map_memory": {
            "description": "The memory used by the version map.",
            "type": "string"
          },
          "segments.fixed_bitset_memory": {
            "description": "The memory used by fixed bit sets for nested object field types and export type filters for types referred in _parent fields.",
            "type": "string"
          },
          "suggest.current": {
            "description": "The number of current suggest operations.",
            "type": "string"
          },
          "suggest.time": {
            "description": "The time spend in suggest.",
            "type": "string"
          },
          "suggest.total": {
            "description": "The number of suggest operations.",
            "type": "string"
          },
          "bulk.total_operations": {
            "description": "The number of bulk shard operations.",
            "type": "string"
          },
          "bulk.total_time": {
            "description": "The time spend in shard bulk.",
            "type": "string"
          },
          "bulk.total_size_in_bytes": {
            "description": "The total size in bytes of shard bulk.",
            "type": "string"
          },
          "bulk.avg_time": {
            "description": "The average time spend in shard bulk.",
            "type": "string"
          },
          "bulk.avg_size_in_bytes": {
            "description": "The average size in bytes of shard bulk.",
            "type": "string"
          }
        }
      },
      "cat.pending_tasks:PendingTasksRecord": {
        "type": "object",
        "properties": {
          "insertOrder": {
            "description": "The task insertion order.",
            "type": "string"
          },
          "timeInQueue": {
            "description": "Indicates how long the task has been in queue.",
            "type": "string"
          },
          "priority": {
            "description": "The task priority.",
            "type": "string"
          },
          "source": {
            "description": "The task source.",
            "type": "string"
          }
        }
      },
      "cat.plugins:PluginsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "component": {
            "description": "The component name.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "description": {
            "description": "The plugin details.",
            "type": "string"
          },
          "type": {
            "description": "The plugin type.",
            "type": "string"
          }
        }
      },
      "cat.segments:SegmentsRecord": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "description": "The shard name.",
            "type": "string"
          },
          "prirep": {
            "description": "The shard type: `primary` or `replica`.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address of the node where it lives.",
            "type": "string"
          },
          "id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "segment": {
            "description": "The segment name, which is derived from the segment generation and used internally to create file names in the directory of the shard.",
            "type": "string"
          },
          "generation": {
            "description": "The segment generation number.\nElasticsearch increments this generation number for each segment written then uses this number to derive the segment name.",
            "type": "string"
          },
          "docs.count": {
            "description": "The number of documents in the segment.\nThis excludes deleted documents and counts any nested documents separately from their parents.\nIt also excludes documents which were indexed recently and do not yet belong to a segment.",
            "type": "string"
          },
          "docs.deleted": {
            "description": "The number of deleted documents in the segment, which might be higher or lower than the number of delete operations you have performed.\nThis number excludes deletes that were performed recently and do not yet belong to a segment.\nDeleted documents are cleaned up by the automatic merge process if it makes sense to do so.\nAlso, Elasticsearch creates extra deleted documents to internally track the recent history of operations on a shard.",
            "type": "string"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size.memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "committed": {
            "description": "If `true`, the segment is synced to disk.\nSegments that are synced can survive a hard reboot.\nIf `false`, the data from uncommitted segments is also stored in the transaction log so that Elasticsearch is able to replay changes on the next start.",
            "type": "string"
          },
          "searchable": {
            "description": "If `true`, the segment is searchable.\nIf `false`, the segment has most likely been written to disk but needs a refresh to be searchable.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "compound": {
            "description": "If `true`, the segment is stored in a compound file.\nThis means Lucene merged all files from the segment in a single file to save file descriptors.",
            "type": "string"
          }
        }
      },
      "cat.shards:ShardsRecord": {
        "type": "object",
        "properties": {
          "index": {
            "description": "The index name.",
            "type": "string"
          },
          "shard": {
            "description": "The shard name.",
            "type": "string"
          },
          "prirep": {
            "description": "The shard type: `primary` or `replica`.",
            "type": "string"
          },
          "state": {
            "description": "The shard state.\nReturned values include:\n`INITIALIZING`: The shard is recovering from a peer shard or gateway.\n`RELOCATING`: The shard is relocating.\n`STARTED`: The shard has started.\n`UNASSIGNED`: The shard is not assigned to any node.",
            "type": "string"
          },
          "docs": {
            "description": "The number of documents in the shard.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "store": {
            "description": "The disk space used by the shard.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "ip": {
            "description": "The IP address of the node.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "id": {
            "description": "The unique identifier for the node.",
            "type": "string"
          },
          "node": {
            "description": "The name of node.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "sync_id": {
            "description": "The sync identifier.",
            "type": "string"
          },
          "unassigned.reason": {
            "description": "The reason for the last change to the state of an unassigned shard.\nIt does not explain why the shard is currently unassigned; use the cluster allocation explain API for that information.\nReturned values include:\n`ALLOCATION_FAILED`: Unassigned as a result of a failed allocation of the shard.\n`CLUSTER_RECOVERED`: Unassigned as a result of a full cluster recovery.\n`DANGLING_INDEX_IMPORTED`: Unassigned as a result of importing a dangling index.\n`EXISTING_INDEX_RESTORED`: Unassigned as a result of restoring into a closed index.\n`FORCED_EMPTY_PRIMARY`: The shards allocation was last modified by forcing an empty primary using the cluster reroute API.\n`INDEX_CLOSED`: Unassigned because the index was closed.\n`INDEX_CREATED`: Unassigned as a result of an API creation of an index.\n`INDEX_REOPENED`: Unassigned as a result of opening a closed index.\n`MANUAL_ALLOCATION`: The shards allocation was last modified by the cluster reroute API.\n`NEW_INDEX_RESTORED`: Unassigned as a result of restoring into a new index.\n`NODE_LEFT`: Unassigned as a result of the node hosting it leaving the cluster.\n`NODE_RESTARTING`: Similar to `NODE_LEFT`, except that the node was registered as restarting using the node shutdown API.\n`PRIMARY_FAILED`: The shard was initializing as a replica, but the primary shard failed before the initialization completed.\n`REALLOCATED_REPLICA`: A better replica location is identified and causes the existing replica allocation to be cancelled.\n`REINITIALIZED`: When a shard moves from started back to initializing.\n`REPLICA_ADDED`: Unassigned as a result of explicit addition of a replica.\n`REROUTE_CANCELLED`: Unassigned as a result of explicit cancel reroute command.",
            "type": "string"
          },
          "unassigned.at": {
            "description": "The time at which the shard became unassigned in Coordinated Universal Time (UTC).",
            "type": "string"
          },
          "unassigned.for": {
            "description": "The time at which the shard was requested to be unassigned in Coordinated Universal Time (UTC).",
            "type": "string"
          },
          "unassigned.details": {
            "description": "Additional details as to why the shard became unassigned.\nIt does not explain why the shard is not assigned; use the cluster allocation explain API for that information.",
            "type": "string"
          },
          "recoverysource.type": {
            "description": "The type of recovery source.",
            "type": "string"
          },
          "completion.size": {
            "description": "The size of completion.",
            "type": "string"
          },
          "fielddata.memory_size": {
            "description": "The used fielddata cache memory.",
            "type": "string"
          },
          "fielddata.evictions": {
            "description": "The fielddata cache evictions.",
            "type": "string"
          },
          "query_cache.memory_size": {
            "description": "The used query cache memory.",
            "type": "string"
          },
          "query_cache.evictions": {
            "description": "The query cache evictions.",
            "type": "string"
          },
          "flush.total": {
            "description": "The number of flushes.",
            "type": "string"
          },
          "flush.total_time": {
            "description": "The time spent in flush.",
            "type": "string"
          },
          "get.current": {
            "description": "The number of current get operations.",
            "type": "string"
          },
          "get.time": {
            "description": "The time spent in get operations.",
            "type": "string"
          },
          "get.total": {
            "description": "The number of get operations.",
            "type": "string"
          },
          "get.exists_time": {
            "description": "The time spent in successful get operations.",
            "type": "string"
          },
          "get.exists_total": {
            "description": "The number of successful get operations.",
            "type": "string"
          },
          "get.missing_time": {
            "description": "The time spent in failed get operations.",
            "type": "string"
          },
          "get.missing_total": {
            "description": "The number of failed get operations.",
            "type": "string"
          },
          "indexing.delete_current": {
            "description": "The number of current deletion operations.",
            "type": "string"
          },
          "indexing.delete_time": {
            "description": "The time spent in deletion operations.",
            "type": "string"
          },
          "indexing.delete_total": {
            "description": "The number of delete operations.",
            "type": "string"
          },
          "indexing.index_current": {
            "description": "The number of current indexing operations.",
            "type": "string"
          },
          "indexing.index_time": {
            "description": "The time spent in indexing operations.",
            "type": "string"
          },
          "indexing.index_total": {
            "description": "The number of indexing operations.",
            "type": "string"
          },
          "indexing.index_failed": {
            "description": "The number of failed indexing operations.",
            "type": "string"
          },
          "merges.current": {
            "description": "The number of current merge operations.",
            "type": "string"
          },
          "merges.current_docs": {
            "description": "The number of current merging documents.",
            "type": "string"
          },
          "merges.current_size": {
            "description": "The size of current merge operations.",
            "type": "string"
          },
          "merges.total": {
            "description": "The number of completed merge operations.",
            "type": "string"
          },
          "merges.total_docs": {
            "description": "The nuber of merged documents.",
            "type": "string"
          },
          "merges.total_size": {
            "description": "The size of current merges.",
            "type": "string"
          },
          "merges.total_time": {
            "description": "The time spent merging documents.",
            "type": "string"
          },
          "refresh.total": {
            "description": "The total number of refreshes.",
            "type": "string"
          },
          "refresh.time": {
            "description": "The time spent in refreshes.",
            "type": "string"
          },
          "refresh.external_total": {
            "description": "The total nunber of external refreshes.",
            "type": "string"
          },
          "refresh.external_time": {
            "description": "The time spent in external refreshes.",
            "type": "string"
          },
          "refresh.listeners": {
            "description": "The number of pending refresh listeners.",
            "type": "string"
          },
          "search.fetch_current": {
            "description": "The current fetch phase operations.",
            "type": "string"
          },
          "search.fetch_time": {
            "description": "The time spent in fetch phase.",
            "type": "string"
          },
          "search.fetch_total": {
            "description": "The total number of fetch operations.",
            "type": "string"
          },
          "search.open_contexts": {
            "description": "The number of open search contexts.",
            "type": "string"
          },
          "search.query_current": {
            "description": "The current query phase operations.",
            "type": "string"
          },
          "search.query_time": {
            "description": "The time spent in query phase.",
            "type": "string"
          },
          "search.query_total": {
            "description": "The total number of query phase operations.",
            "type": "string"
          },
          "search.scroll_current": {
            "description": "The open scroll contexts.",
            "type": "string"
          },
          "search.scroll_time": {
            "description": "The time scroll contexts were held open.",
            "type": "string"
          },
          "search.scroll_total": {
            "description": "The number of completed scroll contexts.",
            "type": "string"
          },
          "segments.count": {
            "description": "The number of segments.",
            "type": "string"
          },
          "segments.memory": {
            "description": "The memory used by segments.",
            "type": "string"
          },
          "segments.index_writer_memory": {
            "description": "The memory used by the index writer.",
            "type": "string"
          },
          "segments.version_map_memory": {
            "description": "The memory used by the version map.",
            "type": "string"
          },
          "segments.fixed_bitset_memory": {
            "description": "The memory used by fixed bit sets for nested object field types and export type filters for types referred in `_parent` fields.",
            "type": "string"
          },
          "seq_no.max": {
            "description": "The maximum sequence number.",
            "type": "string"
          },
          "seq_no.local_checkpoint": {
            "description": "The local checkpoint.",
            "type": "string"
          },
          "seq_no.global_checkpoint": {
            "description": "The global checkpoint.",
            "type": "string"
          },
          "warmer.current": {
            "description": "The number of current warmer operations.",
            "type": "string"
          },
          "warmer.total": {
            "description": "The total number of warmer operations.",
            "type": "string"
          },
          "warmer.total_time": {
            "description": "The time spent in warmer operations.",
            "type": "string"
          },
          "path.data": {
            "description": "The shard data path.",
            "type": "string"
          },
          "path.state": {
            "description": "The shard state path.",
            "type": "string"
          },
          "bulk.total_operations": {
            "description": "The number of bulk shard operations.",
            "type": "string"
          },
          "bulk.total_time": {
            "description": "The time spent in shard bulk operations.",
            "type": "string"
          },
          "bulk.total_size_in_bytes": {
            "description": "The total size in bytes of shard bulk operations.",
            "type": "string"
          },
          "bulk.avg_time": {
            "description": "The average time spent in shard bulk operations.",
            "type": "string"
          },
          "bulk.avg_size_in_bytes": {
            "description": "The average size in bytes of shard bulk operations.",
            "type": "string"
          }
        }
      },
      "cat.snapshots:SnapshotsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The unique identifier for the snapshot.",
            "type": "string"
          },
          "repository": {
            "description": "The repository name.",
            "type": "string"
          },
          "status": {
            "description": "The state of the snapshot process.\nReturned values include:\n`FAILED`: The snapshot process failed.\n`INCOMPATIBLE`: The snapshot process is incompatible with the current cluster version.\n`IN_PROGRESS`: The snapshot process started but has not completed.\n`PARTIAL`: The snapshot process completed with a partial success.\n`SUCCESS`: The snapshot process completed with a full success.",
            "type": "string"
          },
          "start_epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "start_time": {
            "$ref": "#/components/schemas/watcher._types:ScheduleTimeOfDay"
          },
          "end_epoch": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitSeconds"
          },
          "end_time": {
            "$ref": "#/components/schemas/_types:TimeOfDay"
          },
          "duration": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "indices": {
            "description": "The number of indices in the snapshot.",
            "type": "string"
          },
          "successful_shards": {
            "description": "The number of successful shards in the snapshot.",
            "type": "string"
          },
          "failed_shards": {
            "description": "The number of failed shards in the snapshot.",
            "type": "string"
          },
          "total_shards": {
            "description": "The total number of shards in the snapshot.",
            "type": "string"
          },
          "reason": {
            "description": "The reason for any snapshot failures.",
            "type": "string"
          }
        }
      },
      "watcher._types:ScheduleTimeOfDay": {
        "description": "A time of day, expressed either as `hh:mm`, `noon`, `midnight`, or an hour/minutes structure.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/watcher._types:HourAndMinute"
          }
        ]
      },
      "watcher._types:HourAndMinute": {
        "type": "object",
        "properties": {
          "hour": {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "minute": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "hour",
          "minute"
        ]
      },
      "cat.tasks:TasksRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "action": {
            "description": "The task action.",
            "type": "string"
          },
          "task_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "parent_task_id": {
            "description": "The parent task identifier.",
            "type": "string"
          },
          "type": {
            "description": "The task type.",
            "type": "string"
          },
          "start_time": {
            "description": "The start time in milliseconds.",
            "type": "string"
          },
          "timestamp": {
            "description": "The start time in `HH:MM:SS` format.",
            "type": "string"
          },
          "running_time_ns": {
            "description": "The running time in nanoseconds.",
            "type": "string"
          },
          "running_time": {
            "description": "The running time.",
            "type": "string"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "ip": {
            "description": "The IP address for the node.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port for the node.",
            "type": "string"
          },
          "node": {
            "description": "The node name.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "x_opaque_id": {
            "description": "The X-Opaque-ID header.",
            "type": "string"
          },
          "description": {
            "description": "The task action description.",
            "type": "string"
          }
        }
      },
      "cat.templates:TemplatesRecord": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "index_patterns": {
            "description": "The template index patterns.",
            "type": "string"
          },
          "order": {
            "description": "The template application order or priority number.",
            "type": "string"
          },
          "version": {
            "description": "The template version.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:VersionString"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "composed_of": {
            "description": "The component templates that comprise the index template.",
            "type": "string"
          }
        }
      },
      "cat.thread_pool:ThreadPoolRecord": {
        "type": "object",
        "properties": {
          "node_name": {
            "description": "The node name.",
            "type": "string"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "ephemeral_node_id": {
            "description": "The ephemeral node identifier.",
            "type": "string"
          },
          "pid": {
            "description": "The process identifier.",
            "type": "string"
          },
          "host": {
            "description": "The host name for the current node.",
            "type": "string"
          },
          "ip": {
            "description": "The IP address for the current node.",
            "type": "string"
          },
          "port": {
            "description": "The bound transport port for the current node.",
            "type": "string"
          },
          "name": {
            "description": "The thread pool name.",
            "type": "string"
          },
          "type": {
            "description": "The thread pool type.\nReturned values include `fixed`, `fixed_auto_queue_size`, `direct`, and `scaling`.",
            "type": "string"
          },
          "active": {
            "description": "The number of active threads in the current thread pool.",
            "type": "string"
          },
          "pool_size": {
            "description": "The number of threads in the current thread pool.",
            "type": "string"
          },
          "queue": {
            "description": "The number of tasks currently in queue.",
            "type": "string"
          },
          "queue_size": {
            "description": "The maximum number of tasks permitted in the queue.",
            "type": "string"
          },
          "rejected": {
            "description": "The number of rejected tasks.",
            "type": "string"
          },
          "largest": {
            "description": "The highest number of active threads in the current thread pool.",
            "type": "string"
          },
          "completed": {
            "description": "The number of completed tasks.",
            "type": "string"
          },
          "core": {
            "description": "The core number of active threads allowed in a scaling thread pool.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "max": {
            "description": "The maximum number of active threads allowed in a scaling thread pool.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "size": {
            "description": "The number of active threads allowed in a fixed thread pool.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "keep_alive": {
            "description": "The thread keep alive time.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        }
      },
      "cat._types:CatTransformColumns": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/cat._types:CatTransformColumn"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cat._types:CatTransformColumn"
            }
          }
        ]
      },
      "cat._types:CatTransformColumn": {
        "type": "string",
        "enum": [
          "changes_last_detection_time",
          "checkpoint",
          "checkpoint_duration_time_exp_avg",
          "checkpoint_progress",
          "create_time",
          "delete_time",
          "description",
          "dest_index",
          "documents_deleted",
          "documents_indexed",
          "docs_per_second",
          "documents_processed",
          "frequency",
          "id",
          "index_failure",
          "index_time",
          "index_total",
          "indexed_documents_exp_avg",
          "last_search_time",
          "max_page_search_size",
          "pages_processed",
          "pipeline",
          "processed_documents_exp_avg",
          "processing_time",
          "reason",
          "search_failure",
          "search_time",
          "search_total",
          "source_index",
          "state",
          "transform_type",
          "trigger_count",
          "version"
        ]
      },
      "cat.transforms:TransformsRecord": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "description": "The status of the transform.\nReturned values include:\n`aborting`: The transform is aborting.\n`failed: The transform failed. For more information about the failure, check the `reason` field.\n`indexing`: The transform is actively processing data and creating new documents.\n`started`: The transform is running but not actively indexing data.\n`stopped`: The transform is stopped.\n`stopping`: The transform is stopping.",
            "type": "string"
          },
          "checkpoint": {
            "description": "The sequence number for the checkpoint.",
            "type": "string"
          },
          "documents_processed": {
            "description": "The number of documents that have been processed from the source index of the transform.",
            "type": "string"
          },
          "checkpoint_progress": {
            "description": "The progress of the next checkpoint that is currently in progress.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "last_search_time": {
            "description": "The timestamp of the last search in the source indices.\nThis field is shown only if the transform is running.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "changes_last_detection_time": {
            "description": "The timestamp when changes were last detected in the source indices.",
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "create_time": {
            "description": "The time the transform was created.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "source_index": {
            "description": "The source indices for the transform.",
            "type": "string"
          },
          "dest_index": {
            "description": "The destination index for the transform.",
            "type": "string"
          },
          "pipeline": {
            "description": "The unique identifier for the ingest pipeline.",
            "type": "string"
          },
          "description": {
            "description": "The description of the transform.",
            "type": "string"
          },
          "transform_type": {
            "description": "The type of transform: `batch` or `continuous`.",
            "type": "string"
          },
          "frequency": {
            "description": "The interval between checks for changes in the source indices when the transform is running continuously.",
            "type": "string"
          },
          "max_page_search_size": {
            "description": "The initial page size that is used for the composite aggregation for each checkpoint.",
            "type": "string"
          },
          "docs_per_second": {
            "description": "The number of input documents per second.",
            "type": "string"
          },
          "reason": {
            "description": "If a transform has a `failed` state, these details describe the reason for failure.",
            "type": "string"
          },
          "search_total": {
            "description": "The total number of search operations on the source index for the transform.",
            "type": "string"
          },
          "search_failure": {
            "description": "The total number of search failures.",
            "type": "string"
          },
          "search_time": {
            "description": "The total amount of search time, in milliseconds.",
            "type": "string"
          },
          "index_total": {
            "description": "The total number of index operations done by the transform.",
            "type": "string"
          },
          "index_failure": {
            "description": "The total number of indexing failures.",
            "type": "string"
          },
          "index_time": {
            "description": "The total time spent indexing documents, in milliseconds.",
            "type": "string"
          },
          "documents_indexed": {
            "description": "The number of documents that have been indexed into the destination index for the transform.",
            "type": "string"
          },
          "delete_time": {
            "description": "The total time spent deleting documents, in milliseconds.",
            "type": "string"
          },
          "documents_deleted": {
            "description": "The number of documents deleted from the destination index due to the retention policy for the transform.",
            "type": "string"
          },
          "trigger_count": {
            "description": "The number of times the transform has been triggered by the scheduler.\nFor example, the scheduler triggers the transform indexer to check for updates or ingest new data at an interval specified in the `frequency` property.",
            "type": "string"
          },
          "pages_processed": {
            "description": "The number of search or bulk index operations processed.\nDocuments are processed in batches instead of individually.",
            "type": "string"
          },
          "processing_time": {
            "description": "The total time spent processing results, in milliseconds.",
            "type": "string"
          },
          "checkpoint_duration_time_exp_avg": {
            "description": "The exponential moving average of the duration of the checkpoint, in milliseconds.",
            "type": "string"
          },
          "indexed_documents_exp_avg": {
            "description": "The exponential moving average of the number of new documents that have been indexed.",
            "type": "string"
          },
          "processed_documents_exp_avg": {
            "description": "The exponential moving average of the number of documents that have been processed.",
            "type": "string"
          }
        }
      },
      "_types:ScrollIds": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ScrollId"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ScrollId"
            }
          }
        ]
      },
      "cluster.allocation_explain:Decision": {
        "type": "string",
        "enum": [
          "yes",
          "no",
          "worse_balance",
          "throttled",
          "awaiting_info",
          "allocation_delayed",
          "no_valid_shard_copy",
          "no_attempt"
        ]
      },
      "cluster.allocation_explain:AllocationDecision": {
        "type": "object",
        "properties": {
          "decider": {
            "type": "string"
          },
          "decision": {
            "$ref": "#/components/schemas/cluster.allocation_explain:AllocationExplainDecision"
          },
          "explanation": {
            "type": "string"
          }
        },
        "required": [
          "decider",
          "decision",
          "explanation"
        ]
      },
      "cluster.allocation_explain:AllocationExplainDecision": {
        "type": "string",
        "enum": [
          "NO",
          "YES",
          "THROTTLE",
          "ALWAYS"
        ]
      },
      "cluster.allocation_explain:ClusterInfo": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.allocation_explain:NodeDiskUsage"
            }
          },
          "shard_sizes": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "shard_data_set_sizes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "shard_paths": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "reserved_sizes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.allocation_explain:ReservedSize"
            }
          }
        },
        "required": [
          "nodes",
          "shard_sizes",
          "shard_paths",
          "reserved_sizes"
        ]
      },
      "cluster.allocation_explain:NodeDiskUsage": {
        "type": "object",
        "properties": {
          "node_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "least_available": {
            "$ref": "#/components/schemas/cluster.allocation_explain:DiskUsage"
          },
          "most_available": {
            "$ref": "#/components/schemas/cluster.allocation_explain:DiskUsage"
          }
        },
        "required": [
          "node_name",
          "least_available",
          "most_available"
        ]
      },
      "cluster.allocation_explain:DiskUsage": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string"
          },
          "total_bytes": {
            "type": "number"
          },
          "used_bytes": {
            "type": "number"
          },
          "free_bytes": {
            "type": "number"
          },
          "free_disk_percent": {
            "type": "number"
          },
          "used_disk_percent": {
            "type": "number"
          }
        },
        "required": [
          "path",
          "total_bytes",
          "used_bytes",
          "free_bytes",
          "free_disk_percent",
          "used_disk_percent"
        ]
      },
      "cluster.allocation_explain:ReservedSize": {
        "type": "object",
        "properties": {
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "path": {
            "type": "string"
          },
          "total": {
            "type": "number"
          },
          "shards": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "node_id",
          "path",
          "total",
          "shards"
        ]
      },
      "cluster.allocation_explain:CurrentNode": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "weight_ranking": {
            "type": "number"
          }
        },
        "required": [
          "id",
          "name",
          "attributes",
          "transport_address",
          "weight_ranking"
        ]
      },
      "_types:TransportAddress": {
        "type": "string"
      },
      "cluster.allocation_explain:NodeAllocationExplanation": {
        "type": "object",
        "properties": {
          "deciders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.allocation_explain:AllocationDecision"
            }
          },
          "node_attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "node_decision": {
            "$ref": "#/components/schemas/cluster.allocation_explain:Decision"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "store": {
            "$ref": "#/components/schemas/cluster.allocation_explain:AllocationStore"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "weight_ranking": {
            "type": "number"
          }
        },
        "required": [
          "deciders",
          "node_attributes",
          "node_decision",
          "node_id",
          "node_name",
          "transport_address",
          "weight_ranking"
        ]
      },
      "cluster.allocation_explain:AllocationStore": {
        "type": "object",
        "properties": {
          "allocation_id": {
            "type": "string"
          },
          "found": {
            "type": "boolean"
          },
          "in_sync": {
            "type": "boolean"
          },
          "matching_size_in_bytes": {
            "type": "number"
          },
          "matching_sync_id": {
            "type": "boolean"
          },
          "store_exception": {
            "type": "string"
          }
        },
        "required": [
          "allocation_id",
          "found",
          "in_sync",
          "matching_size_in_bytes",
          "matching_sync_id",
          "store_exception"
        ]
      },
      "cluster.allocation_explain:UnassignedInformation": {
        "type": "object",
        "properties": {
          "at": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last_allocation_status": {
            "type": "string"
          },
          "reason": {
            "$ref": "#/components/schemas/cluster.allocation_explain:UnassignedInformationReason"
          },
          "details": {
            "type": "string"
          },
          "failed_allocation_attempts": {
            "type": "number"
          },
          "delayed": {
            "type": "boolean"
          },
          "allocation_status": {
            "type": "string"
          }
        },
        "required": [
          "at",
          "reason"
        ]
      },
      "cluster.allocation_explain:UnassignedInformationReason": {
        "type": "string",
        "enum": [
          "INDEX_CREATED",
          "CLUSTER_RECOVERED",
          "INDEX_REOPENED",
          "DANGLING_INDEX_IMPORTED",
          "NEW_INDEX_RESTORED",
          "EXISTING_INDEX_RESTORED",
          "REPLICA_ADDED",
          "ALLOCATION_FAILED",
          "NODE_LEFT",
          "REROUTE_CANCELLED",
          "REINITIALIZED",
          "REALLOCATED_REPLICA",
          "PRIMARY_FAILED",
          "FORCED_EMPTY_PRIMARY",
          "MANUAL_ALLOCATION"
        ]
      },
      "cluster._types:ComponentTemplate": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "component_template": {
            "$ref": "#/components/schemas/cluster._types:ComponentTemplateNode"
          }
        },
        "required": [
          "name",
          "component_template"
        ]
      },
      "cluster._types:ComponentTemplateNode": {
        "type": "object",
        "properties": {
          "template": {
            "$ref": "#/components/schemas/cluster._types:ComponentTemplateSummary"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "template"
        ]
      },
      "cluster._types:ComponentTemplateSummary": {
        "type": "object",
        "properties": {
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "settings": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:IndexSettings"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:AliasDefinition"
            }
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          }
        }
      },
      "indices._types:IndexSettings": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "mode": {
            "type": "string"
          },
          "routing_path": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            ]
          },
          "soft_deletes": {
            "$ref": "#/components/schemas/indices._types:SoftDeletes"
          },
          "sort": {
            "$ref": "#/components/schemas/indices._types:IndexSegmentSort"
          },
          "number_of_shards": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "number_of_replicas": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "number_of_routing_shards": {
            "type": "number"
          },
          "check_on_startup": {
            "$ref": "#/components/schemas/indices._types:IndexCheckOnStartup"
          },
          "codec": {
            "type": "string"
          },
          "routing_partition_size": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          },
          "load_fixed_bitset_filters_eagerly": {
            "type": "boolean"
          },
          "hidden": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "auto_expand_replicas": {
            "type": "string"
          },
          "merge": {
            "$ref": "#/components/schemas/indices._types:Merge"
          },
          "search": {
            "$ref": "#/components/schemas/indices._types:SettingsSearch"
          },
          "refresh_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_result_window": {
            "type": "number"
          },
          "max_inner_result_window": {
            "type": "number"
          },
          "max_rescore_window": {
            "type": "number"
          },
          "max_docvalue_fields_search": {
            "type": "number"
          },
          "max_script_fields": {
            "type": "number"
          },
          "max_ngram_diff": {
            "type": "number"
          },
          "max_shingle_diff": {
            "type": "number"
          },
          "blocks": {
            "$ref": "#/components/schemas/indices._types:IndexSettingBlocks"
          },
          "max_refresh_listeners": {
            "type": "number"
          },
          "analyze": {
            "$ref": "#/components/schemas/indices._types:SettingsAnalyze"
          },
          "highlight": {
            "$ref": "#/components/schemas/indices._types:SettingsHighlight"
          },
          "max_terms_count": {
            "type": "number"
          },
          "max_regex_length": {
            "type": "number"
          },
          "routing": {
            "$ref": "#/components/schemas/indices._types:IndexRouting"
          },
          "gc_deletes": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "default_pipeline": {
            "$ref": "#/components/schemas/_types:PipelineName"
          },
          "final_pipeline": {
            "$ref": "#/components/schemas/_types:PipelineName"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsLifecycle"
          },
          "provided_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "creation_date": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedEpochTimeUnitMillis"
          },
          "creation_date_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "version": {
            "$ref": "#/components/schemas/indices._types:IndexVersioning"
          },
          "verified_before_close": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "format": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "type": "number"
              }
            ]
          },
          "max_slices_per_scroll": {
            "type": "number"
          },
          "translog": {
            "$ref": "#/components/schemas/indices._types:Translog"
          },
          "query_string": {
            "$ref": "#/components/schemas/indices._types:SettingsQueryString"
          },
          "priority": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          },
          "top_metrics_max_size": {
            "type": "number"
          },
          "analysis": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsAnalysis"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "time_series": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsTimeSeries"
          },
          "shards": {
            "type": "number"
          },
          "queries": {
            "$ref": "#/components/schemas/indices._types:Queries"
          },
          "similarity": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarity"
          },
          "mapping": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettings"
          },
          "indexing.slowlog": {
            "$ref": "#/components/schemas/indices._types:IndexingSlowlogSettings"
          },
          "indexing_pressure": {
            "$ref": "#/components/schemas/indices._types:IndexingPressure"
          },
          "store": {
            "$ref": "#/components/schemas/indices._types:Storage"
          }
        }
      },
      "indices._types:SoftDeletes": {
        "type": "object",
        "properties": {
          "enabled": {
            "description": "Indicates whether soft deletes are enabled on the index.",
            "type": "boolean"
          },
          "retention_lease": {
            "$ref": "#/components/schemas/indices._types:RetentionLease"
          }
        }
      },
      "indices._types:RetentionLease": {
        "type": "object",
        "properties": {
          "period": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "period"
        ]
      },
      "indices._types:IndexSegmentSort": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "order": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/indices._types:SegmentSortOrder"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/indices._types:SegmentSortOrder"
                }
              }
            ]
          },
          "mode": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/indices._types:SegmentSortMode"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/indices._types:SegmentSortMode"
                }
              }
            ]
          },
          "missing": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/indices._types:SegmentSortMissing"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/indices._types:SegmentSortMissing"
                }
              }
            ]
          }
        }
      },
      "indices._types:SegmentSortOrder": {
        "type": "string",
        "enum": [
          "asc",
          "desc"
        ]
      },
      "indices._types:SegmentSortMode": {
        "type": "string",
        "enum": [
          "min",
          "max"
        ]
      },
      "indices._types:SegmentSortMissing": {
        "type": "string",
        "enum": [
          "_last",
          "_first"
        ]
      },
      "indices._types:IndexCheckOnStartup": {
        "type": "string",
        "enum": [
          "true",
          "false",
          "checksum"
        ]
      },
      "_spec_utils:Stringifiedinteger": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "type": "string"
          }
        ]
      },
      "indices._types:Merge": {
        "type": "object",
        "properties": {
          "scheduler": {
            "$ref": "#/components/schemas/indices._types:MergeScheduler"
          }
        }
      },
      "indices._types:MergeScheduler": {
        "type": "object",
        "properties": {
          "max_thread_count": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          },
          "max_merge_count": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          }
        }
      },
      "indices._types:SettingsSearch": {
        "type": "object",
        "properties": {
          "idle": {
            "$ref": "#/components/schemas/indices._types:SearchIdle"
          },
          "slowlog": {
            "$ref": "#/components/schemas/indices._types:SlowlogSettings"
          }
        }
      },
      "indices._types:SearchIdle": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "indices._types:SlowlogSettings": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string"
          },
          "source": {
            "type": "number"
          },
          "reformat": {
            "type": "boolean"
          },
          "threshold": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholds"
          }
        }
      },
      "indices._types:SlowlogTresholds": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholdLevels"
          },
          "fetch": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholdLevels"
          }
        }
      },
      "indices._types:SlowlogTresholdLevels": {
        "type": "object",
        "properties": {
          "warn": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "info": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "debug": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "trace": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "indices._types:IndexSettingBlocks": {
        "type": "object",
        "properties": {
          "read_only": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "read_only_allow_delete": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "read": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "write": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "metadata": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          }
        }
      },
      "_spec_utils:Stringifiedboolean": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "type": "boolean"
          },
          {
            "type": "string"
          }
        ]
      },
      "indices._types:SettingsAnalyze": {
        "type": "object",
        "properties": {
          "max_token_count": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
          }
        }
      },
      "indices._types:SettingsHighlight": {
        "type": "object",
        "properties": {
          "max_analyzed_offset": {
            "type": "number"
          }
        }
      },
      "indices._types:IndexRouting": {
        "type": "object",
        "properties": {
          "allocation": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocation"
          },
          "rebalance": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingRebalance"
          }
        }
      },
      "indices._types:IndexRoutingAllocation": {
        "type": "object",
        "properties": {
          "enable": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationOptions"
          },
          "include": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationInclude"
          },
          "initial_recovery": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationInitialRecovery"
          },
          "disk": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingAllocationDisk"
          }
        }
      },
      "indices._types:IndexRoutingAllocationOptions": {
        "type": "string",
        "enum": [
          "all",
          "primaries",
          "new_primaries",
          "none"
        ]
      },
      "indices._types:IndexRoutingAllocationInclude": {
        "type": "object",
        "properties": {
          "_tier_preference": {
            "type": "string"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        }
      },
      "indices._types:IndexRoutingAllocationInitialRecovery": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        }
      },
      "indices._types:IndexRoutingAllocationDisk": {
        "type": "object",
        "properties": {
          "threshold_enabled": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        }
      },
      "indices._types:IndexRoutingRebalance": {
        "type": "object",
        "properties": {
          "enable": {
            "$ref": "#/components/schemas/indices._types:IndexRoutingRebalanceOptions"
          }
        },
        "required": [
          "enable"
        ]
      },
      "indices._types:IndexRoutingRebalanceOptions": {
        "type": "string",
        "enum": [
          "all",
          "primaries",
          "replicas",
          "none"
        ]
      },
      "_types:PipelineName": {
        "type": "string"
      },
      "indices._types:IndexSettingsLifecycle": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indexing_complete": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          },
          "origination_date": {
            "description": "If specified, this is the timestamp used to calculate the index age for its phase transitions. Use this setting\nif you create a new index that contains old data and want to use the original creation date to calculate the index\nage. Specified as a Unix epoch value in milliseconds.",
            "type": "number"
          },
          "parse_origination_date": {
            "description": "Set to true to parse the origination date from the index name. This origination date is used to calculate the index age\nfor its phase transitions. The index name must match the pattern ^.*-{date_format}-\\\\d+, where the date_format is\nyyyy.MM.dd and the trailing digits are optional. An index that was rolled over would normally match the full format,\nfor example logs-2016.10.31-000002). If the index name doesnt match the pattern, index creation fails.",
            "type": "boolean"
          },
          "step": {
            "$ref": "#/components/schemas/indices._types:IndexSettingsLifecycleStep"
          },
          "rollover_alias": {
            "description": "The index alias to update when the index rolls over. Specify when using a policy that contains a rollover action.\nWhen the index rolls over, the alias is updated to reflect that the index is no longer the write index. For more\ninformation about rolling indices, see Rollover.",
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "indices._types:IndexSettingsLifecycleStep": {
        "type": "object",
        "properties": {
          "wait_time_threshold": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "_spec_utils:StringifiedEpochTimeUnitMillis": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          {
            "type": "string"
          }
        ]
      },
      "_types:Uuid": {
        "type": "string"
      },
      "indices._types:IndexVersioning": {
        "type": "object",
        "properties": {
          "created": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "created_string": {
            "type": "string"
          }
        }
      },
      "indices._types:Translog": {
        "type": "object",
        "properties": {
          "sync_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "durability": {
            "$ref": "#/components/schemas/indices._types:TranslogDurability"
          },
          "flush_threshold_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "retention": {
            "$ref": "#/components/schemas/indices._types:TranslogRetention"
          }
        }
      },
      "indices._types:TranslogDurability": {
        "type": "string",
        "enum": [
          "request",
          "async"
        ]
      },
      "indices._types:TranslogRetention": {
        "type": "object",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "age": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        }
      },
      "indices._types:SettingsQueryString": {
        "type": "object",
        "properties": {
          "lenient": {
            "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
          }
        },
        "required": [
          "lenient"
        ]
      },
      "indices._types:IndexSettingsAnalysis": {
        "type": "object",
        "properties": {
          "analyzer": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:Analyzer"
            }
          },
          "char_filter": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:CharFilter"
            }
          },
          "filter": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:TokenFilter"
            }
          },
          "normalizer": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:Normalizer"
            }
          },
          "tokenizer": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.analysis:Tokenizer"
            }
          }
        }
      },
      "_types.analysis:CharFilter": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterDefinition"
          }
        ]
      },
      "_types.analysis:CharFilterDefinition": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:HtmlStripCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:MappingCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternReplaceCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationCharFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiIterationMarkCharFilter"
          }
        ]
      },
      "_types.analysis:HtmlStripCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "html_strip"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:CharFilterBase": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        }
      },
      "_types.analysis:MappingCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "mapping"
                ]
              },
              "mappings": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "mappings_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PatternReplaceCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern_replace"
                ]
              },
              "flags": {
                "type": "string"
              },
              "pattern": {
                "type": "string"
              },
              "replacement": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "pattern"
            ]
          }
        ]
      },
      "_types.analysis:IcuNormalizationCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_normalizer"
                ]
              },
              "mode": {
                "$ref": "#/components/schemas/_types.analysis:IcuNormalizationMode"
              },
              "name": {
                "$ref": "#/components/schemas/_types.analysis:IcuNormalizationType"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiIterationMarkCharFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_iteration_mark"
                ]
              },
              "normalize_kana": {
                "type": "boolean"
              },
              "normalize_kanji": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "normalize_kana",
              "normalize_kanji"
            ]
          }
        ]
      },
      "_types.analysis:TokenFilter": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterDefinition"
          }
        ]
      },
      "_types.analysis:TokenFilterDefinition": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:AsciiFoldingTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CommonGramsTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ConditionTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DelimitedPayloadTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:EdgeNGramTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ElisionTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:FingerprintTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:HunspellTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:HyphenationDecompounderTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeepTypesTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeepWordsTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeywordMarkerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KStemTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LengthTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LimitTokenCountTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LowercaseTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:MultiplexerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NGramTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NoriPartOfSpeechTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternCaptureTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternReplaceTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PorterStemTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PredicateTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:RemoveDuplicatesTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ReverseTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:ShingleTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SnowballTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StemmerOverrideTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StemmerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StopTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SynonymGraphTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:SynonymTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TrimTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TruncateTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:UniqueTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:UppercaseTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WordDelimiterGraphTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WordDelimiterTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiStemmerTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiReadingFormTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiPartOfSpeechTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuCollationTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuFoldingTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuNormalizationTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuTransformTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PhoneticTokenFilter"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:DictionaryDecompounderTokenFilter"
          }
        ]
      },
      "_types.analysis:AsciiFoldingTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "asciifolding"
                ]
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TokenFilterBase": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        }
      },
      "_types.analysis:CommonGramsTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "common_grams"
                ]
              },
              "common_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "common_words_path": {
                "type": "string"
              },
              "ignore_case": {
                "type": "boolean"
              },
              "query_mode": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ConditionTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "condition"
                ]
              },
              "filter": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "type",
              "filter",
              "script"
            ]
          }
        ]
      },
      "_types.analysis:DelimitedPayloadTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "delimited_payload"
                ]
              },
              "delimiter": {
                "type": "string"
              },
              "encoding": {
                "$ref": "#/components/schemas/_types.analysis:DelimitedPayloadEncoding"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:DelimitedPayloadEncoding": {
        "type": "string",
        "enum": [
          "int",
          "float",
          "identity"
        ]
      },
      "_types.analysis:EdgeNGramTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "edge_ngram"
                ]
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "side": {
                "$ref": "#/components/schemas/_types.analysis:EdgeNGramSide"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:EdgeNGramSide": {
        "type": "string",
        "enum": [
          "front",
          "back"
        ]
      },
      "_types.analysis:ElisionTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "elision"
                ]
              },
              "articles": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "articles_path": {
                "type": "string"
              },
              "articles_case": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:FingerprintTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "fingerprint"
                ]
              },
              "max_output_size": {
                "type": "number"
              },
              "separator": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:HunspellTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "hunspell"
                ]
              },
              "dedup": {
                "type": "boolean"
              },
              "dictionary": {
                "type": "string"
              },
              "locale": {
                "type": "string"
              },
              "longest_only": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "locale"
            ]
          }
        ]
      },
      "_types.analysis:HyphenationDecompounderTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CompoundWordTokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "hyphenation_decompounder"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:CompoundWordTokenFilterBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "hyphenation_patterns_path": {
                "type": "string"
              },
              "max_subword_size": {
                "type": "number"
              },
              "min_subword_size": {
                "type": "number"
              },
              "min_word_size": {
                "type": "number"
              },
              "only_longest_match": {
                "type": "boolean"
              },
              "word_list": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "word_list_path": {
                "type": "string"
              }
            }
          }
        ]
      },
      "_types.analysis:KeepTypesTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keep_types"
                ]
              },
              "mode": {
                "$ref": "#/components/schemas/_types.analysis:KeepTypesMode"
              },
              "types": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KeepTypesMode": {
        "type": "string",
        "enum": [
          "include",
          "exclude"
        ]
      },
      "_types.analysis:KeepWordsTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keep"
                ]
              },
              "keep_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "keep_words_case": {
                "type": "boolean"
              },
              "keep_words_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KeywordMarkerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keyword_marker"
                ]
              },
              "ignore_case": {
                "type": "boolean"
              },
              "keywords": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "keywords_path": {
                "type": "string"
              },
              "keywords_pattern": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KStemTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kstem"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LengthTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "length"
                ]
              },
              "max": {
                "type": "number"
              },
              "min": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LimitTokenCountTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "limit"
                ]
              },
              "consume_all_tokens": {
                "type": "boolean"
              },
              "max_token_count": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LowercaseTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lowercase"
                ]
              },
              "language": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:MultiplexerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "multiplexer"
                ]
              },
              "filters": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type",
              "filters"
            ]
          }
        ]
      },
      "_types.analysis:NGramTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ngram"
                ]
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:NoriPartOfSpeechTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "nori_part_of_speech"
                ]
              },
              "stoptags": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PatternCaptureTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern_capture"
                ]
              },
              "patterns": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              }
            },
            "required": [
              "type",
              "patterns"
            ]
          }
        ]
      },
      "_types.analysis:PatternReplaceTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern_replace"
                ]
              },
              "all": {
                "type": "boolean"
              },
              "flags": {
                "type": "string"
              },
              "pattern": {
                "type": "string"
              },
              "replacement": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "pattern"
            ]
          }
        ]
      },
      "_types.analysis:PorterStemTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "porter_stem"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PredicateTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "predicate_token_filter"
                ]
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              }
            },
            "required": [
              "type",
              "script"
            ]
          }
        ]
      },
      "_types.analysis:RemoveDuplicatesTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "remove_duplicates"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ReverseTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "reverse"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:ShingleTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "shingle"
                ]
              },
              "filler_token": {
                "type": "string"
              },
              "max_shingle_size": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "min_shingle_size": {
                "oneOf": [
                  {
                    "type": "number"
                  },
                  {
                    "type": "string"
                  }
                ]
              },
              "output_unigrams": {
                "type": "boolean"
              },
              "output_unigrams_if_no_shingles": {
                "type": "boolean"
              },
              "token_separator": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SnowballTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "snowball"
                ]
              },
              "language": {
                "$ref": "#/components/schemas/_types.analysis:SnowballLanguage"
              }
            },
            "required": [
              "type",
              "language"
            ]
          }
        ]
      },
      "_types.analysis:StemmerOverrideTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stemmer_override"
                ]
              },
              "rules": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "rules_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:StemmerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stemmer"
                ]
              },
              "language": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:StopTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "stop"
                ]
              },
              "ignore_case": {
                "type": "boolean"
              },
              "remove_trailing": {
                "type": "boolean"
              },
              "stopwords": {
                "$ref": "#/components/schemas/_types.analysis:StopWords"
              },
              "stopwords_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SynonymGraphTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "synonym_graph"
                ]
              },
              "expand": {
                "type": "boolean"
              },
              "format": {
                "$ref": "#/components/schemas/_types.analysis:SynonymFormat"
              },
              "lenient": {
                "type": "boolean"
              },
              "synonyms": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "synonyms_path": {
                "type": "string"
              },
              "tokenizer": {
                "type": "string"
              },
              "updateable": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:SynonymFormat": {
        "type": "string",
        "enum": [
          "solr",
          "wordnet"
        ]
      },
      "_types.analysis:SynonymTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "synonym"
                ]
              },
              "expand": {
                "type": "boolean"
              },
              "format": {
                "$ref": "#/components/schemas/_types.analysis:SynonymFormat"
              },
              "lenient": {
                "type": "boolean"
              },
              "synonyms": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "synonyms_path": {
                "type": "string"
              },
              "tokenizer": {
                "type": "string"
              },
              "updateable": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TrimTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "trim"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:TruncateTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "truncate"
                ]
              },
              "length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:UniqueTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unique"
                ]
              },
              "only_on_same_position": {
                "type": "boolean"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:UppercaseTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "uppercase"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:WordDelimiterGraphTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "word_delimiter_graph"
                ]
              },
              "adjust_offsets": {
                "type": "boolean"
              },
              "catenate_all": {
                "type": "boolean"
              },
              "catenate_numbers": {
                "type": "boolean"
              },
              "catenate_words": {
                "type": "boolean"
              },
              "generate_number_parts": {
                "type": "boolean"
              },
              "generate_word_parts": {
                "type": "boolean"
              },
              "ignore_keywords": {
                "type": "boolean"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              },
              "protected_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "protected_words_path": {
                "type": "string"
              },
              "split_on_case_change": {
                "type": "boolean"
              },
              "split_on_numerics": {
                "type": "boolean"
              },
              "stem_english_possessive": {
                "type": "boolean"
              },
              "type_table": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type_table_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:WordDelimiterTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "word_delimiter"
                ]
              },
              "catenate_all": {
                "type": "boolean"
              },
              "catenate_numbers": {
                "type": "boolean"
              },
              "catenate_words": {
                "type": "boolean"
              },
              "generate_number_parts": {
                "type": "boolean"
              },
              "generate_word_parts": {
                "type": "boolean"
              },
              "preserve_original": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              },
              "protected_words": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "protected_words_path": {
                "type": "string"
              },
              "split_on_case_change": {
                "type": "boolean"
              },
              "split_on_numerics": {
                "type": "boolean"
              },
              "stem_english_possessive": {
                "type": "boolean"
              },
              "type_table": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "type_table_path": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiStemmerTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_stemmer"
                ]
              },
              "minimum_length": {
                "type": "number"
              }
            },
            "required": [
              "type",
              "minimum_length"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiReadingFormTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_readingform"
                ]
              },
              "use_romaji": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "use_romaji"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiPartOfSpeechTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_part_of_speech"
                ]
              },
              "stoptags": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type",
              "stoptags"
            ]
          }
        ]
      },
      "_types.analysis:IcuTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_tokenizer"
                ]
              },
              "rule_files": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "rule_files"
            ]
          }
        ]
      },
      "_types.analysis:TokenizerBase": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        }
      },
      "_types.analysis:IcuCollationTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_collation"
                ]
              },
              "alternate": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationAlternate"
              },
              "caseFirst": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationCaseFirst"
              },
              "caseLevel": {
                "type": "boolean"
              },
              "country": {
                "type": "string"
              },
              "decomposition": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationDecomposition"
              },
              "hiraganaQuaternaryMode": {
                "type": "boolean"
              },
              "language": {
                "type": "string"
              },
              "numeric": {
                "type": "boolean"
              },
              "rules": {
                "type": "string"
              },
              "strength": {
                "$ref": "#/components/schemas/_types.analysis:IcuCollationStrength"
              },
              "variableTop": {
                "type": "string"
              },
              "variant": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:IcuCollationAlternate": {
        "type": "string",
        "enum": [
          "shifted",
          "non-ignorable"
        ]
      },
      "_types.analysis:IcuCollationCaseFirst": {
        "type": "string",
        "enum": [
          "lower",
          "upper"
        ]
      },
      "_types.analysis:IcuCollationDecomposition": {
        "type": "string",
        "enum": [
          "no",
          "identical"
        ]
      },
      "_types.analysis:IcuCollationStrength": {
        "type": "string",
        "enum": [
          "primary",
          "secondary",
          "tertiary",
          "quaternary",
          "identical"
        ]
      },
      "_types.analysis:IcuFoldingTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_folding"
                ]
              },
              "unicode_set_filter": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "unicode_set_filter"
            ]
          }
        ]
      },
      "_types.analysis:IcuNormalizationTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_normalizer"
                ]
              },
              "name": {
                "$ref": "#/components/schemas/_types.analysis:IcuNormalizationType"
              }
            },
            "required": [
              "type",
              "name"
            ]
          }
        ]
      },
      "_types.analysis:IcuTransformTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "icu_transform"
                ]
              },
              "dir": {
                "$ref": "#/components/schemas/_types.analysis:IcuTransformDirection"
              },
              "id": {
                "type": "string"
              }
            },
            "required": [
              "type",
              "id"
            ]
          }
        ]
      },
      "_types.analysis:IcuTransformDirection": {
        "type": "string",
        "enum": [
          "forward",
          "reverse"
        ]
      },
      "_types.analysis:PhoneticTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "phonetic"
                ]
              },
              "encoder": {
                "$ref": "#/components/schemas/_types.analysis:PhoneticEncoder"
              },
              "languageset": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.analysis:PhoneticLanguage"
                }
              },
              "max_code_len": {
                "type": "number"
              },
              "name_type": {
                "$ref": "#/components/schemas/_types.analysis:PhoneticNameType"
              },
              "replace": {
                "type": "boolean"
              },
              "rule_type": {
                "$ref": "#/components/schemas/_types.analysis:PhoneticRuleType"
              }
            },
            "required": [
              "type",
              "encoder",
              "languageset",
              "name_type",
              "rule_type"
            ]
          }
        ]
      },
      "_types.analysis:PhoneticEncoder": {
        "type": "string",
        "enum": [
          "metaphone",
          "double_metaphone",
          "soundex",
          "refined_soundex",
          "caverphone1",
          "caverphone2",
          "cologne",
          "nysiis",
          "koelnerphonetik",
          "haasephonetik",
          "beider_morse",
          "daitch_mokotoff"
        ]
      },
      "_types.analysis:PhoneticLanguage": {
        "type": "string",
        "enum": [
          "any",
          "common",
          "cyrillic",
          "english",
          "french",
          "german",
          "hebrew",
          "hungarian",
          "polish",
          "romanian",
          "russian",
          "spanish"
        ]
      },
      "_types.analysis:PhoneticNameType": {
        "type": "string",
        "enum": [
          "generic",
          "ashkenazi",
          "sephardic"
        ]
      },
      "_types.analysis:PhoneticRuleType": {
        "type": "string",
        "enum": [
          "approx",
          "exact"
        ]
      },
      "_types.analysis:DictionaryDecompounderTokenFilter": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CompoundWordTokenFilterBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "dictionary_decompounder"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:Normalizer": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis-normalizers.html"
        },
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:LowercaseNormalizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:CustomNormalizer"
          }
        ]
      },
      "_types.analysis:LowercaseNormalizer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "lowercase"
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:CustomNormalizer": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "custom"
            ]
          },
          "char_filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "filter": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.analysis:Tokenizer": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerDefinition"
          }
        ]
      },
      "_types.analysis:TokenizerDefinition": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:CharGroupTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:EdgeNGramTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KeywordTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LetterTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:LowercaseTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NGramTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:NoriTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PathHierarchyTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:StandardTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:UaxEmailUrlTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:WhitespaceTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:KuromojiTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:PatternTokenizer"
          },
          {
            "$ref": "#/components/schemas/_types.analysis:IcuTokenizer"
          }
        ]
      },
      "_types.analysis:CharGroupTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "char_group"
                ]
              },
              "tokenize_on_chars": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type",
              "tokenize_on_chars"
            ]
          }
        ]
      },
      "_types.analysis:EdgeNGramTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "edge_ngram"
                ]
              },
              "custom_token_chars": {
                "type": "string"
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "token_chars": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.analysis:TokenChar"
                }
              }
            },
            "required": [
              "type",
              "max_gram",
              "min_gram",
              "token_chars"
            ]
          }
        ]
      },
      "_types.analysis:TokenChar": {
        "type": "string",
        "enum": [
          "letter",
          "digit",
          "whitespace",
          "punctuation",
          "symbol",
          "custom"
        ]
      },
      "_types.analysis:KeywordTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "keyword"
                ]
              },
              "buffer_size": {
                "type": "number"
              }
            },
            "required": [
              "type",
              "buffer_size"
            ]
          }
        ]
      },
      "_types.analysis:LetterTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "letter"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:LowercaseTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "lowercase"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:NGramTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ngram"
                ]
              },
              "custom_token_chars": {
                "type": "string"
              },
              "max_gram": {
                "type": "number"
              },
              "min_gram": {
                "type": "number"
              },
              "token_chars": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.analysis:TokenChar"
                }
              }
            },
            "required": [
              "type",
              "max_gram",
              "min_gram",
              "token_chars"
            ]
          }
        ]
      },
      "_types.analysis:NoriTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "nori_tokenizer"
                ]
              },
              "decompound_mode": {
                "$ref": "#/components/schemas/_types.analysis:NoriDecompoundMode"
              },
              "discard_punctuation": {
                "type": "boolean"
              },
              "user_dictionary": {
                "type": "string"
              },
              "user_dictionary_rules": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:PathHierarchyTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "path_hierarchy"
                ]
              },
              "buffer_size": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
              },
              "delimiter": {
                "type": "string"
              },
              "replacement": {
                "type": "string"
              },
              "reverse": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedboolean"
              },
              "skip": {
                "$ref": "#/components/schemas/_spec_utils:Stringifiedinteger"
              }
            },
            "required": [
              "type",
              "buffer_size",
              "delimiter",
              "replacement",
              "reverse",
              "skip"
            ]
          }
        ]
      },
      "_types.analysis:StandardTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "standard"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:UaxEmailUrlTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "uax_url_email"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:WhitespaceTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "whitespace"
                ]
              },
              "max_token_length": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.analysis:KuromojiTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "kuromoji_tokenizer"
                ]
              },
              "discard_punctuation": {
                "type": "boolean"
              },
              "mode": {
                "$ref": "#/components/schemas/_types.analysis:KuromojiTokenizationMode"
              },
              "nbest_cost": {
                "type": "number"
              },
              "nbest_examples": {
                "type": "string"
              },
              "user_dictionary": {
                "type": "string"
              },
              "user_dictionary_rules": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "discard_compound_token": {
                "type": "boolean"
              }
            },
            "required": [
              "type",
              "mode"
            ]
          }
        ]
      },
      "_types.analysis:PatternTokenizer": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.analysis:TokenizerBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "pattern"
                ]
              },
              "flags": {
                "type": "string"
              },
              "group": {
                "type": "number"
              },
              "pattern": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "indices._types:IndexSettingsTimeSeries": {
        "type": "object",
        "properties": {
          "end_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        }
      },
      "indices._types:Queries": {
        "type": "object",
        "properties": {
          "cache": {
            "$ref": "#/components/schemas/indices._types:CacheQueries"
          }
        }
      },
      "indices._types:CacheQueries": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "indices._types:SettingsSimilarity": {
        "type": "object",
        "properties": {
          "bm25": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityBm25"
          },
          "dfi": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityDfi"
          },
          "dfr": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityDfr"
          },
          "ib": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityIb"
          },
          "lmd": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityLmd"
          },
          "lmj": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityLmj"
          },
          "scripted_tfidf": {
            "$ref": "#/components/schemas/indices._types:SettingsSimilarityScriptedTfidf"
          }
        }
      },
      "indices._types:SettingsSimilarityBm25": {
        "type": "object",
        "properties": {
          "b": {
            "type": "number"
          },
          "discount_overlaps": {
            "type": "boolean"
          },
          "k1": {
            "type": "number"
          },
          "type": {
            "type": "string",
            "enum": [
              "BM25"
            ]
          }
        },
        "required": [
          "b",
          "discount_overlaps",
          "k1",
          "type"
        ]
      },
      "indices._types:SettingsSimilarityDfi": {
        "type": "object",
        "properties": {
          "independence_measure": {
            "$ref": "#/components/schemas/_types:DFIIndependenceMeasure"
          },
          "type": {
            "type": "string",
            "enum": [
              "DFI"
            ]
          }
        },
        "required": [
          "independence_measure",
          "type"
        ]
      },
      "_types:DFIIndependenceMeasure": {
        "type": "string",
        "enum": [
          "standardized",
          "saturated",
          "chisquared"
        ]
      },
      "indices._types:SettingsSimilarityDfr": {
        "type": "object",
        "properties": {
          "after_effect": {
            "$ref": "#/components/schemas/_types:DFRAfterEffect"
          },
          "basic_model": {
            "$ref": "#/components/schemas/_types:DFRBasicModel"
          },
          "normalization": {
            "$ref": "#/components/schemas/_types:Normalization"
          },
          "type": {
            "type": "string",
            "enum": [
              "DFR"
            ]
          }
        },
        "required": [
          "after_effect",
          "basic_model",
          "normalization",
          "type"
        ]
      },
      "_types:DFRAfterEffect": {
        "type": "string",
        "enum": [
          "no",
          "b",
          "l"
        ]
      },
      "_types:DFRBasicModel": {
        "type": "string",
        "enum": [
          "be",
          "d",
          "g",
          "if",
          "in",
          "ine",
          "p"
        ]
      },
      "_types:Normalization": {
        "type": "string",
        "enum": [
          "no",
          "h1",
          "h2",
          "h3",
          "z"
        ]
      },
      "indices._types:SettingsSimilarityIb": {
        "type": "object",
        "properties": {
          "distribution": {
            "$ref": "#/components/schemas/_types:IBDistribution"
          },
          "lambda": {
            "$ref": "#/components/schemas/_types:IBLambda"
          },
          "normalization": {
            "$ref": "#/components/schemas/_types:Normalization"
          },
          "type": {
            "type": "string",
            "enum": [
              "IB"
            ]
          }
        },
        "required": [
          "distribution",
          "lambda",
          "normalization",
          "type"
        ]
      },
      "_types:IBDistribution": {
        "type": "string",
        "enum": [
          "ll",
          "spl"
        ]
      },
      "_types:IBLambda": {
        "type": "string",
        "enum": [
          "df",
          "ttf"
        ]
      },
      "indices._types:SettingsSimilarityLmd": {
        "type": "object",
        "properties": {
          "mu": {
            "type": "number"
          },
          "type": {
            "type": "string",
            "enum": [
              "LMDirichlet"
            ]
          }
        },
        "required": [
          "mu",
          "type"
        ]
      },
      "indices._types:SettingsSimilarityLmj": {
        "type": "object",
        "properties": {
          "lambda": {
            "type": "number"
          },
          "type": {
            "type": "string",
            "enum": [
              "LMJelinekMercer"
            ]
          }
        },
        "required": [
          "lambda",
          "type"
        ]
      },
      "indices._types:SettingsSimilarityScriptedTfidf": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "type": {
            "type": "string",
            "enum": [
              "scripted"
            ]
          }
        },
        "required": [
          "script",
          "type"
        ]
      },
      "indices._types:MappingLimitSettings": {
        "type": "object",
        "properties": {
          "coerce": {
            "type": "boolean"
          },
          "total_fields": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsTotalFields"
          },
          "depth": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsDepth"
          },
          "nested_fields": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsNestedFields"
          },
          "nested_objects": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsNestedObjects"
          },
          "field_name_length": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsFieldNameLength"
          },
          "dimension_fields": {
            "$ref": "#/components/schemas/indices._types:MappingLimitSettingsDimensionFields"
          },
          "ignore_malformed": {
            "type": "boolean"
          }
        }
      },
      "indices._types:MappingLimitSettingsTotalFields": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of fields in an index. Field and object mappings, as well as field aliases count towards this limit.\nThe limit is in place to prevent mappings and searches from becoming too large. Higher values can lead to performance\ndegradations and memory issues, especially in clusters with a high load or few resources.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsDepth": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum depth for a field, which is measured as the number of inner objects. For instance, if all fields are defined\nat the root object level, then the depth is 1. If there is one object mapping, then the depth is 2, etc.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsNestedFields": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of distinct nested mappings in an index. The nested type should only be used in special cases, when\narrays of objects need to be queried independently of each other. To safeguard against poorly designed mappings, this\nsetting limits the number of unique nested types per index.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsNestedObjects": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "The maximum number of nested JSON objects that a single document can contain across all nested types. This limit helps\nto prevent out of memory errors when a document contains too many nested objects.",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsFieldNameLength": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Setting for the maximum length of a field name. This setting isnt really something that addresses mappings explosion but\nmight still be useful if you want to limit the field length. It usually shouldnt be necessary to set this setting. The\ndefault is okay unless a user starts to add a huge number of fields with really long names. Default is `Long.MAX_VALUE` (no limit).",
            "type": "number"
          }
        }
      },
      "indices._types:MappingLimitSettingsDimensionFields": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "[preview] This functionality is in technical preview and may be changed or removed in a future release. Elastic will\napply best effort to fix any issues, but features in technical preview are not subject to the support SLA of official GA features.",
            "type": "number"
          }
        }
      },
      "indices._types:IndexingSlowlogSettings": {
        "type": "object",
        "properties": {
          "level": {
            "type": "string"
          },
          "source": {
            "type": "number"
          },
          "reformat": {
            "type": "boolean"
          },
          "threshold": {
            "$ref": "#/components/schemas/indices._types:IndexingSlowlogTresholds"
          }
        }
      },
      "indices._types:IndexingSlowlogTresholds": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/indices._types:SlowlogTresholdLevels"
          }
        }
      },
      "indices._types:IndexingPressure": {
        "type": "object",
        "properties": {
          "memory": {
            "$ref": "#/components/schemas/indices._types:IndexingPressureMemory"
          }
        },
        "required": [
          "memory"
        ]
      },
      "indices._types:IndexingPressureMemory": {
        "type": "object",
        "properties": {
          "limit": {
            "description": "Number of outstanding bytes that may be consumed by indexing requests. When this limit is reached or exceeded,\nthe node will reject new coordinating and primary operations. When replica operations consume 1.5x this limit,\nthe node will reject new replica operations. Defaults to 10% of the heap.",
            "type": "number"
          }
        }
      },
      "indices._types:Storage": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/indices._types:StorageType"
          },
          "allow_mmap": {
            "description": "You can restrict the use of the mmapfs and the related hybridfs store type via the setting node.store.allow_mmap.\nThis is a boolean setting indicating whether or not memory-mapping is allowed. The default is to allow it. This\nsetting is useful, for example, if you are in an environment where you can not control the ability to create a lot\nof memory maps so you need disable the ability to use memory-mapping.",
            "type": "boolean"
          }
        },
        "required": [
          "type"
        ]
      },
      "indices._types:StorageType": {
        "type": "string",
        "enum": [
          "fs",
          "niofs",
          "mmapfs",
          "hybridfs"
        ]
      },
      "_types.mapping:TypeMapping": {
        "type": "object",
        "properties": {
          "all_field": {
            "$ref": "#/components/schemas/_types.mapping:AllField"
          },
          "date_detection": {
            "type": "boolean"
          },
          "dynamic": {
            "$ref": "#/components/schemas/_types.mapping:DynamicMapping"
          },
          "dynamic_date_formats": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "dynamic_templates": {
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/_types.mapping:DynamicTemplate"
              }
            }
          },
          "_field_names": {
            "$ref": "#/components/schemas/_types.mapping:FieldNamesField"
          },
          "index_field": {
            "$ref": "#/components/schemas/_types.mapping:IndexField"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "numeric_detection": {
            "type": "boolean"
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "_routing": {
            "$ref": "#/components/schemas/_types.mapping:RoutingField"
          },
          "_size": {
            "$ref": "#/components/schemas/_types.mapping:SizeField"
          },
          "_source": {
            "$ref": "#/components/schemas/_types.mapping:SourceField"
          },
          "runtime": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:RuntimeField"
            }
          },
          "enabled": {
            "type": "boolean"
          },
          "_data_stream_timestamp": {
            "$ref": "#/components/schemas/_types.mapping:DataStreamTimestamp"
          }
        }
      },
      "_types.mapping:AllField": {
        "type": "object",
        "properties": {
          "analyzer": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "omit_norms": {
            "type": "boolean"
          },
          "search_analyzer": {
            "type": "string"
          },
          "similarity": {
            "type": "string"
          },
          "store": {
            "type": "boolean"
          },
          "store_term_vector_offsets": {
            "type": "boolean"
          },
          "store_term_vector_payloads": {
            "type": "boolean"
          },
          "store_term_vector_positions": {
            "type": "boolean"
          },
          "store_term_vectors": {
            "type": "boolean"
          }
        },
        "required": [
          "analyzer",
          "enabled",
          "omit_norms",
          "search_analyzer",
          "similarity",
          "store",
          "store_term_vector_offsets",
          "store_term_vector_payloads",
          "store_term_vector_positions",
          "store_term_vectors"
        ]
      },
      "_types.mapping:DynamicMapping": {
        "type": "string",
        "enum": [
          "strict",
          "runtime",
          "true",
          "false"
        ]
      },
      "_types.mapping:DynamicTemplate": {
        "type": "object",
        "properties": {
          "mapping": {
            "$ref": "#/components/schemas/_types.mapping:Property"
          },
          "match": {
            "type": "string"
          },
          "match_mapping_type": {
            "type": "string"
          },
          "match_pattern": {
            "$ref": "#/components/schemas/_types.mapping:MatchType"
          },
          "path_match": {
            "type": "string"
          },
          "path_unmatch": {
            "type": "string"
          },
          "unmatch": {
            "type": "string"
          }
        }
      },
      "_types.mapping:Property": {
        "discriminator": {
          "propertyName": "type"
        },
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:BinaryProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:BooleanProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DynamicProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:JoinProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:KeywordProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:MatchOnlyTextProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:PercolatorProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:RankFeatureProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:RankFeaturesProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:SearchAsYouTypeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:TextProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:VersionProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:WildcardProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DateNanosProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DateProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:AggregateMetricDoubleProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DenseVectorProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FlattenedProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:NestedProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ObjectProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:CompletionProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ConstantKeywordProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FieldAliasProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:HistogramProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IpProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:Murmur3HashProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:TokenCountProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:GeoPointProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:GeoShapeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:PointProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ShapeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ByteNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DoubleNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FloatNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:HalfFloatNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IntegerNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:LongNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ScaledFloatNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:ShortNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:UnsignedLongNumberProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DateRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:DoubleRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:FloatRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IntegerRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:IpRangeProperty"
          },
          {
            "$ref": "#/components/schemas/_types.mapping:LongRangeProperty"
          }
        ]
      },
      "_types.mapping:BinaryProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "binary"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DocValuesPropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "doc_values": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:CorePropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "copy_to": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "similarity": {
                "type": "string"
              },
              "store": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:PropertyBase": {
        "type": "object",
        "properties": {
          "meta": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-meta-field.html"
            },
            "description": "Metadata about the field.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "properties": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "ignore_above": {
            "type": "number"
          },
          "dynamic": {
            "$ref": "#/components/schemas/_types.mapping:DynamicMapping"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          }
        }
      },
      "_types.mapping:BooleanProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "fielddata": {
                "$ref": "#/components/schemas/indices._types:NumericFielddata"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "boolean"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "indices._types:NumericFielddata": {
        "type": "object",
        "properties": {
          "format": {
            "$ref": "#/components/schemas/indices._types:NumericFielddataFormat"
          }
        },
        "required": [
          "format"
        ]
      },
      "indices._types:NumericFielddataFormat": {
        "type": "string",
        "enum": [
          "array",
          "disabled"
        ]
      },
      "_types.mapping:DynamicProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "{dynamic_property}"
                ]
              },
              "enabled": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:FieldValue"
              },
              "boost": {
                "type": "number"
              },
              "coerce": {
                "type": "boolean"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "time_series_metric": {
                "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
              },
              "analyzer": {
                "type": "string"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "index_phrases": {
                "type": "boolean"
              },
              "index_prefixes": {
                "$ref": "#/components/schemas/_types.mapping:TextIndexPrefixes"
              },
              "norms": {
                "type": "boolean"
              },
              "position_increment_gap": {
                "type": "number"
              },
              "search_analyzer": {
                "type": "string"
              },
              "search_quote_analyzer": {
                "type": "string"
              },
              "term_vector": {
                "$ref": "#/components/schemas/_types.mapping:TermVectorOption"
              },
              "format": {
                "type": "string"
              },
              "precision_step": {
                "type": "number"
              },
              "locale": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:OnScriptError": {
        "type": "string",
        "enum": [
          "fail",
          "continue"
        ]
      },
      "_types.mapping:TimeSeriesMetricType": {
        "type": "string",
        "enum": [
          "gauge",
          "counter",
          "summary",
          "histogram",
          "position"
        ]
      },
      "_types.mapping:IndexOptions": {
        "type": "string",
        "enum": [
          "docs",
          "freqs",
          "positions",
          "offsets"
        ]
      },
      "_types.mapping:TextIndexPrefixes": {
        "type": "object",
        "properties": {
          "max_chars": {
            "type": "number"
          },
          "min_chars": {
            "type": "number"
          }
        },
        "required": [
          "max_chars",
          "min_chars"
        ]
      },
      "_types.mapping:TermVectorOption": {
        "type": "string",
        "enum": [
          "no",
          "yes",
          "with_offsets",
          "with_positions",
          "with_positions_offsets",
          "with_positions_offsets_payloads",
          "with_positions_payloads"
        ]
      },
      "_types.mapping:JoinProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "relations": {
                "type": "object",
                "additionalProperties": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/_types:RelationName"
                    },
                    {
                      "type": "array",
                      "items": {
                        "$ref": "#/components/schemas/_types:RelationName"
                      }
                    }
                  ]
                }
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "join"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:KeywordProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "normalizer": {
                "type": "string"
              },
              "norms": {
                "type": "boolean"
              },
              "null_value": {
                "type": "string"
              },
              "split_queries_on_whitespace": {
                "type": "boolean"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "keyword"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:MatchOnlyTextProperty": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "enum": [
              "match_only_text"
            ]
          },
          "fields": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/multi-fields.html"
            },
            "description": "Multi-fields allow the same string value to be indexed in multiple ways for different purposes, such as one\nfield for search and a multi-field for sorting and aggregations, or the same string value analyzed by different analyzers.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.mapping:Property"
            }
          },
          "meta": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-meta-field.html"
            },
            "description": "Metadata about the field.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "copy_to": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        },
        "required": [
          "type"
        ]
      },
      "_types.mapping:PercolatorProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "percolator"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:RankFeatureProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "positive_score_impact": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "rank_feature"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:RankFeaturesProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "rank_features"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:SearchAsYouTypeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "max_shingle_size": {
                "type": "number"
              },
              "norms": {
                "type": "boolean"
              },
              "search_analyzer": {
                "type": "string"
              },
              "search_quote_analyzer": {
                "type": "string"
              },
              "term_vector": {
                "$ref": "#/components/schemas/_types.mapping:TermVectorOption"
              },
              "type": {
                "type": "string",
                "enum": [
                  "search_as_you_type"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:TextProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "boost": {
                "type": "number"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "fielddata": {
                "type": "boolean"
              },
              "fielddata_frequency_filter": {
                "$ref": "#/components/schemas/indices._types:FielddataFrequencyFilter"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "index_phrases": {
                "type": "boolean"
              },
              "index_prefixes": {
                "$ref": "#/components/schemas/_types.mapping:TextIndexPrefixes"
              },
              "norms": {
                "type": "boolean"
              },
              "position_increment_gap": {
                "type": "number"
              },
              "search_analyzer": {
                "type": "string"
              },
              "search_quote_analyzer": {
                "type": "string"
              },
              "term_vector": {
                "$ref": "#/components/schemas/_types.mapping:TermVectorOption"
              },
              "type": {
                "type": "string",
                "enum": [
                  "text"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "indices._types:FielddataFrequencyFilter": {
        "type": "object",
        "properties": {
          "max": {
            "type": "number"
          },
          "min": {
            "type": "number"
          },
          "min_segment_size": {
            "type": "number"
          }
        },
        "required": [
          "max",
          "min",
          "min_segment_size"
        ]
      },
      "_types.mapping:VersionProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "version"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:WildcardProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "wildcard"
                ]
              },
              "null_value": {
                "type": "string"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DateNanosProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "format": {
                "type": "string"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "precision_step": {
                "type": "number"
              },
              "type": {
                "type": "string",
                "enum": [
                  "date_nanos"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:DateProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "fielddata": {
                "$ref": "#/components/schemas/indices._types:NumericFielddata"
              },
              "format": {
                "type": "string"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:DateTime"
              },
              "precision_step": {
                "type": "number"
              },
              "locale": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "date"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:AggregateMetricDoubleProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "aggregate_metric_double"
                ]
              },
              "default_metric": {
                "type": "string"
              },
              "metrics": {
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "time_series_metric": {
                "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
              }
            },
            "required": [
              "type",
              "default_metric",
              "metrics"
            ]
          }
        ]
      },
      "_types.mapping:DenseVectorProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "dense_vector"
                ]
              },
              "dims": {
                "type": "number"
              },
              "similarity": {
                "type": "string"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:DenseVectorIndexOptions"
              }
            },
            "required": [
              "type",
              "dims"
            ]
          }
        ]
      },
      "_types.mapping:DenseVectorIndexOptions": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "m": {
            "type": "number"
          },
          "ef_construction": {
            "type": "number"
          }
        },
        "required": [
          "type",
          "m",
          "ef_construction"
        ]
      },
      "_types.mapping:FlattenedProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "depth_limit": {
                "type": "number"
              },
              "doc_values": {
                "type": "boolean"
              },
              "eager_global_ordinals": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "index_options": {
                "$ref": "#/components/schemas/_types.mapping:IndexOptions"
              },
              "null_value": {
                "type": "string"
              },
              "similarity": {
                "type": "string"
              },
              "split_queries_on_whitespace": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "flattened"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:NestedProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean"
              },
              "include_in_parent": {
                "type": "boolean"
              },
              "include_in_root": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "nested"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ObjectProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:CorePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "enabled": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "object"
                ]
              }
            }
          }
        ]
      },
      "_types.mapping:CompletionProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "contexts": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types.mapping:SuggestContext"
                }
              },
              "max_input_length": {
                "type": "number"
              },
              "preserve_position_increments": {
                "type": "boolean"
              },
              "preserve_separators": {
                "type": "boolean"
              },
              "search_analyzer": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "completion"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:SuggestContext": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "path": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "type": {
            "type": "string"
          },
          "precision": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "_types.mapping:ConstantKeywordProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "value": {
                "type": "object"
              },
              "type": {
                "type": "string",
                "enum": [
                  "constant_keyword"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:FieldAliasProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "path": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "type": {
                "type": "string",
                "enum": [
                  "alias"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:HistogramProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:PropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_malformed": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "histogram"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IpProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "index": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "null_value": {
                "type": "string"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "ip"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:Murmur3HashProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "murmur3"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:TokenCountProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "analyzer": {
                "type": "string"
              },
              "boost": {
                "type": "number"
              },
              "index": {
                "type": "boolean"
              },
              "null_value": {
                "type": "number"
              },
              "enable_position_increments": {
                "type": "boolean"
              },
              "type": {
                "type": "string",
                "enum": [
                  "token_count"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:GeoPointProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:GeoLocation"
              },
              "type": {
                "type": "string",
                "enum": [
                  "geo_point"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:GeoShapeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "coerce": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "orientation": {
                "$ref": "#/components/schemas/_types.mapping:GeoOrientation"
              },
              "strategy": {
                "$ref": "#/components/schemas/_types.mapping:GeoStrategy"
              },
              "type": {
                "type": "string",
                "enum": [
                  "geo_shape"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:GeoOrientation": {
        "type": "string",
        "enum": [
          "right",
          "left"
        ]
      },
      "_types.mapping:GeoStrategy": {
        "type": "string",
        "enum": [
          "recursive",
          "term"
        ]
      },
      "_types.mapping:PointProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "null_value": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "point"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ShapeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "coerce": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "ignore_z_value": {
                "type": "boolean"
              },
              "orientation": {
                "$ref": "#/components/schemas/_types.mapping:GeoOrientation"
              },
              "type": {
                "type": "string",
                "enum": [
                  "shape"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ByteNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "byte"
                ]
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:byte"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types:byte": {
        "type": "number"
      },
      "_types.mapping:NumberPropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "coerce": {
                "type": "boolean"
              },
              "ignore_malformed": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              },
              "on_script_error": {
                "$ref": "#/components/schemas/_types.mapping:OnScriptError"
              },
              "script": {
                "$ref": "#/components/schemas/_types:Script"
              },
              "time_series_metric": {
                "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
              },
              "time_series_dimension": {
                "description": "For internal use by Elastic only. Marks the field as a time series dimension. Defaults to false.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:DoubleNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "double"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:FloatNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "float"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:HalfFloatNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "half_float"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IntegerNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "integer"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:LongNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "long"
                ]
              },
              "null_value": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ScaledFloatNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "scaled_float"
                ]
              },
              "null_value": {
                "type": "number"
              },
              "scaling_factor": {
                "type": "number"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:ShortNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "short"
                ]
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:short"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types:short": {
        "type": "number"
      },
      "_types.mapping:UnsignedLongNumberProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:NumberPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "unsigned_long"
                ]
              },
              "null_value": {
                "$ref": "#/components/schemas/_types:ulong"
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types:ulong": {
        "type": "number"
      },
      "_types.mapping:DateRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "format": {
                "type": "string"
              },
              "type": {
                "type": "string",
                "enum": [
                  "date_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:RangePropertyBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:DocValuesPropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "boost": {
                "type": "number"
              },
              "coerce": {
                "type": "boolean"
              },
              "index": {
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_types.mapping:DoubleRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "double_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:FloatRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "float_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IntegerRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "integer_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:IpRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "ip_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:LongRangeProperty": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types.mapping:RangePropertyBase"
          },
          {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "enum": [
                  "long_range"
                ]
              }
            },
            "required": [
              "type"
            ]
          }
        ]
      },
      "_types.mapping:MatchType": {
        "type": "string",
        "enum": [
          "simple",
          "regex"
        ]
      },
      "_types.mapping:FieldNamesField": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types.mapping:IndexField": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types.mapping:RoutingField": {
        "type": "object",
        "properties": {
          "required": {
            "type": "boolean"
          }
        },
        "required": [
          "required"
        ]
      },
      "_types.mapping:SizeField": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types.mapping:SourceField": {
        "type": "object",
        "properties": {
          "compress": {
            "type": "boolean"
          },
          "compress_threshold": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "excludes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "includes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mode": {
            "$ref": "#/components/schemas/_types.mapping:SourceFieldMode"
          }
        }
      },
      "_types.mapping:SourceFieldMode": {
        "type": "string",
        "enum": [
          "disabled",
          "stored",
          "synthetic"
        ]
      },
      "_types.mapping:DataStreamTimestamp": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "indices._types:AliasDefinition": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "index_routing": {
            "description": "Value used to route indexing operations to a specific shard.\nIf specified, this overwrites the `routing` value for indexing operations.",
            "type": "string"
          },
          "is_write_index": {
            "description": "If `true`, the index is the write index for the alias.",
            "type": "boolean"
          },
          "routing": {
            "description": "Value used to route indexing and search operations to a specific shard.",
            "type": "string"
          },
          "search_routing": {
            "description": "Value used to route search operations to a specific shard.\nIf specified, this overwrites the `routing` value for search operations.",
            "type": "string"
          },
          "is_hidden": {
            "description": "If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.",
            "type": "boolean"
          }
        }
      },
      "indices._types:DataStreamLifecycleWithRollover": {
        "type": "object",
        "properties": {
          "data_retention": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "downsampling": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleDownsampling"
          },
          "rollover": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleRolloverConditions"
          }
        }
      },
      "indices._types:DataStreamLifecycleDownsampling": {
        "type": "object",
        "properties": {
          "rounds": {
            "description": "The list of downsampling rounds to execute as part of this downsampling configuration",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices._types:DownsamplingRound"
            }
          }
        },
        "required": [
          "rounds"
        ]
      },
      "indices._types:DownsamplingRound": {
        "type": "object",
        "properties": {
          "after": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "config": {
            "$ref": "#/components/schemas/indices._types:DownsampleConfig"
          }
        },
        "required": [
          "after",
          "config"
        ]
      },
      "indices._types:DownsampleConfig": {
        "type": "object",
        "properties": {
          "fixed_interval": {
            "$ref": "#/components/schemas/_types:DurationLarge"
          }
        },
        "required": [
          "fixed_interval"
        ]
      },
      "indices._types:DataStreamLifecycleRolloverConditions": {
        "type": "object",
        "properties": {
          "min_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_age": {
            "type": "string"
          },
          "min_docs": {
            "type": "number"
          },
          "max_docs": {
            "type": "number"
          },
          "min_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_docs": {
            "type": "number"
          },
          "max_primary_shard_docs": {
            "type": "number"
          }
        }
      },
      "_types:Level": {
        "type": "string",
        "enum": [
          "cluster",
          "indices",
          "shards"
        ]
      },
      "_types:WaitForEvents": {
        "type": "string",
        "enum": [
          "immediate",
          "urgent",
          "high",
          "normal",
          "low",
          "languid"
        ]
      },
      "cluster.health:HealthResponseBody": {
        "type": "object",
        "properties": {
          "active_primary_shards": {
            "description": "The number of active primary shards.",
            "type": "number"
          },
          "active_shards": {
            "description": "The total number of active primary and replica shards.",
            "type": "number"
          },
          "active_shards_percent_as_number": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "cluster_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "delayed_unassigned_shards": {
            "description": "The number of shards whose allocation has been delayed by the timeout settings.",
            "type": "number"
          },
          "indices": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.health:IndexHealthStats"
            }
          },
          "initializing_shards": {
            "description": "The number of shards that are under initialization.",
            "type": "number"
          },
          "number_of_data_nodes": {
            "description": "The number of nodes that are dedicated data nodes.",
            "type": "number"
          },
          "number_of_in_flight_fetch": {
            "description": "The number of unfinished fetches.",
            "type": "number"
          },
          "number_of_nodes": {
            "description": "The number of nodes within the cluster.",
            "type": "number"
          },
          "number_of_pending_tasks": {
            "description": "The number of cluster-level changes that have not yet been executed.",
            "type": "number"
          },
          "relocating_shards": {
            "description": "The number of shards that are under relocation.",
            "type": "number"
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "task_max_waiting_in_queue": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "task_max_waiting_in_queue_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "timed_out": {
            "description": "If false the response returned within the period of time that is specified by the timeout parameter (30s by default)",
            "type": "boolean"
          },
          "unassigned_shards": {
            "description": "The number of shards that are not allocated.",
            "type": "number"
          }
        },
        "required": [
          "active_primary_shards",
          "active_shards",
          "active_shards_percent_as_number",
          "cluster_name",
          "delayed_unassigned_shards",
          "initializing_shards",
          "number_of_data_nodes",
          "number_of_in_flight_fetch",
          "number_of_nodes",
          "number_of_pending_tasks",
          "relocating_shards",
          "status",
          "task_max_waiting_in_queue_millis",
          "timed_out",
          "unassigned_shards"
        ]
      },
      "cluster.health:IndexHealthStats": {
        "type": "object",
        "properties": {
          "active_primary_shards": {
            "type": "number"
          },
          "active_shards": {
            "type": "number"
          },
          "initializing_shards": {
            "type": "number"
          },
          "number_of_replicas": {
            "type": "number"
          },
          "number_of_shards": {
            "type": "number"
          },
          "relocating_shards": {
            "type": "number"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.health:ShardHealthStats"
            }
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "unassigned_shards": {
            "type": "number"
          }
        },
        "required": [
          "active_primary_shards",
          "active_shards",
          "initializing_shards",
          "number_of_replicas",
          "number_of_shards",
          "relocating_shards",
          "status",
          "unassigned_shards"
        ]
      },
      "cluster.health:ShardHealthStats": {
        "type": "object",
        "properties": {
          "active_shards": {
            "type": "number"
          },
          "initializing_shards": {
            "type": "number"
          },
          "primary_active": {
            "type": "boolean"
          },
          "relocating_shards": {
            "type": "number"
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "unassigned_shards": {
            "type": "number"
          }
        },
        "required": [
          "active_shards",
          "initializing_shards",
          "primary_active",
          "relocating_shards",
          "status",
          "unassigned_shards"
        ]
      },
      "_types:ClusterInfoTargets": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:ClusterInfoTarget"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ClusterInfoTarget"
            }
          }
        ]
      },
      "_types:ClusterInfoTarget": {
        "type": "string",
        "enum": [
          "_all",
          "http",
          "ingest",
          "thread_pool",
          "script"
        ]
      },
      "nodes._types:Http": {
        "type": "object",
        "properties": {
          "current_open": {
            "description": "Current number of open HTTP connections for the node.",
            "type": "number"
          },
          "total_opened": {
            "description": "Total number of HTTP connections opened for the node.",
            "type": "number"
          },
          "clients": {
            "description": "Information on current and recently-closed HTTP client connections.\nClients that have been closed longer than the `http.client_stats.closed_channels.max_age` setting will not be represented here.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:Client"
            }
          }
        }
      },
      "nodes._types:Client": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Unique ID for the HTTP client.",
            "type": "number"
          },
          "agent": {
            "description": "Reported agent for the HTTP client.\nIf unavailable, this property is not included in the response.",
            "type": "string"
          },
          "local_address": {
            "description": "Local address for the HTTP connection.",
            "type": "string"
          },
          "remote_address": {
            "description": "Remote address for the HTTP connection.",
            "type": "string"
          },
          "last_uri": {
            "description": "The URI of the clients most recent request.",
            "type": "string"
          },
          "opened_time_millis": {
            "description": "Time at which the client opened the connection.",
            "type": "number"
          },
          "closed_time_millis": {
            "description": "Time at which the client closed the connection if the connection is closed.",
            "type": "number"
          },
          "last_request_time_millis": {
            "description": "Time of the most recent request from this client.",
            "type": "number"
          },
          "request_count": {
            "description": "Number of requests from this client.",
            "type": "number"
          },
          "request_size_bytes": {
            "description": "Cumulative size in bytes of all requests from this client.",
            "type": "number"
          },
          "x_opaque_id": {
            "description": "Value from the clients `x-opaque-id` HTTP header.\nIf unavailable, this property is not included in the response.",
            "type": "string"
          }
        }
      },
      "nodes._types:Ingest": {
        "type": "object",
        "properties": {
          "pipelines": {
            "description": "Contains statistics about ingest pipelines for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:IngestTotal"
            }
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:IngestTotal"
          }
        }
      },
      "nodes._types:IngestTotal": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of documents ingested during the lifetime of this node.",
            "type": "number"
          },
          "current": {
            "description": "Total number of documents currently being ingested.",
            "type": "number"
          },
          "failed": {
            "description": "Total number of failed ingest operations during the lifetime of this node.",
            "type": "number"
          },
          "processors": {
            "description": "Total number of ingest processors.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/nodes._types:KeyedProcessor"
              }
            }
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        }
      },
      "nodes._types:KeyedProcessor": {
        "type": "object",
        "properties": {
          "stats": {
            "$ref": "#/components/schemas/nodes._types:Processor"
          },
          "type": {
            "type": "string"
          }
        }
      },
      "nodes._types:Processor": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of documents transformed by the processor.",
            "type": "number"
          },
          "current": {
            "description": "Number of documents currently being transformed by the processor.",
            "type": "number"
          },
          "failed": {
            "description": "Number of failed operations for the processor.",
            "type": "number"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        }
      },
      "nodes._types:ThreadCount": {
        "type": "object",
        "properties": {
          "active": {
            "description": "Number of active threads in the thread pool.",
            "type": "number"
          },
          "completed": {
            "description": "Number of tasks completed by the thread pool executor.",
            "type": "number"
          },
          "largest": {
            "description": "Highest number of active threads in the thread pool.",
            "type": "number"
          },
          "queue": {
            "description": "Number of tasks in queue for the thread pool.",
            "type": "number"
          },
          "rejected": {
            "description": "Number of tasks rejected by the thread pool executor.",
            "type": "number"
          },
          "threads": {
            "description": "Number of threads in the thread pool.",
            "type": "number"
          }
        }
      },
      "nodes._types:Scripting": {
        "type": "object",
        "properties": {
          "cache_evictions": {
            "description": "Total number of times the script cache has evicted old data.",
            "type": "number"
          },
          "compilations": {
            "description": "Total number of inline script compilations performed by the node.",
            "type": "number"
          },
          "compilations_history": {
            "description": "Contains this recent history of script compilations.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "compilation_limit_triggered": {
            "description": "Total number of times the script compilation circuit breaker has limited inline script compilations.",
            "type": "number"
          },
          "contexts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:Context"
            }
          }
        }
      },
      "nodes._types:Context": {
        "type": "object",
        "properties": {
          "context": {
            "type": "string"
          },
          "compilations": {
            "type": "number"
          },
          "cache_evictions": {
            "type": "number"
          },
          "compilation_limit_triggered": {
            "type": "number"
          }
        }
      },
      "cluster.pending_tasks:PendingTask": {
        "type": "object",
        "properties": {
          "executing": {
            "description": "Indicates whether the pending tasks are currently executing or not.",
            "type": "boolean"
          },
          "insert_order": {
            "description": "The number that represents when the task has been inserted into the task queue.",
            "type": "number"
          },
          "priority": {
            "description": "The priority of the pending task.\nThe valid priorities in descending priority order are: `IMMEDIATE` > `URGENT` > `HIGH` > `NORMAL` > `LOW` > `LANGUID`.",
            "type": "string"
          },
          "source": {
            "description": "A general description of the cluster task that may include a reason and origin.",
            "type": "string"
          },
          "time_in_queue": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_queue_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "executing",
          "insert_order",
          "priority",
          "source",
          "time_in_queue_millis"
        ]
      },
      "indices._types:IndexState": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "defaults": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "data_stream": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycle"
          }
        }
      },
      "indices._types:Alias": {
        "type": "object",
        "properties": {
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "index_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "is_hidden": {
            "description": "If `true`, the alias is hidden.\nAll indices for the alias must have the same `is_hidden` value.",
            "type": "boolean"
          },
          "is_write_index": {
            "description": "If `true`, the index is the write index for the alias.",
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "search_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          }
        }
      },
      "_types:DataStreamName": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indices-create-data-stream.html#indices-create-data-stream-api-path-params"
        },
        "type": "string"
      },
      "indices._types:DataStreamLifecycle": {
        "type": "object",
        "properties": {
          "data_retention": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "downsampling": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleDownsampling"
          }
        }
      },
      "_types:Metrics": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "cluster.reroute:Command": {
        "type": "object",
        "properties": {
          "cancel": {
            "$ref": "#/components/schemas/cluster.reroute:CommandCancelAction"
          },
          "move": {
            "$ref": "#/components/schemas/cluster.reroute:CommandMoveAction"
          },
          "allocate_replica": {
            "$ref": "#/components/schemas/cluster.reroute:CommandAllocateReplicaAction"
          },
          "allocate_stale_primary": {
            "$ref": "#/components/schemas/cluster.reroute:CommandAllocatePrimaryAction"
          },
          "allocate_empty_primary": {
            "$ref": "#/components/schemas/cluster.reroute:CommandAllocatePrimaryAction"
          }
        }
      },
      "cluster.reroute:CommandCancelAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "node": {
            "type": "string"
          },
          "allow_primary": {
            "type": "boolean"
          }
        },
        "required": [
          "index",
          "shard",
          "node"
        ]
      },
      "cluster.reroute:CommandMoveAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "from_node": {
            "description": "The node to move the shard from",
            "type": "string"
          },
          "to_node": {
            "description": "The node to move the shard to",
            "type": "string"
          }
        },
        "required": [
          "index",
          "shard",
          "from_node",
          "to_node"
        ]
      },
      "cluster.reroute:CommandAllocateReplicaAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "node": {
            "type": "string"
          }
        },
        "required": [
          "index",
          "shard",
          "node"
        ]
      },
      "cluster.reroute:CommandAllocatePrimaryAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "shard": {
            "type": "number"
          },
          "node": {
            "type": "string"
          },
          "accept_data_loss": {
            "description": "If a node which has a copy of the data rejoins the cluster later on, that data will be deleted. To ensure that these implications are well-understood, this command requires the flag accept_data_loss to be explicitly set to true",
            "type": "boolean"
          }
        },
        "required": [
          "index",
          "shard",
          "node",
          "accept_data_loss"
        ]
      },
      "cluster.reroute:RerouteExplanation": {
        "type": "object",
        "properties": {
          "command": {
            "type": "string"
          },
          "decisions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.reroute:RerouteDecision"
            }
          },
          "parameters": {
            "$ref": "#/components/schemas/cluster.reroute:RerouteParameters"
          }
        },
        "required": [
          "command",
          "decisions",
          "parameters"
        ]
      },
      "cluster.reroute:RerouteDecision": {
        "type": "object",
        "properties": {
          "decider": {
            "type": "string"
          },
          "decision": {
            "type": "string"
          },
          "explanation": {
            "type": "string"
          }
        },
        "required": [
          "decider",
          "decision",
          "explanation"
        ]
      },
      "cluster.reroute:RerouteParameters": {
        "type": "object",
        "properties": {
          "allow_primary": {
            "type": "boolean"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "shard": {
            "type": "number"
          },
          "from_node": {
            "$ref": "#/components/schemas/_types:NodeName"
          },
          "to_node": {
            "$ref": "#/components/schemas/_types:NodeName"
          }
        },
        "required": [
          "allow_primary",
          "index",
          "node",
          "shard"
        ]
      },
      "_types:NodeName": {
        "externalDocs": {
          "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-node.html"
        },
        "type": "string"
      },
      "cluster.stats:StatsResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "cluster_uuid": {
                "$ref": "#/components/schemas/_types:Uuid"
              },
              "indices": {
                "$ref": "#/components/schemas/cluster.stats:ClusterIndices"
              },
              "nodes": {
                "$ref": "#/components/schemas/cluster.stats:ClusterNodes"
              },
              "status": {
                "$ref": "#/components/schemas/_types:HealthStatus"
              },
              "timestamp": {
                "description": "Unix timestamp, in milliseconds, for the last time the cluster statistics were refreshed.",
                "type": "number"
              }
            },
            "required": [
              "cluster_name",
              "cluster_uuid",
              "indices",
              "nodes",
              "status",
              "timestamp"
            ]
          }
        ]
      },
      "cluster.stats:ClusterIndices": {
        "type": "object",
        "properties": {
          "analysis": {
            "$ref": "#/components/schemas/cluster.stats:CharFilterTypes"
          },
          "completion": {
            "$ref": "#/components/schemas/_types:CompletionStats"
          },
          "count": {
            "description": "Total number of indices with shards assigned to selected nodes.",
            "type": "number"
          },
          "docs": {
            "$ref": "#/components/schemas/_types:DocStats"
          },
          "fielddata": {
            "$ref": "#/components/schemas/_types:FielddataStats"
          },
          "query_cache": {
            "$ref": "#/components/schemas/_types:QueryCacheStats"
          },
          "segments": {
            "$ref": "#/components/schemas/_types:SegmentsStats"
          },
          "shards": {
            "$ref": "#/components/schemas/cluster.stats:ClusterIndicesShards"
          },
          "store": {
            "$ref": "#/components/schemas/_types:StoreStats"
          },
          "mappings": {
            "$ref": "#/components/schemas/cluster.stats:FieldTypesMappings"
          },
          "versions": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/analyzer-anatomy.html"
            },
            "description": "Contains statistics about analyzers and analyzer components used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:IndicesVersions"
            }
          }
        },
        "required": [
          "analysis",
          "completion",
          "count",
          "docs",
          "fielddata",
          "query_cache",
          "segments",
          "shards",
          "store",
          "mappings"
        ]
      },
      "cluster.stats:CharFilterTypes": {
        "type": "object",
        "properties": {
          "analyzer_types": {
            "description": "Contains statistics about analyzer types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_analyzers": {
            "description": "Contains statistics about built-in analyzers used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_char_filters": {
            "description": "Contains statistics about built-in character filters used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_filters": {
            "description": "Contains statistics about built-in token filters used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "built_in_tokenizers": {
            "description": "Contains statistics about built-in tokenizers used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "char_filter_types": {
            "description": "Contains statistics about character filter types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "filter_types": {
            "description": "Contains statistics about token filter types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "tokenizer_types": {
            "description": "Contains statistics about tokenizer types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          }
        },
        "required": [
          "analyzer_types",
          "built_in_analyzers",
          "built_in_char_filters",
          "built_in_filters",
          "built_in_tokenizers",
          "char_filter_types",
          "filter_types",
          "tokenizer_types"
        ]
      },
      "cluster.stats:FieldTypes": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "count": {
            "description": "The number of occurrences of the field type in selected nodes.",
            "type": "number"
          },
          "index_count": {
            "description": "The number of indices containing the field type in selected nodes.",
            "type": "number"
          },
          "indexed_vector_count": {
            "description": "For dense_vector field types, number of indexed vector types in selected nodes.",
            "type": "number"
          },
          "indexed_vector_dim_max": {
            "description": "For dense_vector field types, the maximum dimension of all indexed vector types in selected nodes.",
            "type": "number"
          },
          "indexed_vector_dim_min": {
            "description": "For dense_vector field types, the minimum dimension of all indexed vector types in selected nodes.",
            "type": "number"
          },
          "script_count": {
            "description": "The number of fields that declare a script.",
            "type": "number"
          }
        },
        "required": [
          "name",
          "count",
          "index_count"
        ]
      },
      "_types:CompletionStats": {
        "type": "object",
        "properties": {
          "size_in_bytes": {
            "description": "Total amount, in bytes, of memory used for completion across all shards assigned to selected nodes.",
            "type": "number"
          },
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:FieldSizeUsage"
            }
          }
        },
        "required": [
          "size_in_bytes"
        ]
      },
      "_types:FieldSizeUsage": {
        "type": "object",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "size_in_bytes"
        ]
      },
      "_types:DocStats": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of non-deleted documents across all primary shards assigned to selected nodes.\nThis number is based on documents in Lucene segments and may include documents from nested fields.",
            "type": "number"
          },
          "deleted": {
            "description": "Total number of deleted documents across all primary shards assigned to selected nodes.\nThis number is based on documents in Lucene segments.\nElasticsearch reclaims the disk space of deleted Lucene documents when a segment is merged.",
            "type": "number"
          }
        },
        "required": [
          "count"
        ]
      },
      "_types:FielddataStats": {
        "type": "object",
        "properties": {
          "evictions": {
            "type": "number"
          },
          "memory_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_size_in_bytes": {
            "type": "number"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:FieldMemoryUsage"
            }
          }
        },
        "required": [
          "memory_size_in_bytes"
        ]
      },
      "_types:FieldMemoryUsage": {
        "type": "object",
        "properties": {
          "memory_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "memory_size_in_bytes"
        ]
      },
      "_types:QueryCacheStats": {
        "type": "object",
        "properties": {
          "cache_count": {
            "description": "Total number of entries added to the query cache across all shards assigned to selected nodes.\nThis number includes current and evicted entries.",
            "type": "number"
          },
          "cache_size": {
            "description": "Total number of entries currently in the query cache across all shards assigned to selected nodes.",
            "type": "number"
          },
          "evictions": {
            "description": "Total number of query cache evictions across all shards assigned to selected nodes.",
            "type": "number"
          },
          "hit_count": {
            "description": "Total count of query cache hits across all shards assigned to selected nodes.",
            "type": "number"
          },
          "memory_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_size_in_bytes": {
            "description": "Total amount, in bytes, of memory used for the query cache across all shards assigned to selected nodes.",
            "type": "number"
          },
          "miss_count": {
            "description": "Total count of query cache misses across all shards assigned to selected nodes.",
            "type": "number"
          },
          "total_count": {
            "description": "Total count of hits and misses in the query cache across all shards assigned to selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "cache_count",
          "cache_size",
          "evictions",
          "hit_count",
          "memory_size_in_bytes",
          "miss_count",
          "total_count"
        ]
      },
      "_types:SegmentsStats": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Total number of segments across all shards assigned to selected nodes.",
            "type": "number"
          },
          "doc_values_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "doc_values_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for doc values across all shards assigned to selected nodes.",
            "type": "number"
          },
          "file_sizes": {
            "description": "This object is not populated by the cluster stats API.\nTo get information on segment files, use the node stats API.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices.stats:ShardFileSizeInfo"
            }
          },
          "fixed_bit_set": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "fixed_bit_set_memory_in_bytes": {
            "description": "Total amount of memory, in bytes, used by fixed bit sets across all shards assigned to selected nodes.",
            "type": "number"
          },
          "index_writer_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "index_writer_max_memory_in_bytes": {
            "type": "number"
          },
          "index_writer_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used by all index writers across all shards assigned to selected nodes.",
            "type": "number"
          },
          "max_unsafe_auto_id_timestamp": {
            "description": "Unix timestamp, in milliseconds, of the most recently retried indexing request.",
            "type": "number"
          },
          "memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for segments across all shards assigned to selected nodes.",
            "type": "number"
          },
          "norms_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "norms_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for normalization factors across all shards assigned to selected nodes.",
            "type": "number"
          },
          "points_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "points_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for points across all shards assigned to selected nodes.",
            "type": "number"
          },
          "stored_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "stored_fields_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for stored fields across all shards assigned to selected nodes.",
            "type": "number"
          },
          "terms_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for terms across all shards assigned to selected nodes.",
            "type": "number"
          },
          "terms_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "term_vectory_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "term_vectors_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used for term vectors across all shards assigned to selected nodes.",
            "type": "number"
          },
          "version_map_memory": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "version_map_memory_in_bytes": {
            "description": "Total amount, in bytes, of memory used by all version maps across all shards assigned to selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "count",
          "doc_values_memory_in_bytes",
          "file_sizes",
          "fixed_bit_set_memory_in_bytes",
          "index_writer_memory_in_bytes",
          "max_unsafe_auto_id_timestamp",
          "memory_in_bytes",
          "norms_memory_in_bytes",
          "points_memory_in_bytes",
          "stored_fields_memory_in_bytes",
          "terms_memory_in_bytes",
          "term_vectors_memory_in_bytes",
          "version_map_memory_in_bytes"
        ]
      },
      "indices.stats:ShardFileSizeInfo": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "size_in_bytes": {
            "type": "number"
          },
          "min_size_in_bytes": {
            "type": "number"
          },
          "max_size_in_bytes": {
            "type": "number"
          },
          "average_size_in_bytes": {
            "type": "number"
          },
          "count": {
            "type": "number"
          }
        },
        "required": [
          "description",
          "size_in_bytes"
        ]
      },
      "cluster.stats:ClusterIndicesShards": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/cluster.stats:ClusterIndicesShardsIndex"
          },
          "primaries": {
            "description": "Number of primary shards assigned to selected nodes.",
            "type": "number"
          },
          "replication": {
            "description": "Ratio of replica shards to primary shards across all selected nodes.",
            "type": "number"
          },
          "total": {
            "description": "Total number of shards assigned to selected nodes.",
            "type": "number"
          }
        }
      },
      "cluster.stats:ClusterIndicesShardsIndex": {
        "type": "object",
        "properties": {
          "primaries": {
            "$ref": "#/components/schemas/cluster.stats:ClusterShardMetrics"
          },
          "replication": {
            "$ref": "#/components/schemas/cluster.stats:ClusterShardMetrics"
          },
          "shards": {
            "$ref": "#/components/schemas/cluster.stats:ClusterShardMetrics"
          }
        },
        "required": [
          "primaries",
          "replication",
          "shards"
        ]
      },
      "cluster.stats:ClusterShardMetrics": {
        "type": "object",
        "properties": {
          "avg": {
            "description": "Mean number of shards in an index, counting only shards assigned to selected nodes.",
            "type": "number"
          },
          "max": {
            "description": "Maximum number of shards in an index, counting only shards assigned to selected nodes.",
            "type": "number"
          },
          "min": {
            "description": "Minimum number of shards in an index, counting only shards assigned to selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "avg",
          "max",
          "min"
        ]
      },
      "_types:StoreStats": {
        "type": "object",
        "properties": {
          "size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "size_in_bytes": {
            "description": "Total size, in bytes, of all shards assigned to selected nodes.",
            "type": "number"
          },
          "reserved": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "reserved_in_bytes": {
            "description": "A prediction, in bytes, of how much larger the shard stores will eventually grow due to ongoing peer recoveries, restoring snapshots, and similar activities.",
            "type": "number"
          },
          "total_data_set_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_data_set_size_in_bytes": {
            "description": "Total data set size, in bytes, of all shards assigned to selected nodes.\nThis includes the size of shards not stored fully on the nodes, such as the cache for partially mounted indices.",
            "type": "number"
          }
        },
        "required": [
          "size_in_bytes",
          "reserved_in_bytes"
        ]
      },
      "cluster.stats:FieldTypesMappings": {
        "type": "object",
        "properties": {
          "field_types": {
            "description": "Contains statistics about field data types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:FieldTypes"
            }
          },
          "runtime_field_types": {
            "description": "Contains statistics about runtime field data types used in selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:RuntimeFieldTypes"
            }
          },
          "total_field_count": {
            "description": "Total number of fields in all non-system indices.",
            "type": "number"
          },
          "total_deduplicated_field_count": {
            "description": "Total number of fields in all non-system indices, accounting for mapping deduplication.",
            "type": "number"
          },
          "total_deduplicated_mapping_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_deduplicated_mapping_size_in_bytes": {
            "description": "Total size of all mappings, in bytes, after deduplication and compression.",
            "type": "number"
          }
        },
        "required": [
          "field_types"
        ]
      },
      "cluster.stats:RuntimeFieldTypes": {
        "type": "object",
        "properties": {
          "chars_max": {
            "description": "Maximum number of characters for a single runtime field script.",
            "type": "number"
          },
          "chars_total": {
            "description": "Total number of characters for the scripts that define the current runtime field data type.",
            "type": "number"
          },
          "count": {
            "description": "Number of runtime fields mapped to the field data type in selected nodes.",
            "type": "number"
          },
          "doc_max": {
            "description": "Maximum number of accesses to doc_values for a single runtime field script",
            "type": "number"
          },
          "doc_total": {
            "description": "Total number of accesses to doc_values for the scripts that define the current runtime field data type.",
            "type": "number"
          },
          "index_count": {
            "description": "Number of indices containing a mapping of the runtime field data type in selected nodes.",
            "type": "number"
          },
          "lang": {
            "description": "Script languages used for the runtime fields scripts.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "lines_max": {
            "description": "Maximum number of lines for a single runtime field script.",
            "type": "number"
          },
          "lines_total": {
            "description": "Total number of lines for the scripts that define the current runtime field data type.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "scriptless_count": {
            "description": "Number of runtime fields that dont declare a script.",
            "type": "number"
          },
          "shadowed_count": {
            "description": "Number of runtime fields that shadow an indexed field.",
            "type": "number"
          },
          "source_max": {
            "description": "Maximum number of accesses to _source for a single runtime field script.",
            "type": "number"
          },
          "source_total": {
            "description": "Total number of accesses to _source for the scripts that define the current runtime field data type.",
            "type": "number"
          }
        },
        "required": [
          "chars_max",
          "chars_total",
          "count",
          "doc_max",
          "doc_total",
          "index_count",
          "lang",
          "lines_max",
          "lines_total",
          "name",
          "scriptless_count",
          "shadowed_count",
          "source_max",
          "source_total"
        ]
      },
      "cluster.stats:IndicesVersions": {
        "type": "object",
        "properties": {
          "index_count": {
            "type": "number"
          },
          "primary_shard_count": {
            "type": "number"
          },
          "total_primary_bytes": {
            "type": "number"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "index_count",
          "primary_shard_count",
          "total_primary_bytes",
          "version"
        ]
      },
      "cluster.stats:ClusterNodes": {
        "type": "object",
        "properties": {
          "count": {
            "$ref": "#/components/schemas/cluster.stats:ClusterNodeCount"
          },
          "discovery_types": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/modules-discovery-hosts-providers.html"
            },
            "description": "Contains statistics about the discovery types used by selected nodes.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "fs": {
            "$ref": "#/components/schemas/cluster.stats:ClusterFileSystem"
          },
          "indexing_pressure": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressure"
          },
          "ingest": {
            "$ref": "#/components/schemas/cluster.stats:ClusterIngest"
          },
          "jvm": {
            "$ref": "#/components/schemas/cluster.stats:ClusterJvm"
          },
          "network_types": {
            "$ref": "#/components/schemas/cluster.stats:ClusterNetworkTypes"
          },
          "os": {
            "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystem"
          },
          "packaging_types": {
            "description": "Contains statistics about Elasticsearch distributions installed on selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:NodePackagingType"
            }
          },
          "plugins": {
            "description": "Contains statistics about installed plugins and modules by selected nodes.\nIf no plugins or modules are installed, this array is empty.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:PluginStats"
            }
          },
          "process": {
            "$ref": "#/components/schemas/cluster.stats:ClusterProcess"
          },
          "versions": {
            "description": "Array of Elasticsearch versions used on selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:VersionString"
            }
          }
        },
        "required": [
          "count",
          "discovery_types",
          "fs",
          "indexing_pressure",
          "ingest",
          "jvm",
          "network_types",
          "os",
          "packaging_types",
          "plugins",
          "process",
          "versions"
        ]
      },
      "cluster.stats:ClusterNodeCount": {
        "type": "object",
        "properties": {
          "coordinating_only": {
            "type": "number"
          },
          "data": {
            "type": "number"
          },
          "data_cold": {
            "type": "number"
          },
          "data_content": {
            "type": "number"
          },
          "data_frozen": {
            "type": "number"
          },
          "data_hot": {
            "type": "number"
          },
          "data_warm": {
            "type": "number"
          },
          "ingest": {
            "type": "number"
          },
          "master": {
            "type": "number"
          },
          "ml": {
            "type": "number"
          },
          "remote_cluster_client": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "transform": {
            "type": "number"
          },
          "voting_only": {
            "type": "number"
          }
        },
        "required": [
          "coordinating_only",
          "data",
          "data_cold",
          "data_content",
          "data_hot",
          "data_warm",
          "ingest",
          "master",
          "ml",
          "remote_cluster_client",
          "total",
          "transform",
          "voting_only"
        ]
      },
      "cluster.stats:ClusterFileSystem": {
        "type": "object",
        "properties": {
          "available_in_bytes": {
            "description": "Total number of bytes available to JVM in file stores across all selected nodes.\nDepending on operating system or process-level restrictions, this number may be less than `nodes.fs.free_in_byes`.\nThis is the actual amount of free disk space the selected Elasticsearch nodes can use.",
            "type": "number"
          },
          "free_in_bytes": {
            "description": "Total number of unallocated bytes in file stores across all selected nodes.",
            "type": "number"
          },
          "total_in_bytes": {
            "description": "Total size, in bytes, of all file stores across all selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "available_in_bytes",
          "free_in_bytes",
          "total_in_bytes"
        ]
      },
      "cluster.stats:IndexingPressure": {
        "type": "object",
        "properties": {
          "memory": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressureMemory"
          }
        },
        "required": [
          "memory"
        ]
      },
      "cluster.stats:IndexingPressureMemory": {
        "type": "object",
        "properties": {
          "current": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressureMemorySummary"
          },
          "limit_in_bytes": {
            "type": "number"
          },
          "total": {
            "$ref": "#/components/schemas/cluster.stats:IndexingPressureMemorySummary"
          }
        },
        "required": [
          "current",
          "limit_in_bytes",
          "total"
        ]
      },
      "cluster.stats:IndexingPressureMemorySummary": {
        "type": "object",
        "properties": {
          "all_in_bytes": {
            "type": "number"
          },
          "combined_coordinating_and_primary_in_bytes": {
            "type": "number"
          },
          "coordinating_in_bytes": {
            "type": "number"
          },
          "coordinating_rejections": {
            "type": "number"
          },
          "primary_in_bytes": {
            "type": "number"
          },
          "primary_rejections": {
            "type": "number"
          },
          "replica_in_bytes": {
            "type": "number"
          },
          "replica_rejections": {
            "type": "number"
          }
        },
        "required": [
          "all_in_bytes",
          "combined_coordinating_and_primary_in_bytes",
          "coordinating_in_bytes",
          "primary_in_bytes",
          "replica_in_bytes"
        ]
      },
      "cluster.stats:ClusterIngest": {
        "type": "object",
        "properties": {
          "number_of_pipelines": {
            "type": "number"
          },
          "processor_stats": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/cluster.stats:ClusterProcessor"
            }
          }
        },
        "required": [
          "number_of_pipelines",
          "processor_stats"
        ]
      },
      "cluster.stats:ClusterProcessor": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "current": {
            "type": "number"
          },
          "failed": {
            "type": "number"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "count",
          "current",
          "failed",
          "time_in_millis"
        ]
      },
      "cluster.stats:ClusterJvm": {
        "type": "object",
        "properties": {
          "max_uptime_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "mem": {
            "$ref": "#/components/schemas/cluster.stats:ClusterJvmMemory"
          },
          "threads": {
            "description": "Number of active threads in use by JVM across all selected nodes.",
            "type": "number"
          },
          "versions": {
            "description": "Contains statistics about the JVM versions used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterJvmVersion"
            }
          }
        },
        "required": [
          "max_uptime_in_millis",
          "mem",
          "threads",
          "versions"
        ]
      },
      "cluster.stats:ClusterJvmMemory": {
        "type": "object",
        "properties": {
          "heap_max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap across all selected nodes.",
            "type": "number"
          },
          "heap_used_in_bytes": {
            "description": "Memory, in bytes, currently in use by the heap across all selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "heap_max_in_bytes",
          "heap_used_in_bytes"
        ]
      },
      "cluster.stats:ClusterJvmVersion": {
        "type": "object",
        "properties": {
          "bundled_jdk": {
            "description": "Always `true`. All distributions come with a bundled Java Development Kit (JDK).",
            "type": "boolean"
          },
          "count": {
            "description": "Total number of selected nodes using JVM.",
            "type": "number"
          },
          "using_bundled_jdk": {
            "description": "If `true`, a bundled JDK is in use by JVM.",
            "type": "boolean"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "vm_name": {
            "description": "Name of the JVM.",
            "type": "string"
          },
          "vm_vendor": {
            "description": "Vendor of the JVM.",
            "type": "string"
          },
          "vm_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "bundled_jdk",
          "count",
          "using_bundled_jdk",
          "version",
          "vm_name",
          "vm_vendor",
          "vm_version"
        ]
      },
      "cluster.stats:ClusterNetworkTypes": {
        "type": "object",
        "properties": {
          "http_types": {
            "description": "Contains statistics about the HTTP network types used by selected nodes.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "transport_types": {
            "description": "Contains statistics about the transport network types used by selected nodes.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "http_types",
          "transport_types"
        ]
      },
      "cluster.stats:ClusterOperatingSystem": {
        "type": "object",
        "properties": {
          "allocated_processors": {
            "description": "Number of processors used to calculate thread pool size across all selected nodes.\nThis number can be set with the processors setting of a node and defaults to the number of processors reported by the operating system.\nIn both cases, this number will never be larger than 32.",
            "type": "number"
          },
          "architectures": {
            "description": "Contains statistics about processor architectures (for example, x86_64 or aarch64) used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystemArchitecture"
            }
          },
          "available_processors": {
            "description": "Number of processors available to JVM across all selected nodes.",
            "type": "number"
          },
          "mem": {
            "$ref": "#/components/schemas/cluster.stats:OperatingSystemMemoryInfo"
          },
          "names": {
            "description": "Contains statistics about operating systems used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystemName"
            }
          },
          "pretty_names": {
            "description": "Contains statistics about operating systems used by selected nodes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cluster.stats:ClusterOperatingSystemPrettyName"
            }
          }
        },
        "required": [
          "allocated_processors",
          "available_processors",
          "mem",
          "names",
          "pretty_names"
        ]
      },
      "cluster.stats:ClusterOperatingSystemArchitecture": {
        "type": "object",
        "properties": {
          "arch": {
            "description": "Name of an architecture used by one or more selected nodes.",
            "type": "string"
          },
          "count": {
            "description": "Number of selected nodes using the architecture.",
            "type": "number"
          }
        },
        "required": [
          "arch",
          "count"
        ]
      },
      "cluster.stats:OperatingSystemMemoryInfo": {
        "type": "object",
        "properties": {
          "adjusted_total_in_bytes": {
            "description": "Total amount, in bytes, of memory across all selected nodes, but using the value specified using the `es.total_memory_bytes` system property instead of measured total memory for those nodes where that system property was set.",
            "type": "number"
          },
          "free_in_bytes": {
            "description": "Amount, in bytes, of free physical memory across all selected nodes.",
            "type": "number"
          },
          "free_percent": {
            "description": "Percentage of free physical memory across all selected nodes.",
            "type": "number"
          },
          "total_in_bytes": {
            "description": "Total amount, in bytes, of physical memory across all selected nodes.",
            "type": "number"
          },
          "used_in_bytes": {
            "description": "Amount, in bytes, of physical memory in use across all selected nodes.",
            "type": "number"
          },
          "used_percent": {
            "description": "Percentage of physical memory in use across all selected nodes.",
            "type": "number"
          }
        },
        "required": [
          "free_in_bytes",
          "free_percent",
          "total_in_bytes",
          "used_in_bytes",
          "used_percent"
        ]
      },
      "cluster.stats:ClusterOperatingSystemName": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of selected nodes using the operating system.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "count",
          "name"
        ]
      },
      "cluster.stats:ClusterOperatingSystemPrettyName": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of selected nodes using the operating system.",
            "type": "number"
          },
          "pretty_name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "count",
          "pretty_name"
        ]
      },
      "cluster.stats:NodePackagingType": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of selected nodes using the distribution flavor and file type.",
            "type": "number"
          },
          "flavor": {
            "description": "Type of Elasticsearch distribution. This is always `default`.",
            "type": "string"
          },
          "type": {
            "description": "File type (such as `tar` or `zip`) used for the distribution package.",
            "type": "string"
          }
        },
        "required": [
          "count",
          "flavor",
          "type"
        ]
      },
      "_types:PluginStats": {
        "type": "object",
        "properties": {
          "classname": {
            "type": "string"
          },
          "description": {
            "type": "string"
          },
          "elasticsearch_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "extended_plugins": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "has_native_controller": {
            "type": "boolean"
          },
          "java_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "licensed": {
            "type": "boolean"
          }
        },
        "required": [
          "classname",
          "description",
          "elasticsearch_version",
          "extended_plugins",
          "has_native_controller",
          "java_version",
          "name",
          "version",
          "licensed"
        ]
      },
      "cluster.stats:ClusterProcess": {
        "type": "object",
        "properties": {
          "cpu": {
            "$ref": "#/components/schemas/cluster.stats:ClusterProcessCpu"
          },
          "open_file_descriptors": {
            "$ref": "#/components/schemas/cluster.stats:ClusterProcessOpenFileDescriptors"
          }
        },
        "required": [
          "cpu",
          "open_file_descriptors"
        ]
      },
      "cluster.stats:ClusterProcessCpu": {
        "type": "object",
        "properties": {
          "percent": {
            "description": "Percentage of CPU used across all selected nodes.\nReturns `-1` if not supported.",
            "type": "number"
          }
        },
        "required": [
          "percent"
        ]
      },
      "cluster.stats:ClusterProcessOpenFileDescriptors": {
        "type": "object",
        "properties": {
          "avg": {
            "description": "Average number of concurrently open file descriptors.\nReturns `-1` if not supported.",
            "type": "number"
          },
          "max": {
            "description": "Maximum number of concurrently open file descriptors allowed across all selected nodes.\nReturns `-1` if not supported.",
            "type": "number"
          },
          "min": {
            "description": "Minimum number of concurrently open file descriptors across all selected nodes.\nReturns -1 if not supported.",
            "type": "number"
          }
        },
        "required": [
          "avg",
          "max",
          "min"
        ]
      },
      "nodes._types:NodesResponseBase": {
        "type": "object",
        "properties": {
          "_nodes": {
            "$ref": "#/components/schemas/_types:NodeStatistics"
          }
        }
      },
      "_types:NodeStatistics": {
        "type": "object",
        "properties": {
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          },
          "total": {
            "description": "Total number of nodes selected by the request.",
            "type": "number"
          },
          "successful": {
            "description": "Number of nodes that responded successfully to the request.",
            "type": "number"
          },
          "failed": {
            "description": "Number of nodes that rejected the request or failed to respond. If this value is not 0, a reason for the rejection or failure is included in the response.",
            "type": "number"
          }
        },
        "required": [
          "total",
          "successful",
          "failed"
        ]
      },
      "_types:WriteResponseBase": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_primary_term": {
            "type": "number"
          },
          "result": {
            "$ref": "#/components/schemas/_types:Result"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "forced_refresh": {
            "type": "boolean"
          }
        },
        "required": [
          "_id",
          "_index",
          "_primary_term",
          "result",
          "_seq_no",
          "_shards",
          "_version"
        ]
      },
      "_types:Result": {
        "type": "string",
        "enum": [
          "created",
          "updated",
          "deleted",
          "not_found",
          "noop"
        ]
      },
      "_types:Conflicts": {
        "type": "string",
        "enum": [
          "abort",
          "proceed"
        ]
      },
      "_types:Slices": {
        "description": "Slices configuration used to parallelize a process.",
        "oneOf": [
          {
            "type": "number"
          },
          {
            "$ref": "#/components/schemas/_types:SlicesCalculation"
          }
        ]
      },
      "_types:SlicesCalculation": {
        "type": "string",
        "enum": [
          "auto"
        ]
      },
      "_types:BulkIndexByScrollFailure": {
        "type": "object",
        "properties": {
          "cause": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "status": {
            "type": "number"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "cause",
          "id",
          "index",
          "status",
          "type"
        ]
      },
      "_types:Retries": {
        "type": "object",
        "properties": {
          "bulk": {
            "type": "number"
          },
          "search": {
            "type": "number"
          }
        },
        "required": [
          "bulk",
          "search"
        ]
      },
      "_types:TaskId": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          }
        ]
      },
      "enrich.execute_policy:ExecuteEnrichPolicyStatus": {
        "type": "object",
        "properties": {
          "phase": {
            "$ref": "#/components/schemas/enrich.execute_policy:EnrichPolicyPhase"
          }
        },
        "required": [
          "phase"
        ]
      },
      "enrich.execute_policy:EnrichPolicyPhase": {
        "type": "string",
        "enum": [
          "SCHEDULED",
          "RUNNING",
          "COMPLETE",
          "FAILED"
        ]
      },
      "enrich._types:Summary": {
        "type": "object",
        "properties": {
          "config": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/enrich._types:Policy"
            },
            "minProperties": 1,
            "maxProperties": 1
          }
        },
        "required": [
          "config"
        ]
      },
      "enrich._types:Policy": {
        "type": "object",
        "properties": {
          "enrich_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "match_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "query": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "elasticsearch_version": {
            "type": "string"
          }
        },
        "required": [
          "enrich_fields",
          "indices",
          "match_field"
        ]
      },
      "enrich.stats:CoordinatorStats": {
        "type": "object",
        "properties": {
          "executed_searches_total": {
            "type": "number"
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "queue_size": {
            "type": "number"
          },
          "remote_requests_current": {
            "type": "number"
          },
          "remote_requests_total": {
            "type": "number"
          }
        },
        "required": [
          "executed_searches_total",
          "node_id",
          "queue_size",
          "remote_requests_current",
          "remote_requests_total"
        ]
      },
      "enrich.stats:ExecutingPolicy": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "task": {
            "$ref": "#/components/schemas/tasks._types:TaskInfo"
          }
        },
        "required": [
          "name",
          "task"
        ]
      },
      "tasks._types:TaskInfo": {
        "type": "object",
        "properties": {
          "action": {
            "type": "string"
          },
          "cancelled": {
            "type": "boolean"
          },
          "cancellable": {
            "type": "boolean"
          },
          "description": {
            "type": "string"
          },
          "headers": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "id": {
            "type": "number"
          },
          "node": {
            "$ref": "#/components/schemas/_types:NodeId"
          },
          "running_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "running_time_in_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "status": {
            "description": "Task status information can vary wildly from task to task.",
            "type": "object"
          },
          "type": {
            "type": "string"
          },
          "parent_task_id": {
            "$ref": "#/components/schemas/_types:TaskId"
          }
        },
        "required": [
          "action",
          "cancellable",
          "headers",
          "id",
          "node",
          "running_time_in_nanos",
          "start_time_in_millis",
          "type"
        ]
      },
      "enrich.stats:CacheStats": {
        "type": "object",
        "properties": {
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "count": {
            "type": "number"
          },
          "hits": {
            "type": "number"
          },
          "misses": {
            "type": "number"
          },
          "evictions": {
            "type": "number"
          }
        },
        "required": [
          "node_id",
          "count",
          "hits",
          "misses",
          "evictions"
        ]
      },
      "_global.field_caps:FieldCapability": {
        "type": "object",
        "properties": {
          "aggregatable": {
            "description": "Whether this field can be aggregated on all indices.",
            "type": "boolean"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "non_aggregatable_indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "non_searchable_indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "searchable": {
            "description": "Whether this field is indexed for search on all indices.",
            "type": "boolean"
          },
          "type": {
            "type": "string"
          },
          "metadata_field": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/mapping-fields.html"
            },
            "description": "Whether this field is registered as a metadata field.",
            "type": "boolean"
          },
          "time_series_dimension": {
            "description": "Whether this field is used as a time series dimension.",
            "type": "boolean"
          },
          "time_series_metric": {
            "$ref": "#/components/schemas/_types.mapping:TimeSeriesMetricType"
          },
          "non_dimension_indices": {
            "description": "If this list is present in response then some indices have the\nfield marked as a dimension and other indices, the ones in this list, do not.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "metric_conflicts_indices": {
            "description": "The list of indices where this field is present if these indices\ndont have the same `time_series_metric` value for this field.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          }
        },
        "required": [
          "aggregatable",
          "searchable",
          "type"
        ]
      },
      "_types:IndexAlias": {
        "type": "string"
      },
      "fleet._types:Checkpoint": {
        "type": "number"
      },
      "_global.msearch:RequestItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.msearch:MultisearchHeader"
          },
          {
            "$ref": "#/components/schemas/_global.msearch:MultisearchBody"
          }
        ]
      },
      "_global.msearch:MultisearchHeader": {
        "type": "object",
        "properties": {
          "allow_no_indices": {
            "type": "boolean"
          },
          "expand_wildcards": {
            "$ref": "#/components/schemas/_types:ExpandWildcards"
          },
          "ignore_unavailable": {
            "type": "boolean"
          },
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "preference": {
            "type": "string"
          },
          "request_cache": {
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "search_type": {
            "$ref": "#/components/schemas/_types:SearchType"
          },
          "ccs_minimize_roundtrips": {
            "type": "boolean"
          },
          "allow_partial_search_results": {
            "type": "boolean"
          },
          "ignore_throttled": {
            "type": "boolean"
          }
        }
      },
      "_global.msearch:MultisearchBody": {
        "type": "object",
        "properties": {
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "collapse": {
            "$ref": "#/components/schemas/_global.search._types:FieldCollapse"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "explain": {
            "description": "If true, returns detailed information about score computation as part of a hit.",
            "type": "boolean"
          },
          "ext": {
            "description": "Configuration of search extensions defined by Elasticsearch plugins.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "stored_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "docvalue_fields": {
            "description": "Array of wildcard (*) patterns. The request returns doc values for field\nnames matching these patterns in the hits.fields property of the response.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
            }
          },
          "knn": {
            "description": "Defines the approximate kNN search to run.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:KnnQuery"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:KnnQuery"
                }
              }
            ]
          },
          "from": {
            "description": "Starting document offset. By default, you cannot page through more than 10,000\nhits using the from and size parameters. To page through more hits, use the\nsearch_after parameter.",
            "type": "number"
          },
          "highlight": {
            "$ref": "#/components/schemas/_global.search._types:Highlight"
          },
          "indices_boost": {
            "description": "Boosts the _score of documents from specified indices.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "type": "number"
              }
            }
          },
          "min_score": {
            "description": "Minimum _score for matching documents. Documents with a lower _score are\nnot included in the search results.",
            "type": "number"
          },
          "post_filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "profile": {
            "type": "boolean"
          },
          "rescore": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_global.search._types:Rescore"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_global.search._types:Rescore"
                }
              }
            ]
          },
          "script_fields": {
            "description": "Retrieve a script evaluation (based on different fields) for each hit.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "search_after": {
            "$ref": "#/components/schemas/_types:SortResults"
          },
          "size": {
            "description": "The number of hits to return. By default, you cannot page through more\nthan 10,000 hits using the from and size parameters. To page through more\nhits, use the search_after parameter.",
            "type": "number"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:Sort"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "fields": {
            "description": "Array of wildcard (*) patterns. The request returns values for field names\nmatching these patterns in the hits.fields property of the response.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:FieldAndFormat"
            }
          },
          "terminate_after": {
            "description": "Maximum number of documents to collect for each shard. If a query reaches this\nlimit, Elasticsearch terminates the query early. Elasticsearch collects documents\nbefore sorting. Defaults to 0, which does not terminate query execution early.",
            "type": "number"
          },
          "stats": {
            "description": "Stats groups to associate with the search. Each group maintains a statistics\naggregation for its associated searches. You can retrieve these stats using\nthe indices stats API.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "timeout": {
            "description": "Specifies the period of time to wait for a response from each shard. If no response\nis received before the timeout expires, the request fails and returns an error.\nDefaults to no timeout.",
            "type": "string"
          },
          "track_scores": {
            "description": "If true, calculate and return document scores, even if the scores are not used for sorting.",
            "type": "boolean"
          },
          "track_total_hits": {
            "$ref": "#/components/schemas/_global.search._types:TrackHits"
          },
          "version": {
            "description": "If true, returns document version as part of a hit.",
            "type": "boolean"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "seq_no_primary_term": {
            "description": "If true, returns sequence number and primary term of the last modification\nof each hit. See Optimistic concurrency control.",
            "type": "boolean"
          },
          "pit": {
            "$ref": "#/components/schemas/_global.search._types:PointInTimeReference"
          },
          "suggest": {
            "$ref": "#/components/schemas/_global.search._types:Suggester"
          }
        }
      },
      "_global.msearch:ResponseItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.msearch:MultiSearchItem"
          },
          {
            "$ref": "#/components/schemas/_types:ErrorResponseBase"
          }
        ]
      },
      "_global.msearch:MultiSearchItem": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.search:ResponseBody"
          },
          {
            "type": "object",
            "properties": {
              "status": {
                "type": "number"
              }
            }
          }
        ]
      },
      "_global.search:ResponseBody": {
        "type": "object",
        "properties": {
          "took": {
            "type": "number"
          },
          "timed_out": {
            "type": "boolean"
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          },
          "hits": {
            "$ref": "#/components/schemas/_global.search._types:HitsMetadata"
          },
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:Aggregate"
            }
          },
          "_clusters": {
            "$ref": "#/components/schemas/_types:ClusterStatistics"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "max_score": {
            "type": "number"
          },
          "num_reduce_phases": {
            "type": "number"
          },
          "profile": {
            "$ref": "#/components/schemas/_global.search._types:Profile"
          },
          "pit_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_scroll_id": {
            "$ref": "#/components/schemas/_types:ScrollId"
          },
          "suggest": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/_global.search._types:Suggest"
              }
            }
          },
          "terminated_early": {
            "type": "boolean"
          }
        },
        "required": [
          "took",
          "timed_out",
          "_shards",
          "hits"
        ]
      },
      "_types:ErrorResponseBase": {
        "type": "object",
        "properties": {
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "status": {
            "type": "number"
          }
        },
        "required": [
          "error",
          "status"
        ]
      },
      "_global.get:GetResult": {
        "type": "object",
        "properties": {
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "found": {
            "type": "boolean"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_primary_term": {
            "type": "number"
          },
          "_routing": {
            "type": "string"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_source": {
            "type": "object"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "_index",
          "found",
          "_id"
        ]
      },
      "_types:StoredScript": {
        "type": "object",
        "properties": {
          "lang": {
            "$ref": "#/components/schemas/_types:ScriptLanguage"
          },
          "options": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "source": {
            "description": "The script source.",
            "type": "string"
          }
        },
        "required": [
          "lang",
          "source"
        ]
      },
      "graph._types:Hop": {
        "type": "object",
        "properties": {
          "connections": {
            "$ref": "#/components/schemas/graph._types:Hop"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "vertices": {
            "description": "Contains the fields you are interested in.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/graph._types:VertexDefinition"
            }
          }
        },
        "required": [
          "query",
          "vertices"
        ]
      },
      "graph._types:VertexDefinition": {
        "type": "object",
        "properties": {
          "exclude": {
            "description": "Prevents the specified terms from being included in the results.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "include": {
            "description": "Identifies the terms of interest that form the starting points from which you want to spider out.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/graph._types:VertexInclude"
            }
          },
          "min_doc_count": {
            "description": "Specifies how many documents must contain a pair of terms before it is considered to be a useful connection.\nThis setting acts as a certainty threshold.",
            "type": "number"
          },
          "shard_min_doc_count": {
            "description": "Controls how many documents on a particular shard have to contain a pair of terms before the connection is returned for global consideration.",
            "type": "number"
          },
          "size": {
            "description": "Specifies the maximum number of vertex terms returned for each field.",
            "type": "number"
          }
        },
        "required": [
          "field"
        ]
      },
      "graph._types:VertexInclude": {
        "type": "object",
        "properties": {
          "boost": {
            "type": "number"
          },
          "term": {
            "type": "string"
          }
        },
        "required": [
          "boost",
          "term"
        ]
      },
      "graph._types:ExploreControls": {
        "type": "object",
        "properties": {
          "sample_diversity": {
            "$ref": "#/components/schemas/graph._types:SampleDiversity"
          },
          "sample_size": {
            "description": "Each hop considers a sample of the best-matching documents on each shard.\nUsing samples improves the speed of execution and keeps exploration focused on meaningfully-connected terms.\nVery small values (less than 50) might not provide sufficient weight-of-evidence to identify significant connections between terms.\nVery large sample sizes can dilute the quality of the results and increase execution times.",
            "type": "number"
          },
          "timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "use_significance": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/search-aggregations-bucket-significantterms-aggregation.html"
            },
            "description": "Filters associated terms so only those that are significantly associated with your query are included.",
            "type": "boolean"
          }
        },
        "required": [
          "use_significance"
        ]
      },
      "graph._types:SampleDiversity": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "max_docs_per_value": {
            "type": "number"
          }
        },
        "required": [
          "field",
          "max_docs_per_value"
        ]
      },
      "graph._types:Connection": {
        "type": "object",
        "properties": {
          "doc_count": {
            "type": "number"
          },
          "source": {
            "type": "number"
          },
          "target": {
            "type": "number"
          },
          "weight": {
            "type": "number"
          }
        },
        "required": [
          "doc_count",
          "source",
          "target",
          "weight"
        ]
      },
      "graph._types:Vertex": {
        "type": "object",
        "properties": {
          "depth": {
            "type": "number"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "term": {
            "type": "string"
          },
          "weight": {
            "type": "number"
          }
        },
        "required": [
          "depth",
          "field",
          "term",
          "weight"
        ]
      },
      "_types:OpType": {
        "type": "string",
        "enum": [
          "index",
          "create"
        ]
      },
      "indices.analyze:TextToAnalyze": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        ]
      },
      "indices.analyze:AnalyzeDetail": {
        "type": "object",
        "properties": {
          "analyzer": {
            "$ref": "#/components/schemas/indices.analyze:AnalyzerDetail"
          },
          "charfilters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:CharFilterDetail"
            }
          },
          "custom_analyzer": {
            "type": "boolean"
          },
          "tokenfilters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:TokenDetail"
            }
          },
          "tokenizer": {
            "$ref": "#/components/schemas/indices.analyze:TokenDetail"
          }
        },
        "required": [
          "custom_analyzer"
        ]
      },
      "indices.analyze:AnalyzerDetail": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:ExplainAnalyzeToken"
            }
          }
        },
        "required": [
          "name",
          "tokens"
        ]
      },
      "indices.analyze:ExplainAnalyzeToken": {
        "type": "object",
        "properties": {
          "bytes": {
            "type": "string"
          },
          "end_offset": {
            "type": "number"
          },
          "keyword": {
            "type": "boolean"
          },
          "position": {
            "type": "number"
          },
          "positionLength": {
            "type": "number"
          },
          "start_offset": {
            "type": "number"
          },
          "termFrequency": {
            "type": "number"
          },
          "token": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "bytes",
          "end_offset",
          "position",
          "positionLength",
          "start_offset",
          "termFrequency",
          "token",
          "type"
        ]
      },
      "indices.analyze:CharFilterDetail": {
        "type": "object",
        "properties": {
          "filtered_text": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "type": "string"
          }
        },
        "required": [
          "filtered_text",
          "name"
        ]
      },
      "indices.analyze:TokenDetail": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.analyze:ExplainAnalyzeToken"
            }
          }
        },
        "required": [
          "name",
          "tokens"
        ]
      },
      "indices.analyze:AnalyzeToken": {
        "type": "object",
        "properties": {
          "end_offset": {
            "type": "number"
          },
          "position": {
            "type": "number"
          },
          "positionLength": {
            "type": "number"
          },
          "start_offset": {
            "type": "number"
          },
          "token": {
            "type": "string"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "end_offset",
          "position",
          "start_offset",
          "token",
          "type"
        ]
      },
      "indices.close:CloseIndexResult": {
        "type": "object",
        "properties": {
          "closed": {
            "type": "boolean"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices.close:CloseShardResult"
            }
          }
        },
        "required": [
          "closed"
        ]
      },
      "indices.close:CloseShardResult": {
        "type": "object",
        "properties": {
          "failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:ShardFailure"
            }
          }
        },
        "required": [
          "failures"
        ]
      },
      "indices.data_streams_stats:DataStreamsStatsItem": {
        "type": "object",
        "properties": {
          "backing_indices": {
            "description": "Current number of backing indices for the data stream.",
            "type": "number"
          },
          "data_stream": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "maximum_timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "store_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "store_size_bytes": {
            "description": "Total size, in bytes, of all shards for the data streams backing indices.",
            "type": "number"
          }
        },
        "required": [
          "backing_indices",
          "data_stream",
          "maximum_timestamp",
          "store_size_bytes"
        ]
      },
      "_types:IndicesResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "_shards": {
                "$ref": "#/components/schemas/_types:ShardStatistics"
              }
            }
          }
        ]
      },
      "_types:DataStreamNames": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:DataStreamName"
            }
          }
        ]
      },
      "indices.explain_data_lifecycle:DataStreamLifecycleExplain": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "managed_by_lifecycle": {
            "type": "boolean"
          },
          "index_creation_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time_since_index_creation": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "rollover_date_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time_since_rollover": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          },
          "generation_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "error": {
            "type": "string"
          }
        },
        "required": [
          "index",
          "managed_by_lifecycle"
        ]
      },
      "indices.get:Features": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/indices.get:Feature"
          },
          {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.get:Feature"
            }
          }
        ]
      },
      "indices.get:Feature": {
        "type": "string",
        "enum": [
          "aliases",
          "mappings",
          "settings"
        ]
      },
      "indices.get_alias:IndexAliases": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:AliasDefinition"
            }
          }
        },
        "required": [
          "aliases"
        ]
      },
      "indices.get_data_lifecycle:DataStreamWithLifecycle": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycle"
          }
        },
        "required": [
          "name"
        ]
      },
      "indices._types:DataStream": {
        "type": "object",
        "properties": {
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "allow_custom_routing": {
            "description": "If `true`, the data stream allows custom routing on write request.",
            "type": "boolean"
          },
          "generation": {
            "description": "Current generation for the data stream. This number acts as a cumulative count of the streams rollovers, starting at 1.",
            "type": "number"
          },
          "hidden": {
            "description": "If `true`, the data stream is hidden.",
            "type": "boolean"
          },
          "ilm_policy": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "description": "Array of objects containing information about the data streams backing indices.\nThe last item in this array contains information about the streams current write index.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices._types:DataStreamIndex"
            }
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          },
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "replicated": {
            "description": "If `true`, the data stream is created and managed by cross-cluster replication and the local cluster can not write into this data stream or change its mappings.",
            "type": "boolean"
          },
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "system": {
            "description": "If `true`, the data stream is created and managed by an Elastic stack component and cannot be modified through normal user interaction.",
            "type": "boolean"
          },
          "template": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "timestamp_field": {
            "$ref": "#/components/schemas/indices._types:DataStreamTimestampField"
          }
        },
        "required": [
          "generation",
          "hidden",
          "indices",
          "name",
          "status",
          "template",
          "timestamp_field"
        ]
      },
      "indices._types:DataStreamIndex": {
        "type": "object",
        "properties": {
          "index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "index_uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          }
        },
        "required": [
          "index_name",
          "index_uuid"
        ]
      },
      "indices._types:DataStreamTimestampField": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "name"
        ]
      },
      "indices.get_index_template:IndexTemplateItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "index_template": {
            "$ref": "#/components/schemas/indices._types:IndexTemplate"
          }
        },
        "required": [
          "name",
          "index_template"
        ]
      },
      "indices._types:IndexTemplate": {
        "type": "object",
        "properties": {
          "index_patterns": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "composed_of": {
            "description": "An ordered list of component template names.\nComponent templates are merged in the order specified, meaning that the last component template specified has the highest precedence.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          },
          "template": {
            "$ref": "#/components/schemas/indices._types:IndexTemplateSummary"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "priority": {
            "description": "Priority to determine index template precedence when a new data stream or index is created.\nThe index template with the highest priority is chosen.\nIf no priority is specified the template is treated as though it is of priority 0 (lowest priority).\nThis number is not automatically generated by Elasticsearch.",
            "type": "number"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "allow_auto_create": {
            "type": "boolean"
          },
          "data_stream": {
            "$ref": "#/components/schemas/indices._types:IndexTemplateDataStreamConfiguration"
          }
        },
        "required": [
          "index_patterns",
          "composed_of"
        ]
      },
      "indices._types:IndexTemplateSummary": {
        "type": "object",
        "properties": {
          "aliases": {
            "description": "Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycleWithRollover"
          }
        }
      },
      "indices._types:IndexTemplateDataStreamConfiguration": {
        "type": "object",
        "properties": {
          "hidden": {
            "description": "If true, the data stream is hidden.",
            "type": "boolean"
          },
          "allow_custom_routing": {
            "description": "If true, the data stream supports custom routing.",
            "type": "boolean"
          }
        }
      },
      "indices.get_mapping:IndexMappingRecord": {
        "type": "object",
        "properties": {
          "item": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          }
        },
        "required": [
          "mappings"
        ]
      },
      "indices._types:TemplateMapping": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "index_patterns": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Name"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "order": {
            "type": "number"
          },
          "settings": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        },
        "required": [
          "aliases",
          "index_patterns",
          "mappings",
          "order",
          "settings"
        ]
      },
      "indices.modify_data_stream:Action": {
        "type": "object",
        "properties": {
          "add_backing_index": {
            "$ref": "#/components/schemas/indices.modify_data_stream:IndexAndDataStreamAction"
          },
          "remove_backing_index": {
            "$ref": "#/components/schemas/indices.modify_data_stream:IndexAndDataStreamAction"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "indices.modify_data_stream:IndexAndDataStreamAction": {
        "type": "object",
        "properties": {
          "data_stream": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "data_stream",
          "index"
        ]
      },
      "indices.put_index_template:IndexTemplateMapping": {
        "type": "object",
        "properties": {
          "aliases": {
            "description": "Aliases to add.\nIf the index template includes a `data_stream` object, these are data stream aliases.\nOtherwise, these are index aliases.\nData stream aliases ignore the `index_routing`, `routing`, and `search_routing` options.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          },
          "lifecycle": {
            "$ref": "#/components/schemas/indices._types:DataStreamLifecycle"
          }
        }
      },
      "indices._types:DataStreamVisibility": {
        "type": "object",
        "properties": {
          "hidden": {
            "type": "boolean"
          }
        }
      },
      "indices.recovery:RecoveryStatus": {
        "type": "object",
        "properties": {
          "shards": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.recovery:ShardRecovery"
            }
          }
        },
        "required": [
          "shards"
        ]
      },
      "indices.recovery:ShardRecovery": {
        "type": "object",
        "properties": {
          "id": {
            "type": "number"
          },
          "index": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryIndexStatus"
          },
          "primary": {
            "type": "boolean"
          },
          "source": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryOrigin"
          },
          "stage": {
            "type": "string"
          },
          "start": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryStartStatus"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "stop_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "stop_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "target": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryOrigin"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "translog": {
            "$ref": "#/components/schemas/indices.recovery:TranslogStatus"
          },
          "type": {
            "type": "string"
          },
          "verify_index": {
            "$ref": "#/components/schemas/indices.recovery:VerifyIndex"
          }
        },
        "required": [
          "id",
          "index",
          "primary",
          "source",
          "stage",
          "start_time_in_millis",
          "target",
          "total_time_in_millis",
          "translog",
          "type",
          "verify_index"
        ]
      },
      "indices.recovery:RecoveryIndexStatus": {
        "type": "object",
        "properties": {
          "bytes": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryBytes"
          },
          "files": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryFiles"
          },
          "size": {
            "$ref": "#/components/schemas/indices.recovery:RecoveryBytes"
          },
          "source_throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "source_throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "target_throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "target_throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "files",
          "size",
          "source_throttle_time_in_millis",
          "target_throttle_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "indices.recovery:RecoveryBytes": {
        "type": "object",
        "properties": {
          "percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "recovered": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "recovered_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "recovered_from_snapshot": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "recovered_from_snapshot_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "reused": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "reused_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          }
        },
        "required": [
          "percent",
          "recovered_in_bytes",
          "reused_in_bytes",
          "total_in_bytes"
        ]
      },
      "indices.recovery:RecoveryFiles": {
        "type": "object",
        "properties": {
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.recovery:FileDetails"
            }
          },
          "percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "recovered": {
            "type": "number"
          },
          "reused": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "percent",
          "recovered",
          "reused",
          "total"
        ]
      },
      "indices.recovery:FileDetails": {
        "type": "object",
        "properties": {
          "length": {
            "type": "number"
          },
          "name": {
            "type": "string"
          },
          "recovered": {
            "type": "number"
          }
        },
        "required": [
          "length",
          "name",
          "recovered"
        ]
      },
      "indices.recovery:RecoveryOrigin": {
        "type": "object",
        "properties": {
          "hostname": {
            "type": "string"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "ip": {
            "$ref": "#/components/schemas/_types:Ip"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "bootstrap_new_history_uuid": {
            "type": "boolean"
          },
          "repository": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "snapshot": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "restoreUUID": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        }
      },
      "indices.recovery:RecoveryStartStatus": {
        "type": "object",
        "properties": {
          "check_index_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "check_index_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "check_index_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "indices.recovery:TranslogStatus": {
        "type": "object",
        "properties": {
          "percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          },
          "recovered": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_on_start": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "percent",
          "recovered",
          "total",
          "total_on_start",
          "total_time_in_millis"
        ]
      },
      "indices.recovery:VerifyIndex": {
        "type": "object",
        "properties": {
          "check_index_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "check_index_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "check_index_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "indices.resolve_index:ResolveIndexItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "aliases": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "attributes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "data_stream": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          }
        },
        "required": [
          "name",
          "attributes"
        ]
      },
      "indices.resolve_index:ResolveIndexAliasItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          }
        },
        "required": [
          "name",
          "indices"
        ]
      },
      "indices.resolve_index:ResolveIndexDataStreamsItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:DataStreamName"
          },
          "timestamp_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "backing_indices": {
            "$ref": "#/components/schemas/_types:Indices"
          }
        },
        "required": [
          "name",
          "timestamp_field",
          "backing_indices"
        ]
      },
      "indices.rollover:RolloverConditions": {
        "type": "object",
        "properties": {
          "min_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_age": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max_age_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "min_docs": {
            "type": "number"
          },
          "max_docs": {
            "type": "number"
          },
          "max_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_size_bytes": {
            "type": "number"
          },
          "min_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_size_bytes": {
            "type": "number"
          },
          "max_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_primary_shard_size_bytes": {
            "type": "number"
          },
          "min_primary_shard_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "min_primary_shard_size_bytes": {
            "type": "number"
          },
          "max_primary_shard_docs": {
            "type": "number"
          },
          "min_primary_shard_docs": {
            "type": "number"
          }
        }
      },
      "indices.simulate_template:Overlapping": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "index_patterns": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "name",
          "index_patterns"
        ]
      },
      "indices.simulate_template:Template": {
        "type": "object",
        "properties": {
          "aliases": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/indices._types:Alias"
            }
          },
          "mappings": {
            "$ref": "#/components/schemas/_types.mapping:TypeMapping"
          },
          "settings": {
            "$ref": "#/components/schemas/indices._types:IndexSettings"
          }
        },
        "required": [
          "aliases",
          "mappings",
          "settings"
        ]
      },
      "indices.stats:IndicesStats": {
        "type": "object",
        "properties": {
          "primaries": {
            "$ref": "#/components/schemas/indices.stats:IndexStats"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "type": "array",
              "items": {
                "$ref": "#/components/schemas/indices.stats:ShardStats"
              }
            }
          },
          "total": {
            "$ref": "#/components/schemas/indices.stats:IndexStats"
          },
          "uuid": {
            "$ref": "#/components/schemas/_types:Uuid"
          },
          "health": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          },
          "status": {
            "$ref": "#/components/schemas/indices.stats:IndexMetadataState"
          }
        }
      },
      "indices.stats:IndexStats": {
        "type": "object",
        "properties": {
          "completion": {
            "$ref": "#/components/schemas/_types:CompletionStats"
          },
          "docs": {
            "$ref": "#/components/schemas/_types:DocStats"
          },
          "fielddata": {
            "$ref": "#/components/schemas/_types:FielddataStats"
          },
          "flush": {
            "$ref": "#/components/schemas/_types:FlushStats"
          },
          "get": {
            "$ref": "#/components/schemas/_types:GetStats"
          },
          "indexing": {
            "$ref": "#/components/schemas/_types:IndexingStats"
          },
          "indices": {
            "$ref": "#/components/schemas/indices.stats:IndicesStats"
          },
          "merges": {
            "$ref": "#/components/schemas/_types:MergesStats"
          },
          "query_cache": {
            "$ref": "#/components/schemas/_types:QueryCacheStats"
          },
          "recovery": {
            "$ref": "#/components/schemas/_types:RecoveryStats"
          },
          "refresh": {
            "$ref": "#/components/schemas/_types:RefreshStats"
          },
          "request_cache": {
            "$ref": "#/components/schemas/_types:RequestCacheStats"
          },
          "search": {
            "$ref": "#/components/schemas/_types:SearchStats"
          },
          "segments": {
            "$ref": "#/components/schemas/_types:SegmentsStats"
          },
          "store": {
            "$ref": "#/components/schemas/_types:StoreStats"
          },
          "translog": {
            "$ref": "#/components/schemas/_types:TranslogStats"
          },
          "warmer": {
            "$ref": "#/components/schemas/_types:WarmerStats"
          },
          "bulk": {
            "$ref": "#/components/schemas/_types:BulkStats"
          },
          "shard_stats": {
            "$ref": "#/components/schemas/indices.stats:ShardsTotalStats"
          }
        }
      },
      "_types:FlushStats": {
        "type": "object",
        "properties": {
          "periodic": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "periodic",
          "total",
          "total_time_in_millis"
        ]
      },
      "_types:GetStats": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number"
          },
          "exists_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "exists_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "exists_total": {
            "type": "number"
          },
          "missing_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "missing_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "missing_total": {
            "type": "number"
          },
          "time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "current",
          "exists_time_in_millis",
          "exists_total",
          "missing_time_in_millis",
          "missing_total",
          "time_in_millis",
          "total"
        ]
      },
      "_types:IndexingStats": {
        "type": "object",
        "properties": {
          "index_current": {
            "type": "number"
          },
          "delete_current": {
            "type": "number"
          },
          "delete_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "delete_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "delete_total": {
            "type": "number"
          },
          "is_throttled": {
            "type": "boolean"
          },
          "noop_update_total": {
            "type": "number"
          },
          "throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "index_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_total": {
            "type": "number"
          },
          "index_failed": {
            "type": "number"
          },
          "types": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:IndexingStats"
            }
          },
          "write_load": {
            "type": "number"
          }
        },
        "required": [
          "index_current",
          "delete_current",
          "delete_time_in_millis",
          "delete_total",
          "is_throttled",
          "noop_update_total",
          "throttle_time_in_millis",
          "index_time_in_millis",
          "index_total",
          "index_failed"
        ]
      },
      "_types:MergesStats": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number"
          },
          "current_docs": {
            "type": "number"
          },
          "current_size": {
            "type": "string"
          },
          "current_size_in_bytes": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_auto_throttle": {
            "type": "string"
          },
          "total_auto_throttle_in_bytes": {
            "type": "number"
          },
          "total_docs": {
            "type": "number"
          },
          "total_size": {
            "type": "string"
          },
          "total_size_in_bytes": {
            "type": "number"
          },
          "total_stopped_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_stopped_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_throttled_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_throttled_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "current",
          "current_docs",
          "current_size_in_bytes",
          "total",
          "total_auto_throttle_in_bytes",
          "total_docs",
          "total_size_in_bytes",
          "total_stopped_time_in_millis",
          "total_throttled_time_in_millis",
          "total_time_in_millis"
        ]
      },
      "_types:RecoveryStats": {
        "type": "object",
        "properties": {
          "current_as_source": {
            "type": "number"
          },
          "current_as_target": {
            "type": "number"
          },
          "throttle_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "throttle_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "current_as_source",
          "current_as_target",
          "throttle_time_in_millis"
        ]
      },
      "_types:RefreshStats": {
        "type": "object",
        "properties": {
          "external_total": {
            "type": "number"
          },
          "external_total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "listeners": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "external_total",
          "external_total_time_in_millis",
          "listeners",
          "total",
          "total_time_in_millis"
        ]
      },
      "_types:RequestCacheStats": {
        "type": "object",
        "properties": {
          "evictions": {
            "type": "number"
          },
          "hit_count": {
            "type": "number"
          },
          "memory_size": {
            "type": "string"
          },
          "memory_size_in_bytes": {
            "type": "number"
          },
          "miss_count": {
            "type": "number"
          }
        },
        "required": [
          "evictions",
          "hit_count",
          "memory_size_in_bytes",
          "miss_count"
        ]
      },
      "_types:SearchStats": {
        "type": "object",
        "properties": {
          "fetch_current": {
            "type": "number"
          },
          "fetch_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "fetch_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "fetch_total": {
            "type": "number"
          },
          "open_contexts": {
            "type": "number"
          },
          "query_current": {
            "type": "number"
          },
          "query_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "query_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "query_total": {
            "type": "number"
          },
          "scroll_current": {
            "type": "number"
          },
          "scroll_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "scroll_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "scroll_total": {
            "type": "number"
          },
          "suggest_current": {
            "type": "number"
          },
          "suggest_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "suggest_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "suggest_total": {
            "type": "number"
          },
          "groups": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:SearchStats"
            }
          }
        },
        "required": [
          "fetch_current",
          "fetch_time_in_millis",
          "fetch_total",
          "query_current",
          "query_time_in_millis",
          "query_total",
          "scroll_current",
          "scroll_time_in_millis",
          "scroll_total",
          "suggest_current",
          "suggest_time_in_millis",
          "suggest_total"
        ]
      },
      "_types:TranslogStats": {
        "type": "object",
        "properties": {
          "earliest_last_modified_age": {
            "type": "number"
          },
          "operations": {
            "type": "number"
          },
          "size": {
            "type": "string"
          },
          "size_in_bytes": {
            "type": "number"
          },
          "uncommitted_operations": {
            "type": "number"
          },
          "uncommitted_size": {
            "type": "string"
          },
          "uncommitted_size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "earliest_last_modified_age",
          "operations",
          "size_in_bytes",
          "uncommitted_operations",
          "uncommitted_size_in_bytes"
        ]
      },
      "_types:WarmerStats": {
        "type": "object",
        "properties": {
          "current": {
            "type": "number"
          },
          "total": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "current",
          "total",
          "total_time_in_millis"
        ]
      },
      "_types:BulkStats": {
        "type": "object",
        "properties": {
          "total_operations": {
            "type": "number"
          },
          "total_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_size_in_bytes": {
            "type": "number"
          },
          "avg_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "avg_time_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "avg_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "avg_size_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "total_operations",
          "total_time_in_millis",
          "total_size_in_bytes",
          "avg_time_in_millis",
          "avg_size_in_bytes"
        ]
      },
      "indices.stats:ShardsTotalStats": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "number"
          }
        },
        "required": [
          "total_count"
        ]
      },
      "indices.stats:ShardStats": {
        "type": "object",
        "properties": {
          "commit": {
            "$ref": "#/components/schemas/indices.stats:ShardCommit"
          },
          "completion": {
            "$ref": "#/components/schemas/_types:CompletionStats"
          },
          "docs": {
            "$ref": "#/components/schemas/_types:DocStats"
          },
          "fielddata": {
            "$ref": "#/components/schemas/_types:FielddataStats"
          },
          "flush": {
            "$ref": "#/components/schemas/_types:FlushStats"
          },
          "get": {
            "$ref": "#/components/schemas/_types:GetStats"
          },
          "indexing": {
            "$ref": "#/components/schemas/_types:IndexingStats"
          },
          "mappings": {
            "$ref": "#/components/schemas/indices.stats:MappingStats"
          },
          "merges": {
            "$ref": "#/components/schemas/_types:MergesStats"
          },
          "shard_path": {
            "$ref": "#/components/schemas/indices.stats:ShardPath"
          },
          "query_cache": {
            "$ref": "#/components/schemas/indices.stats:ShardQueryCache"
          },
          "recovery": {
            "$ref": "#/components/schemas/_types:RecoveryStats"
          },
          "refresh": {
            "$ref": "#/components/schemas/_types:RefreshStats"
          },
          "request_cache": {
            "$ref": "#/components/schemas/_types:RequestCacheStats"
          },
          "retention_leases": {
            "$ref": "#/components/schemas/indices.stats:ShardRetentionLeases"
          },
          "routing": {
            "$ref": "#/components/schemas/indices.stats:ShardRouting"
          },
          "search": {
            "$ref": "#/components/schemas/_types:SearchStats"
          },
          "segments": {
            "$ref": "#/components/schemas/_types:SegmentsStats"
          },
          "seq_no": {
            "$ref": "#/components/schemas/indices.stats:ShardSequenceNumber"
          },
          "store": {
            "$ref": "#/components/schemas/_types:StoreStats"
          },
          "translog": {
            "$ref": "#/components/schemas/_types:TranslogStats"
          },
          "warmer": {
            "$ref": "#/components/schemas/_types:WarmerStats"
          },
          "bulk": {
            "$ref": "#/components/schemas/_types:BulkStats"
          },
          "shards": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "shard_stats": {
            "$ref": "#/components/schemas/indices.stats:ShardsTotalStats"
          },
          "indices": {
            "$ref": "#/components/schemas/indices.stats:IndicesStats"
          }
        }
      },
      "indices.stats:ShardCommit": {
        "type": "object",
        "properties": {
          "generation": {
            "type": "number"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "num_docs": {
            "type": "number"
          },
          "user_data": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "generation",
          "id",
          "num_docs",
          "user_data"
        ]
      },
      "indices.stats:MappingStats": {
        "type": "object",
        "properties": {
          "total_count": {
            "type": "number"
          },
          "total_estimated_overhead": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_estimated_overhead_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "total_count",
          "total_estimated_overhead_in_bytes"
        ]
      },
      "indices.stats:ShardPath": {
        "type": "object",
        "properties": {
          "data_path": {
            "type": "string"
          },
          "is_custom_data_path": {
            "type": "boolean"
          },
          "state_path": {
            "type": "string"
          }
        },
        "required": [
          "data_path",
          "is_custom_data_path",
          "state_path"
        ]
      },
      "indices.stats:ShardQueryCache": {
        "type": "object",
        "properties": {
          "cache_count": {
            "type": "number"
          },
          "cache_size": {
            "type": "number"
          },
          "evictions": {
            "type": "number"
          },
          "hit_count": {
            "type": "number"
          },
          "memory_size_in_bytes": {
            "type": "number"
          },
          "miss_count": {
            "type": "number"
          },
          "total_count": {
            "type": "number"
          }
        },
        "required": [
          "cache_count",
          "cache_size",
          "evictions",
          "hit_count",
          "memory_size_in_bytes",
          "miss_count",
          "total_count"
        ]
      },
      "indices.stats:ShardRetentionLeases": {
        "type": "object",
        "properties": {
          "primary_term": {
            "type": "number"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "leases": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.stats:ShardLease"
            }
          }
        },
        "required": [
          "primary_term",
          "version",
          "leases"
        ]
      },
      "indices.stats:ShardLease": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "retaining_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "timestamp": {
            "type": "number"
          },
          "source": {
            "type": "string"
          }
        },
        "required": [
          "id",
          "retaining_seq_no",
          "timestamp",
          "source"
        ]
      },
      "indices.stats:ShardRouting": {
        "type": "object",
        "properties": {
          "node": {
            "type": "string"
          },
          "primary": {
            "type": "boolean"
          },
          "relocating_node": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "state": {
            "$ref": "#/components/schemas/indices.stats:ShardRoutingState"
          }
        },
        "required": [
          "node",
          "primary",
          "state"
        ]
      },
      "indices.stats:ShardRoutingState": {
        "type": "string",
        "enum": [
          "UNASSIGNED",
          "INITIALIZING",
          "STARTED",
          "RELOCATING"
        ]
      },
      "indices.stats:ShardSequenceNumber": {
        "type": "object",
        "properties": {
          "global_checkpoint": {
            "type": "number"
          },
          "local_checkpoint": {
            "type": "number"
          },
          "max_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          }
        },
        "required": [
          "global_checkpoint",
          "local_checkpoint",
          "max_seq_no"
        ]
      },
      "indices.stats:IndexMetadataState": {
        "type": "string",
        "enum": [
          "open",
          "close"
        ]
      },
      "indices.update_aliases:Action": {
        "type": "object",
        "properties": {
          "add": {
            "$ref": "#/components/schemas/indices.update_aliases:AddAction"
          },
          "remove": {
            "$ref": "#/components/schemas/indices.update_aliases:RemoveAction"
          },
          "remove_index": {
            "$ref": "#/components/schemas/indices.update_aliases:RemoveIndexAction"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "indices.update_aliases:AddAction": {
        "type": "object",
        "properties": {
          "alias": {
            "$ref": "#/components/schemas/_types:IndexAlias"
          },
          "aliases": {
            "description": "Aliases for the action.\nIndex alias names support date math.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexAlias"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexAlias"
                }
              }
            ]
          },
          "filter": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "index_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "is_hidden": {
            "description": "If `true`, the alias is hidden.",
            "type": "boolean"
          },
          "is_write_index": {
            "description": "If `true`, sets the write index or data stream for the alias.",
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "search_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "must_exist": {
            "description": "If `true`, the alias must exist to perform the action.",
            "type": "boolean"
          }
        }
      },
      "indices.update_aliases:RemoveAction": {
        "type": "object",
        "properties": {
          "alias": {
            "$ref": "#/components/schemas/_types:IndexAlias"
          },
          "aliases": {
            "description": "Aliases for the action.\nIndex alias names support date math.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:IndexAlias"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:IndexAlias"
                }
              }
            ]
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "must_exist": {
            "description": "If `true`, the alias must exist to perform the action.",
            "type": "boolean"
          }
        }
      },
      "indices.update_aliases:RemoveIndexAction": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "indices": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "must_exist": {
            "description": "If `true`, the alias must exist to perform the action.",
            "type": "boolean"
          }
        }
      },
      "indices.validate_query:IndicesValidationExplanation": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string"
          },
          "explanation": {
            "type": "string"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "valid": {
            "type": "boolean"
          }
        },
        "required": [
          "index",
          "valid"
        ]
      },
      "_types:ElasticsearchVersionInfo": {
        "type": "object",
        "properties": {
          "build_date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "build_flavor": {
            "type": "string"
          },
          "build_hash": {
            "type": "string"
          },
          "build_snapshot": {
            "type": "boolean"
          },
          "build_type": {
            "type": "string"
          },
          "lucene_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "minimum_index_compatibility_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "minimum_wire_compatibility_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "number": {
            "type": "string"
          }
        },
        "required": [
          "build_date",
          "build_flavor",
          "build_hash",
          "build_snapshot",
          "build_type",
          "lucene_version",
          "minimum_index_compatibility_version",
          "minimum_wire_compatibility_version",
          "number"
        ]
      },
      "ingest.geo_ip_stats:GeoIpDownloadStatistics": {
        "type": "object",
        "properties": {
          "successful_downloads": {
            "description": "Total number of successful database downloads.",
            "type": "number"
          },
          "failed_downloads": {
            "description": "Total number of failed database downloads.",
            "type": "number"
          },
          "total_download_time": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "database_count": {
            "description": "Current number of databases available for use.",
            "type": "number"
          },
          "skipped_updates": {
            "description": "Total number of database updates skipped.",
            "type": "number"
          }
        },
        "required": [
          "successful_downloads",
          "failed_downloads",
          "total_download_time",
          "database_count",
          "skipped_updates"
        ]
      },
      "ingest.geo_ip_stats:GeoIpNodeDatabases": {
        "type": "object",
        "properties": {
          "databases": {
            "description": "Downloaded databases for the node.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest.geo_ip_stats:GeoIpNodeDatabaseName"
            }
          },
          "files_in_temp": {
            "description": "Downloaded database files, including related license files. Elasticsearch stores these files in the nodes temporary directory: $ES_TMPDIR/geoip-databases/<node_id>.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "databases",
          "files_in_temp"
        ]
      },
      "ingest.geo_ip_stats:GeoIpNodeDatabaseName": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name"
        ]
      },
      "ingest._types:Pipeline": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the ingest pipeline.",
            "type": "string"
          },
          "on_failure": {
            "description": "Processors to run immediately after a processor failure.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          },
          "processors": {
            "description": "Processors used to perform transformations on documents before indexing.\nProcessors run sequentially in the order specified.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          }
        }
      },
      "ingest._types:ProcessorContainer": {
        "type": "object",
        "properties": {
          "attachment": {
            "$ref": "#/components/schemas/ingest._types:AttachmentProcessor"
          },
          "append": {
            "$ref": "#/components/schemas/ingest._types:AppendProcessor"
          },
          "csv": {
            "$ref": "#/components/schemas/ingest._types:CsvProcessor"
          },
          "convert": {
            "$ref": "#/components/schemas/ingest._types:ConvertProcessor"
          },
          "date": {
            "$ref": "#/components/schemas/ingest._types:DateProcessor"
          },
          "date_index_name": {
            "$ref": "#/components/schemas/ingest._types:DateIndexNameProcessor"
          },
          "dot_expander": {
            "$ref": "#/components/schemas/ingest._types:DotExpanderProcessor"
          },
          "enrich": {
            "$ref": "#/components/schemas/ingest._types:EnrichProcessor"
          },
          "fail": {
            "$ref": "#/components/schemas/ingest._types:FailProcessor"
          },
          "foreach": {
            "$ref": "#/components/schemas/ingest._types:ForeachProcessor"
          },
          "json": {
            "$ref": "#/components/schemas/ingest._types:JsonProcessor"
          },
          "user_agent": {
            "$ref": "#/components/schemas/ingest._types:UserAgentProcessor"
          },
          "kv": {
            "$ref": "#/components/schemas/ingest._types:KeyValueProcessor"
          },
          "geoip": {
            "$ref": "#/components/schemas/ingest._types:GeoIpProcessor"
          },
          "grok": {
            "$ref": "#/components/schemas/ingest._types:GrokProcessor"
          },
          "gsub": {
            "$ref": "#/components/schemas/ingest._types:GsubProcessor"
          },
          "join": {
            "$ref": "#/components/schemas/ingest._types:JoinProcessor"
          },
          "lowercase": {
            "$ref": "#/components/schemas/ingest._types:LowercaseProcessor"
          },
          "remove": {
            "$ref": "#/components/schemas/ingest._types:RemoveProcessor"
          },
          "rename": {
            "$ref": "#/components/schemas/ingest._types:RenameProcessor"
          },
          "script": {
            "$ref": "#/components/schemas/_types:Script"
          },
          "set": {
            "$ref": "#/components/schemas/ingest._types:SetProcessor"
          },
          "sort": {
            "$ref": "#/components/schemas/ingest._types:SortProcessor"
          },
          "split": {
            "$ref": "#/components/schemas/ingest._types:SplitProcessor"
          },
          "trim": {
            "$ref": "#/components/schemas/ingest._types:TrimProcessor"
          },
          "uppercase": {
            "$ref": "#/components/schemas/ingest._types:UppercaseProcessor"
          },
          "urldecode": {
            "$ref": "#/components/schemas/ingest._types:UrlDecodeProcessor"
          },
          "bytes": {
            "$ref": "#/components/schemas/ingest._types:BytesProcessor"
          },
          "dissect": {
            "$ref": "#/components/schemas/ingest._types:DissectProcessor"
          },
          "set_security_user": {
            "$ref": "#/components/schemas/ingest._types:SetSecurityUserProcessor"
          },
          "pipeline": {
            "$ref": "#/components/schemas/ingest._types:PipelineProcessor"
          },
          "drop": {
            "$ref": "#/components/schemas/ingest._types:DropProcessor"
          },
          "circle": {
            "$ref": "#/components/schemas/ingest._types:CircleProcessor"
          },
          "inference": {
            "$ref": "#/components/schemas/ingest._types:InferenceProcessor"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ingest._types:AttachmentProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and field does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "indexed_chars": {
                "description": "The number of chars being used for extraction to prevent huge fields.\nUse `-1` for no limit.",
                "type": "number"
              },
              "indexed_chars_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "properties": {
                "description": "Array of properties to select to be stored.\nCan be `content`, `title`, `name`, `author`, `keywords`, `date`, `content_type`, `content_length`, `language`.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "resource_name": {
                "description": "Field containing the name of the resource to decode.\nIf specified, the processor passes this resource name to the underlying Tika library to enable Resource Name Based Detection.",
                "type": "string"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:ProcessorBase": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the processor.\nUseful for describing the purpose of the processor or its configuration.",
            "type": "string"
          },
          "if": {
            "description": "Conditionally execute the processor.",
            "type": "string"
          },
          "ignore_failure": {
            "description": "Ignore failures for the processor.",
            "type": "boolean"
          },
          "on_failure": {
            "description": "Handle failures for the processor.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          },
          "tag": {
            "description": "Identifier for the processor.\nUseful for debugging and metrics.",
            "type": "string"
          }
        }
      },
      "ingest._types:AppendProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "value": {
                "description": "The value to be appended. Supports template snippets.",
                "type": "array",
                "items": {
                  "type": "object"
                }
              },
              "allow_duplicates": {
                "description": "If `false`, the processor does not append values already present in the field.",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "value"
            ]
          }
        ]
      },
      "ingest._types:CsvProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "empty_value": {
                "description": "Value used to fill empty fields.\nEmpty fields are skipped if this is not provided.\nAn empty field is one with no value (2 consecutive separators) or empty quotes (`\"\"`).",
                "type": "object"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "quote": {
                "description": "Quote used in CSV, has to be single character string.",
                "type": "string"
              },
              "separator": {
                "description": "Separator used in CSV, has to be single character string.",
                "type": "string"
              },
              "target_fields": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "trim": {
                "description": "Trim whitespaces in unquoted fields.",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "target_fields"
            ]
          }
        ]
      },
      "ingest._types:ConvertProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "type": {
                "$ref": "#/components/schemas/ingest._types:ConvertType"
              }
            },
            "required": [
              "field",
              "type"
            ]
          }
        ]
      },
      "ingest._types:ConvertType": {
        "type": "string",
        "enum": [
          "integer",
          "long",
          "float",
          "double",
          "string",
          "boolean",
          "auto"
        ]
      },
      "ingest._types:DateProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "formats": {
                "description": "An array of the expected date formats.\nCan be a java time pattern or one of the following formats: ISO8601, UNIX, UNIX_MS, or TAI64N.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "locale": {
                "description": "The locale to use when parsing the date, relevant when parsing month names or week days.\nSupports template snippets.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "timezone": {
                "description": "The timezone to use when parsing the date.\nSupports template snippets.",
                "type": "string"
              }
            },
            "required": [
              "field",
              "formats"
            ]
          }
        ]
      },
      "ingest._types:DateIndexNameProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "date_formats": {
                "description": "An array of the expected date formats for parsing dates / timestamps in the document being preprocessed.\nCan be a java time pattern or one of the following formats: ISO8601, UNIX, UNIX_MS, or TAI64N.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "date_rounding": {
                "description": "How to round the date when formatting the date into the index name. Valid values are:\n`y` (year), `M` (month), `w` (week), `d` (day), `h` (hour), `m` (minute) and `s` (second).\nSupports template snippets.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "index_name_format": {
                "description": "The format to be used when printing the parsed date into the index name.\nA valid java time pattern is expected here.\nSupports template snippets.",
                "type": "string"
              },
              "index_name_prefix": {
                "description": "A prefix of the index name to be prepended before the printed date.\nSupports template snippets.",
                "type": "string"
              },
              "locale": {
                "description": "The locale to use when parsing the date from the document being preprocessed, relevant when parsing month names or week days.",
                "type": "string"
              },
              "timezone": {
                "description": "The timezone to use when parsing the date and when date math index supports resolves expressions into concrete index names.",
                "type": "string"
              }
            },
            "required": [
              "date_formats",
              "date_rounding",
              "field"
            ]
          }
        ]
      },
      "ingest._types:DotExpanderProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "path": {
                "description": "The field that contains the field to expand.\nOnly required if the field to expand is part another object field, because the `field` option can only understand leaf fields.",
                "type": "string"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:EnrichProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "max_matches": {
                "description": "The maximum number of matched documents to include under the configured target field.\nThe `target_field` will be turned into a json array if `max_matches` is higher than 1, otherwise `target_field` will become a json object.\nIn order to avoid documents getting too large, the maximum allowed value is 128.",
                "type": "number"
              },
              "override": {
                "description": "If processor will update fields with pre-existing non-null-valued field.\nWhen set to `false`, such fields will not be touched.",
                "type": "boolean"
              },
              "policy_name": {
                "description": "The name of the enrich policy to use.",
                "type": "string"
              },
              "shape_relation": {
                "$ref": "#/components/schemas/_types:GeoShapeRelation"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "policy_name",
              "target_field"
            ]
          }
        ]
      },
      "_types:GeoShapeRelation": {
        "type": "string",
        "enum": [
          "intersects",
          "disjoint",
          "within",
          "contains"
        ]
      },
      "ingest._types:FailProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "message": {
                "description": "The error message thrown by the processor.\nSupports template snippets.",
                "type": "string"
              }
            },
            "required": [
              "message"
            ]
          }
        ]
      },
      "ingest._types:ForeachProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true`, the processor silently exits without changing the document if the `field` is `null` or missing.",
                "type": "boolean"
              },
              "processor": {
                "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
              }
            },
            "required": [
              "field",
              "processor"
            ]
          }
        ]
      },
      "ingest._types:JsonProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "add_to_root": {
                "description": "Flag that forces the parsed JSON to be added at the top level of the document.\n`target_field` must not be set when this option is chosen.",
                "type": "boolean"
              },
              "add_to_root_conflict_strategy": {
                "$ref": "#/components/schemas/ingest._types:JsonProcessorConflictStrategy"
              },
              "allow_duplicate_keys": {
                "description": "When set to `true`, the JSON parser will not fail if the JSON contains duplicate keys.\nInstead, the last encountered value for any duplicate key wins.",
                "type": "boolean"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:JsonProcessorConflictStrategy": {
        "type": "string",
        "enum": [
          "replace",
          "merge"
        ]
      },
      "ingest._types:UserAgentProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "options": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ingest._types:UserAgentProperty"
                }
              },
              "regex_file": {
                "description": "The name of the file in the `config/ingest-user-agent` directory containing the regular expressions for parsing the user agent string. Both the directory and the file have to be created before starting Elasticsearch. If not specified, ingest-user-agent will use the `regexes.yaml` from uap-core it ships with.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UserAgentProperty": {
        "type": "string",
        "enum": [
          "NAME",
          "MAJOR",
          "MINOR",
          "PATCH",
          "OS",
          "OS_NAME",
          "OS_MAJOR",
          "OS_MINOR",
          "DEVICE",
          "BUILD"
        ]
      },
      "ingest._types:KeyValueProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "exclude_keys": {
                "description": "List of keys to exclude from document.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "field_split": {
                "description": "Regex pattern to use for splitting key-value pairs.",
                "type": "string"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "include_keys": {
                "description": "List of keys to filter and insert into document.\nDefaults to including all keys.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "prefix": {
                "description": "Prefix to be added to extracted keys.",
                "type": "string"
              },
              "strip_brackets": {
                "description": "If `true`. strip brackets `()`, `<>`, `[]` as well as quotes `'` and `\"` from extracted values.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "trim_key": {
                "description": "String of characters to trim from extracted keys.",
                "type": "string"
              },
              "trim_value": {
                "description": "String of characters to trim from extracted values.",
                "type": "string"
              },
              "value_split": {
                "description": "Regex pattern to use for splitting the key from the value within a key-value pair.",
                "type": "string"
              }
            },
            "required": [
              "field",
              "field_split",
              "value_split"
            ]
          }
        ]
      },
      "ingest._types:GeoIpProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "database_file": {
                "description": "The database filename referring to a database the module ships with (GeoLite2-City.mmdb, GeoLite2-Country.mmdb, or GeoLite2-ASN.mmdb) or a custom database in the ingest-geoip config directory.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "first_only": {
                "description": "If `true`, only the first found geoip data will be returned, even if the field contains an array.",
                "type": "boolean"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "properties": {
                "description": "Controls what properties are added to the `target_field` based on the geoip lookup.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:GrokProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "pattern_definitions": {
                "description": "A map of pattern-name and pattern tuples defining custom patterns to be used by the current processor.\nPatterns matching existing names will override the pre-existing definition.",
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "patterns": {
                "description": "An ordered list of grok expression to match and extract named captures with.\nReturns on the first expression in the list that matches.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "trace_match": {
                "description": "When `true`, `_ingest._grok_match_index` will be inserted into your matched documents metadata with the index into the pattern found in `patterns` that matched.",
                "type": "boolean"
              }
            },
            "required": [
              "field",
              "patterns"
            ]
          }
        ]
      },
      "ingest._types:GsubProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "pattern": {
                "description": "The pattern to be replaced.",
                "type": "string"
              },
              "replacement": {
                "description": "The string to replace the matching patterns with.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "pattern",
              "replacement"
            ]
          }
        ]
      },
      "ingest._types:JoinProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "separator": {
                "description": "The separator character.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "separator"
            ]
          }
        ]
      },
      "ingest._types:LowercaseProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:RemoveProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Fields"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:RenameProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "target_field"
            ]
          }
        ]
      },
      "ingest._types:SetProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "copy_from": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_empty_value": {
                "description": "If `true` and `value` is a template snippet that evaluates to `null` or the empty string, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "media_type": {
                "description": "The media type for encoding `value`.\nApplies only when value is a template snippet.\nMust be one of `application/json`, `text/plain`, or `application/x-www-form-urlencoded`.",
                "type": "string"
              },
              "override": {
                "description": "If `true` processor will update fields with pre-existing non-null-valued field.\nWhen set to `false`, such fields will not be touched.",
                "type": "boolean"
              },
              "value": {
                "description": "The value to be set for the field.\nSupports template snippets.\nMay specify only one of `value` or `copy_from`.",
                "type": "object"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:SortProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "order": {
                "$ref": "#/components/schemas/_types:SortOrder"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:SplitProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "preserve_trailing": {
                "description": "Preserves empty trailing fields, if any.",
                "type": "boolean"
              },
              "separator": {
                "description": "A regex which matches the separator, for example, `,` or `\\s+`.",
                "type": "string"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field",
              "separator"
            ]
          }
        ]
      },
      "ingest._types:TrimProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UppercaseProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:UrlDecodeProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:BytesProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:DissectProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "append_separator": {
                "description": "The character(s) that separate the appended fields.",
                "type": "string"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist or is `null`, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "pattern": {
                "description": "The pattern to apply to the field.",
                "type": "string"
              }
            },
            "required": [
              "field",
              "pattern"
            ]
          }
        ]
      },
      "ingest._types:SetSecurityUserProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "properties": {
                "description": "Controls what user related properties are added to the field.",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "required": [
              "field"
            ]
          }
        ]
      },
      "ingest._types:PipelineProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "ignore_missing_pipeline": {
                "description": "Whether to ignore missing pipelines instead of failing.",
                "type": "boolean"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      },
      "ingest._types:DropProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object"
          }
        ]
      },
      "ingest._types:CircleProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "error_distance": {
                "description": "The difference between the resulting inscribed distance from center to side and the circles radius (measured in meters for `geo_shape`, unit-less for `shape`).",
                "type": "number"
              },
              "field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "ignore_missing": {
                "description": "If `true` and `field` does not exist, the processor quietly exits without modifying the document.",
                "type": "boolean"
              },
              "shape_type": {
                "$ref": "#/components/schemas/ingest._types:ShapeType"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              }
            },
            "required": [
              "error_distance",
              "field",
              "shape_type"
            ]
          }
        ]
      },
      "ingest._types:ShapeType": {
        "type": "string",
        "enum": [
          "geo_shape",
          "shape"
        ]
      },
      "ingest._types:InferenceProcessor": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ingest._types:ProcessorBase"
          },
          {
            "type": "object",
            "properties": {
              "model_id": {
                "$ref": "#/components/schemas/_types:Id"
              },
              "target_field": {
                "$ref": "#/components/schemas/_types:Field"
              },
              "field_map": {
                "description": "Maps the document field names to the known field names of the model.\nThis mapping takes precedence over any default mappings provided in the model configuration.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "inference_config": {
                "$ref": "#/components/schemas/ingest._types:InferenceConfig"
              }
            },
            "required": [
              "model_id"
            ]
          }
        ]
      },
      "ingest._types:InferenceConfig": {
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ingest._types:InferenceConfigRegression"
          },
          "classification": {
            "$ref": "#/components/schemas/ingest._types:InferenceConfigClassification"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ingest._types:InferenceConfigRegression": {
        "type": "object",
        "properties": {
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "num_top_feature_importance_values": {
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          }
        }
      },
      "ingest._types:InferenceConfigClassification": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return.",
            "type": "number"
          },
          "num_top_feature_importance_values": {
            "description": "Specifies the maximum number of feature importance values per document.",
            "type": "number"
          },
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "top_classes_results_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "prediction_field_type": {
            "description": "Specifies the type of the predicted field to write.\nValid values are: `string`, `number`, `boolean`.",
            "type": "string"
          }
        }
      },
      "ingest.simulate:Document": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_source": {
            "description": "JSON body for the document.",
            "type": "object"
          }
        },
        "required": [
          "_source"
        ]
      },
      "ingest.simulate:PipelineSimulation": {
        "type": "object",
        "properties": {
          "doc": {
            "$ref": "#/components/schemas/ingest.simulate:DocumentSimulation"
          },
          "processor_results": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest.simulate:PipelineSimulation"
            }
          },
          "tag": {
            "type": "string"
          },
          "processor_type": {
            "type": "string"
          },
          "status": {
            "$ref": "#/components/schemas/watcher._types:ActionStatusOptions"
          }
        }
      },
      "ingest.simulate:DocumentSimulation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_ingest": {
            "$ref": "#/components/schemas/ingest.simulate:Ingest"
          },
          "_routing": {
            "description": "Value used to send the document to a specific primary shard.",
            "type": "string"
          },
          "_source": {
            "description": "JSON body for the document.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "_version": {
            "$ref": "#/components/schemas/_spec_utils:StringifiedVersionNumber"
          },
          "_version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "_id",
          "_index",
          "_ingest",
          "_source"
        ]
      },
      "ingest.simulate:Ingest": {
        "type": "object",
        "properties": {
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "pipeline": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "timestamp"
        ]
      },
      "_spec_utils:StringifiedVersionNumber": {
        "description": "Some APIs will return values such as numbers also as a string (notably epoch timestamps). This behavior\nis used to capture this behavior while keeping the semantics of the field type.\n\nDepending on the target language, code generators can keep the union or remove it and leniently parse\nstrings to the target type.",
        "oneOf": [
          {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          {
            "type": "string"
          }
        ]
      },
      "watcher._types:ActionStatusOptions": {
        "type": "string",
        "enum": [
          "success",
          "failure",
          "simulated",
          "throttled"
        ]
      },
      "logstash._types:Pipeline": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the pipeline.\nThis description is not used by Elasticsearch or Logstash.",
            "type": "string"
          },
          "last_modified": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "pipeline_metadata": {
            "$ref": "#/components/schemas/logstash._types:PipelineMetadata"
          },
          "username": {
            "description": "User who last updated the pipeline.",
            "type": "string"
          },
          "pipeline": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/logstash/current/configuration-file-structure.html"
            },
            "description": "Configuration for the pipeline.",
            "type": "string"
          },
          "pipeline_settings": {
            "$ref": "#/components/schemas/logstash._types:PipelineSettings"
          }
        },
        "required": [
          "description",
          "last_modified",
          "pipeline_metadata",
          "username",
          "pipeline",
          "pipeline_settings"
        ]
      },
      "logstash._types:PipelineMetadata": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "version": {
            "type": "string"
          }
        },
        "required": [
          "type",
          "version"
        ]
      },
      "logstash._types:PipelineSettings": {
        "type": "object",
        "properties": {
          "pipeline.workers": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html"
            },
            "description": "The number of workers that will, in parallel, execute the filter and output stages of the pipeline.",
            "type": "number"
          },
          "pipeline.batch.size": {
            "description": "The maximum number of events an individual worker thread will collect from inputs before attempting to execute its filters and outputs.",
            "type": "number"
          },
          "pipeline.batch.delay": {
            "description": "When creating pipeline event batches, how long in milliseconds to wait for each event before dispatching an undersized batch to pipeline workers.",
            "type": "number"
          },
          "queue.type": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/logstash/current/logstash-settings-file.html"
            },
            "description": "The internal queuing model to use for event buffering.",
            "type": "string"
          },
          "queue.max_bytes.number": {
            "description": "The total capacity of the queue (`queue.type: persisted`) in number of bytes.",
            "type": "number"
          },
          "queue.max_bytes.units": {
            "description": "The total capacity of the queue (`queue.type: persisted`) in terms of units of bytes.",
            "type": "string"
          },
          "queue.checkpoint.writes": {
            "description": "The maximum number of written events before forcing a checkpoint when persistent queues are enabled (`queue.type: persisted`).",
            "type": "number"
          }
        },
        "required": [
          "pipeline.workers",
          "pipeline.batch.size",
          "pipeline.batch.delay",
          "queue.type",
          "queue.max_bytes.number",
          "queue.max_bytes.units",
          "queue.checkpoint.writes"
        ]
      },
      "_global.mget:Operation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_source": {
            "$ref": "#/components/schemas/_global.search._types:SourceConfig"
          },
          "stored_fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "_id"
        ]
      },
      "_global.mget:ResponseItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.get:GetResult"
          },
          {
            "$ref": "#/components/schemas/_global.mget:MultiGetError"
          }
        ]
      },
      "_global.mget:MultiGetError": {
        "type": "object",
        "properties": {
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          },
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "error",
          "_id",
          "_index"
        ]
      },
      "ml._types:AnalysisConfig": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "categorization_analyzer": {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzer"
          },
          "categorization_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "categorization_filters": {
            "description": "If `categorization_field_name` is specified, you can also define optional filters. This property expects an array of regular expressions. The expressions are used to filter out matching sequences from the categorization field values. You can use this functionality to fine tune the categorization by excluding sequences from consideration when categories are defined. For example, you can exclude SQL statements that appear in your log files. This property cannot be used at the same time as `categorization_analyzer`. If you only want to define simple regular expression filters that are applied prior to tokenization, setting this property is the easiest method. If you also want to customize the tokenizer or post-tokenization filtering, use the `categorization_analyzer` property instead and include the filters as pattern_replace character filters. The effect is exactly the same.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "detectors": {
            "description": "Detector configuration objects specify which data fields a job analyzes. They also specify which analytical functions are used. You can specify multiple detectors for a job. If the detectors array does not contain at least one detector, no analysis can occur and an error is returned.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Detector"
            }
          },
          "influencers": {
            "description": "A comma separated list of influencer field names. Typically these can be the by, over, or partition fields that are used in the detector configuration. You might also want to use a field name that is not specifically named in a detector, but is available as part of the input data. When you use multiple detectors, the use of influencers is recommended as it aggregates results for each influencer entity.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          },
          "latency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "model_prune_window": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "multivariate_by_fields": {
            "description": "This functionality is reserved for internal use. It is not supported for use in customer environments and is not subject to the support SLA of official GA features. If set to `true`, the analysis will automatically find correlations between metrics for a given by field value and report anomalies when those correlations cease to hold. For example, suppose CPU and memory usage on host A is usually highly correlated with the same metrics on host B. Perhaps this correlation occurs because they are running a load-balanced application. If you enable this property, anomalies will be reported when, for example, CPU usage on host A is high and the value of CPU usage on host B is low. That is to say, youll see an anomaly when the CPU of host A is unusual given the CPU of host B. To use the `multivariate_by_fields` property, you must also specify `by_field_name` in your detector.",
            "type": "boolean"
          },
          "per_partition_categorization": {
            "$ref": "#/components/schemas/ml._types:PerPartitionCategorization"
          },
          "summary_count_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "detectors"
        ]
      },
      "ml._types:CategorizationAnalyzer": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzerDefinition"
          }
        ]
      },
      "ml._types:CategorizationAnalyzerDefinition": {
        "type": "object",
        "properties": {
          "char_filter": {
            "description": "One or more character filters. In addition to the built-in character filters, other plugins can provide more character filters. If this property is not specified, no character filters are applied prior to categorization. If you are customizing some other aspect of the analyzer and you need to achieve the equivalent of `categorization_filters` (which are not permitted when some other aspect of the analyzer is customized), add them here as pattern replace character filters.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.analysis:CharFilter"
            }
          },
          "filter": {
            "description": "One or more token filters. In addition to the built-in token filters, other plugins can provide more token filters. If this property is not specified, no token filters are applied prior to categorization.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.analysis:TokenFilter"
            }
          },
          "tokenizer": {
            "$ref": "#/components/schemas/_types.analysis:Tokenizer"
          }
        }
      },
      "ml._types:Detector": {
        "type": "object",
        "properties": {
          "by_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "custom_rules": {
            "description": "Custom rules enable you to customize the way detectors operate. For example, a rule may dictate conditions under which results should be skipped. Kibana refers to custom rules as job rules.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectionRule"
            }
          },
          "detector_description": {
            "description": "A description of the detector.",
            "type": "string"
          },
          "detector_index": {
            "description": "A unique identifier for the detector. This identifier is based on the order of the detectors in the `analysis_config`, starting at zero. If you specify a value for this property, it is ignored.",
            "type": "number"
          },
          "exclude_frequent": {
            "$ref": "#/components/schemas/ml._types:ExcludeFrequent"
          },
          "field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "function": {
            "description": "The analysis function that is used. For example, `count`, `rare`, `mean`, `min`, `max`, or `sum`.",
            "type": "string"
          },
          "over_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "partition_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "use_null": {
            "description": "Defines whether a new series is used as the null series when there is no value for the by or partition fields.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DetectionRule": {
        "type": "object",
        "properties": {
          "actions": {
            "description": "The set of actions to be triggered when the rule applies. If more than one action is specified the effects of all actions are combined.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:RuleAction"
            }
          },
          "conditions": {
            "description": "An array of numeric conditions when the rule applies. A rule must either have a non-empty scope or at least one condition. Multiple conditions are combined together with a logical AND.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:RuleCondition"
            }
          },
          "scope": {
            "description": "A scope of series where the rule applies. A rule must either have a non-empty scope or at least one condition. By default, the scope includes all series. Scoping is allowed for any of the fields that are also specified in `by_field_name`, `over_field_name`, or `partition_field_name`.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ml._types:FilterRef"
            }
          }
        }
      },
      "ml._types:RuleAction": {
        "type": "string",
        "enum": [
          "skip_result",
          "skip_model_update"
        ]
      },
      "ml._types:RuleCondition": {
        "type": "object",
        "properties": {
          "applies_to": {
            "$ref": "#/components/schemas/ml._types:AppliesTo"
          },
          "operator": {
            "$ref": "#/components/schemas/ml._types:ConditionOperator"
          },
          "value": {
            "description": "The value that is compared against the `applies_to` field using the operator.",
            "type": "number"
          }
        },
        "required": [
          "applies_to",
          "operator",
          "value"
        ]
      },
      "ml._types:AppliesTo": {
        "type": "string",
        "enum": [
          "actual",
          "typical",
          "diff_from_typical",
          "time"
        ]
      },
      "ml._types:ConditionOperator": {
        "type": "string",
        "enum": [
          "gt",
          "gte",
          "lt",
          "lte"
        ]
      },
      "ml._types:FilterRef": {
        "type": "object",
        "properties": {
          "filter_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "filter_type": {
            "$ref": "#/components/schemas/ml._types:FilterType"
          }
        },
        "required": [
          "filter_id"
        ]
      },
      "ml._types:FilterType": {
        "type": "string",
        "enum": [
          "include",
          "exclude"
        ]
      },
      "ml._types:ExcludeFrequent": {
        "type": "string",
        "enum": [
          "all",
          "none",
          "by",
          "over"
        ]
      },
      "ml._types:PerPartitionCategorization": {
        "type": "object",
        "properties": {
          "enabled": {
            "description": "To enable this setting, you must also set the `partition_field_name` property to the same value in every detector that uses the keyword `mlcategory`. Otherwise, job creation fails.",
            "type": "boolean"
          },
          "stop_on_warn": {
            "description": "This setting can be set to true only if per-partition categorization is enabled. If true, both categorization and subsequent anomaly detection stops for partitions where the categorization status changes to warn. This setting makes it viable to have a job where it is expected that categorization works well for some partitions but not others; you do not pay the cost of bad categorization forever in the partitions where it works badly.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeEvaluationContainer": {
        "type": "object",
        "properties": {
          "classification": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationClassification"
          },
          "outlier_detection": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationOutlierDetection"
          },
          "regression": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegression"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeEvaluationClassification": {
        "type": "object",
        "properties": {
          "actual_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "predicted_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "top_classes_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationClassificationMetrics"
          }
        },
        "required": [
          "actual_field"
        ]
      },
      "ml._types:DataframeEvaluationClassificationMetrics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationMetrics"
          },
          {
            "type": "object",
            "properties": {
              "accuracy": {
                "description": "Accuracy of predictions (per-class and overall).",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              },
              "multiclass_confusion_matrix": {
                "description": "Multiclass confusion matrix.",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              }
            }
          }
        ]
      },
      "ml._types:DataframeEvaluationMetrics": {
        "type": "object",
        "properties": {
          "auc_roc": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationClassificationMetricsAucRoc"
          },
          "precision": {
            "description": "Precision of predictions (per-class and average).",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "recall": {
            "description": "Recall of predictions (per-class and average).",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        }
      },
      "ml._types:DataframeEvaluationClassificationMetricsAucRoc": {
        "type": "object",
        "properties": {
          "class_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "include_curve": {
            "description": "Whether or not the curve should be returned in addition to the score. Default value is false.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeEvaluationOutlierDetection": {
        "type": "object",
        "properties": {
          "actual_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "predicted_probability_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationOutlierDetectionMetrics"
          }
        },
        "required": [
          "actual_field",
          "predicted_probability_field"
        ]
      },
      "ml._types:DataframeEvaluationOutlierDetectionMetrics": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationMetrics"
          },
          {
            "type": "object",
            "properties": {
              "confusion_matrix": {
                "description": "Accuracy of predictions (per-class and overall).",
                "type": "object",
                "additionalProperties": {
                  "type": "object"
                }
              }
            }
          }
        ]
      },
      "ml._types:DataframeEvaluationRegression": {
        "type": "object",
        "properties": {
          "actual_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "predicted_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "metrics": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegressionMetrics"
          }
        },
        "required": [
          "actual_field",
          "predicted_field"
        ]
      },
      "ml._types:DataframeEvaluationRegressionMetrics": {
        "type": "object",
        "properties": {
          "mse": {
            "externalDocs": {
              "url": "https://en.wikipedia.org/wiki/Mean_squared_error"
            },
            "description": "Average squared difference between the predicted values and the actual (ground truth) value. For more information, read this wiki article.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "msle": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegressionMetricsMsle"
          },
          "huber": {
            "$ref": "#/components/schemas/ml._types:DataframeEvaluationRegressionMetricsHuber"
          },
          "r_squared": {
            "externalDocs": {
              "url": "https://en.wikipedia.org/wiki/Coefficient_of_determination"
            },
            "description": "Proportion of the variance in the dependent variable that is predictable from the independent variables.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        }
      },
      "ml._types:DataframeEvaluationRegressionMetricsMsle": {
        "type": "object",
        "properties": {
          "offset": {
            "description": "Defines the transition point at which you switch from minimizing quadratic error to minimizing quadratic log error. Defaults to 1.",
            "type": "number"
          }
        }
      },
      "ml._types:DataframeEvaluationRegressionMetricsHuber": {
        "type": "object",
        "properties": {
          "delta": {
            "description": "Approximates 1/2 (prediction - actual)2 for values much less than delta and approximates a straight line with slope delta for values much larger than delta. Defaults to 1. Delta needs to be greater than 0.",
            "type": "number"
          }
        }
      },
      "ml.evaluate_data_frame:DataframeClassificationSummary": {
        "type": "object",
        "properties": {
          "auc_roc": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationSummaryAucRoc"
          },
          "accuracy": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryAccuracy"
          },
          "multiclass_confusion_matrix": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryMulticlassConfusionMatrix"
          },
          "precision": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryPrecision"
          },
          "recall": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeClassificationSummaryRecall"
          }
        }
      },
      "ml.evaluate_data_frame:DataframeEvaluationSummaryAucRoc": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          {
            "type": "object",
            "properties": {
              "curve": {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationSummaryAucRocCurveItem"
                }
              }
            }
          }
        ]
      },
      "ml.evaluate_data_frame:DataframeEvaluationSummaryAucRocCurveItem": {
        "type": "object",
        "properties": {
          "tpr": {
            "type": "number"
          },
          "fpr": {
            "type": "number"
          },
          "threshold": {
            "type": "number"
          }
        },
        "required": [
          "tpr",
          "fpr",
          "threshold"
        ]
      },
      "ml.evaluate_data_frame:DataframeEvaluationValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number"
          }
        },
        "required": [
          "value"
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryAccuracy": {
        "type": "object",
        "properties": {
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationClass"
            }
          },
          "overall_accuracy": {
            "type": "number"
          }
        },
        "required": [
          "classes",
          "overall_accuracy"
        ]
      },
      "ml.evaluate_data_frame:DataframeEvaluationClass": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          {
            "type": "object",
            "properties": {
              "class_name": {
                "$ref": "#/components/schemas/_types:Name"
              }
            },
            "required": [
              "class_name"
            ]
          }
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryMulticlassConfusionMatrix": {
        "type": "object",
        "properties": {
          "confusion_matrix": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:ConfusionMatrixItem"
            }
          },
          "other_actual_class_count": {
            "type": "number"
          }
        },
        "required": [
          "confusion_matrix",
          "other_actual_class_count"
        ]
      },
      "ml.evaluate_data_frame:ConfusionMatrixItem": {
        "type": "object",
        "properties": {
          "actual_class": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "actual_class_doc_count": {
            "type": "number"
          },
          "predicted_classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:ConfusionMatrixPrediction"
            }
          },
          "other_predicted_class_doc_count": {
            "type": "number"
          }
        },
        "required": [
          "actual_class",
          "actual_class_doc_count",
          "predicted_classes",
          "other_predicted_class_doc_count"
        ]
      },
      "ml.evaluate_data_frame:ConfusionMatrixPrediction": {
        "type": "object",
        "properties": {
          "predicted_class": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "count": {
            "type": "number"
          }
        },
        "required": [
          "predicted_class",
          "count"
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryPrecision": {
        "type": "object",
        "properties": {
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationClass"
            }
          },
          "avg_precision": {
            "type": "number"
          }
        },
        "required": [
          "classes",
          "avg_precision"
        ]
      },
      "ml.evaluate_data_frame:DataframeClassificationSummaryRecall": {
        "type": "object",
        "properties": {
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationClass"
            }
          },
          "avg_recall": {
            "type": "number"
          }
        },
        "required": [
          "classes",
          "avg_recall"
        ]
      },
      "ml.evaluate_data_frame:DataframeOutlierDetectionSummary": {
        "type": "object",
        "properties": {
          "auc_roc": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationSummaryAucRoc"
          },
          "precision": {
            "description": "Set the different thresholds of the outlier score at where the metric is calculated.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "recall": {
            "description": "Set the different thresholds of the outlier score at where the metric is calculated.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "confusion_matrix": {
            "description": "Set the different thresholds of the outlier score at where the metrics (`tp` - true positive, `fp` - false positive, `tn` - true negative, `fn` - false negative) are calculated.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ml.evaluate_data_frame:ConfusionMatrixThreshold"
            }
          }
        }
      },
      "ml.evaluate_data_frame:ConfusionMatrixThreshold": {
        "type": "object",
        "properties": {
          "tp": {
            "description": "True Positive",
            "type": "number"
          },
          "fp": {
            "description": "False Positive",
            "type": "number"
          },
          "tn": {
            "description": "True Negative",
            "type": "number"
          },
          "fn": {
            "description": "False Negative",
            "type": "number"
          }
        },
        "required": [
          "tp",
          "fp",
          "tn",
          "fn"
        ]
      },
      "ml.evaluate_data_frame:DataframeRegressionSummary": {
        "type": "object",
        "properties": {
          "huber": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          "mse": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          "msle": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          },
          "r_squared": {
            "$ref": "#/components/schemas/ml.evaluate_data_frame:DataframeEvaluationValue"
          }
        }
      },
      "ml._types:DataframeAnalyticsSource": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "_source": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:DataframeAnalysisAnalyzedFields": {
        "type": "object",
        "properties": {
          "includes": {
            "description": "An array of strings that defines the fields that will be excluded from the analysis. You do not need to add fields with unsupported data types to excludes, these fields are excluded from the analysis automatically.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "excludes": {
            "description": "An array of strings that defines the fields that will be included in the analysis.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "includes",
          "excludes"
        ]
      },
      "ml._types:DataframeAnalyticsDestination": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "results_field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:DataframeAnalysisContainer": {
        "type": "object",
        "properties": {
          "classification": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisClassification"
          },
          "outlier_detection": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisOutlierDetection"
          },
          "regression": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisRegression"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeAnalysisClassification": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysis"
          },
          {
            "type": "object",
            "properties": {
              "class_assignment_objective": {
                "type": "string"
              },
              "num_top_classes": {
                "description": "Defines the number of categories for which the predicted probabilities are reported. It must be non-negative or -1. If it is -1 or greater than the total number of categories, probabilities are reported for all categories; if you have a large number of categories, there could be a significant effect on the size of your destination index. NOTE: To use the AUC ROC evaluation method, `num_top_classes` must be set to -1 or a value greater than or equal to the total number of categories.",
                "type": "number"
              }
            }
          }
        ]
      },
      "ml._types:DataframeAnalysis": {
        "type": "object",
        "properties": {
          "alpha": {
            "description": "Advanced configuration option. Machine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly. This parameter affects loss calculations by acting as a multiplier of the tree depth. Higher alpha values result in shallower trees and faster training times. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to zero.",
            "type": "number"
          },
          "dependent_variable": {
            "description": "Defines which field of the document is to be predicted. It must match one of the fields in the index being used to train. If this field is missing from a document, then that document will not be used for training, but a prediction with the trained model will be generated for it. It is also known as continuous target variable.\nFor classification analysis, the data type of the field must be numeric (`integer`, `short`, `long`, `byte`), categorical (`ip` or `keyword`), or `boolean`. There must be no more than 30 different values in this field.\nFor regression analysis, the data type of the field must be numeric.",
            "type": "string"
          },
          "downsample_factor": {
            "description": "Advanced configuration option. Controls the fraction of data that is used to compute the derivatives of the loss function for tree training. A small value results in the use of a small fraction of the data. If this value is set to be less than 1, accuracy typically improves. However, too small a value may result in poor convergence for the ensemble and so require more trees. By default, this value is calculated during hyperparameter optimization. It must be greater than zero and less than or equal to 1.",
            "type": "number"
          },
          "early_stopping_enabled": {
            "description": "Advanced configuration option. Specifies whether the training process should finish if it is not finding any better performing models. If disabled, the training process can take significantly longer and the chance of finding a better performing model is unremarkable.",
            "type": "boolean"
          },
          "eta": {
            "description": "Advanced configuration option. The shrinkage applied to the weights. Smaller values result in larger forests which have a better generalization error. However, larger forests cause slower training. By default, this value is calculated during hyperparameter optimization. It must be a value between 0.001 and 1.",
            "type": "number"
          },
          "eta_growth_rate_per_tree": {
            "description": "Advanced configuration option. Specifies the rate at which `eta` increases for each new tree that is added to the forest. For example, a rate of 1.05 increases `eta` by 5% for each extra tree. By default, this value is calculated during hyperparameter optimization. It must be between 0.5 and 2.",
            "type": "number"
          },
          "feature_bag_fraction": {
            "description": "Advanced configuration option. Defines the fraction of features that will be used when selecting a random bag for each candidate split. By default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "feature_processors": {
            "description": "Advanced configuration option. A collection of feature preprocessors that modify one or more included fields. The analysis uses the resulting one or more features instead of the original document field. However, these features are ephemeral; they are not stored in the destination index. Multiple `feature_processors` entries can refer to the same document fields. Automatic categorical feature encoding still occurs for the fields that are unprocessed by a custom processor or that have categorical values. Use this property only if you want to override the automatic feature encoding of the specified fields.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessor"
            }
          },
          "gamma": {
            "description": "Advanced configuration option. Regularization parameter to prevent overfitting on the training data set. Multiplies a linear penalty associated with the size of individual trees in the forest. A high gamma value causes training to prefer small trees. A small gamma value results in larger individual trees and slower training. By default, this value is calculated during hyperparameter optimization. It must be a nonnegative value.",
            "type": "number"
          },
          "lambda": {
            "description": "Advanced configuration option. Regularization parameter to prevent overfitting on the training data set. Multiplies an L2 regularization term which applies to leaf weights of the individual trees in the forest. A high lambda value causes training to favor small leaf weights. This behavior makes the prediction function smoother at the expense of potentially not being able to capture relevant relationships between the features and the dependent variable. A small lambda value results in large individual trees and slower training. By default, this value is calculated during hyperparameter optimization. It must be a nonnegative value.",
            "type": "number"
          },
          "max_optimization_rounds_per_hyperparameter": {
            "description": "Advanced configuration option. A multiplier responsible for determining the maximum number of hyperparameter optimization steps in the Bayesian optimization procedure. The maximum number of steps is determined based on the number of undefined hyperparameters times the maximum optimization rounds per hyperparameter. By default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "max_trees": {
            "description": "Advanced configuration option. Defines the maximum number of decision trees in the forest. The maximum value is 2000. By default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "num_top_feature_importance_values": {
            "description": "Advanced configuration option. Specifies the maximum number of feature importance values per document to return. By default, no feature importance calculation occurs.",
            "type": "number"
          },
          "prediction_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "randomize_seed": {
            "description": "Defines the seed for the random generator that is used to pick training data. By default, it is randomly generated. Set it to a specific value to use the same training data each time you start a job (assuming other related parameters such as `source` and `analyzed_fields` are the same).",
            "type": "number"
          },
          "soft_tree_depth_limit": {
            "description": "Advanced configuration option. Machine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly. This soft limit combines with the `soft_tree_depth_tolerance` to penalize trees that exceed the specified depth; the regularized loss increases quickly beyond this depth. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to 0.",
            "type": "number"
          },
          "soft_tree_depth_tolerance": {
            "description": "Advanced configuration option. This option controls how quickly the regularized loss increases when the tree depth exceeds `soft_tree_depth_limit`. By default, this value is calculated during hyperparameter optimization. It must be greater than or equal to 0.01.",
            "type": "number"
          },
          "training_percent": {
            "$ref": "#/components/schemas/_types:Percentage"
          }
        },
        "required": [
          "dependent_variable"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessor": {
        "type": "object",
        "properties": {
          "frequency_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorFrequencyEncoding"
          },
          "multi_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorMultiEncoding"
          },
          "n_gram_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorNGramEncoding"
          },
          "one_hot_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorOneHotEncoding"
          },
          "target_mean_encoding": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisFeatureProcessorTargetMeanEncoding"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeAnalysisFeatureProcessorFrequencyEncoding": {
        "type": "object",
        "properties": {
          "feature_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "frequency_map": {
            "description": "The resulting frequency map for the field value. If the field value is missing from the frequency_map, the resulting value is 0.",
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "feature_name",
          "field",
          "frequency_map"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorMultiEncoding": {
        "type": "object",
        "properties": {
          "processors": {
            "description": "The ordered array of custom processors to execute. Must be more than 1.",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "processors"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorNGramEncoding": {
        "type": "object",
        "properties": {
          "feature_prefix": {
            "description": "The feature name prefix. Defaults to ngram_<start>_<length>.",
            "type": "string"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "length": {
            "description": "Specifies the length of the n-gram substring. Defaults to 50. Must be greater than 0.",
            "type": "number"
          },
          "n_grams": {
            "description": "Specifies which n-grams to gather. Its an array of integer values where the minimum value is 1, and a maximum value is 5.",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "start": {
            "description": "Specifies the zero-indexed start of the n-gram substring. Negative values are allowed for encoding n-grams of string suffixes. Defaults to 0.",
            "type": "number"
          },
          "custom": {
            "type": "boolean"
          }
        },
        "required": [
          "field",
          "n_grams"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorOneHotEncoding": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "hot_map": {
            "description": "The one hot map mapping the field value with the column name.",
            "type": "string"
          }
        },
        "required": [
          "field",
          "hot_map"
        ]
      },
      "ml._types:DataframeAnalysisFeatureProcessorTargetMeanEncoding": {
        "type": "object",
        "properties": {
          "default_value": {
            "description": "The default value if field value is not found in the target_map.",
            "type": "number"
          },
          "feature_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "target_map": {
            "description": "The field value to target mean transition map.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "default_value",
          "feature_name",
          "field",
          "target_map"
        ]
      },
      "ml._types:DataframeAnalysisOutlierDetection": {
        "type": "object",
        "properties": {
          "compute_feature_influence": {
            "description": "Specifies whether the feature influence calculation is enabled.",
            "type": "boolean"
          },
          "feature_influence_threshold": {
            "description": "The minimum outlier score that a document needs to have in order to calculate its feature influence score. Value range: 0-1.",
            "type": "number"
          },
          "method": {
            "description": "The method that outlier detection uses. Available methods are `lof`, `ldof`, `distance_kth_nn`, `distance_knn`, and `ensemble`. The default value is ensemble, which means that outlier detection uses an ensemble of different methods and normalises and combines their individual outlier scores to obtain the overall outlier score.",
            "type": "string"
          },
          "n_neighbors": {
            "description": "Defines the value for how many nearest neighbors each method of outlier detection uses to calculate its outlier score. When the value is not set, different values are used for different ensemble members. This default behavior helps improve the diversity in the ensemble; only override it if you are confident that the value you choose is appropriate for the data set.",
            "type": "number"
          },
          "outlier_fraction": {
            "description": "The proportion of the data set that is assumed to be outlying prior to outlier detection. For example, 0.05 means it is assumed that 5% of values are real outliers and 95% are inliers.",
            "type": "number"
          },
          "standardization_enabled": {
            "description": "If true, the following operation is performed on the columns before computing outlier scores: `(x_i - mean(x_i)) / sd(x_i)`.",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeAnalysisRegression": {
        "allOf": [
          {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysis"
          },
          {
            "type": "object",
            "properties": {
              "loss_function": {
                "description": "The loss function used during regression. Available options are `mse` (mean squared error), `msle` (mean squared logarithmic error), `huber` (Pseudo-Huber loss).",
                "type": "string"
              },
              "loss_function_parameter": {
                "description": "A positive number that is used as a parameter to the `loss_function`.",
                "type": "number"
              }
            }
          }
        ]
      },
      "ml._types:DataframeAnalyticsFieldSelection": {
        "type": "object",
        "properties": {
          "is_included": {
            "description": "Whether the field is selected to be included in the analysis.",
            "type": "boolean"
          },
          "is_required": {
            "description": "Whether the field is required.",
            "type": "boolean"
          },
          "feature_type": {
            "description": "The feature type of this field for the analysis. May be categorical or numerical.",
            "type": "string"
          },
          "mapping_types": {
            "description": "The mapping types of the field.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "reason": {
            "description": "The reason a field is not selected to be included in the analysis.",
            "type": "string"
          }
        },
        "required": [
          "is_included",
          "is_required",
          "mapping_types",
          "name"
        ]
      },
      "ml._types:DataframeAnalyticsMemoryEstimation": {
        "type": "object",
        "properties": {
          "expected_memory_with_disk": {
            "description": "Estimated memory usage under the assumption that overflowing to disk is allowed during data frame analytics. expected_memory_with_disk is usually smaller than expected_memory_without_disk as using disk allows to limit the main memory needed to perform data frame analytics.",
            "type": "string"
          },
          "expected_memory_without_disk": {
            "description": "Estimated memory usage under the assumption that the whole data frame analytics should happen in memory (i.e. without overflowing to disk).",
            "type": "string"
          }
        },
        "required": [
          "expected_memory_with_disk",
          "expected_memory_without_disk"
        ]
      },
      "ml._types:Page": {
        "type": "object",
        "properties": {
          "from": {
            "description": "Skips the specified number of items.",
            "type": "number"
          },
          "size": {
            "description": "Specifies the maximum number of items to obtain.",
            "type": "number"
          }
        }
      },
      "ml._types:BucketSummary": {
        "type": "object",
        "properties": {
          "anomaly_score": {
            "description": "The maximum anomaly score, between 0-100, for any of the bucket influencers. This is an overall, rate-limited\nscore for the job. All the anomaly records in the bucket contribute to this score. This value might be updated as\nnew data is analyzed.",
            "type": "number"
          },
          "bucket_influencers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:BucketInfluencer"
            }
          },
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "event_count": {
            "description": "The number of input data records processed in this bucket.",
            "type": "number"
          },
          "initial_anomaly_score": {
            "description": "The maximum anomaly score for any of the bucket influencers. This is the initial value that was calculated at the\ntime the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "result_type": {
            "description": "Internal. This value is always set to bucket.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "anomaly_score",
          "bucket_influencers",
          "bucket_span",
          "event_count",
          "initial_anomaly_score",
          "is_interim",
          "job_id",
          "processing_time_ms",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:BucketInfluencer": {
        "type": "object",
        "properties": {
          "anomaly_score": {
            "description": "A normalized score between 0-100, which is calculated for each bucket influencer. This score might be updated as\nnewer data is analyzed.",
            "type": "number"
          },
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "influencer_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "initial_anomaly_score": {
            "description": "The score between 0-100 for each bucket influencer. This score is the initial value that was calculated at the\ntime the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "probability": {
            "description": "The probability that the bucket has this behavior, in the range 0 to 1. This value can be held to a high precision\nof over 300 decimal places, so the `anomaly_score` is provided as a human-readable and friendly interpretation of\nthis.",
            "type": "number"
          },
          "raw_anomaly_score": {
            "description": "Internal.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This value is always set to `bucket_influencer`.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "anomaly_score",
          "bucket_span",
          "influencer_field_name",
          "initial_anomaly_score",
          "is_interim",
          "job_id",
          "probability",
          "raw_anomaly_score",
          "result_type",
          "timestamp"
        ]
      },
      "_types:DurationValueUnitSeconds": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitSeconds"
          }
        ]
      },
      "ml._types:CalendarEvent": {
        "type": "object",
        "properties": {
          "calendar_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "event_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "description": {
            "description": "A description of the scheduled event.",
            "type": "string"
          },
          "end_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "description",
          "end_time",
          "start_time"
        ]
      },
      "ml.get_calendars:Calendar": {
        "type": "object",
        "properties": {
          "calendar_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "description": {
            "description": "A description of the calendar.",
            "type": "string"
          },
          "job_ids": {
            "description": "An array of anomaly detection job identifiers.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          }
        },
        "required": [
          "calendar_id",
          "job_ids"
        ]
      },
      "_types:CategoryId": {
        "type": "string"
      },
      "ml._types:Category": {
        "type": "object",
        "properties": {
          "category_id": {
            "$ref": "#/components/schemas/_types:ulong"
          },
          "examples": {
            "description": "A list of examples of actual values that matched the category.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "grok_pattern": {
            "description": "[experimental] A Grok pattern that could be used in Logstash or an ingest pipeline to extract fields from messages that match the category. This field is experimental and may be changed or removed in a future release. The Grok patterns that are found are not optimal, but are often a good starting point for manual tweaking.",
            "type": "string"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_matching_length": {
            "$ref": "#/components/schemas/_types:ulong"
          },
          "partition_field_name": {
            "description": "If per-partition categorization is enabled, this property identifies the field used to segment the categorization. It is not present when per-partition categorization is disabled.",
            "type": "string"
          },
          "partition_field_value": {
            "description": "If per-partition categorization is enabled, this property identifies the value of the partition_field_name for the category. It is not present when per-partition categorization is disabled.",
            "type": "string"
          },
          "regex": {
            "description": "A regular expression that is used to search for values that match the category.",
            "type": "string"
          },
          "terms": {
            "description": "A space separated list of the common tokens that are matched in values of the category.",
            "type": "string"
          },
          "num_matches": {
            "description": "The number of messages that have been matched by this category. This is only guaranteed to have the latest accurate count after a job _flush or _close",
            "type": "number"
          },
          "preferred_to_categories": {
            "description": "A list of category_id entries that this current category encompasses. Any new message that is processed by the categorizer will match against this category and not any of the categories in this list. This is only guaranteed to have the latest accurate list of categories after a job _flush or _close",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "p": {
            "type": "string"
          },
          "result_type": {
            "type": "string"
          },
          "mlcategory": {
            "type": "string"
          }
        },
        "required": [
          "category_id",
          "examples",
          "job_id",
          "max_matching_length",
          "regex",
          "terms",
          "result_type",
          "mlcategory"
        ]
      },
      "ml._types:DataframeAnalyticsSummary": {
        "type": "object",
        "properties": {
          "allow_lazy_start": {
            "type": "boolean"
          },
          "analysis": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
          },
          "analyzed_fields": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
          },
          "authorization": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsAuthorization"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "description": {
            "type": "string"
          },
          "dest": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsDestination"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_num_threads": {
            "type": "number"
          },
          "model_memory_limit": {
            "type": "string"
          },
          "source": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "analysis",
          "dest",
          "id",
          "source"
        ]
      },
      "ml._types:DataframeAnalyticsAuthorization": {
        "type": "object",
        "properties": {
          "api_key": {
            "$ref": "#/components/schemas/ml._types:ApiKeyAuthorization"
          },
          "roles": {
            "description": "If a user ID was used for the most recent update to the job, its roles at the time of the update are listed in the response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "service_account": {
            "description": "If a service account was used for the most recent update to the job, the account name is listed in the response.",
            "type": "string"
          }
        }
      },
      "ml._types:ApiKeyAuthorization": {
        "type": "object",
        "properties": {
          "id": {
            "description": "The identifier for the API key.",
            "type": "string"
          },
          "name": {
            "description": "The name of the API key.",
            "type": "string"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "ml._types:DataframeAnalytics": {
        "type": "object",
        "properties": {
          "analysis_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsContainer"
          },
          "assignment_explanation": {
            "description": "For running jobs only, contains messages relating to the selection of a node to run the job.",
            "type": "string"
          },
          "data_counts": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsDataCounts"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "memory_usage": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsMemoryUsage"
          },
          "progress": {
            "description": "The progress report of the data frame analytics job by phase.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsProgress"
            }
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DataframeState"
          }
        },
        "required": [
          "data_counts",
          "id",
          "memory_usage",
          "progress",
          "state"
        ]
      },
      "ml._types:DataframeAnalyticsStatsContainer": {
        "type": "object",
        "properties": {
          "classification_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsHyperparameters"
          },
          "outlier_detection_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsOutlierDetection"
          },
          "regression_stats": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsStatsHyperparameters"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:DataframeAnalyticsStatsHyperparameters": {
        "type": "object",
        "properties": {
          "hyperparameters": {
            "$ref": "#/components/schemas/ml._types:Hyperparameters"
          },
          "iteration": {
            "description": "The number of iterations on the analysis.",
            "type": "number"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:TimingStats"
          },
          "validation_loss": {
            "$ref": "#/components/schemas/ml._types:ValidationLoss"
          }
        },
        "required": [
          "hyperparameters",
          "iteration",
          "timestamp",
          "timing_stats",
          "validation_loss"
        ]
      },
      "ml._types:Hyperparameters": {
        "type": "object",
        "properties": {
          "alpha": {
            "description": "Advanced configuration option.\nMachine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly.\nThis parameter affects loss calculations by acting as a multiplier of the tree depth.\nHigher alpha values result in shallower trees and faster training times.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to zero.",
            "type": "number"
          },
          "lambda": {
            "description": "Advanced configuration option.\nRegularization parameter to prevent overfitting on the training data set.\nMultiplies an L2 regularization term which applies to leaf weights of the individual trees in the forest.\nA high lambda value causes training to favor small leaf weights.\nThis behavior makes the prediction function smoother at the expense of potentially not being able to capture relevant relationships between the features and the dependent variable.\nA small lambda value results in large individual trees and slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a nonnegative value.",
            "type": "number"
          },
          "gamma": {
            "description": "Advanced configuration option.\nRegularization parameter to prevent overfitting on the training data set.\nMultiplies a linear penalty associated with the size of individual trees in the forest.\nA high gamma value causes training to prefer small trees.\nA small gamma value results in larger individual trees and slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a nonnegative value.",
            "type": "number"
          },
          "eta": {
            "description": "Advanced configuration option.\nThe shrinkage applied to the weights.\nSmaller values result in larger forests which have a better generalization error.\nHowever, larger forests cause slower training.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be a value between `0.001` and `1`.",
            "type": "number"
          },
          "eta_growth_rate_per_tree": {
            "description": "Advanced configuration option.\nSpecifies the rate at which `eta` increases for each new tree that is added to the forest.\nFor example, a rate of 1.05 increases `eta` by 5% for each extra tree.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be between `0.5` and `2`.",
            "type": "number"
          },
          "feature_bag_fraction": {
            "description": "Advanced configuration option.\nDefines the fraction of features that will be used when selecting a random bag for each candidate split.\nBy default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "downsample_factor": {
            "description": "Advanced configuration option.\nControls the fraction of data that is used to compute the derivatives of the loss function for tree training.\nA small value results in the use of a small fraction of the data.\nIf this value is set to be less than 1, accuracy typically improves.\nHowever, too small a value may result in poor convergence for the ensemble and so require more trees.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than zero and less than or equal to 1.",
            "type": "number"
          },
          "max_attempts_to_add_tree": {
            "description": "If the algorithm fails to determine a non-trivial tree (more than a single leaf), this parameter determines how many of such consecutive failures are tolerated.\nOnce the number of attempts exceeds the threshold, the forest training stops.",
            "type": "number"
          },
          "max_optimization_rounds_per_hyperparameter": {
            "description": "Advanced configuration option.\nA multiplier responsible for determining the maximum number of hyperparameter optimization steps in the Bayesian optimization procedure.\nThe maximum number of steps is determined based on the number of undefined hyperparameters times the maximum optimization rounds per hyperparameter.\nBy default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "max_trees": {
            "description": "Advanced configuration option.\nDefines the maximum number of decision trees in the forest.\nThe maximum value is 2000.\nBy default, this value is calculated during hyperparameter optimization.",
            "type": "number"
          },
          "num_folds": {
            "description": "The maximum number of folds for the cross-validation procedure.",
            "type": "number"
          },
          "num_splits_per_feature": {
            "description": "Determines the maximum number of splits for every feature that can occur in a decision tree when the tree is trained.",
            "type": "number"
          },
          "soft_tree_depth_limit": {
            "description": "Advanced configuration option.\nMachine learning uses loss guided tree growing, which means that the decision trees grow where the regularized loss decreases most quickly.\nThis soft limit combines with the `soft_tree_depth_tolerance` to penalize trees that exceed the specified depth; the regularized loss increases quickly beyond this depth.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to 0.",
            "type": "number"
          },
          "soft_tree_depth_tolerance": {
            "description": "Advanced configuration option.\nThis option controls how quickly the regularized loss increases when the tree depth exceeds `soft_tree_depth_limit`.\nBy default, this value is calculated during hyperparameter optimization.\nIt must be greater than or equal to 0.01.",
            "type": "number"
          }
        }
      },
      "ml._types:TimingStats": {
        "type": "object",
        "properties": {
          "elapsed_time": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "iteration_time": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "elapsed_time"
        ]
      },
      "ml._types:ValidationLoss": {
        "type": "object",
        "properties": {
          "fold_values": {
            "description": "Validation loss values for every added decision tree during the forest growing procedure.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "loss_type": {
            "description": "The type of the loss metric. For example, binomial_logistic.",
            "type": "string"
          }
        },
        "required": [
          "fold_values",
          "loss_type"
        ]
      },
      "ml._types:DataframeAnalyticsStatsOutlierDetection": {
        "type": "object",
        "properties": {
          "parameters": {
            "$ref": "#/components/schemas/ml._types:OutlierDetectionParameters"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:TimingStats"
          }
        },
        "required": [
          "parameters",
          "timestamp",
          "timing_stats"
        ]
      },
      "ml._types:OutlierDetectionParameters": {
        "type": "object",
        "properties": {
          "compute_feature_influence": {
            "description": "Specifies whether the feature influence calculation is enabled.",
            "type": "boolean"
          },
          "feature_influence_threshold": {
            "description": "The minimum outlier score that a document needs to have in order to calculate its feature influence score.\nValue range: 0-1",
            "type": "number"
          },
          "method": {
            "description": "The method that outlier detection uses.\nAvailable methods are `lof`, `ldof`, `distance_kth_nn`, `distance_knn`, and `ensemble`.\nThe default value is ensemble, which means that outlier detection uses an ensemble of different methods and normalises and combines their individual outlier scores to obtain the overall outlier score.",
            "type": "string"
          },
          "n_neighbors": {
            "description": "Defines the value for how many nearest neighbors each method of outlier detection uses to calculate its outlier score.\nWhen the value is not set, different values are used for different ensemble members.\nThis default behavior helps improve the diversity in the ensemble; only override it if you are confident that the value you choose is appropriate for the data set.",
            "type": "number"
          },
          "outlier_fraction": {
            "description": "The proportion of the data set that is assumed to be outlying prior to outlier detection.\nFor example, 0.05 means it is assumed that 5% of values are real outliers and 95% are inliers.",
            "type": "number"
          },
          "standardization_enabled": {
            "description": "If `true`, the following operation is performed on the columns before computing outlier scores: (x_i - mean(x_i)) / sd(x_i).",
            "type": "boolean"
          }
        }
      },
      "ml._types:DataframeAnalyticsStatsDataCounts": {
        "type": "object",
        "properties": {
          "skipped_docs_count": {
            "description": "The number of documents that are skipped during the analysis because they contained values that are not supported by the analysis. For example, outlier detection does not support missing fields so it skips documents with missing fields. Likewise, all types of analysis skip documents that contain arrays with more than one element.",
            "type": "number"
          },
          "test_docs_count": {
            "description": "The number of documents that are not used for training the model and can be used for testing.",
            "type": "number"
          },
          "training_docs_count": {
            "description": "The number of documents that are used for training the model.",
            "type": "number"
          }
        },
        "required": [
          "skipped_docs_count",
          "test_docs_count",
          "training_docs_count"
        ]
      },
      "ml._types:DataframeAnalyticsStatsMemoryUsage": {
        "type": "object",
        "properties": {
          "memory_reestimate_bytes": {
            "description": "This value is present when the status is hard_limit and it is a new estimate of how much memory the job needs.",
            "type": "number"
          },
          "peak_usage_bytes": {
            "description": "The number of bytes used at the highest peak of memory usage.",
            "type": "number"
          },
          "status": {
            "description": "The memory usage status.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "peak_usage_bytes",
          "status"
        ]
      },
      "ml._types:DataframeAnalyticsStatsProgress": {
        "type": "object",
        "properties": {
          "phase": {
            "description": "Defines the phase of the data frame analytics job.",
            "type": "string"
          },
          "progress_percent": {
            "description": "The progress that the data frame analytics job has made expressed in percentage.",
            "type": "number"
          }
        },
        "required": [
          "phase",
          "progress_percent"
        ]
      },
      "ml._types:DataframeState": {
        "type": "string",
        "enum": [
          "started",
          "stopped",
          "starting",
          "stopping",
          "failed"
        ]
      },
      "ml._types:DatafeedStats": {
        "type": "object",
        "properties": {
          "assignment_explanation": {
            "description": "For started datafeeds only, contains messages relating to the selection of a node.",
            "type": "string"
          },
          "datafeed_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DatafeedState"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:DatafeedTimingStats"
          },
          "running_state": {
            "$ref": "#/components/schemas/ml._types:DatafeedRunningState"
          }
        },
        "required": [
          "datafeed_id",
          "state",
          "timing_stats"
        ]
      },
      "ml._types:DatafeedTimingStats": {
        "type": "object",
        "properties": {
          "bucket_count": {
            "description": "The number of buckets processed.",
            "type": "number"
          },
          "exponential_average_search_time_per_hour_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "search_count": {
            "description": "The number of searches run by the datafeed.",
            "type": "number"
          },
          "total_search_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "average_search_time_per_bucket_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          }
        },
        "required": [
          "bucket_count",
          "exponential_average_search_time_per_hour_ms",
          "job_id",
          "search_count",
          "total_search_time_ms"
        ]
      },
      "_types:DurationValueUnitFloatMillis": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:UnitFloatMillis"
          }
        ]
      },
      "_types:UnitFloatMillis": {
        "description": "Time unit for fractional milliseconds",
        "type": "number"
      },
      "ml._types:DatafeedRunningState": {
        "type": "object",
        "properties": {
          "real_time_configured": {
            "description": "Indicates if the datafeed is \"real-time\"; meaning that the datafeed has no configured `end` time.",
            "type": "boolean"
          },
          "real_time_running": {
            "description": "Indicates whether the datafeed has finished running on the available past data.\nFor datafeeds without a configured `end` time, this means that the datafeed is now running on \"real-time\" data.",
            "type": "boolean"
          },
          "search_interval": {
            "$ref": "#/components/schemas/ml._types:RunningStateSearchInterval"
          }
        },
        "required": [
          "real_time_configured",
          "real_time_running"
        ]
      },
      "ml._types:RunningStateSearchInterval": {
        "type": "object",
        "properties": {
          "end": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "end_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "start": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "start_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "end_ms",
          "start_ms"
        ]
      },
      "ml._types:Datafeed": {
        "type": "object",
        "properties": {
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "authorization": {
            "$ref": "#/components/schemas/ml._types:DatafeedAuthorization"
          },
          "chunking_config": {
            "$ref": "#/components/schemas/ml._types:ChunkingConfig"
          },
          "datafeed_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "frequency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "indices": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "indexes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_empty_searches": {
            "type": "number"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "query_delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "script_fields": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "scroll_size": {
            "type": "number"
          },
          "delayed_data_check_config": {
            "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "indices_options": {
            "$ref": "#/components/schemas/_types:IndicesOptions"
          }
        },
        "required": [
          "datafeed_id",
          "indices",
          "job_id",
          "query",
          "delayed_data_check_config"
        ]
      },
      "ml._types:DatafeedAuthorization": {
        "type": "object",
        "properties": {
          "api_key": {
            "$ref": "#/components/schemas/ml._types:ApiKeyAuthorization"
          },
          "roles": {
            "description": "If a user ID was used for the most recent update to the datafeed, its roles at the time of the update are listed in the response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "service_account": {
            "description": "If a service account was used for the most recent update to the datafeed, the account name is listed in the response.",
            "type": "string"
          }
        }
      },
      "ml._types:ChunkingConfig": {
        "type": "object",
        "properties": {
          "mode": {
            "$ref": "#/components/schemas/ml._types:ChunkingMode"
          },
          "time_span": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "mode"
        ]
      },
      "ml._types:ChunkingMode": {
        "type": "string",
        "enum": [
          "auto",
          "manual",
          "off"
        ]
      },
      "ml._types:DelayedDataCheckConfig": {
        "type": "object",
        "properties": {
          "check_window": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "enabled": {
            "description": "Specifies whether the datafeed periodically checks for delayed data.",
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "_types:IndicesOptions": {
        "type": "object",
        "properties": {
          "allow_no_indices": {
            "description": "If false, the request returns an error if any wildcard expression, index alias, or `_all` value targets only\nmissing or closed indices. This behavior applies even if the request targets other open indices. For example,\na request targeting `foo*,bar*` returns an error if an index starts with `foo` but no index starts with `bar`.",
            "type": "boolean"
          },
          "expand_wildcards": {
            "$ref": "#/components/schemas/_types:ExpandWildcards"
          },
          "ignore_unavailable": {
            "description": "If true, missing or closed indices are not included in the response.",
            "type": "boolean"
          },
          "ignore_throttled": {
            "description": "If true, concrete, expanded or aliased indices are ignored when frozen.",
            "type": "boolean"
          }
        }
      },
      "ml._types:Filter": {
        "type": "object",
        "properties": {
          "description": {
            "description": "A description of the filter.",
            "type": "string"
          },
          "filter_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "items": {
            "description": "An array of strings which is the filter item list.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "filter_id",
          "items"
        ]
      },
      "ml._types:Influencer": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "influencer_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the influencer in this bucket aggregated\nacross detectors. Unlike `initial_influencer_score`, this value is updated by a re-normalization process as new\ndata is analyzed.",
            "type": "number"
          },
          "influencer_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "influencer_field_value": {
            "description": "The entity that influenced, contributed to, or was to blame for the anomaly.",
            "type": "string"
          },
          "initial_influencer_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the influencer aggregated across detectors.\nThis is the initial value that was calculated at the time the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "probability": {
            "description": "The probability that the influencer has this behavior, in the range 0 to 1. This value can be held to a high\nprecision of over 300 decimal places, so the `influencer_score` is provided as a human-readable and friendly\ninterpretation of this value.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This value is always set to `influencer`.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "foo": {
            "description": "Additional influencer properties are added, depending on the fields being analyzed. For example, if its\nanalyzing `user_name` as an influencer, a field `user_name` is added to the result document. This\ninformation enables you to filter the anomaly results more easily.",
            "type": "string"
          }
        },
        "required": [
          "bucket_span",
          "influencer_score",
          "influencer_field_name",
          "influencer_field_value",
          "initial_influencer_score",
          "is_interim",
          "job_id",
          "probability",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:JobStats": {
        "type": "object",
        "properties": {
          "assignment_explanation": {
            "description": "For open anomaly detection jobs only, contains messages relating to the selection of a node to run the job.",
            "type": "string"
          },
          "data_counts": {
            "$ref": "#/components/schemas/ml._types:DataCounts"
          },
          "forecasts_stats": {
            "$ref": "#/components/schemas/ml._types:JobForecastStatistics"
          },
          "job_id": {
            "description": "Identifier for the anomaly detection job.",
            "type": "string"
          },
          "model_size_stats": {
            "$ref": "#/components/schemas/ml._types:ModelSizeStats"
          },
          "open_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:JobState"
          },
          "timing_stats": {
            "$ref": "#/components/schemas/ml._types:JobTimingStats"
          },
          "deleting": {
            "description": "Indicates that the process of deleting the job is in progress but not yet completed. It is only reported when `true`.",
            "type": "boolean"
          }
        },
        "required": [
          "data_counts",
          "forecasts_stats",
          "job_id",
          "model_size_stats",
          "state",
          "timing_stats"
        ]
      },
      "ml._types:DataCounts": {
        "type": "object",
        "properties": {
          "bucket_count": {
            "type": "number"
          },
          "earliest_record_timestamp": {
            "type": "number"
          },
          "empty_bucket_count": {
            "type": "number"
          },
          "input_bytes": {
            "type": "number"
          },
          "input_field_count": {
            "type": "number"
          },
          "input_record_count": {
            "type": "number"
          },
          "invalid_date_count": {
            "type": "number"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "last_data_time": {
            "type": "number"
          },
          "latest_empty_bucket_timestamp": {
            "type": "number"
          },
          "latest_record_timestamp": {
            "type": "number"
          },
          "latest_sparse_bucket_timestamp": {
            "type": "number"
          },
          "latest_bucket_timestamp": {
            "type": "number"
          },
          "log_time": {
            "type": "number"
          },
          "missing_field_count": {
            "type": "number"
          },
          "out_of_order_timestamp_count": {
            "type": "number"
          },
          "processed_field_count": {
            "type": "number"
          },
          "processed_record_count": {
            "type": "number"
          },
          "sparse_bucket_count": {
            "type": "number"
          }
        },
        "required": [
          "bucket_count",
          "empty_bucket_count",
          "input_bytes",
          "input_field_count",
          "input_record_count",
          "invalid_date_count",
          "job_id",
          "missing_field_count",
          "out_of_order_timestamp_count",
          "processed_field_count",
          "processed_record_count",
          "sparse_bucket_count"
        ]
      },
      "ml._types:JobForecastStatistics": {
        "type": "object",
        "properties": {
          "memory_bytes": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "processing_time_ms": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "records": {
            "$ref": "#/components/schemas/ml._types:JobStatistics"
          },
          "status": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "total": {
            "type": "number"
          },
          "forecasted_jobs": {
            "type": "number"
          }
        },
        "required": [
          "total",
          "forecasted_jobs"
        ]
      },
      "ml._types:JobStatistics": {
        "type": "object",
        "properties": {
          "avg": {
            "type": "number"
          },
          "max": {
            "type": "number"
          },
          "min": {
            "type": "number"
          },
          "total": {
            "type": "number"
          }
        },
        "required": [
          "avg",
          "max",
          "min",
          "total"
        ]
      },
      "ml._types:ModelSizeStats": {
        "type": "object",
        "properties": {
          "bucket_allocation_failures_count": {
            "type": "number"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "log_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "memory_status": {
            "$ref": "#/components/schemas/ml._types:MemoryStatus"
          },
          "model_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model_bytes_exceeded": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "model_bytes_memory_limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "peak_model_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "assignment_memory_basis": {
            "type": "string"
          },
          "result_type": {
            "type": "string"
          },
          "total_by_field_count": {
            "type": "number"
          },
          "total_over_field_count": {
            "type": "number"
          },
          "total_partition_field_count": {
            "type": "number"
          },
          "categorization_status": {
            "$ref": "#/components/schemas/ml._types:CategorizationStatus"
          },
          "categorized_doc_count": {
            "type": "number"
          },
          "dead_category_count": {
            "type": "number"
          },
          "failed_category_count": {
            "type": "number"
          },
          "frequent_category_count": {
            "type": "number"
          },
          "rare_category_count": {
            "type": "number"
          },
          "total_category_count": {
            "type": "number"
          },
          "timestamp": {
            "type": "number"
          }
        },
        "required": [
          "bucket_allocation_failures_count",
          "job_id",
          "log_time",
          "memory_status",
          "model_bytes",
          "result_type",
          "total_by_field_count",
          "total_over_field_count",
          "total_partition_field_count",
          "categorization_status",
          "categorized_doc_count",
          "dead_category_count",
          "failed_category_count",
          "frequent_category_count",
          "rare_category_count",
          "total_category_count"
        ]
      },
      "ml._types:JobTimingStats": {
        "type": "object",
        "properties": {
          "average_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "bucket_count": {
            "type": "number"
          },
          "exponential_average_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "exponential_average_bucket_processing_time_per_hour_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "total_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "maximum_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "minimum_bucket_processing_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          }
        },
        "required": [
          "bucket_count",
          "exponential_average_bucket_processing_time_per_hour_ms",
          "job_id",
          "total_bucket_processing_time_ms"
        ]
      },
      "ml._types:Job": {
        "type": "object",
        "properties": {
          "allow_lazy_open": {
            "description": "Advanced configuration option.\nSpecifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node.",
            "type": "boolean"
          },
          "analysis_config": {
            "$ref": "#/components/schemas/ml._types:AnalysisConfig"
          },
          "analysis_limits": {
            "$ref": "#/components/schemas/ml._types:AnalysisLimits"
          },
          "background_persist_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "blocked": {
            "$ref": "#/components/schemas/ml._types:JobBlocked"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "custom_settings": {
            "$ref": "#/components/schemas/ml._types:CustomSettings"
          },
          "daily_model_snapshot_retention_after_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies a period of time (in days) after which only the first snapshot per day is retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nValid values range from 0 to `model_snapshot_retention_days`.",
            "type": "number"
          },
          "data_description": {
            "$ref": "#/components/schemas/ml._types:DataDescription"
          },
          "datafeed_config": {
            "$ref": "#/components/schemas/ml._types:Datafeed"
          },
          "deleting": {
            "description": "Indicates that the process of deleting the job is in progress but not yet completed.\nIt is only reported when `true`.",
            "type": "boolean"
          },
          "description": {
            "description": "A description of the job.",
            "type": "string"
          },
          "finished_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "groups": {
            "description": "A list of job groups.\nA job can belong to no groups or many.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "job_type": {
            "description": "Reserved for future use, currently set to `anomaly_detector`.",
            "type": "string"
          },
          "job_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "model_plot_config": {
            "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
          },
          "model_snapshot_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "model_snapshot_retention_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies the maximum period of time (in days) that snapshots are retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nBy default, snapshots ten days older than the newest snapshot are deleted.",
            "type": "number"
          },
          "renormalization_window_days": {
            "description": "Advanced configuration option.\nThe period over which adjustments to the score are applied, as new data is seen.\nThe default value is the longer of 30 days or 100 `bucket_spans`.",
            "type": "number"
          },
          "results_index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "results_retention_days": {
            "description": "Advanced configuration option.\nThe period of time (in days) that results are retained.\nAge is calculated relative to the timestamp of the latest bucket result.\nIf this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch.\nThe default value is null, which means all results are retained.\nAnnotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results.\nAnnotations added by users are retained forever.",
            "type": "number"
          }
        },
        "required": [
          "allow_lazy_open",
          "analysis_config",
          "data_description",
          "job_id",
          "model_snapshot_retention_days",
          "results_index_name"
        ]
      },
      "ml._types:AnalysisLimits": {
        "type": "object",
        "properties": {
          "categorization_examples_limit": {
            "description": "The maximum number of examples stored per category in memory and in the results data store. If you increase this value, more examples are available, however it requires that you have more storage available. If you set this value to 0, no examples are stored. NOTE: The `categorization_examples_limit` applies only to analysis that uses categorization.",
            "type": "number"
          },
          "model_memory_limit": {
            "description": "The approximate maximum amount of memory resources that are required for analytical processing. Once this limit is approached, data pruning becomes more aggressive. Upon exceeding this limit, new entities are not modeled. If the `xpack.ml.max_model_memory_limit` setting has a value greater than 0 and less than 1024mb, that value is used instead of the default. The default value is relatively small to ensure that high resource usage is a conscious decision. If you have jobs that are expected to analyze high cardinality fields, you will likely need to use a higher value. If you specify a number instead of a string, the units are assumed to be MiB. Specifying a string is recommended for clarity. If you specify a byte size unit of `b` or `kb` and the number does not equate to a discrete number of megabytes, it is rounded down to the closest MiB. The minimum valid value is 1 MiB. If you specify a value less than 1 MiB, an error occurs. If you specify a value for the `xpack.ml.max_model_memory_limit` setting, an error occurs when you try to create jobs that have `model_memory_limit` values greater than that setting value.",
            "type": "string"
          }
        }
      },
      "ml._types:JobBlocked": {
        "type": "object",
        "properties": {
          "reason": {
            "$ref": "#/components/schemas/ml._types:JobBlockedReason"
          },
          "task_id": {
            "$ref": "#/components/schemas/_types:TaskId"
          }
        },
        "required": [
          "reason"
        ]
      },
      "ml._types:JobBlockedReason": {
        "type": "string",
        "enum": [
          "delete",
          "reset",
          "revert"
        ]
      },
      "ml._types:CustomSettings": {
        "description": "Custom metadata about the job",
        "type": "object"
      },
      "ml._types:DataDescription": {
        "type": "object",
        "properties": {
          "format": {
            "description": "Only JSON format is supported at this time.",
            "type": "string"
          },
          "time_field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "time_format": {
            "description": "The time format, which can be `epoch`, `epoch_ms`, or a custom pattern. The value `epoch` refers to UNIX or Epoch time (the number of seconds since 1 Jan 1970). The value `epoch_ms` indicates that time is measured in milliseconds since the epoch. The `epoch` and `epoch_ms` time formats accept either integer or real values. Custom patterns must conform to the Java DateTimeFormatter class. When you use date-time formatting patterns, it is recommended that you provide the full date, time and time zone. For example: `yyyy-MM-dd'T'HH:mm:ssX`. If the pattern that you specify is not sufficient to produce a complete timestamp, job creation fails.",
            "type": "string"
          },
          "field_delimiter": {
            "type": "string"
          }
        }
      },
      "ml._types:ModelPlotConfig": {
        "type": "object",
        "properties": {
          "annotations_enabled": {
            "description": "If true, enables calculation and storage of the model change annotations for each entity that is being analyzed.",
            "type": "boolean"
          },
          "enabled": {
            "description": "If true, enables calculation and storage of the model bounds for each entity that is being analyzed.",
            "type": "boolean"
          },
          "terms": {
            "$ref": "#/components/schemas/_types:Field"
          }
        }
      },
      "ml.get_memory_stats:Memory": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "jvm": {
            "$ref": "#/components/schemas/ml.get_memory_stats:JvmStats"
          },
          "mem": {
            "$ref": "#/components/schemas/ml.get_memory_stats:MemStats"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "description": "Roles assigned to the node.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "ephemeral_id": {
            "$ref": "#/components/schemas/_types:Id"
          }
        },
        "required": [
          "attributes",
          "jvm",
          "mem",
          "name",
          "roles",
          "transport_address",
          "ephemeral_id"
        ]
      },
      "ml.get_memory_stats:JvmStats": {
        "type": "object",
        "properties": {
          "heap_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "heap_max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "java_inference": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "java_inference_in_bytes": {
            "description": "Amount of Java heap, in bytes, currently being used for caching inference models.",
            "type": "number"
          },
          "java_inference_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "java_inference_max_in_bytes": {
            "description": "Maximum amount of Java heap, in bytes, to be used for caching inference models.",
            "type": "number"
          }
        },
        "required": [
          "heap_max_in_bytes",
          "java_inference_in_bytes",
          "java_inference_max_in_bytes"
        ]
      },
      "ml.get_memory_stats:MemStats": {
        "type": "object",
        "properties": {
          "adjusted_total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "adjusted_total_in_bytes": {
            "description": "If the amount of physical memory has been overridden using the `es.total_memory_bytes` system property\nthen this reports the overridden value in bytes. Otherwise it reports the same value as `total_in_bytes`.",
            "type": "number"
          },
          "total": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "total_in_bytes": {
            "description": "Total amount of physical memory in bytes.",
            "type": "number"
          },
          "ml": {
            "$ref": "#/components/schemas/ml.get_memory_stats:MemMlStats"
          }
        },
        "required": [
          "adjusted_total_in_bytes",
          "total_in_bytes",
          "ml"
        ]
      },
      "ml.get_memory_stats:MemMlStats": {
        "type": "object",
        "properties": {
          "anomaly_detectors": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "anomaly_detectors_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for anomaly detection jobs.",
            "type": "number"
          },
          "data_frame_analytics": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "data_frame_analytics_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for data frame analytics jobs.",
            "type": "number"
          },
          "max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_in_bytes": {
            "description": "Maximum amount of native memory (separate to the JVM heap), in bytes, that may be used by machine learning native processes.",
            "type": "number"
          },
          "native_code_overhead": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "native_code_overhead_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for loading machine learning native code shared libraries.",
            "type": "number"
          },
          "native_inference": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "native_inference_in_bytes": {
            "description": "Amount of native memory, in bytes, set aside for trained models that have a PyTorch model_type.",
            "type": "number"
          }
        },
        "required": [
          "anomaly_detectors_in_bytes",
          "data_frame_analytics_in_bytes",
          "max_in_bytes",
          "native_code_overhead_in_bytes",
          "native_inference_in_bytes"
        ]
      },
      "ml._types:ModelSnapshotUpgrade": {
        "type": "object",
        "properties": {
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "snapshot_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:SnapshotUpgradeState"
          },
          "assignment_explanation": {
            "type": "string"
          }
        },
        "required": [
          "job_id",
          "snapshot_id",
          "state",
          "assignment_explanation"
        ]
      },
      "ml._types:SnapshotUpgradeState": {
        "type": "string",
        "enum": [
          "loading_old_state",
          "saving_new_state",
          "stopped",
          "failed"
        ]
      },
      "ml._types:ModelSnapshot": {
        "type": "object",
        "properties": {
          "description": {
            "description": "An optional description of the job.",
            "type": "string"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "latest_record_time_stamp": {
            "description": "The timestamp of the latest processed record.",
            "type": "number"
          },
          "latest_result_time_stamp": {
            "description": "The timestamp of the latest bucket result.",
            "type": "number"
          },
          "min_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "model_size_stats": {
            "$ref": "#/components/schemas/ml._types:ModelSizeStats"
          },
          "retain": {
            "description": "If true, this snapshot will not be deleted during automatic cleanup of snapshots older than model_snapshot_retention_days. However, this snapshot will be deleted when the job is deleted. The default value is false.",
            "type": "boolean"
          },
          "snapshot_doc_count": {
            "description": "For internal use only.",
            "type": "number"
          },
          "snapshot_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "timestamp": {
            "description": "The creation timestamp for the snapshot.",
            "type": "number"
          }
        },
        "required": [
          "job_id",
          "min_version",
          "retain",
          "snapshot_doc_count",
          "snapshot_id",
          "timestamp"
        ]
      },
      "ml._types:OverallBucket": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "jobs": {
            "description": "An array of objects that contain the max_anomaly_score per job_id.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:OverallBucketJob"
            }
          },
          "overall_score": {
            "description": "The top_n average of the maximum bucket anomaly_score per job.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This is always set to overall_bucket.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp_string": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "bucket_span",
          "is_interim",
          "jobs",
          "overall_score",
          "result_type",
          "timestamp",
          "timestamp_string"
        ]
      },
      "ml._types:OverallBucketJob": {
        "type": "object",
        "properties": {
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_anomaly_score": {
            "type": "number"
          }
        },
        "required": [
          "job_id",
          "max_anomaly_score"
        ]
      },
      "ml._types:Anomaly": {
        "type": "object",
        "properties": {
          "actual": {
            "description": "The actual value for the bucket.",
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "anomaly_score_explanation": {
            "$ref": "#/components/schemas/ml._types:AnomalyExplanation"
          },
          "bucket_span": {
            "$ref": "#/components/schemas/_types:DurationValueUnitSeconds"
          },
          "by_field_name": {
            "description": "The field used to split the data. In particular, this property is used for analyzing the splits with respect to their own history. It is used for finding unusual values in the context of the split.",
            "type": "string"
          },
          "by_field_value": {
            "description": "The value of `by_field_name`.",
            "type": "string"
          },
          "causes": {
            "description": "For population analysis, an over field must be specified in the detector. This property contains an array of anomaly records that are the causes for the anomaly that has been identified for the over field. This sub-resource contains the most anomalous records for the `over_field_name`. For scalability reasons, a maximum of the 10 most significant causes of the anomaly are returned. As part of the core analytical modeling, these low-level anomaly records are aggregated for their parent over field record. The `causes` resource contains similar elements to the record resource, namely `actual`, `typical`, `geo_results.actual_point`, `geo_results.typical_point`, `*_field_name` and `*_field_value`. Probability and scores are not applicable to causes.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:AnomalyCause"
            }
          },
          "detector_index": {
            "description": "A unique identifier for the detector.",
            "type": "number"
          },
          "field_name": {
            "description": "Certain functions require a field to operate on, for example, `sum()`. For those functions, this value is the name of the field to be analyzed.",
            "type": "string"
          },
          "function": {
            "description": "The function in which the anomaly occurs, as specified in the detector configuration. For example, `max`.",
            "type": "string"
          },
          "function_description": {
            "description": "The description of the function in which the anomaly occurs, as specified in the detector configuration.",
            "type": "string"
          },
          "geo_results": {
            "$ref": "#/components/schemas/ml._types:GeoResults"
          },
          "influencers": {
            "description": "If influencers were specified in the detector configuration, this array contains influencers that contributed to or were to blame for an anomaly.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Influence"
            }
          },
          "initial_record_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the anomalousness of this record. This is the initial value that was calculated at the time the bucket was processed.",
            "type": "number"
          },
          "is_interim": {
            "description": "If true, this is an interim result. In other words, the results are calculated based on partial input data.",
            "type": "boolean"
          },
          "job_id": {
            "description": "Identifier for the anomaly detection job.",
            "type": "string"
          },
          "over_field_name": {
            "description": "The field used to split the data. In particular, this property is used for analyzing the splits with respect to the history of all splits. It is used for finding unusual values in the population of all splits.",
            "type": "string"
          },
          "over_field_value": {
            "description": "The value of `over_field_name`.",
            "type": "string"
          },
          "partition_field_name": {
            "description": "The field used to segment the analysis. When you use this property, you have completely independent baselines for each value of this field.",
            "type": "string"
          },
          "partition_field_value": {
            "description": "The value of `partition_field_name`.",
            "type": "string"
          },
          "probability": {
            "description": "The probability of the individual anomaly occurring, in the range 0 to 1. For example, `0.0000772031`. This value can be held to a high precision of over 300 decimal places, so the `record_score` is provided as a human-readable and friendly interpretation of this.",
            "type": "number"
          },
          "record_score": {
            "description": "A normalized score between 0-100, which is based on the probability of the anomalousness of this record. Unlike `initial_record_score`, this value will be updated by a re-normalization process as new data is analyzed.",
            "type": "number"
          },
          "result_type": {
            "description": "Internal. This is always set to `record`.",
            "type": "string"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "typical": {
            "description": "The typical value for the bucket, according to analytical modeling.",
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "bucket_span",
          "detector_index",
          "initial_record_score",
          "is_interim",
          "job_id",
          "probability",
          "record_score",
          "result_type",
          "timestamp"
        ]
      },
      "ml._types:AnomalyExplanation": {
        "type": "object",
        "properties": {
          "anomaly_characteristics_impact": {
            "description": "Impact from the duration and magnitude of the detected anomaly relative to the historical average.",
            "type": "number"
          },
          "anomaly_length": {
            "description": "Length of the detected anomaly in the number of buckets.",
            "type": "number"
          },
          "anomaly_type": {
            "description": "Type of the detected anomaly: `spike` or `dip`.",
            "type": "string"
          },
          "high_variance_penalty": {
            "description": "Indicates reduction of anomaly score for the bucket with large confidence intervals. If a bucket has large confidence intervals, the score is reduced.",
            "type": "boolean"
          },
          "incomplete_bucket_penalty": {
            "description": "If the bucket contains fewer samples than expected, the score is reduced.",
            "type": "boolean"
          },
          "lower_confidence_bound": {
            "description": "Lower bound of the 95% confidence interval.",
            "type": "number"
          },
          "multi_bucket_impact": {
            "description": "Impact of the deviation between actual and typical values in the past 12 buckets.",
            "type": "number"
          },
          "single_bucket_impact": {
            "description": "Impact of the deviation between actual and typical values in the current bucket.",
            "type": "number"
          },
          "typical_value": {
            "description": "Typical (expected) value for this bucket.",
            "type": "number"
          },
          "upper_confidence_bound": {
            "description": "Upper bound of the 95% confidence interval.",
            "type": "number"
          }
        }
      },
      "ml._types:AnomalyCause": {
        "type": "object",
        "properties": {
          "actual": {
            "type": "array",
            "items": {
              "type": "number"
            }
          },
          "by_field_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "by_field_value": {
            "type": "string"
          },
          "correlated_by_field_value": {
            "type": "string"
          },
          "field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "function": {
            "type": "string"
          },
          "function_description": {
            "type": "string"
          },
          "influencers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Influence"
            }
          },
          "over_field_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "over_field_value": {
            "type": "string"
          },
          "partition_field_name": {
            "type": "string"
          },
          "partition_field_value": {
            "type": "string"
          },
          "probability": {
            "type": "number"
          },
          "typical": {
            "type": "array",
            "items": {
              "type": "number"
            }
          }
        },
        "required": [
          "actual",
          "by_field_name",
          "by_field_value",
          "correlated_by_field_value",
          "field_name",
          "function",
          "function_description",
          "influencers",
          "over_field_name",
          "over_field_value",
          "partition_field_name",
          "partition_field_value",
          "probability",
          "typical"
        ]
      },
      "ml._types:Influence": {
        "type": "object",
        "properties": {
          "influencer_field_name": {
            "type": "string"
          },
          "influencer_field_values": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "influencer_field_name",
          "influencer_field_values"
        ]
      },
      "ml._types:GeoResults": {
        "type": "object",
        "properties": {
          "actual_point": {
            "description": "The actual value for the bucket formatted as a `geo_point`.",
            "type": "string"
          },
          "typical_point": {
            "description": "The typical value for the bucket formatted as a `geo_point`.",
            "type": "string"
          }
        },
        "required": [
          "actual_point",
          "typical_point"
        ]
      },
      "ml._types:Include": {
        "type": "string",
        "enum": [
          "definition",
          "feature_importance_baseline",
          "hyperparameters",
          "total_feature_importance",
          "definition_status"
        ]
      },
      "ml._types:TrainedModelConfig": {
        "type": "object",
        "properties": {
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "model_type": {
            "$ref": "#/components/schemas/ml._types:TrainedModelType"
          },
          "tags": {
            "description": "A comma delimited string of tags. A trained model can have many tags, or none.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "compressed_definition": {
            "type": "string"
          },
          "created_by": {
            "description": "Information on the creator of the trained model.",
            "type": "string"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "default_field_map": {
            "description": "Any field map described in the inference configuration takes precedence.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "description": {
            "description": "The free-text description of the trained model.",
            "type": "string"
          },
          "estimated_heap_memory_usage_bytes": {
            "description": "The estimated heap usage in bytes to keep the trained model in memory.",
            "type": "number"
          },
          "estimated_operations": {
            "description": "The estimated number of operations to use the trained model.",
            "type": "number"
          },
          "fully_defined": {
            "description": "True if the full model definition is present.",
            "type": "boolean"
          },
          "inference_config": {
            "$ref": "#/components/schemas/ml._types:InferenceConfigCreateContainer"
          },
          "input": {
            "$ref": "#/components/schemas/ml._types:TrainedModelConfigInput"
          },
          "license_level": {
            "description": "The license level of the trained model.",
            "type": "string"
          },
          "metadata": {
            "$ref": "#/components/schemas/ml._types:TrainedModelConfigMetadata"
          },
          "model_size_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "location": {
            "$ref": "#/components/schemas/ml._types:TrainedModelLocation"
          }
        },
        "required": [
          "model_id",
          "tags",
          "input"
        ]
      },
      "ml._types:TrainedModelType": {
        "type": "string",
        "enum": [
          "tree_ensemble",
          "lang_ident",
          "pytorch"
        ]
      },
      "ml._types:InferenceConfigCreateContainer": {
        "description": "Inference configuration provided when storing the model config",
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ml._types:RegressionInferenceOptions"
          },
          "classification": {
            "$ref": "#/components/schemas/ml._types:ClassificationInferenceOptions"
          },
          "text_classification": {
            "$ref": "#/components/schemas/ml._types:TextClassificationInferenceOptions"
          },
          "zero_shot_classification": {
            "$ref": "#/components/schemas/ml._types:ZeroShotClassificationInferenceOptions"
          },
          "fill_mask": {
            "$ref": "#/components/schemas/ml._types:FillMaskInferenceOptions"
          },
          "ner": {
            "$ref": "#/components/schemas/ml._types:NerInferenceOptions"
          },
          "pass_through": {
            "$ref": "#/components/schemas/ml._types:PassThroughInferenceOptions"
          },
          "text_embedding": {
            "$ref": "#/components/schemas/ml._types:TextEmbeddingInferenceOptions"
          },
          "text_expansion": {
            "$ref": "#/components/schemas/ml._types:TextExpansionInferenceOptions"
          },
          "question_answering": {
            "$ref": "#/components/schemas/ml._types:QuestionAnsweringInferenceOptions"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:TextClassificationInferenceOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "classification_labels": {
            "description": "Classification labels to apply other than the stored labels. Must have the same deminsions as the default configured labels",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ml._types:TokenizationConfigContainer": {
        "description": "Tokenization options stored in inference configuration",
        "type": "object",
        "properties": {
          "bert": {
            "$ref": "#/components/schemas/ml._types:NlpBertTokenizationConfig"
          },
          "mpnet": {
            "$ref": "#/components/schemas/ml._types:NlpBertTokenizationConfig"
          },
          "roberta": {
            "$ref": "#/components/schemas/ml._types:NlpRobertaTokenizationConfig"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:NlpBertTokenizationConfig": {
        "type": "object",
        "properties": {
          "do_lower_case": {
            "description": "Should the tokenizer lower case the text",
            "type": "boolean"
          },
          "with_special_tokens": {
            "description": "Is tokenization completed with special tokens",
            "type": "boolean"
          },
          "max_sequence_length": {
            "description": "Maximum input sequence length for the model",
            "type": "number"
          },
          "truncate": {
            "$ref": "#/components/schemas/ml._types:TokenizationTruncate"
          },
          "span": {
            "description": "Tokenization spanning options. Special value of -1 indicates no spanning takes place",
            "type": "number"
          }
        }
      },
      "ml._types:TokenizationTruncate": {
        "type": "string",
        "enum": [
          "first",
          "second",
          "none"
        ]
      },
      "ml._types:NlpRobertaTokenizationConfig": {
        "type": "object",
        "properties": {
          "add_prefix_space": {
            "description": "Should the tokenizer prefix input with a space character",
            "type": "boolean"
          },
          "with_special_tokens": {
            "description": "Is tokenization completed with special tokens",
            "type": "boolean"
          },
          "max_sequence_length": {
            "description": "Maximum input sequence length for the model",
            "type": "number"
          },
          "truncate": {
            "$ref": "#/components/schemas/ml._types:TokenizationTruncate"
          },
          "span": {
            "description": "Tokenization spanning options. Special value of -1 indicates no spanning takes place",
            "type": "number"
          }
        }
      },
      "ml._types:ZeroShotClassificationInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "hypothesis_template": {
            "description": "Hypothesis template used when tokenizing labels for prediction",
            "type": "string"
          },
          "classification_labels": {
            "description": "The zero shot classification labels indicating entailment, neutral, and contradiction\nMust contain exactly and only entailment, neutral, and contradiction",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "multi_label": {
            "description": "Indicates if more than one true label exists.",
            "type": "boolean"
          },
          "labels": {
            "description": "The labels to predict.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "classification_labels"
        ]
      },
      "ml._types:FillMaskInferenceOptions": {
        "type": "object",
        "properties": {
          "mask_token": {
            "description": "The string/token which will be removed from incoming documents and replaced with the inference prediction(s).\nIn a response, this field contains the mask token for the specified model/tokenizer. Each model and tokenizer\nhas a predefined mask token which cannot be changed. Thus, it is recommended not to set this value in requests.\nHowever, if this field is present in a request, its value must match the predefined value for that model/tokenizer,\notherwise the request will fail.",
            "type": "string"
          },
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:NerInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "classification_labels": {
            "description": "The token classification labels. Must be IOB formatted tags",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        }
      },
      "ml._types:Vocabulary": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:PassThroughInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "vocabulary": {
            "$ref": "#/components/schemas/ml._types:Vocabulary"
          }
        }
      },
      "ml._types:TextEmbeddingInferenceOptions": {
        "type": "object",
        "properties": {
          "embedding_size": {
            "description": "The number of dimensions in the embedding output",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:TextExpansionInferenceOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:QuestionAnsweringInferenceOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:TokenizationConfigContainer"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "max_answer_length": {
            "description": "The maximum answer length to consider",
            "type": "number"
          }
        }
      },
      "ml._types:TrainedModelConfigInput": {
        "type": "object",
        "properties": {
          "field_names": {
            "description": "An array of input field names for the model.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          }
        },
        "required": [
          "field_names"
        ]
      },
      "ml._types:TrainedModelConfigMetadata": {
        "type": "object",
        "properties": {
          "model_aliases": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_importance_baseline": {
            "description": "An object that contains the baseline for feature importance values. For regression analysis, it is a single value. For classification analysis, there is a value for each class.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "hyperparameters": {
            "description": "List of the available hyperparameters optimized during the fine_parameter_tuning phase as well as specified by the user.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:Hyperparameter"
            }
          },
          "total_feature_importance": {
            "description": "An array of the total feature importance for each feature used from the training data set. This array of objects is returned if data frame analytics trained the model and the request includes total_feature_importance in the include request parameter.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportance"
            }
          }
        }
      },
      "ml._types:Hyperparameter": {
        "type": "object",
        "properties": {
          "absolute_importance": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/machine-learning/current/dfa-regression-lossfunction.html"
            },
            "description": "A positive number showing how much the parameter influences the variation of the loss function. For hyperparameters with values that are not specified by the user but tuned during hyperparameter optimization.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "relative_importance": {
            "description": "A number between 0 and 1 showing the proportion of influence on the variation of the loss function among all tuned hyperparameters. For hyperparameters with values that are not specified by the user but tuned during hyperparameter optimization.",
            "type": "number"
          },
          "supplied": {
            "description": "Indicates if the hyperparameter is specified by the user (true) or optimized (false).",
            "type": "boolean"
          },
          "value": {
            "description": "The value of the hyperparameter, either optimized or specified by the user.",
            "type": "number"
          }
        },
        "required": [
          "name",
          "supplied",
          "value"
        ]
      },
      "ml._types:TotalFeatureImportance": {
        "type": "object",
        "properties": {
          "feature_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "importance": {
            "description": "A collection of feature importance statistics related to the training data set for this particular feature.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportanceStatistics"
            }
          },
          "classes": {
            "description": "If the trained model is a classification model, feature importance statistics are gathered per target class value.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportanceClass"
            }
          }
        },
        "required": [
          "feature_name",
          "importance",
          "classes"
        ]
      },
      "ml._types:TotalFeatureImportanceStatistics": {
        "type": "object",
        "properties": {
          "mean_magnitude": {
            "description": "The average magnitude of this feature across all the training data. This value is the average of the absolute values of the importance for this feature.",
            "type": "number"
          },
          "max": {
            "description": "The maximum importance value across all the training data for this feature.",
            "type": "number"
          },
          "min": {
            "description": "The minimum importance value across all the training data for this feature.",
            "type": "number"
          }
        },
        "required": [
          "mean_magnitude",
          "max",
          "min"
        ]
      },
      "ml._types:TotalFeatureImportanceClass": {
        "type": "object",
        "properties": {
          "class_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "importance": {
            "description": "A collection of feature importance statistics related to the training data set for this particular feature.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TotalFeatureImportanceStatistics"
            }
          }
        },
        "required": [
          "class_name",
          "importance"
        ]
      },
      "ml._types:TrainedModelLocation": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/ml._types:TrainedModelLocationIndex"
          }
        },
        "required": [
          "index"
        ]
      },
      "ml._types:TrainedModelLocationIndex": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "name"
        ]
      },
      "ml._types:TrainedModelStats": {
        "type": "object",
        "properties": {
          "deployment_stats": {
            "$ref": "#/components/schemas/ml._types:TrainedModelDeploymentStats"
          },
          "inference_stats": {
            "$ref": "#/components/schemas/ml._types:TrainedModelInferenceStats"
          },
          "ingest": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/cluster-nodes-stats.html"
            },
            "description": "A collection of ingest stats for the model across all nodes.\nThe values are summations of the individual node statistics.\nThe format matches the ingest section in the nodes stats API.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "model_size_stats": {
            "$ref": "#/components/schemas/ml._types:TrainedModelSizeStats"
          },
          "pipeline_count": {
            "description": "The number of ingest pipelines that currently refer to the model.",
            "type": "number"
          }
        },
        "required": [
          "model_id",
          "model_size_stats",
          "pipeline_count"
        ]
      },
      "ml._types:TrainedModelDeploymentStats": {
        "type": "object",
        "properties": {
          "allocation_status": {
            "$ref": "#/components/schemas/ml._types:TrainedModelDeploymentAllocationStatus"
          },
          "cache_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "deployment_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "error_count": {
            "description": "The sum of `error_count` for all nodes in the deployment.",
            "type": "number"
          },
          "inference_count": {
            "description": "The sum of `inference_count` for all nodes in the deployment.",
            "type": "number"
          },
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "nodes": {
            "$ref": "#/components/schemas/ml._types:TrainedModelDeploymentNodesStats"
          },
          "number_of_allocations": {
            "description": "The number of allocations requested.",
            "type": "number"
          },
          "queue_capacity": {
            "description": "The number of inference requests that can be queued before new requests are rejected.",
            "type": "number"
          },
          "rejected_execution_count": {
            "description": "The sum of `rejected_execution_count` for all nodes in the deployment.\nIndividual nodes reject an inference request if the inference queue is full.\nThe queue size is controlled by the `queue_capacity` setting in the start\ntrained model deployment API.",
            "type": "number"
          },
          "reason": {
            "description": "The reason for the current deployment state. Usually only populated when\nthe model is not deployed to a node.",
            "type": "string"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DeploymentState"
          },
          "threads_per_allocation": {
            "description": "The number of threads used be each allocation during inference.",
            "type": "number"
          },
          "timeout_count": {
            "description": "The sum of `timeout_count` for all nodes in the deployment.",
            "type": "number"
          }
        },
        "required": [
          "allocation_status",
          "deployment_id",
          "error_count",
          "inference_count",
          "model_id",
          "nodes",
          "number_of_allocations",
          "queue_capacity",
          "rejected_execution_count",
          "reason",
          "start_time",
          "state",
          "threads_per_allocation",
          "timeout_count"
        ]
      },
      "ml._types:TrainedModelDeploymentAllocationStatus": {
        "type": "object",
        "properties": {
          "allocation_count": {
            "description": "The current number of nodes where the model is allocated.",
            "type": "number"
          },
          "state": {
            "$ref": "#/components/schemas/ml._types:DeploymentAllocationState"
          },
          "target_allocation_count": {
            "description": "The desired number of nodes for model allocation.",
            "type": "number"
          }
        },
        "required": [
          "allocation_count",
          "state",
          "target_allocation_count"
        ]
      },
      "ml._types:DeploymentAllocationState": {
        "type": "string",
        "enum": [
          "started",
          "starting",
          "fully_allocated"
        ]
      },
      "ml._types:TrainedModelDeploymentNodesStats": {
        "type": "object",
        "properties": {
          "average_inference_time_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "error_count": {
            "description": "The number of errors when evaluating the trained model.",
            "type": "number"
          },
          "inference_count": {
            "description": "The total number of inference calls made against this node for this model.",
            "type": "number"
          },
          "last_access": {
            "description": "The epoch time stamp of the last inference call for the model on this node.",
            "type": "number"
          },
          "number_of_allocations": {
            "description": "The number of allocations assigned to this node.",
            "type": "number"
          },
          "number_of_pending_requests": {
            "description": "The number of inference requests queued to be processed.",
            "type": "number"
          },
          "rejection_execution_count": {
            "description": "The number of inference requests that were not processed because the queue was full.",
            "type": "number"
          },
          "routing_state": {
            "$ref": "#/components/schemas/ml._types:TrainedModelAssignmentRoutingTable"
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "threads_per_allocation": {
            "description": "The number of threads used by each allocation during inference.",
            "type": "number"
          },
          "timeout_count": {
            "description": "The number of inference requests that timed out before being processed.",
            "type": "number"
          }
        },
        "required": [
          "average_inference_time_ms",
          "error_count",
          "inference_count",
          "last_access",
          "number_of_allocations",
          "number_of_pending_requests",
          "rejection_execution_count",
          "routing_state",
          "start_time",
          "threads_per_allocation",
          "timeout_count"
        ]
      },
      "ml._types:TrainedModelAssignmentRoutingTable": {
        "type": "object",
        "properties": {
          "reason": {
            "description": "The reason for the current state. It is usually populated only when the\n`routing_state` is `failed`.",
            "type": "string"
          },
          "routing_state": {
            "$ref": "#/components/schemas/ml._types:RoutingState"
          },
          "current_allocations": {
            "description": "Current number of allocations.",
            "type": "number"
          },
          "target_allocations": {
            "description": "Target number of allocations.",
            "type": "number"
          }
        },
        "required": [
          "reason",
          "routing_state",
          "current_allocations",
          "target_allocations"
        ]
      },
      "ml._types:RoutingState": {
        "type": "string",
        "enum": [
          "failed",
          "started",
          "starting",
          "stopped",
          "stopping"
        ]
      },
      "ml._types:DeploymentState": {
        "type": "string",
        "enum": [
          "started",
          "starting",
          "stopping"
        ]
      },
      "ml._types:TrainedModelInferenceStats": {
        "type": "object",
        "properties": {
          "cache_miss_count": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-settings.html"
            },
            "description": "The number of times the model was loaded for inference and was not retrieved from the cache.\nIf this number is close to the `inference_count`, the cache is not being appropriately used.\nThis can be solved by increasing the cache size or its time-to-live (TTL).\nRefer to general machine learning settings for the appropriate settings.",
            "type": "number"
          },
          "failure_count": {
            "description": "The number of failures when using the model for inference.",
            "type": "number"
          },
          "inference_count": {
            "description": "The total number of times the model has been called for inference.\nThis is across all inference contexts, including all pipelines.",
            "type": "number"
          },
          "missing_all_fields_count": {
            "description": "The number of inference calls where all the training features for the model were missing.",
            "type": "number"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          }
        },
        "required": [
          "cache_miss_count",
          "failure_count",
          "inference_count",
          "missing_all_fields_count",
          "timestamp"
        ]
      },
      "ml._types:TrainedModelSizeStats": {
        "type": "object",
        "properties": {
          "model_size_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "required_native_memory_bytes": {
            "description": "The amount of memory required to load the model in bytes.",
            "type": "number"
          }
        },
        "required": [
          "model_size_bytes",
          "required_native_memory_bytes"
        ]
      },
      "ml._types:InferenceConfigUpdateContainer": {
        "type": "object",
        "properties": {
          "regression": {
            "$ref": "#/components/schemas/ml._types:RegressionInferenceOptions"
          },
          "classification": {
            "$ref": "#/components/schemas/ml._types:ClassificationInferenceOptions"
          },
          "text_classification": {
            "$ref": "#/components/schemas/ml._types:TextClassificationInferenceUpdateOptions"
          },
          "zero_shot_classification": {
            "$ref": "#/components/schemas/ml._types:ZeroShotClassificationInferenceUpdateOptions"
          },
          "fill_mask": {
            "$ref": "#/components/schemas/ml._types:FillMaskInferenceUpdateOptions"
          },
          "ner": {
            "$ref": "#/components/schemas/ml._types:NerInferenceUpdateOptions"
          },
          "pass_through": {
            "$ref": "#/components/schemas/ml._types:PassThroughInferenceUpdateOptions"
          },
          "text_embedding": {
            "$ref": "#/components/schemas/ml._types:TextEmbeddingInferenceUpdateOptions"
          },
          "text_expansion": {
            "$ref": "#/components/schemas/ml._types:TextExpansionInferenceUpdateOptions"
          },
          "question_answering": {
            "$ref": "#/components/schemas/ml._types:QuestionAnsweringInferenceUpdateOptions"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml._types:TextClassificationInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "classification_labels": {
            "description": "Classification labels to apply other than the stored labels. Must have the same deminsions as the default configured labels",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ml._types:NlpTokenizationUpdateOptions": {
        "type": "object",
        "properties": {
          "truncate": {
            "$ref": "#/components/schemas/ml._types:TokenizationTruncate"
          },
          "span": {
            "description": "Span options to apply",
            "type": "number"
          }
        }
      },
      "ml._types:ZeroShotClassificationInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "multi_label": {
            "description": "Update the configured multi label option. Indicates if more than one true label exists. Defaults to the configured value.",
            "type": "boolean"
          },
          "labels": {
            "description": "The labels to predict.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "labels"
        ]
      },
      "ml._types:FillMaskInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:NerInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:PassThroughInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:TextEmbeddingInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:TextExpansionInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          }
        }
      },
      "ml._types:QuestionAnsweringInferenceUpdateOptions": {
        "type": "object",
        "properties": {
          "question": {
            "description": "The question to answer given the inference context",
            "type": "string"
          },
          "num_top_classes": {
            "description": "Specifies the number of top class predictions to return. Defaults to 0.",
            "type": "number"
          },
          "tokenization": {
            "$ref": "#/components/schemas/ml._types:NlpTokenizationUpdateOptions"
          },
          "results_field": {
            "description": "The field that is added to incoming documents to contain the inference prediction. Defaults to predicted_value.",
            "type": "string"
          },
          "max_answer_length": {
            "description": "The maximum answer length to consider for extraction",
            "type": "number"
          }
        },
        "required": [
          "question"
        ]
      },
      "ml._types:InferenceResponseResult": {
        "type": "object",
        "properties": {
          "entities": {
            "description": "If the model is trained for named entity recognition (NER) tasks, the response contains the recognized entities.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelEntities"
            }
          },
          "is_truncated": {
            "description": "Indicates whether the input text was truncated to meet the model's maximum sequence length limit. This property\nis present only when it is true.",
            "type": "boolean"
          },
          "predicted_value": {
            "description": "If the model is trained for a text classification or zero shot classification task, the response is the\npredicted class.\nFor named entity recognition (NER) tasks, it contains the annotated text output.\nFor fill mask tasks, it contains the top prediction for replacing the mask token.\nFor text embedding tasks, it contains the raw numerical text embedding values.\nFor regression models, its a numerical value\nFor classification models, it may be an integer, double, boolean or string depending on prediction type",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:PredictedValue"
            }
          },
          "predicted_value_sequence": {
            "description": "For fill mask tasks, the response contains the input text sequence with the mask token replaced by the predicted\nvalue.\nAdditionally",
            "type": "string"
          },
          "prediction_probability": {
            "description": "Specifies a probability for the predicted value.",
            "type": "number"
          },
          "prediction_score": {
            "description": "Specifies a confidence score for the predicted value.",
            "type": "number"
          },
          "top_classes": {
            "description": "For fill mask, text classification, and zero shot classification tasks, the response contains a list of top\nclass entries.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TopClassEntry"
            }
          },
          "warning": {
            "description": "If the request failed, the response contains the reason for the failure.",
            "type": "string"
          },
          "feature_importance": {
            "description": "The feature importance for the inference results. Relevant only for classification or regression models",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelInferenceFeatureImportance"
            }
          }
        }
      },
      "ml._types:TrainedModelEntities": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "class_probability": {
            "type": "number"
          },
          "entity": {
            "type": "string"
          },
          "start_pos": {
            "type": "number"
          },
          "end_pos": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "class_probability",
          "entity",
          "start_pos",
          "end_pos"
        ]
      },
      "ml._types:PredictedValue": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "type": "number"
          },
          {
            "type": "boolean"
          },
          {
            "type": "number"
          }
        ]
      },
      "ml._types:TopClassEntry": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "class_probability": {
            "type": "number"
          },
          "class_score": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "class_probability",
          "class_score"
        ]
      },
      "ml._types:TrainedModelInferenceFeatureImportance": {
        "type": "object",
        "properties": {
          "feature_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          },
          "classes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:TrainedModelInferenceClassImportance"
            }
          }
        },
        "required": [
          "feature_name"
        ]
      },
      "ml._types:TrainedModelInferenceClassImportance": {
        "type": "object",
        "properties": {
          "class_name": {
            "type": "string"
          },
          "importance": {
            "type": "number"
          }
        },
        "required": [
          "class_name",
          "importance"
        ]
      },
      "ml.info:Defaults": {
        "type": "object",
        "properties": {
          "anomaly_detectors": {
            "$ref": "#/components/schemas/ml.info:AnomalyDetectors"
          },
          "datafeeds": {
            "$ref": "#/components/schemas/ml.info:Datafeeds"
          }
        },
        "required": [
          "anomaly_detectors",
          "datafeeds"
        ]
      },
      "ml.info:AnomalyDetectors": {
        "type": "object",
        "properties": {
          "categorization_analyzer": {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzer"
          },
          "categorization_examples_limit": {
            "type": "number"
          },
          "model_memory_limit": {
            "type": "string"
          },
          "model_snapshot_retention_days": {
            "type": "number"
          },
          "daily_model_snapshot_retention_after_days": {
            "type": "number"
          }
        },
        "required": [
          "categorization_analyzer",
          "categorization_examples_limit",
          "model_memory_limit",
          "model_snapshot_retention_days",
          "daily_model_snapshot_retention_after_days"
        ]
      },
      "ml.info:Datafeeds": {
        "type": "object",
        "properties": {
          "scroll_size": {
            "type": "number"
          }
        },
        "required": [
          "scroll_size"
        ]
      },
      "ml.info:Limits": {
        "type": "object",
        "properties": {
          "max_model_memory_limit": {
            "type": "string"
          },
          "effective_max_model_memory_limit": {
            "type": "string"
          },
          "total_ml_memory": {
            "type": "string"
          }
        },
        "required": [
          "effective_max_model_memory_limit",
          "total_ml_memory"
        ]
      },
      "ml.info:NativeCode": {
        "type": "object",
        "properties": {
          "build_hash": {
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "build_hash",
          "version"
        ]
      },
      "ml.preview_data_frame_analytics:DataframePreviewConfig": {
        "type": "object",
        "properties": {
          "source": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalyticsSource"
          },
          "analysis": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisContainer"
          },
          "model_memory_limit": {
            "type": "string"
          },
          "max_num_threads": {
            "type": "number"
          },
          "analyzed_fields": {
            "$ref": "#/components/schemas/ml._types:DataframeAnalysisAnalyzedFields"
          }
        },
        "required": [
          "source",
          "analysis"
        ]
      },
      "ml._types:DatafeedConfig": {
        "type": "object",
        "properties": {
          "aggregations": {
            "description": "If set, the datafeed performs aggregation searches. Support for aggregations is limited and should be used only with low cardinality data.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "chunking_config": {
            "$ref": "#/components/schemas/ml._types:ChunkingConfig"
          },
          "datafeed_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "delayed_data_check_config": {
            "$ref": "#/components/schemas/ml._types:DelayedDataCheckConfig"
          },
          "frequency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "indices": {
            "description": "An array of index names. Wildcards are supported. If any indices are in remote clusters, the machine learning nodes must have the `remote_cluster_client` role.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "indices_options": {
            "$ref": "#/components/schemas/_types:IndicesOptions"
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "max_empty_searches": {
            "description": "If a real-time datafeed has never seen any data (including during any initial training period) then it will automatically stop itself and close its associated job after this many real-time searches that return no documents. In other words, it will stop after `frequency` times `max_empty_searches` of real-time operation. If not set then a datafeed with no end time that sees no data will remain started until it is explicitly stopped.",
            "type": "number"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "query_delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          },
          "script_fields": {
            "description": "Specifies scripts that evaluate custom expressions and returns script fields to the datafeed. The detector configuration objects in a job can contain functions that use these script fields.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ScriptField"
            }
          },
          "scroll_size": {
            "description": "The size parameter that is used in Elasticsearch searches when the datafeed does not use aggregations. The maximum value is the value of `index.max_result_window`, which is 10,000 by default.",
            "type": "number"
          }
        }
      },
      "ml._types:JobConfig": {
        "type": "object",
        "properties": {
          "allow_lazy_open": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/ml-put-job.html"
            },
            "description": "Advanced configuration option. Specifies whether this job can open when there is insufficient machine learning node capacity for it to be immediately assigned to a node.",
            "type": "boolean"
          },
          "analysis_config": {
            "$ref": "#/components/schemas/ml._types:AnalysisConfig"
          },
          "analysis_limits": {
            "$ref": "#/components/schemas/ml._types:AnalysisLimits"
          },
          "background_persist_interval": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "custom_settings": {
            "$ref": "#/components/schemas/ml._types:CustomSettings"
          },
          "daily_model_snapshot_retention_after_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies a period of time (in days) after which only the first snapshot per day is retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.",
            "type": "number"
          },
          "data_description": {
            "$ref": "#/components/schemas/ml._types:DataDescription"
          },
          "datafeed_config": {
            "$ref": "#/components/schemas/ml._types:DatafeedConfig"
          },
          "description": {
            "description": "A description of the job.",
            "type": "string"
          },
          "groups": {
            "description": "A list of job groups. A job can belong to no groups or many.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "job_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "job_type": {
            "description": "Reserved for future use, currently set to `anomaly_detector`.",
            "type": "string"
          },
          "model_plot_config": {
            "$ref": "#/components/schemas/ml._types:ModelPlotConfig"
          },
          "model_snapshot_retention_days": {
            "description": "Advanced configuration option, which affects the automatic removal of old model snapshots for this job.\nIt specifies the maximum period of time (in days) that snapshots are retained.\nThis period is relative to the timestamp of the most recent snapshot for this job.\nThe default value is `10`, which means snapshots ten days older than the newest snapshot are deleted.",
            "type": "number"
          },
          "renormalization_window_days": {
            "description": "Advanced configuration option.\nThe period over which adjustments to the score are applied, as new data is seen.\nThe default value is the longer of 30 days or 100 `bucket_spans`.",
            "type": "number"
          },
          "results_index_name": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "results_retention_days": {
            "description": "Advanced configuration option.\nThe period of time (in days) that results are retained.\nAge is calculated relative to the timestamp of the latest bucket result.\nIf this property has a non-null value, once per day at 00:30 (server time), results that are the specified number of days older than the latest bucket result are deleted from Elasticsearch.\nThe default value is null, which means all results are retained.\nAnnotations generated by the system also count as results for retention purposes; they are deleted after the same number of days as results.\nAnnotations added by users are retained forever.",
            "type": "number"
          }
        },
        "required": [
          "analysis_config",
          "data_description"
        ]
      },
      "_types:HttpHeaders": {
        "type": "object",
        "additionalProperties": {
          "oneOf": [
            {
              "type": "string"
            },
            {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          ]
        }
      },
      "ml._types:AnalysisConfigRead": {
        "type": "object",
        "properties": {
          "bucket_span": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "categorization_analyzer": {
            "$ref": "#/components/schemas/ml._types:CategorizationAnalyzer"
          },
          "categorization_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "categorization_filters": {
            "description": "If `categorization_field_name` is specified, you can also define optional filters.\nThis property expects an array of regular expressions.\nThe expressions are used to filter out matching sequences from the categorization field values.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "detectors": {
            "description": "An array of detector configuration objects.\nDetector configuration objects specify which data fields a job analyzes.\nThey also specify which analytical functions are used.\nYou can specify multiple detectors for a job.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectorRead"
            }
          },
          "influencers": {
            "description": "A comma separated list of influencer field names.\nTypically these can be the by, over, or partition fields that are used in the detector configuration.\nYou might also want to use a field name that is not specifically named in a detector, but is available as part of the input data.\nWhen you use multiple detectors, the use of influencers is recommended as it aggregates results for each influencer entity.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          },
          "model_prune_window": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "latency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "multivariate_by_fields": {
            "description": "This functionality is reserved for internal use.\nIt is not supported for use in customer environments and is not subject to the support SLA of official GA features.\nIf set to `true`, the analysis will automatically find correlations between metrics for a given by field value and report anomalies when those correlations cease to hold.",
            "type": "boolean"
          },
          "per_partition_categorization": {
            "$ref": "#/components/schemas/ml._types:PerPartitionCategorization"
          },
          "summary_count_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "bucket_span",
          "detectors",
          "influencers"
        ]
      },
      "ml._types:DetectorRead": {
        "type": "object",
        "properties": {
          "by_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "custom_rules": {
            "description": "An array of custom rule objects, which enable you to customize the way detectors operate.\nFor example, a rule may dictate to the detector conditions under which results should be skipped.\nKibana refers to custom rules as job rules.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml._types:DetectionRule"
            }
          },
          "detector_description": {
            "description": "A description of the detector.",
            "type": "string"
          },
          "detector_index": {
            "description": "A unique identifier for the detector.\nThis identifier is based on the order of the detectors in the `analysis_config`, starting at zero.",
            "type": "number"
          },
          "exclude_frequent": {
            "$ref": "#/components/schemas/ml._types:ExcludeFrequent"
          },
          "field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "function": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/machine-learning/current/ml-functions.html"
            },
            "description": "The analysis function that is used.\nFor example, `count`, `rare`, `mean`, `min`, `max`, and `sum`.",
            "type": "string"
          },
          "over_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "partition_field_name": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "use_null": {
            "description": "Defines whether a new series is used as the null series when there is no value for the by or partition fields.",
            "type": "boolean"
          }
        },
        "required": [
          "function"
        ]
      },
      "ml.put_trained_model:Definition": {
        "type": "object",
        "properties": {
          "preprocessors": {
            "description": "Collection of preprocessors",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.put_trained_model:Preprocessor"
            }
          },
          "trained_model": {
            "$ref": "#/components/schemas/ml.put_trained_model:TrainedModel"
          }
        },
        "required": [
          "trained_model"
        ]
      },
      "ml.put_trained_model:Preprocessor": {
        "type": "object",
        "properties": {
          "frequency_encoding": {
            "$ref": "#/components/schemas/ml.put_trained_model:FrequencyEncodingPreprocessor"
          },
          "one_hot_encoding": {
            "$ref": "#/components/schemas/ml.put_trained_model:OneHotEncodingPreprocessor"
          },
          "target_mean_encoding": {
            "$ref": "#/components/schemas/ml.put_trained_model:TargetMeanEncodingPreprocessor"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "ml.put_trained_model:FrequencyEncodingPreprocessor": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "feature_name": {
            "type": "string"
          },
          "frequency_map": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        },
        "required": [
          "field",
          "feature_name",
          "frequency_map"
        ]
      },
      "ml.put_trained_model:OneHotEncodingPreprocessor": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "hot_map": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "field",
          "hot_map"
        ]
      },
      "ml.put_trained_model:TargetMeanEncodingPreprocessor": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string"
          },
          "feature_name": {
            "type": "string"
          },
          "target_map": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "default_value": {
            "type": "number"
          }
        },
        "required": [
          "field",
          "feature_name",
          "target_map",
          "default_value"
        ]
      },
      "ml.put_trained_model:TrainedModel": {
        "type": "object",
        "properties": {
          "tree": {
            "$ref": "#/components/schemas/ml.put_trained_model:TrainedModelTree"
          },
          "tree_node": {
            "$ref": "#/components/schemas/ml.put_trained_model:TrainedModelTreeNode"
          },
          "ensemble": {
            "$ref": "#/components/schemas/ml.put_trained_model:Ensemble"
          }
        }
      },
      "ml.put_trained_model:TrainedModelTree": {
        "type": "object",
        "properties": {
          "classification_labels": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "target_type": {
            "type": "string"
          },
          "tree_structure": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.put_trained_model:TrainedModelTreeNode"
            }
          }
        },
        "required": [
          "feature_names",
          "tree_structure"
        ]
      },
      "ml.put_trained_model:TrainedModelTreeNode": {
        "type": "object",
        "properties": {
          "decision_type": {
            "type": "string"
          },
          "default_left": {
            "type": "boolean"
          },
          "leaf_value": {
            "type": "number"
          },
          "left_child": {
            "type": "number"
          },
          "node_index": {
            "type": "number"
          },
          "right_child": {
            "type": "number"
          },
          "split_feature": {
            "type": "number"
          },
          "split_gain": {
            "type": "number"
          },
          "threshold": {
            "type": "number"
          }
        },
        "required": [
          "node_index"
        ]
      },
      "ml.put_trained_model:Ensemble": {
        "type": "object",
        "properties": {
          "aggregate_output": {
            "$ref": "#/components/schemas/ml.put_trained_model:AggregateOutput"
          },
          "classification_labels": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "feature_names": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "target_type": {
            "type": "string"
          },
          "trained_models": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ml.put_trained_model:TrainedModel"
            }
          }
        },
        "required": [
          "trained_models"
        ]
      },
      "ml.put_trained_model:AggregateOutput": {
        "type": "object",
        "properties": {
          "logistic_regression": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          },
          "weighted_sum": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          },
          "weighted_mode": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          },
          "exponent": {
            "$ref": "#/components/schemas/ml.put_trained_model:Weights"
          }
        }
      },
      "ml.put_trained_model:Weights": {
        "type": "object",
        "properties": {
          "weights": {
            "type": "number"
          }
        },
        "required": [
          "weights"
        ]
      },
      "ml.put_trained_model:Input": {
        "type": "object",
        "properties": {
          "field_names": {
            "$ref": "#/components/schemas/_types:Names"
          }
        },
        "required": [
          "field_names"
        ]
      },
      "ml._types:TrainingPriority": {
        "type": "string",
        "enum": [
          "normal",
          "low"
        ]
      },
      "ml._types:TrainedModelAssignment": {
        "type": "object",
        "properties": {
          "assignment_state": {
            "$ref": "#/components/schemas/ml._types:DeploymentAssignmentState"
          },
          "max_assigned_allocations": {
            "type": "number"
          },
          "routing_table": {
            "description": "The allocation state for each node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/ml._types:TrainedModelAssignmentRoutingTable"
            }
          },
          "start_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "task_parameters": {
            "$ref": "#/components/schemas/ml._types:TrainedModelAssignmentTaskParameters"
          }
        },
        "required": [
          "assignment_state",
          "routing_table",
          "start_time",
          "task_parameters"
        ]
      },
      "ml._types:DeploymentAssignmentState": {
        "type": "string",
        "enum": [
          "starting",
          "started",
          "stopping",
          "failed"
        ]
      },
      "ml._types:TrainedModelAssignmentTaskParameters": {
        "type": "object",
        "properties": {
          "model_bytes": {
            "description": "The size of the trained model in bytes.",
            "type": "number"
          },
          "model_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "deployment_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "cache_size": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "number_of_allocations": {
            "description": "The total number of allocations this model is assigned across ML nodes.",
            "type": "number"
          },
          "priority": {
            "$ref": "#/components/schemas/ml._types:TrainingPriority"
          },
          "queue_capacity": {
            "description": "Number of inference requests are allowed in the queue at a time.",
            "type": "number"
          },
          "threads_per_allocation": {
            "description": "Number of threads per allocation.",
            "type": "number"
          }
        },
        "required": [
          "model_bytes",
          "model_id",
          "deployment_id",
          "cache_size",
          "number_of_allocations",
          "priority",
          "queue_capacity",
          "threads_per_allocation"
        ]
      },
      "ml._types:AnalysisMemoryLimit": {
        "type": "object",
        "properties": {
          "model_memory_limit": {
            "description": "Limits can be applied for the resources required to hold the mathematical models in memory. These limits are approximate and can be set per job. They do not control the memory used by other processes, for example the Elasticsearch Java processes.",
            "type": "string"
          }
        },
        "required": [
          "model_memory_limit"
        ]
      },
      "_global.msearch:MultiSearchResult": {
        "type": "object",
        "properties": {
          "took": {
            "type": "number"
          },
          "responses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.msearch:ResponseItem"
            }
          }
        },
        "required": [
          "took",
          "responses"
        ]
      },
      "_global.msearch_template:RequestItem": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/_global.msearch:MultisearchHeader"
          },
          {
            "$ref": "#/components/schemas/_global.msearch_template:TemplateConfig"
          }
        ]
      },
      "_global.msearch_template:TemplateConfig": {
        "type": "object",
        "properties": {
          "explain": {
            "description": "If `true`, returns detailed information about score calculation as part of each hit.",
            "type": "boolean"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "description": "Key-value pairs used to replace Mustache variables in the template.\nThe key is the variable name.\nThe value is the variable value.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "profile": {
            "description": "If `true`, the query execution is profiled.",
            "type": "boolean"
          },
          "source": {
            "description": "An inline search template. Supports the same parameters as the search API's\nrequest body. Also supports Mustache variables. If no id is specified, this\nparameter is required.",
            "type": "string"
          }
        }
      },
      "_global.mtermvectors:Operation": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "doc": {
            "description": "An artificial document (a document not present in the index) for which you want to retrieve term vectors.",
            "type": "object"
          },
          "fields": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "field_statistics": {
            "description": "If `true`, the response includes the document count, sum of document frequencies, and sum of total term frequencies.",
            "type": "boolean"
          },
          "filter": {
            "$ref": "#/components/schemas/_global.termvectors:Filter"
          },
          "offsets": {
            "description": "If `true`, the response includes term offsets.",
            "type": "boolean"
          },
          "payloads": {
            "description": "If `true`, the response includes term payloads.",
            "type": "boolean"
          },
          "positions": {
            "description": "If `true`, the response includes term positions.",
            "type": "boolean"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "term_statistics": {
            "description": "If true, the response includes term frequency and document frequency.",
            "type": "boolean"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "_id"
        ]
      },
      "_global.termvectors:Filter": {
        "type": "object",
        "properties": {
          "max_doc_freq": {
            "description": "Ignore words which occur in more than this many docs.\nDefaults to unbounded.",
            "type": "number"
          },
          "max_num_terms": {
            "description": "Maximum number of terms that must be returned per field.",
            "type": "number"
          },
          "max_term_freq": {
            "description": "Ignore words with more than this frequency in the source doc.\nDefaults to unbounded.",
            "type": "number"
          },
          "max_word_length": {
            "description": "The maximum word length above which words will be ignored.\nDefaults to unbounded.",
            "type": "number"
          },
          "min_doc_freq": {
            "description": "Ignore terms which do not occur in at least this many docs.",
            "type": "number"
          },
          "min_term_freq": {
            "description": "Ignore words with less than this frequency in the source doc.",
            "type": "number"
          },
          "min_word_length": {
            "description": "The minimum word length below which words will be ignored.",
            "type": "number"
          }
        }
      },
      "_global.mtermvectors:TermVectorsResult": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "took": {
            "type": "number"
          },
          "found": {
            "type": "boolean"
          },
          "term_vectors": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_global.termvectors:TermVector"
            }
          },
          "error": {
            "$ref": "#/components/schemas/_types:ErrorCause"
          }
        },
        "required": [
          "_id",
          "_index"
        ]
      },
      "_global.termvectors:TermVector": {
        "type": "object",
        "properties": {
          "field_statistics": {
            "$ref": "#/components/schemas/_global.termvectors:FieldStatistics"
          },
          "terms": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_global.termvectors:Term"
            }
          }
        },
        "required": [
          "field_statistics",
          "terms"
        ]
      },
      "_global.termvectors:FieldStatistics": {
        "type": "object",
        "properties": {
          "doc_count": {
            "type": "number"
          },
          "sum_doc_freq": {
            "type": "number"
          },
          "sum_ttf": {
            "type": "number"
          }
        },
        "required": [
          "doc_count",
          "sum_doc_freq",
          "sum_ttf"
        ]
      },
      "_global.termvectors:Term": {
        "type": "object",
        "properties": {
          "doc_freq": {
            "type": "number"
          },
          "score": {
            "type": "number"
          },
          "term_freq": {
            "type": "number"
          },
          "tokens": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.termvectors:Token"
            }
          },
          "ttf": {
            "type": "number"
          }
        },
        "required": [
          "term_freq"
        ]
      },
      "_global.termvectors:Token": {
        "type": "object",
        "properties": {
          "end_offset": {
            "type": "number"
          },
          "payload": {
            "type": "string"
          },
          "position": {
            "type": "number"
          },
          "start_offset": {
            "type": "number"
          }
        },
        "required": [
          "position"
        ]
      },
      "_types:ThreadType": {
        "type": "string",
        "enum": [
          "cpu",
          "wait",
          "block",
          "gpu",
          "mem"
        ]
      },
      "nodes.hot_threads:HotThread": {
        "type": "object",
        "properties": {
          "hosts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Host"
            }
          },
          "node_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "node_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "threads": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "hosts",
          "node_id",
          "node_name",
          "threads"
        ]
      },
      "nodes.info:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes.info:NodeInfo"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "nodes.info:NodeInfo": {
        "type": "object",
        "properties": {
          "attributes": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "build_flavor": {
            "type": "string"
          },
          "build_hash": {
            "description": "Short hash of the last git commit in this release.",
            "type": "string"
          },
          "build_type": {
            "type": "string"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "http": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoHttp"
          },
          "ip": {
            "$ref": "#/components/schemas/_types:Ip"
          },
          "jvm": {
            "$ref": "#/components/schemas/nodes.info:NodeJvmInfo"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "network": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoNetwork"
          },
          "os": {
            "$ref": "#/components/schemas/nodes.info:NodeOperatingSystemInfo"
          },
          "plugins": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:PluginStats"
            }
          },
          "process": {
            "$ref": "#/components/schemas/nodes.info:NodeProcessInfo"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "settings": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettings"
          },
          "thread_pool": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeThreadPoolInfo"
            }
          },
          "total_indexing_buffer": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/indexing-buffer.html"
            },
            "description": "Total heap allowed to be used to hold recently indexed documents before they must be written to disk. This size is a shared pool across all shards on this node, and is controlled by Indexing Buffer settings.",
            "type": "number"
          },
          "total_indexing_buffer_in_bytes": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoTransport"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "modules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:PluginStats"
            }
          },
          "ingest": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngest"
          },
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoAggregation"
            }
          }
        },
        "required": [
          "attributes",
          "build_flavor",
          "build_hash",
          "build_type",
          "host",
          "ip",
          "name",
          "roles",
          "transport_address",
          "version"
        ]
      },
      "nodes.info:NodeInfoHttp": {
        "type": "object",
        "properties": {
          "bound_address": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "max_content_length": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "max_content_length_in_bytes": {
            "type": "number"
          },
          "publish_address": {
            "type": "string"
          }
        },
        "required": [
          "bound_address",
          "max_content_length_in_bytes",
          "publish_address"
        ]
      },
      "nodes.info:NodeJvmInfo": {
        "type": "object",
        "properties": {
          "gc_collectors": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "mem": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoJvmMemory"
          },
          "memory_pools": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "pid": {
            "type": "number"
          },
          "start_time_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "vm_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "vm_vendor": {
            "type": "string"
          },
          "vm_version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "using_bundled_jdk": {
            "type": "boolean"
          },
          "using_compressed_ordinary_object_pointers": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "input_arguments": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "gc_collectors",
          "mem",
          "memory_pools",
          "pid",
          "start_time_in_millis",
          "version",
          "vm_name",
          "vm_vendor",
          "vm_version",
          "using_bundled_jdk",
          "input_arguments"
        ]
      },
      "nodes.info:NodeInfoJvmMemory": {
        "type": "object",
        "properties": {
          "direct_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "direct_max_in_bytes": {
            "type": "number"
          },
          "heap_init": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "heap_init_in_bytes": {
            "type": "number"
          },
          "heap_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "heap_max_in_bytes": {
            "type": "number"
          },
          "non_heap_init": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "non_heap_init_in_bytes": {
            "type": "number"
          },
          "non_heap_max": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "non_heap_max_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "direct_max_in_bytes",
          "heap_init_in_bytes",
          "heap_max_in_bytes",
          "non_heap_init_in_bytes",
          "non_heap_max_in_bytes"
        ]
      },
      "nodes.info:NodeInfoNetwork": {
        "type": "object",
        "properties": {
          "primary_interface": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoNetworkInterface"
          },
          "refresh_interval": {
            "type": "number"
          }
        },
        "required": [
          "primary_interface",
          "refresh_interval"
        ]
      },
      "nodes.info:NodeInfoNetworkInterface": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "mac_address": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "address",
          "mac_address",
          "name"
        ]
      },
      "nodes.info:NodeOperatingSystemInfo": {
        "type": "object",
        "properties": {
          "arch": {
            "description": "Name of the JVM architecture (ex: amd64, x86)",
            "type": "string"
          },
          "available_processors": {
            "description": "Number of processors available to the Java virtual machine",
            "type": "number"
          },
          "allocated_processors": {
            "description": "The number of processors actually used to calculate thread pool size. This number can be set with the node.processors setting of a node and defaults to the number of processors reported by the OS.",
            "type": "number"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "pretty_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "refresh_interval_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "cpu": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoOSCPU"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoMemory"
          },
          "swap": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoMemory"
          }
        },
        "required": [
          "arch",
          "available_processors",
          "name",
          "pretty_name",
          "refresh_interval_in_millis",
          "version"
        ]
      },
      "nodes.info:NodeInfoOSCPU": {
        "type": "object",
        "properties": {
          "cache_size": {
            "type": "string"
          },
          "cache_size_in_bytes": {
            "type": "number"
          },
          "cores_per_socket": {
            "type": "number"
          },
          "mhz": {
            "type": "number"
          },
          "model": {
            "type": "string"
          },
          "total_cores": {
            "type": "number"
          },
          "total_sockets": {
            "type": "number"
          },
          "vendor": {
            "type": "string"
          }
        },
        "required": [
          "cache_size",
          "cache_size_in_bytes",
          "cores_per_socket",
          "mhz",
          "model",
          "total_cores",
          "total_sockets",
          "vendor"
        ]
      },
      "nodes.info:NodeInfoMemory": {
        "type": "object",
        "properties": {
          "total": {
            "type": "string"
          },
          "total_in_bytes": {
            "type": "number"
          }
        },
        "required": [
          "total",
          "total_in_bytes"
        ]
      },
      "nodes.info:NodeProcessInfo": {
        "type": "object",
        "properties": {
          "id": {
            "description": "Process identifier (PID)",
            "type": "number"
          },
          "mlockall": {
            "description": "Indicates if the process address space has been successfully locked in memory",
            "type": "boolean"
          },
          "refresh_interval_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "id",
          "mlockall",
          "refresh_interval_in_millis"
        ]
      },
      "_types:NodeRoles": {
        "description": "* @doc_id node-roles",
        "type": "array",
        "items": {
          "$ref": "#/components/schemas/_types:NodeRole"
        }
      },
      "_types:NodeRole": {
        "type": "string",
        "enum": [
          "master",
          "data",
          "data_cold",
          "data_content",
          "data_frozen",
          "data_hot",
          "data_warm",
          "client",
          "ingest",
          "ml",
          "voting_only",
          "transform",
          "remote_cluster_client",
          "coordinating_only"
        ]
      },
      "nodes.info:NodeInfoSettings": {
        "type": "object",
        "properties": {
          "cluster": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsCluster"
          },
          "node": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsNode"
          },
          "path": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoPath"
          },
          "repositories": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoRepositories"
          },
          "discovery": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoDiscover"
          },
          "action": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoAction"
          },
          "client": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoClient"
          },
          "http": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsHttp"
          },
          "bootstrap": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoBootstrap"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsTransport"
          },
          "network": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsNetwork"
          },
          "xpack": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpack"
          },
          "script": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoScript"
          },
          "search": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSearch"
          },
          "ingest": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsIngest"
          }
        },
        "required": [
          "cluster",
          "node",
          "path",
          "client",
          "http",
          "transport"
        ]
      },
      "nodes.info:NodeInfoSettingsCluster": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "routing": {
            "$ref": "#/components/schemas/indices._types:IndexRouting"
          },
          "election": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsClusterElection"
          },
          "initial_master_nodes": {
            "type": "string"
          },
          "deprecation_indexing": {
            "$ref": "#/components/schemas/nodes.info:DeprecationIndexing"
          }
        },
        "required": [
          "name",
          "election"
        ]
      },
      "nodes.info:NodeInfoSettingsClusterElection": {
        "type": "object",
        "properties": {
          "strategy": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "strategy"
        ]
      },
      "nodes.info:DeprecationIndexing": {
        "type": "object",
        "properties": {
          "enabled": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeInfoSettingsNode": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "attr": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "max_local_storage_nodes": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "attr"
        ]
      },
      "nodes.info:NodeInfoPath": {
        "type": "object",
        "properties": {
          "logs": {
            "type": "string"
          },
          "home": {
            "type": "string"
          },
          "repo": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "data": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "logs",
          "home",
          "repo"
        ]
      },
      "nodes.info:NodeInfoRepositories": {
        "type": "object",
        "properties": {
          "url": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoRepositoriesUrl"
          }
        },
        "required": [
          "url"
        ]
      },
      "nodes.info:NodeInfoRepositoriesUrl": {
        "type": "object",
        "properties": {
          "allowed_urls": {
            "type": "string"
          }
        },
        "required": [
          "allowed_urls"
        ]
      },
      "nodes.info:NodeInfoDiscover": {
        "type": "object",
        "properties": {
          "seed_hosts": {
            "type": "string"
          }
        },
        "required": [
          "seed_hosts"
        ]
      },
      "nodes.info:NodeInfoAction": {
        "type": "object",
        "properties": {
          "destructive_requires_name": {
            "type": "string"
          }
        },
        "required": [
          "destructive_requires_name"
        ]
      },
      "nodes.info:NodeInfoClient": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoSettingsHttp": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsHttpType"
          },
          "type.default": {
            "type": "string"
          },
          "compression": {
            "oneOf": [
              {
                "type": "boolean"
              },
              {
                "type": "string"
              }
            ]
          },
          "port": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoSettingsHttpType": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string"
          }
        },
        "required": [
          "default"
        ]
      },
      "nodes.info:NodeInfoBootstrap": {
        "type": "object",
        "properties": {
          "memory_lock": {
            "type": "string"
          }
        },
        "required": [
          "memory_lock"
        ]
      },
      "nodes.info:NodeInfoSettingsTransport": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsTransportType"
          },
          "type.default": {
            "type": "string"
          },
          "features": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSettingsTransportFeatures"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoSettingsTransportType": {
        "type": "object",
        "properties": {
          "default": {
            "type": "string"
          }
        },
        "required": [
          "default"
        ]
      },
      "nodes.info:NodeInfoSettingsTransportFeatures": {
        "type": "object",
        "properties": {
          "x-pack": {
            "type": "string"
          }
        },
        "required": [
          "x-pack"
        ]
      },
      "nodes.info:NodeInfoSettingsNetwork": {
        "type": "object",
        "properties": {
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          }
        },
        "required": [
          "host"
        ]
      },
      "nodes.info:NodeInfoXpack": {
        "type": "object",
        "properties": {
          "license": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackLicense"
          },
          "security": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurity"
          },
          "notification": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "security"
        ]
      },
      "nodes.info:NodeInfoXpackLicense": {
        "type": "object",
        "properties": {
          "self_generated": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackLicenseType"
          }
        },
        "required": [
          "self_generated"
        ]
      },
      "nodes.info:NodeInfoXpackLicenseType": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoXpackSecurity": {
        "type": "object",
        "properties": {
          "http": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecuritySsl"
          },
          "enabled": {
            "type": "string"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecuritySsl"
          },
          "authc": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthc"
          }
        },
        "required": [
          "http",
          "enabled"
        ]
      },
      "nodes.info:NodeInfoXpackSecuritySsl": {
        "type": "object",
        "properties": {
          "ssl": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "ssl"
        ]
      },
      "nodes.info:NodeInfoXpackSecurityAuthc": {
        "type": "object",
        "properties": {
          "realms": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealms"
          },
          "token": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcToken"
          }
        },
        "required": [
          "realms",
          "token"
        ]
      },
      "nodes.info:NodeInfoXpackSecurityAuthcRealms": {
        "type": "object",
        "properties": {
          "file": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus"
            }
          },
          "native": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus"
            }
          },
          "pki": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus"
            }
          }
        }
      },
      "nodes.info:NodeInfoXpackSecurityAuthcRealmsStatus": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "string"
          },
          "order": {
            "type": "string"
          }
        },
        "required": [
          "order"
        ]
      },
      "nodes.info:NodeInfoXpackSecurityAuthcToken": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "string"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeInfoScript": {
        "type": "object",
        "properties": {
          "allowed_types": {
            "type": "string"
          },
          "disable_max_compilations_rate": {
            "type": "string"
          }
        },
        "required": [
          "allowed_types",
          "disable_max_compilations_rate"
        ]
      },
      "nodes.info:NodeInfoSearch": {
        "type": "object",
        "properties": {
          "remote": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoSearchRemote"
          }
        },
        "required": [
          "remote"
        ]
      },
      "nodes.info:NodeInfoSearchRemote": {
        "type": "object",
        "properties": {
          "connect": {
            "type": "string"
          }
        },
        "required": [
          "connect"
        ]
      },
      "nodes.info:NodeInfoSettingsIngest": {
        "type": "object",
        "properties": {
          "attachment": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "append": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "csv": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "convert": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "date": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "date_index_name": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "dot_expander": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "enrich": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "fail": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "foreach": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "json": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "user_agent": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "kv": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "geoip": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "grok": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "gsub": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "join": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "lowercase": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "remove": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "rename": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "script": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "set": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "sort": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "split": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "trim": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "uppercase": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "urldecode": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "bytes": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "dissect": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "set_security_user": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "pipeline": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "drop": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "circle": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          },
          "inference": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestInfo"
          }
        }
      },
      "nodes.info:NodeInfoIngestInfo": {
        "type": "object",
        "properties": {
          "downloader": {
            "$ref": "#/components/schemas/nodes.info:NodeInfoIngestDownloader"
          }
        },
        "required": [
          "downloader"
        ]
      },
      "nodes.info:NodeInfoIngestDownloader": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "string"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "nodes.info:NodeThreadPoolInfo": {
        "type": "object",
        "properties": {
          "core": {
            "type": "number"
          },
          "keep_alive": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "max": {
            "type": "number"
          },
          "queue_size": {
            "type": "number"
          },
          "size": {
            "type": "number"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "queue_size",
          "type"
        ]
      },
      "nodes.info:NodeInfoTransport": {
        "type": "object",
        "properties": {
          "bound_address": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "publish_address": {
            "type": "string"
          },
          "profiles": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          }
        },
        "required": [
          "bound_address",
          "publish_address",
          "profiles"
        ]
      },
      "nodes.info:NodeInfoIngest": {
        "type": "object",
        "properties": {
          "processors": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes.info:NodeInfoIngestProcessor"
            }
          }
        },
        "required": [
          "processors"
        ]
      },
      "nodes.info:NodeInfoIngestProcessor": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          }
        },
        "required": [
          "type"
        ]
      },
      "nodes.info:NodeInfoAggregation": {
        "type": "object",
        "properties": {
          "types": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "types"
        ]
      },
      "nodes.stats:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes._types:Stats"
                }
              }
            },
            "required": [
              "nodes"
            ]
          }
        ]
      },
      "nodes._types:Stats": {
        "type": "object",
        "properties": {
          "adaptive_selection": {
            "description": "Statistics about adaptive replica selection.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:AdaptiveSelection"
            }
          },
          "breakers": {
            "description": "Statistics about the field data circuit breaker.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:Breaker"
            }
          },
          "fs": {
            "$ref": "#/components/schemas/nodes._types:FileSystem"
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "http": {
            "$ref": "#/components/schemas/nodes._types:Http"
          },
          "ingest": {
            "$ref": "#/components/schemas/nodes._types:Ingest"
          },
          "ip": {
            "description": "IP address and port for the node.",
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Ip"
              },
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/_types:Ip"
                }
              }
            ]
          },
          "jvm": {
            "$ref": "#/components/schemas/nodes._types:Jvm"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "os": {
            "$ref": "#/components/schemas/nodes._types:OperatingSystem"
          },
          "process": {
            "$ref": "#/components/schemas/nodes._types:Process"
          },
          "roles": {
            "$ref": "#/components/schemas/_types:NodeRoles"
          },
          "script": {
            "$ref": "#/components/schemas/nodes._types:Scripting"
          },
          "script_cache": {
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "$ref": "#/components/schemas/nodes._types:ScriptCache"
                },
                {
                  "type": "array",
                  "items": {
                    "$ref": "#/components/schemas/nodes._types:ScriptCache"
                  }
                }
              ]
            }
          },
          "thread_pool": {
            "description": "Statistics about each thread pool, including current size, queue and rejected tasks.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:ThreadCount"
            }
          },
          "timestamp": {
            "type": "number"
          },
          "transport": {
            "$ref": "#/components/schemas/nodes._types:Transport"
          },
          "transport_address": {
            "$ref": "#/components/schemas/_types:TransportAddress"
          },
          "attributes": {
            "description": "Contains a list of attributes for the node.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "discovery": {
            "$ref": "#/components/schemas/nodes._types:Discovery"
          },
          "indexing_pressure": {
            "$ref": "#/components/schemas/nodes._types:IndexingPressure"
          },
          "indices": {
            "$ref": "#/components/schemas/indices.stats:ShardStats"
          }
        }
      },
      "nodes._types:AdaptiveSelection": {
        "type": "object",
        "properties": {
          "avg_queue_size": {
            "description": "The exponentially weighted moving average queue size of search requests on the keyed node.",
            "type": "number"
          },
          "avg_response_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "avg_response_time_ns": {
            "description": "The exponentially weighted moving average response time, in nanoseconds, of search requests on the keyed node.",
            "type": "number"
          },
          "avg_service_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "avg_service_time_ns": {
            "description": "The exponentially weighted moving average service time, in nanoseconds, of search requests on the keyed node.",
            "type": "number"
          },
          "outgoing_searches": {
            "description": "The number of outstanding search requests to the keyed node from the node these stats are for.",
            "type": "number"
          },
          "rank": {
            "description": "The rank of this node; used for shard selection when routing search requests.",
            "type": "string"
          }
        }
      },
      "nodes._types:Breaker": {
        "type": "object",
        "properties": {
          "estimated_size": {
            "description": "Estimated memory used for the operation.",
            "type": "string"
          },
          "estimated_size_in_bytes": {
            "description": "Estimated memory used, in bytes, for the operation.",
            "type": "number"
          },
          "limit_size": {
            "description": "Memory limit for the circuit breaker.",
            "type": "string"
          },
          "limit_size_in_bytes": {
            "description": "Memory limit, in bytes, for the circuit breaker.",
            "type": "number"
          },
          "overhead": {
            "description": "A constant that all estimates for the circuit breaker are multiplied with to calculate a final estimate.",
            "type": "number"
          },
          "tripped": {
            "description": "Total number of times the circuit breaker has been triggered and prevented an out of memory error.",
            "type": "number"
          }
        }
      },
      "nodes._types:FileSystem": {
        "type": "object",
        "properties": {
          "data": {
            "description": "List of all file stores.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:DataPathStats"
            }
          },
          "timestamp": {
            "description": "Last time the file stores statistics were refreshed.\nRecorded in milliseconds since the Unix Epoch.",
            "type": "number"
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:FileSystemTotal"
          },
          "io_stats": {
            "$ref": "#/components/schemas/nodes._types:IoStats"
          }
        }
      },
      "nodes._types:DataPathStats": {
        "type": "object",
        "properties": {
          "available": {
            "description": "Total amount of disk space available to this Java virtual machine on this file store.",
            "type": "string"
          },
          "available_in_bytes": {
            "description": "Total number of bytes available to this Java virtual machine on this file store.",
            "type": "number"
          },
          "disk_queue": {
            "type": "string"
          },
          "disk_reads": {
            "type": "number"
          },
          "disk_read_size": {
            "type": "string"
          },
          "disk_read_size_in_bytes": {
            "type": "number"
          },
          "disk_writes": {
            "type": "number"
          },
          "disk_write_size": {
            "type": "string"
          },
          "disk_write_size_in_bytes": {
            "type": "number"
          },
          "free": {
            "description": "Total amount of unallocated disk space in the file store.",
            "type": "string"
          },
          "free_in_bytes": {
            "description": "Total number of unallocated bytes in the file store.",
            "type": "number"
          },
          "mount": {
            "description": "Mount point of the file store (for example: `/dev/sda2`).",
            "type": "string"
          },
          "path": {
            "description": "Path to the file store.",
            "type": "string"
          },
          "total": {
            "description": "Total size of the file store.",
            "type": "string"
          },
          "total_in_bytes": {
            "description": "Total size of the file store in bytes.",
            "type": "number"
          },
          "type": {
            "description": "Type of the file store (ex: ext4).",
            "type": "string"
          }
        }
      },
      "nodes._types:FileSystemTotal": {
        "type": "object",
        "properties": {
          "available": {
            "description": "Total disk space available to this Java virtual machine on all file stores.\nDepending on OS or process level restrictions, this might appear less than `free`.\nThis is the actual amount of free disk space the Elasticsearch node can utilise.",
            "type": "string"
          },
          "available_in_bytes": {
            "description": "Total number of bytes available to this Java virtual machine on all file stores.\nDepending on OS or process level restrictions, this might appear less than `free_in_bytes`.\nThis is the actual amount of free disk space the Elasticsearch node can utilise.",
            "type": "number"
          },
          "free": {
            "description": "Total unallocated disk space in all file stores.",
            "type": "string"
          },
          "free_in_bytes": {
            "description": "Total number of unallocated bytes in all file stores.",
            "type": "number"
          },
          "total": {
            "description": "Total size of all file stores.",
            "type": "string"
          },
          "total_in_bytes": {
            "description": "Total size of all file stores in bytes.",
            "type": "number"
          }
        }
      },
      "nodes._types:IoStats": {
        "type": "object",
        "properties": {
          "devices": {
            "description": "Array of disk metrics for each device that is backing an Elasticsearch data path.\nThese disk metrics are probed periodically and averages between the last probe and the current probe are computed.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:IoStatDevice"
            }
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:IoStatDevice"
          }
        }
      },
      "nodes._types:IoStatDevice": {
        "type": "object",
        "properties": {
          "device_name": {
            "description": "The Linux device name.",
            "type": "string"
          },
          "operations": {
            "description": "The total number of read and write operations for the device completed since starting Elasticsearch.",
            "type": "number"
          },
          "read_kilobytes": {
            "description": "The total number of kilobytes read for the device since starting Elasticsearch.",
            "type": "number"
          },
          "read_operations": {
            "description": "The total number of read operations for the device completed since starting Elasticsearch.",
            "type": "number"
          },
          "write_kilobytes": {
            "description": "The total number of kilobytes written for the device since starting Elasticsearch.",
            "type": "number"
          },
          "write_operations": {
            "description": "The total number of write operations for the device completed since starting Elasticsearch.",
            "type": "number"
          }
        }
      },
      "nodes._types:Jvm": {
        "type": "object",
        "properties": {
          "buffer_pools": {
            "description": "Contains statistics about JVM buffer pools for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:NodeBufferPool"
            }
          },
          "classes": {
            "$ref": "#/components/schemas/nodes._types:JvmClasses"
          },
          "gc": {
            "$ref": "#/components/schemas/nodes._types:GarbageCollector"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes._types:JvmMemoryStats"
          },
          "threads": {
            "$ref": "#/components/schemas/nodes._types:JvmThreads"
          },
          "timestamp": {
            "description": "Last time JVM statistics were refreshed.",
            "type": "number"
          },
          "uptime": {
            "description": "Human-readable JVM uptime.\nOnly returned if the `human` query parameter is `true`.",
            "type": "string"
          },
          "uptime_in_millis": {
            "description": "JVM uptime in milliseconds.",
            "type": "number"
          }
        }
      },
      "nodes._types:NodeBufferPool": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of buffer pools.",
            "type": "number"
          },
          "total_capacity": {
            "description": "Total capacity of buffer pools.",
            "type": "string"
          },
          "total_capacity_in_bytes": {
            "description": "Total capacity of buffer pools in bytes.",
            "type": "number"
          },
          "used": {
            "description": "Size of buffer pools.",
            "type": "string"
          },
          "used_in_bytes": {
            "description": "Size of buffer pools in bytes.",
            "type": "number"
          }
        }
      },
      "nodes._types:JvmClasses": {
        "type": "object",
        "properties": {
          "current_loaded_count": {
            "description": "Number of classes currently loaded by JVM.",
            "type": "number"
          },
          "total_loaded_count": {
            "description": "Total number of classes loaded since the JVM started.",
            "type": "number"
          },
          "total_unloaded_count": {
            "description": "Total number of classes unloaded since the JVM started.",
            "type": "number"
          }
        }
      },
      "nodes._types:GarbageCollector": {
        "type": "object",
        "properties": {
          "collectors": {
            "description": "Contains statistics about JVM garbage collectors for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:GarbageCollectorTotal"
            }
          }
        }
      },
      "nodes._types:GarbageCollectorTotal": {
        "type": "object",
        "properties": {
          "collection_count": {
            "description": "Total number of JVM garbage collectors that collect objects.",
            "type": "number"
          },
          "collection_time": {
            "description": "Total time spent by JVM collecting objects.",
            "type": "string"
          },
          "collection_time_in_millis": {
            "description": "Total time, in milliseconds, spent by JVM collecting objects.",
            "type": "number"
          }
        }
      },
      "nodes._types:JvmMemoryStats": {
        "type": "object",
        "properties": {
          "heap_used_in_bytes": {
            "description": "Memory, in bytes, currently in use by the heap.",
            "type": "number"
          },
          "heap_used_percent": {
            "description": "Percentage of memory currently in use by the heap.",
            "type": "number"
          },
          "heap_committed_in_bytes": {
            "description": "Amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "heap_max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "non_heap_used_in_bytes": {
            "description": "Non-heap memory used, in bytes.",
            "type": "number"
          },
          "non_heap_committed_in_bytes": {
            "description": "Amount of non-heap memory available, in bytes.",
            "type": "number"
          },
          "pools": {
            "description": "Contains statistics about heap memory usage for the node.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:Pool"
            }
          }
        }
      },
      "nodes._types:Pool": {
        "type": "object",
        "properties": {
          "used_in_bytes": {
            "description": "Memory, in bytes, used by the heap.",
            "type": "number"
          },
          "max_in_bytes": {
            "description": "Maximum amount of memory, in bytes, available for use by the heap.",
            "type": "number"
          },
          "peak_used_in_bytes": {
            "description": "Largest amount of memory, in bytes, historically used by the heap.",
            "type": "number"
          },
          "peak_max_in_bytes": {
            "description": "Largest amount of memory, in bytes, historically used by the heap.",
            "type": "number"
          }
        }
      },
      "nodes._types:JvmThreads": {
        "type": "object",
        "properties": {
          "count": {
            "description": "Number of active threads in use by JVM.",
            "type": "number"
          },
          "peak_count": {
            "description": "Highest number of threads used by JVM.",
            "type": "number"
          }
        }
      },
      "nodes._types:OperatingSystem": {
        "type": "object",
        "properties": {
          "cpu": {
            "$ref": "#/components/schemas/nodes._types:Cpu"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes._types:ExtendedMemoryStats"
          },
          "swap": {
            "$ref": "#/components/schemas/nodes._types:MemoryStats"
          },
          "cgroup": {
            "$ref": "#/components/schemas/nodes._types:Cgroup"
          },
          "timestamp": {
            "type": "number"
          }
        }
      },
      "nodes._types:Cpu": {
        "type": "object",
        "properties": {
          "percent": {
            "type": "number"
          },
          "sys": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "sys_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "total": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "total_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "user": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "user_in_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "load_average": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          }
        }
      },
      "nodes._types:ExtendedMemoryStats": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:MemoryStats"
          },
          {
            "type": "object",
            "properties": {
              "free_percent": {
                "description": "Percentage of free memory.",
                "type": "number"
              },
              "used_percent": {
                "description": "Percentage of used memory.",
                "type": "number"
              }
            }
          }
        ]
      },
      "nodes._types:MemoryStats": {
        "type": "object",
        "properties": {
          "adjusted_total_in_bytes": {
            "description": "If the amount of physical memory has been overridden using the `es`.`total_memory_bytes` system property then this reports the overridden value in bytes.\nOtherwise it reports the same value as `total_in_bytes`.",
            "type": "number"
          },
          "resident": {
            "type": "string"
          },
          "resident_in_bytes": {
            "type": "number"
          },
          "share": {
            "type": "string"
          },
          "share_in_bytes": {
            "type": "number"
          },
          "total_virtual": {
            "type": "string"
          },
          "total_virtual_in_bytes": {
            "type": "number"
          },
          "total_in_bytes": {
            "description": "Total amount of physical memory in bytes.",
            "type": "number"
          },
          "free_in_bytes": {
            "description": "Amount of free physical memory in bytes.",
            "type": "number"
          },
          "used_in_bytes": {
            "description": "Amount of used physical memory in bytes.",
            "type": "number"
          }
        }
      },
      "nodes._types:Cgroup": {
        "type": "object",
        "properties": {
          "cpuacct": {
            "$ref": "#/components/schemas/nodes._types:CpuAcct"
          },
          "cpu": {
            "$ref": "#/components/schemas/nodes._types:CgroupCpu"
          },
          "memory": {
            "$ref": "#/components/schemas/nodes._types:CgroupMemory"
          }
        }
      },
      "nodes._types:CpuAcct": {
        "type": "object",
        "properties": {
          "control_group": {
            "description": "The `cpuacct` control group to which the Elasticsearch process belongs.",
            "type": "string"
          },
          "usage_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          }
        }
      },
      "nodes._types:CgroupCpu": {
        "type": "object",
        "properties": {
          "control_group": {
            "description": "The `cpu` control group to which the Elasticsearch process belongs.",
            "type": "string"
          },
          "cfs_period_micros": {
            "description": "The period of time, in microseconds, for how regularly all tasks in the same cgroup as the Elasticsearch process should have their access to CPU resources reallocated.",
            "type": "number"
          },
          "cfs_quota_micros": {
            "description": "The total amount of time, in microseconds, for which all tasks in the same cgroup as the Elasticsearch process can run during one period `cfs_period_micros`.",
            "type": "number"
          },
          "stat": {
            "$ref": "#/components/schemas/nodes._types:CgroupCpuStat"
          }
        }
      },
      "nodes._types:CgroupCpuStat": {
        "type": "object",
        "properties": {
          "number_of_elapsed_periods": {
            "description": "The number of reporting periods (as specified by `cfs_period_micros`) that have elapsed.",
            "type": "number"
          },
          "number_of_times_throttled": {
            "description": "The number of times all tasks in the same cgroup as the Elasticsearch process have been throttled.",
            "type": "number"
          },
          "time_throttled_nanos": {
            "$ref": "#/components/schemas/_types:DurationValueUnitNanos"
          }
        }
      },
      "nodes._types:CgroupMemory": {
        "type": "object",
        "properties": {
          "control_group": {
            "description": "The `memory` control group to which the Elasticsearch process belongs.",
            "type": "string"
          },
          "limit_in_bytes": {
            "description": "The maximum amount of user memory (including file cache) allowed for all tasks in the same cgroup as the Elasticsearch process.\nThis value can be too big to store in a `long`, so is returned as a string so that the value returned can exactly match what the underlying operating system interface returns.\nAny value that is too large to parse into a `long` almost certainly means no limit has been set for the cgroup.",
            "type": "string"
          },
          "usage_in_bytes": {
            "description": "The total current memory usage by processes in the cgroup, in bytes, by all tasks in the same cgroup as the Elasticsearch process.\nThis value is stored as a string for consistency with `limit_in_bytes`.",
            "type": "string"
          }
        }
      },
      "nodes._types:Process": {
        "type": "object",
        "properties": {
          "cpu": {
            "$ref": "#/components/schemas/nodes._types:Cpu"
          },
          "mem": {
            "$ref": "#/components/schemas/nodes._types:MemoryStats"
          },
          "open_file_descriptors": {
            "description": "Number of opened file descriptors associated with the current or `-1` if not supported.",
            "type": "number"
          },
          "max_file_descriptors": {
            "description": "Maximum number of file descriptors allowed on the system, or `-1` if not supported.",
            "type": "number"
          },
          "timestamp": {
            "description": "Last time the statistics were refreshed.\nRecorded in milliseconds since the Unix Epoch.",
            "type": "number"
          }
        }
      },
      "nodes._types:ScriptCache": {
        "type": "object",
        "properties": {
          "cache_evictions": {
            "description": "Total number of times the script cache has evicted old data.",
            "type": "number"
          },
          "compilation_limit_triggered": {
            "description": "Total number of times the script compilation circuit breaker has limited inline script compilations.",
            "type": "number"
          },
          "compilations": {
            "description": "Total number of inline script compilations performed by the node.",
            "type": "number"
          },
          "context": {
            "type": "string"
          }
        }
      },
      "nodes._types:Transport": {
        "type": "object",
        "properties": {
          "inbound_handling_time_histogram": {
            "description": "The distribution of the time spent handling each inbound message on a transport thread, represented as a histogram.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:TransportHistogram"
            }
          },
          "outbound_handling_time_histogram": {
            "description": "The distribution of the time spent sending each outbound transport message on a transport thread, represented as a histogram.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:TransportHistogram"
            }
          },
          "rx_count": {
            "description": "Total number of RX (receive) packets received by the node during internal cluster communication.",
            "type": "number"
          },
          "rx_size": {
            "description": "Size of RX packets received by the node during internal cluster communication.",
            "type": "string"
          },
          "rx_size_in_bytes": {
            "description": "Size, in bytes, of RX packets received by the node during internal cluster communication.",
            "type": "number"
          },
          "server_open": {
            "description": "Current number of inbound TCP connections used for internal communication between nodes.",
            "type": "number"
          },
          "tx_count": {
            "description": "Total number of TX (transmit) packets sent by the node during internal cluster communication.",
            "type": "number"
          },
          "tx_size": {
            "description": "Size of TX packets sent by the node during internal cluster communication.",
            "type": "string"
          },
          "tx_size_in_bytes": {
            "description": "Size, in bytes, of TX packets sent by the node during internal cluster communication.",
            "type": "number"
          },
          "total_outbound_connections": {
            "description": "The cumulative number of outbound transport connections that this node has opened since it started.\nEach transport connection may comprise multiple TCP connections but is only counted once in this statistic.\nTransport connections are typically long-lived so this statistic should remain constant in a stable cluster.",
            "type": "number"
          }
        }
      },
      "nodes._types:TransportHistogram": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of times a transport thread took a period of time within the bounds of this bucket to handle an inbound message.",
            "type": "number"
          },
          "lt_millis": {
            "description": "The exclusive upper bound of the bucket in milliseconds.\nMay be omitted on the last bucket if this bucket has no upper bound.",
            "type": "number"
          },
          "ge_millis": {
            "description": "The inclusive lower bound of the bucket in milliseconds. May be omitted on the first bucket if this bucket has no lower bound.",
            "type": "number"
          }
        }
      },
      "nodes._types:Discovery": {
        "type": "object",
        "properties": {
          "cluster_state_queue": {
            "$ref": "#/components/schemas/nodes._types:ClusterStateQueue"
          },
          "published_cluster_states": {
            "$ref": "#/components/schemas/nodes._types:PublishedClusterStates"
          },
          "cluster_state_update": {
            "description": "Contains low-level statistics about how long various activities took during cluster state updates while the node was the elected master.\nOmitted if the node is not master-eligible.\nEvery field whose name ends in `_time` within this object is also represented as a raw number of milliseconds in a field whose name ends in `_time_millis`.\nThe human-readable fields with a `_time` suffix are only returned if requested with the `?human=true` query parameter.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/nodes._types:ClusterStateUpdate"
            }
          },
          "serialized_cluster_states": {
            "$ref": "#/components/schemas/nodes._types:SerializedClusterState"
          },
          "cluster_applier_stats": {
            "$ref": "#/components/schemas/nodes._types:ClusterAppliedStats"
          }
        }
      },
      "nodes._types:ClusterStateQueue": {
        "type": "object",
        "properties": {
          "total": {
            "description": "Total number of cluster states in queue.",
            "type": "number"
          },
          "pending": {
            "description": "Number of pending cluster states in queue.",
            "type": "number"
          },
          "committed": {
            "description": "Number of committed cluster states in queue.",
            "type": "number"
          }
        }
      },
      "nodes._types:PublishedClusterStates": {
        "type": "object",
        "properties": {
          "full_states": {
            "description": "Number of published cluster states.",
            "type": "number"
          },
          "incompatible_diffs": {
            "description": "Number of incompatible differences between published cluster states.",
            "type": "number"
          },
          "compatible_diffs": {
            "description": "Number of compatible differences between published cluster states.",
            "type": "number"
          }
        }
      },
      "nodes._types:ClusterStateUpdate": {
        "type": "object",
        "properties": {
          "count": {
            "description": "The number of cluster state update attempts that did not change the cluster state since the node started.",
            "type": "number"
          },
          "computation_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "computation_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "publication_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "publication_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "context_construction_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "context_construction_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "commit_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "commit_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "completion_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "completion_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "master_apply_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "master_apply_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "notification_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "notification_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        },
        "required": [
          "count"
        ]
      },
      "nodes._types:SerializedClusterState": {
        "type": "object",
        "properties": {
          "full_states": {
            "$ref": "#/components/schemas/nodes._types:SerializedClusterStateDetail"
          },
          "diffs": {
            "$ref": "#/components/schemas/nodes._types:SerializedClusterStateDetail"
          }
        }
      },
      "nodes._types:SerializedClusterStateDetail": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "uncompressed_size": {
            "type": "string"
          },
          "uncompressed_size_in_bytes": {
            "type": "number"
          },
          "compressed_size": {
            "type": "string"
          },
          "compressed_size_in_bytes": {
            "type": "number"
          }
        }
      },
      "nodes._types:ClusterAppliedStats": {
        "type": "object",
        "properties": {
          "recordings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/nodes._types:Recording"
            }
          }
        }
      },
      "nodes._types:Recording": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "cumulative_execution_count": {
            "type": "number"
          },
          "cumulative_execution_time": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "cumulative_execution_time_millis": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          }
        }
      },
      "nodes._types:IndexingPressure": {
        "type": "object",
        "properties": {
          "memory": {
            "$ref": "#/components/schemas/nodes._types:IndexingPressureMemory"
          }
        }
      },
      "nodes._types:IndexingPressureMemory": {
        "type": "object",
        "properties": {
          "limit": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "limit_in_bytes": {
            "description": "Configured memory limit, in bytes, for the indexing requests.\nReplica requests have an automatic limit that is 1.5x this value.",
            "type": "number"
          },
          "current": {
            "$ref": "#/components/schemas/nodes._types:PressureMemory"
          },
          "total": {
            "$ref": "#/components/schemas/nodes._types:PressureMemory"
          }
        }
      },
      "nodes._types:PressureMemory": {
        "type": "object",
        "properties": {
          "all": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "all_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the coordinating, primary, or replica stage.",
            "type": "number"
          },
          "combined_coordinating_and_primary": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "combined_coordinating_and_primary_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the coordinating or primary stage.\nThis value is not the sum of coordinating and primary as a node can reuse the coordinating memory if the primary stage is executed locally.",
            "type": "number"
          },
          "coordinating": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "coordinating_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the coordinating stage.",
            "type": "number"
          },
          "primary": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "primary_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the primary stage.",
            "type": "number"
          },
          "replica": {
            "$ref": "#/components/schemas/_types:ByteSize"
          },
          "replica_in_bytes": {
            "description": "Memory consumed, in bytes, by indexing requests in the replica stage.",
            "type": "number"
          },
          "coordinating_rejections": {
            "description": "Number of indexing requests rejected in the coordinating stage.",
            "type": "number"
          },
          "primary_rejections": {
            "description": "Number of indexing requests rejected in the primary stage.",
            "type": "number"
          },
          "replica_rejections": {
            "description": "Number of indexing requests rejected in the replica stage.",
            "type": "number"
          }
        }
      },
      "nodes.usage:ResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/nodes._types:NodesResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "cluster_name": {
                "$ref": "#/components/schemas/_types:Name"
              },
              "nodes": {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/nodes.usage:NodeUsage"
                }
              }
            },
            "required": [
              "cluster_name",
              "nodes"
            ]
          }
        ]
      },
      "nodes.usage:NodeUsage": {
        "type": "object",
        "properties": {
          "rest_actions": {
            "type": "object",
            "additionalProperties": {
              "type": "number"
            }
          },
          "since": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "aggregations": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "rest_actions",
          "since",
          "timestamp",
          "aggregations"
        ]
      },
      "query_ruleset._types:QueryRuleset": {
        "type": "object",
        "properties": {
          "ruleset_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "rules": {
            "description": "Rules associated with the query ruleset",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/query_ruleset._types:QueryRule"
            }
          }
        },
        "required": [
          "ruleset_id",
          "rules"
        ]
      },
      "query_ruleset._types:QueryRule": {
        "type": "object",
        "properties": {
          "rule_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "type": {
            "$ref": "#/components/schemas/query_ruleset._types:QueryRuleType"
          },
          "criteria": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/query_ruleset._types:QueryRuleCriteria"
            }
          },
          "actions": {
            "$ref": "#/components/schemas/query_ruleset._types:QueryRuleActions"
          }
        },
        "required": [
          "rule_id",
          "type",
          "criteria",
          "actions"
        ]
      },
      "query_ruleset._types:QueryRuleType": {
        "type": "string",
        "enum": [
          "pinned"
        ]
      },
      "query_ruleset._types:QueryRuleCriteria": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/query_ruleset._types:QueryRuleCriteriaType"
          },
          "metadata": {
            "type": "string"
          },
          "values": {
            "type": "array",
            "items": {
              "type": "object"
            }
          }
        },
        "required": [
          "type",
          "metadata"
        ]
      },
      "query_ruleset._types:QueryRuleCriteriaType": {
        "type": "string",
        "enum": [
          "global",
          "exact",
          "exact_fuzzy",
          "prefix",
          "suffix",
          "contains",
          "lt",
          "lte",
          "gt",
          "gte"
        ]
      },
      "query_ruleset._types:QueryRuleActions": {
        "type": "object",
        "properties": {
          "ids": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Id"
            }
          },
          "docs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types.query_dsl:PinnedDoc"
            }
          }
        }
      },
      "query_ruleset.list:QueryRulesetListItem": {
        "type": "object",
        "properties": {
          "ruleset_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "rules_count": {
            "description": "The number of rules associated with this ruleset",
            "type": "number"
          }
        },
        "required": [
          "ruleset_id",
          "rules_count"
        ]
      },
      "_global.rank_eval:RankEvalRequestItem": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "request": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalQuery"
          },
          "ratings": {
            "description": "List of document ratings",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.rank_eval:DocumentRating"
            }
          },
          "template_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "params": {
            "description": "The search template parameters.",
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          }
        },
        "required": [
          "id",
          "ratings"
        ]
      },
      "_global.rank_eval:RankEvalQuery": {
        "type": "object",
        "properties": {
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "size": {
            "type": "number"
          }
        },
        "required": [
          "query"
        ]
      },
      "_global.rank_eval:DocumentRating": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "rating": {
            "description": "The documents relevance with regard to this search request.",
            "type": "number"
          }
        },
        "required": [
          "_id",
          "_index",
          "rating"
        ]
      },
      "_global.rank_eval:RankEvalMetric": {
        "type": "object",
        "properties": {
          "precision": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricPrecision"
          },
          "recall": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRecall"
          },
          "mean_reciprocal_rank": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricMeanReciprocalRank"
          },
          "dcg": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricDiscountedCumulativeGain"
          },
          "expected_reciprocal_rank": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricExpectedReciprocalRank"
          }
        }
      },
      "_global.rank_eval:RankEvalMetricPrecision": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRatingTreshold"
          },
          {
            "type": "object",
            "properties": {
              "ignore_unlabeled": {
                "description": "Controls how unlabeled documents in the search results are counted. If set to true, unlabeled documents are ignored and neither count as relevant or irrelevant. Set to false (the default), they are treated as irrelevant.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricRatingTreshold": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricBase"
          },
          {
            "type": "object",
            "properties": {
              "relevant_rating_threshold": {
                "description": "Sets the rating threshold above which documents are considered to be \"relevant\".",
                "type": "number"
              }
            }
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricBase": {
        "type": "object",
        "properties": {
          "k": {
            "description": "Sets the maximum number of documents retrieved per query. This value will act in place of the usual size parameter in the query.",
            "type": "number"
          }
        }
      },
      "_global.rank_eval:RankEvalMetricRecall": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRatingTreshold"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricMeanReciprocalRank": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricRatingTreshold"
          },
          {
            "type": "object"
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricDiscountedCumulativeGain": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricBase"
          },
          {
            "type": "object",
            "properties": {
              "normalize": {
                "externalDocs": {
                  "url": "https://en.wikipedia.org/wiki/Discounted_cumulative_gain#Normalized_DCG"
                },
                "description": "If set to true, this metric will calculate the Normalized DCG.",
                "type": "boolean"
              }
            }
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricExpectedReciprocalRank": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalMetricBase"
          },
          {
            "type": "object",
            "properties": {
              "maximum_relevance": {
                "description": "The highest relevance grade used in the user-supplied relevance judgments.",
                "type": "number"
              }
            },
            "required": [
              "maximum_relevance"
            ]
          }
        ]
      },
      "_global.rank_eval:RankEvalMetricDetail": {
        "type": "object",
        "properties": {
          "metric_score": {
            "description": "The metric_score in the details section shows the contribution of this query to the global quality metric score",
            "type": "number"
          },
          "unrated_docs": {
            "description": "The unrated_docs section contains an _index and _id entry for each document in the search result for this query that didnt have a ratings value. This can be used to ask the user to supply ratings for these documents",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.rank_eval:UnratedDocument"
            }
          },
          "hits": {
            "description": "The hits section shows a grouping of the search results with their supplied ratings",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_global.rank_eval:RankEvalHitItem"
            }
          },
          "metric_details": {
            "description": "The metric_details give additional information about the calculated quality metric (e.g. how many of the retrieved documents were relevant). The content varies for each metric but allows for better interpretation of the results",
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "object"
              }
            }
          }
        },
        "required": [
          "metric_score",
          "unrated_docs",
          "hits",
          "metric_details"
        ]
      },
      "_global.rank_eval:UnratedDocument": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "_id",
          "_index"
        ]
      },
      "_global.rank_eval:RankEvalHitItem": {
        "type": "object",
        "properties": {
          "hit": {
            "$ref": "#/components/schemas/_global.rank_eval:RankEvalHit"
          },
          "rating": {
            "oneOf": [
              {
                "type": "number"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          }
        },
        "required": [
          "hit"
        ]
      },
      "_global.rank_eval:RankEvalHit": {
        "type": "object",
        "properties": {
          "_id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "_index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "_score": {
            "type": "number"
          }
        },
        "required": [
          "_id",
          "_index",
          "_score"
        ]
      },
      "_global.scripts_painless_execute:PainlessContextSetup": {
        "type": "object",
        "properties": {
          "document": {
            "description": "Document thats temporarily indexed in-memory and accessible from the script.",
            "type": "object"
          },
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        },
        "required": [
          "document",
          "index",
          "query"
        ]
      },
      "_types:RankContainer": {
        "type": "object",
        "properties": {
          "rrf": {
            "$ref": "#/components/schemas/_types:RrfRank"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "_types:RrfRank": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:RankBase"
          },
          {
            "type": "object",
            "properties": {
              "rank_constant": {
                "description": "How much influence documents in individual result sets per query have over the final ranked result set",
                "type": "number"
              },
              "window_size": {
                "description": "Size of the individual result sets per query",
                "type": "number"
              }
            }
          }
        ]
      },
      "_types:RankBase": {
        "type": "object"
      },
      "search_application._types:SearchApplication": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "description": "Indices that are part of the Search Application.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "updated_at_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "analytics_collection_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "template": {
            "$ref": "#/components/schemas/search_application._types:SearchApplicationTemplate"
          }
        },
        "required": [
          "name",
          "indices",
          "updated_at_millis"
        ]
      },
      "search_application._types:SearchApplicationTemplate": {
        "type": "object",
        "properties": {
          "script": {
            "$ref": "#/components/schemas/_types:InlineScript"
          }
        },
        "required": [
          "script"
        ]
      },
      "search_application._types:AnalyticsCollection": {
        "type": "object",
        "properties": {
          "event_data_stream": {
            "$ref": "#/components/schemas/search_application._types:EventDataStream"
          }
        },
        "required": [
          "event_data_stream"
        ]
      },
      "search_application._types:EventDataStream": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:IndexName"
          }
        },
        "required": [
          "name"
        ]
      },
      "search_application.list:SearchApplicationListItem": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "indices": {
            "description": "Indices that are part of the Search Application",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:IndexName"
            }
          },
          "updated_at_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "analytics_collection_name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name",
          "indices",
          "updated_at_millis"
        ]
      },
      "search_application.put_behavioral_analytics:AnalyticsAcknowledgeResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:AcknowledgedResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "name": {
                "$ref": "#/components/schemas/_types:Name"
              }
            },
            "required": [
              "name"
            ]
          }
        ]
      },
      "_global.search_mvt._types:ZoomLevel": {
        "type": "number"
      },
      "_global.search_mvt._types:Coordinate": {
        "type": "number"
      },
      "_global.search_mvt._types:GridAggregationType": {
        "type": "string",
        "enum": [
          "geotile",
          "geohex"
        ]
      },
      "_global.search_mvt._types:GridType": {
        "type": "string",
        "enum": [
          "grid",
          "point",
          "centroid"
        ]
      },
      "_types:MapboxVectorTiles": {
        "type": "object"
      },
      "security._types:GrantType": {
        "type": "string",
        "enum": [
          "password",
          "access_token"
        ]
      },
      "security._types:UserProfileWithMetadata": {
        "allOf": [
          {
            "$ref": "#/components/schemas/security._types:UserProfile"
          },
          {
            "type": "object",
            "properties": {
              "last_synchronized": {
                "type": "number"
              },
              "_doc": {
                "$ref": "#/components/schemas/security._types:UserProfileHitMetadata"
              }
            },
            "required": [
              "last_synchronized",
              "_doc"
            ]
          }
        ]
      },
      "security._types:UserProfileHitMetadata": {
        "type": "object",
        "properties": {
          "_primary_term": {
            "type": "number"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          }
        },
        "required": [
          "_primary_term",
          "_seq_no"
        ]
      },
      "security._types:UserProfile": {
        "type": "object",
        "properties": {
          "uid": {
            "$ref": "#/components/schemas/security._types:UserProfileId"
          },
          "user": {
            "$ref": "#/components/schemas/security._types:UserProfileUser"
          },
          "data": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "labels": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "uid",
          "user",
          "data",
          "labels"
        ]
      },
      "security._types:UserProfileId": {
        "type": "string"
      },
      "security._types:UserProfileUser": {
        "type": "object",
        "properties": {
          "email": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "full_name": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Name"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "realm_name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "realm_domain": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          }
        },
        "required": [
          "realm_name",
          "roles",
          "username"
        ]
      },
      "_types:Username": {
        "type": "string"
      },
      "security._types:ApiKey": {
        "type": "object",
        "properties": {
          "creation": {
            "description": "Creation time for the API key in milliseconds.",
            "type": "number"
          },
          "expiration": {
            "description": "Expiration time for the API key in milliseconds.",
            "type": "number"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "invalidated": {
            "description": "Invalidation status for the API key.\nIf the key has been invalidated, it has a value of `true`. Otherwise, it is `false`.",
            "type": "boolean"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "realm": {
            "description": "Realm name of the principal for which this API key was created.",
            "type": "string"
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "role_descriptors": {
            "description": "The role descriptors assigned to this API key when it was created or last updated.\nAn empty role descriptor means the API key inherits the owner users permissions.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/security._types:RoleDescriptor"
            }
          },
          "limited_by": {
            "description": "The owner users permissions associated with the API key.\nIt is a point-in-time snapshot captured at creation and subsequent updates.\nAn API keys effective permissions are an intersection of its assigned privileges and the owner users permissions.",
            "type": "array",
            "items": {
              "type": "object",
              "additionalProperties": {
                "$ref": "#/components/schemas/security._types:RoleDescriptor"
              }
            }
          },
          "_sort": {
            "$ref": "#/components/schemas/_types:SortResults"
          }
        },
        "required": [
          "id",
          "name"
        ]
      },
      "security._types:RoleDescriptor": {
        "type": "object",
        "properties": {
          "cluster": {
            "description": "A list of cluster privileges. These privileges define the cluster level actions that API keys are able to execute.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "indices": {
            "description": "A list of indices permissions entries.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivileges"
            }
          },
          "global": {
            "description": "An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.",
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/security._types:GlobalPrivilege"
                }
              },
              {
                "$ref": "#/components/schemas/security._types:GlobalPrivilege"
              }
            ]
          },
          "applications": {
            "description": "A list of application privilege entries",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "run_as": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/run-as-privilege.html"
            },
            "description": "A list of users that the API keys can impersonate.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transient_metadata": {
            "$ref": "#/components/schemas/security._types:TransientMetadataConfig"
          }
        }
      },
      "security._types:IndicesPrivileges": {
        "type": "object",
        "properties": {
          "field_security": {
            "$ref": "#/components/schemas/security._types:FieldSecurity"
          },
          "names": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "privileges": {
            "description": "The index level privileges that owners of the role have on the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "query": {
            "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "names",
          "privileges"
        ]
      },
      "security._types:FieldSecurity": {
        "type": "object",
        "properties": {
          "except": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "grant": {
            "$ref": "#/components/schemas/_types:Fields"
          }
        }
      },
      "security._types:IndexPrivilege": {
        "type": "string",
        "enum": [
          "none",
          "all",
          "auto_configure",
          "create",
          "create_doc",
          "create_index",
          "delete",
          "delete_index",
          "index",
          "maintenance",
          "manage",
          "manage_follow_index",
          "manage_ilm",
          "manage_leader_index",
          "monitor",
          "read",
          "read_cross_cluster",
          "view_index_metadata",
          "write"
        ]
      },
      "security._types:IndicesPrivilegesQuery": {
        "description": "While creating or updating a role you can provide either a JSON structure or a string to the API.\nHowever, the response provided by Elasticsearch will only be string with a json-as-text content.\n\nSince this is embedded in `IndicesPrivileges`, the same structure is used for clarity in both contexts.",
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          {
            "$ref": "#/components/schemas/security._types:RoleTemplateQuery"
          }
        ]
      },
      "security._types:RoleTemplateQuery": {
        "type": "object",
        "properties": {
          "template": {
            "$ref": "#/components/schemas/security._types:RoleTemplateScript"
          }
        }
      },
      "security._types:RoleTemplateScript": {
        "oneOf": [
          {
            "$ref": "#/components/schemas/security._types:RoleTemplateInlineScript"
          },
          {
            "$ref": "#/components/schemas/_types:StoredScriptId"
          }
        ]
      },
      "security._types:RoleTemplateInlineScript": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:ScriptBase"
          },
          {
            "type": "object",
            "properties": {
              "lang": {
                "$ref": "#/components/schemas/_types:ScriptLanguage"
              },
              "options": {
                "type": "object",
                "additionalProperties": {
                  "type": "string"
                }
              },
              "source": {
                "$ref": "#/components/schemas/security._types:RoleTemplateInlineQuery"
              }
            },
            "required": [
              "source"
            ]
          }
        ]
      },
      "security._types:RoleTemplateInlineQuery": {
        "oneOf": [
          {
            "type": "string"
          },
          {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          }
        ]
      },
      "security._types:GlobalPrivilege": {
        "type": "object",
        "properties": {
          "application": {
            "$ref": "#/components/schemas/security._types:ApplicationGlobalUserPrivileges"
          }
        },
        "required": [
          "application"
        ]
      },
      "security._types:ApplicationGlobalUserPrivileges": {
        "type": "object",
        "properties": {
          "manage": {
            "$ref": "#/components/schemas/security._types:ManageUserPrivileges"
          }
        },
        "required": [
          "manage"
        ]
      },
      "security._types:ManageUserPrivileges": {
        "type": "object",
        "properties": {
          "applications": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "applications"
        ]
      },
      "security._types:ApplicationPrivileges": {
        "type": "object",
        "properties": {
          "application": {
            "description": "The name of the application to which this entry applies.",
            "type": "string"
          },
          "privileges": {
            "description": "A list of strings, where each element is the name of an application privilege or action.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "resources": {
            "description": "A list resources to which the privileges are applied.",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "application",
          "privileges",
          "resources"
        ]
      },
      "security._types:TransientMetadataConfig": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          }
        },
        "required": [
          "enabled"
        ]
      },
      "security._types:RealmInfo": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "security.authenticate:Token": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name"
        ]
      },
      "security._types:ClusterNode": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name"
        ]
      },
      "_types:Namespace": {
        "type": "string"
      },
      "_types:Service": {
        "type": "string"
      },
      "security.create_service_token:Token": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "value": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "value"
        ]
      },
      "security.delete_privileges:FoundStatus": {
        "type": "object",
        "properties": {
          "found": {
            "type": "boolean"
          }
        },
        "required": [
          "found"
        ]
      },
      "security.put_privileges:Actions": {
        "type": "object",
        "properties": {
          "actions": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "application": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "actions"
        ]
      },
      "security.get_role:Role": {
        "type": "object",
        "properties": {
          "cluster": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "indices": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivileges"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "run_as": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transient_metadata": {
            "$ref": "#/components/schemas/security._types:TransientMetadataConfig"
          },
          "applications": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
            }
          },
          "role_templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.get_role:RoleTemplate"
            }
          },
          "global": {
            "type": "object",
            "additionalProperties": {
              "type": "object",
              "additionalProperties": {
                "type": "object",
                "additionalProperties": {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "required": [
          "cluster",
          "indices",
          "metadata",
          "run_as",
          "transient_metadata",
          "applications"
        ]
      },
      "security.get_role:RoleTemplate": {
        "type": "object",
        "properties": {
          "format": {
            "$ref": "#/components/schemas/security.get_role:TemplateFormat"
          },
          "template": {
            "$ref": "#/components/schemas/_types:Script"
          }
        },
        "required": [
          "template"
        ]
      },
      "security.get_role:TemplateFormat": {
        "type": "string",
        "enum": [
          "string",
          "json"
        ]
      },
      "security._types:RoleMapping": {
        "type": "object",
        "properties": {
          "enabled": {
            "type": "boolean"
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "rules": {
            "$ref": "#/components/schemas/security._types:RoleMappingRule"
          },
          "role_templates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.get_role:RoleTemplate"
            }
          }
        },
        "required": [
          "enabled",
          "metadata",
          "roles",
          "rules"
        ]
      },
      "security._types:RoleMappingRule": {
        "type": "object",
        "properties": {
          "any": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RoleMappingRule"
            }
          },
          "all": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:RoleMappingRule"
            }
          },
          "field": {
            "$ref": "#/components/schemas/security._types:FieldRule"
          },
          "except": {
            "$ref": "#/components/schemas/security._types:RoleMappingRule"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security._types:FieldRule": {
        "type": "object",
        "properties": {
          "username": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "dn": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "groups": {
            "$ref": "#/components/schemas/_types:Names"
          },
          "metadata": {
            "type": "object"
          },
          "realm": {
            "$ref": "#/components/schemas/security._types:Realm"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "security._types:Realm": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "name"
        ]
      },
      "security.get_service_accounts:RoleDescriptorWrapper": {
        "type": "object",
        "properties": {
          "role_descriptor": {
            "$ref": "#/components/schemas/security._types:RoleDescriptorRead"
          }
        },
        "required": [
          "role_descriptor"
        ]
      },
      "security._types:RoleDescriptorRead": {
        "type": "object",
        "properties": {
          "cluster": {
            "description": "A list of cluster privileges. These privileges define the cluster level actions that API keys are able to execute.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "indices": {
            "description": "A list of indices permissions entries.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivileges"
            }
          },
          "global": {
            "description": "An object defining global privileges. A global privilege is a form of cluster privilege that is request-aware. Support for global privileges is currently limited to the management of application privileges.",
            "oneOf": [
              {
                "type": "array",
                "items": {
                  "$ref": "#/components/schemas/security._types:GlobalPrivilege"
                }
              },
              {
                "$ref": "#/components/schemas/security._types:GlobalPrivilege"
              }
            ]
          },
          "applications": {
            "description": "A list of application privilege entries",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ApplicationPrivileges"
            }
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "run_as": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/run-as-privilege.html"
            },
            "description": "A list of users that the API keys can impersonate.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "transient_metadata": {
            "$ref": "#/components/schemas/security._types:TransientMetadataConfig"
          }
        },
        "required": [
          "cluster",
          "indices"
        ]
      },
      "security.get_service_credentials:NodesCredentials": {
        "type": "object",
        "properties": {
          "_nodes": {
            "$ref": "#/components/schemas/_types:NodeStatistics"
          },
          "file_tokens": {
            "description": "File-backed tokens collected from all nodes",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/security.get_service_credentials:NodesCredentialsFileToken"
            }
          }
        },
        "required": [
          "_nodes",
          "file_tokens"
        ]
      },
      "security.get_service_credentials:NodesCredentialsFileToken": {
        "type": "object",
        "properties": {
          "nodes": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "nodes"
        ]
      },
      "security.get_token:AccessTokenGrantType": {
        "type": "string",
        "enum": [
          "password",
          "client_credentials",
          "_kerberos",
          "refresh_token"
        ]
      },
      "_types:Password": {
        "type": "string"
      },
      "security.get_token:AuthenticatedUser": {
        "allOf": [
          {
            "$ref": "#/components/schemas/security._types:User"
          },
          {
            "type": "object",
            "properties": {
              "authentication_realm": {
                "$ref": "#/components/schemas/security.get_token:UserRealm"
              },
              "lookup_realm": {
                "$ref": "#/components/schemas/security.get_token:UserRealm"
              },
              "authentication_provider": {
                "$ref": "#/components/schemas/security.get_token:AuthenticationProvider"
              },
              "authentication_type": {
                "type": "string"
              }
            },
            "required": [
              "authentication_realm",
              "lookup_realm",
              "authentication_type"
            ]
          }
        ]
      },
      "security.get_token:UserRealm": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "type": {
            "type": "string"
          }
        },
        "required": [
          "name",
          "type"
        ]
      },
      "security.get_token:AuthenticationProvider": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          }
        },
        "required": [
          "type",
          "name"
        ]
      },
      "security._types:User": {
        "type": "object",
        "properties": {
          "email": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "full_name": {
            "oneOf": [
              {
                "$ref": "#/components/schemas/_types:Name"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          },
          "roles": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "enabled": {
            "type": "boolean"
          },
          "profile_uid": {
            "$ref": "#/components/schemas/security._types:UserProfileId"
          }
        },
        "required": [
          "metadata",
          "roles",
          "username",
          "enabled"
        ]
      },
      "security._types:UserIndicesPrivileges": {
        "type": "object",
        "properties": {
          "field_security": {
            "externalDocs": {
              "url": "https://www.elastic.co/guide/en/elasticsearch/reference/current/field-and-document-access-control.html"
            },
            "description": "The document fields that the owners of the role have read access to.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:FieldSecurity"
            }
          },
          "names": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "privileges": {
            "description": "The index level privileges that owners of the role have on the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "query": {
            "description": "Search queries that define the documents the user has access to. A document within the specified indices must match these queries for it to be accessible by the owners of the role.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndicesPrivilegesQuery"
            }
          },
          "allow_restricted_indices": {
            "description": "Set to `true` if using wildcard or regular expressions for patterns that cover restricted indices. Implicitly, restricted indices have limited privileges that can cause pattern tests to fail. If restricted indices are explicitly included in the `names` list, Elasticsearch checks privileges against these indices regardless of the value set for `allow_restricted_indices`.",
            "type": "boolean"
          }
        },
        "required": [
          "names",
          "privileges",
          "allow_restricted_indices"
        ]
      },
      "security.get_user_profile:GetUserProfileErrors": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "count",
          "details"
        ]
      },
      "security.grant_api_key:GrantApiKey": {
        "type": "object",
        "properties": {
          "name": {
            "$ref": "#/components/schemas/_types:Name"
          },
          "expiration": {
            "$ref": "#/components/schemas/_types:DurationLarge"
          },
          "role_descriptors": {
            "description": "The role descriptors for this API key.\nThis parameter is optional.\nWhen it is not specified or is an empty array, the API key has a point in time snapshot of permissions of the specified user or access token.\nIf you supply role descriptors, the resultant permissions are an intersection of API keys permissions and the permissions of the user or access token.",
            "oneOf": [
              {
                "type": "object",
                "additionalProperties": {
                  "$ref": "#/components/schemas/security._types:RoleDescriptor"
                }
              },
              {
                "type": "array",
                "items": {
                  "type": "object",
                  "additionalProperties": {
                    "$ref": "#/components/schemas/security._types:RoleDescriptor"
                  }
                }
              }
            ]
          },
          "metadata": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "name"
        ]
      },
      "security.grant_api_key:ApiKeyGrantType": {
        "type": "string",
        "enum": [
          "access_token",
          "password"
        ]
      },
      "security.has_privileges:ApplicationPrivilegesCheck": {
        "type": "object",
        "properties": {
          "application": {
            "description": "The name of the application.",
            "type": "string"
          },
          "privileges": {
            "description": "A list of the privileges that you want to check for the specified resources. May be either application privilege names, or the names of actions that are granted by those privileges",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "resources": {
            "description": "A list of resource names against which the privileges should be checked",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "application",
          "privileges",
          "resources"
        ]
      },
      "security._types:ClusterPrivilege": {
        "type": "string",
        "enum": [
          "all",
          "cancel_task",
          "create_snapshot",
          "grant_api_key",
          "manage",
          "manage_api_key",
          "manage_ccr",
          "manage_enrich",
          "manage_ilm",
          "manage_index_templates",
          "manage_ingest_pipelines",
          "manage_logstash_pipelines",
          "manage_ml",
          "manage_oidc",
          "manage_own_api_key",
          "manage_pipeline",
          "manage_rollup",
          "manage_saml",
          "manage_security",
          "manage_service_account",
          "manage_slm",
          "manage_token",
          "manage_transform",
          "manage_user_profile",
          "manage_watcher",
          "monitor",
          "monitor_ml",
          "monitor_rollup",
          "monitor_snapshot",
          "monitor_text_structure",
          "monitor_transform",
          "monitor_watcher",
          "read_ccr",
          "read_ilm",
          "read_pipeline",
          "read_slm",
          "transport_client"
        ]
      },
      "security.has_privileges:IndexPrivilegesCheck": {
        "type": "object",
        "properties": {
          "names": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "privileges": {
            "description": "A list of the privileges that you want to check for the specified indices.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:IndexPrivilege"
            }
          },
          "allow_restricted_indices": {
            "description": "This needs to be set to true (default is false) if using wildcards or regexps for patterns that cover restricted indices.\nImplicitly, restricted indices do not match index patterns because restricted indices usually have limited privileges and including them in pattern tests would render most such tests false.\nIf restricted indices are explicitly included in the names list, privileges will be checked against them regardless of the value of allow_restricted_indices.",
            "type": "boolean"
          }
        },
        "required": [
          "names",
          "privileges"
        ]
      },
      "security.has_privileges:ApplicationsPrivileges": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/security.has_privileges:ResourcePrivileges"
        }
      },
      "security.has_privileges:ResourcePrivileges": {
        "type": "object",
        "additionalProperties": {
          "$ref": "#/components/schemas/security.has_privileges:Privileges"
        }
      },
      "security.has_privileges:Privileges": {
        "type": "object",
        "additionalProperties": {
          "type": "boolean"
        }
      },
      "security.has_privileges_user_profile:PrivilegesCheck": {
        "type": "object",
        "properties": {
          "application": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.has_privileges:ApplicationPrivilegesCheck"
            }
          },
          "cluster": {
            "description": "A list of the cluster privileges that you want to check.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:ClusterPrivilege"
            }
          },
          "index": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security.has_privileges:IndexPrivilegesCheck"
            }
          }
        }
      },
      "security.has_privileges_user_profile:HasPrivilegesUserProfileErrors": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types:ErrorCause"
            }
          }
        },
        "required": [
          "count",
          "details"
        ]
      },
      "security._types:CreatedStatus": {
        "type": "object",
        "properties": {
          "created": {
            "type": "boolean"
          }
        },
        "required": [
          "created"
        ]
      },
      "security.suggest_user_profiles:Hint": {
        "type": "object",
        "properties": {
          "uids": {
            "description": "A list of Profile UIDs to match against.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/security._types:UserProfileId"
            }
          },
          "labels": {
            "description": "A single key-value pair to match against the labels section\nof a profile. A profile is considered matching if it matches\nat least one of the strings.",
            "type": "object",
            "additionalProperties": {
              "oneOf": [
                {
                  "type": "string"
                },
                {
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              ]
            }
          }
        }
      },
      "security.suggest_user_profiles:TotalUserProfiles": {
        "type": "object",
        "properties": {
          "value": {
            "type": "number"
          },
          "relation": {
            "$ref": "#/components/schemas/_types:RelationName"
          }
        },
        "required": [
          "value",
          "relation"
        ]
      },
      "ssl.certificates:CertificateInformation": {
        "type": "object",
        "properties": {
          "alias": {
            "oneOf": [
              {
                "type": "string"
              },
              {
                "nullable": true,
                "type": "string"
              }
            ]
          },
          "expiry": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "format": {
            "type": "string"
          },
          "has_private_key": {
            "type": "boolean"
          },
          "issuer": {
            "type": "string"
          },
          "path": {
            "type": "string"
          },
          "serial_number": {
            "type": "string"
          },
          "subject_dn": {
            "type": "string"
          }
        },
        "required": [
          "alias",
          "expiry",
          "format",
          "has_private_key",
          "path",
          "serial_number",
          "subject_dn"
        ]
      },
      "synonyms._types:SynonymsUpdateResult": {
        "type": "object",
        "properties": {
          "result": {
            "$ref": "#/components/schemas/_types:Result"
          },
          "reload_analyzers_details": {
            "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadResult"
          }
        },
        "required": [
          "result",
          "reload_analyzers_details"
        ]
      },
      "indices.reload_search_analyzers:ReloadResult": {
        "type": "object",
        "properties": {
          "reload_details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/indices.reload_search_analyzers:ReloadDetails"
            }
          },
          "_shards": {
            "$ref": "#/components/schemas/_types:ShardStatistics"
          }
        },
        "required": [
          "reload_details",
          "_shards"
        ]
      },
      "indices.reload_search_analyzers:ReloadDetails": {
        "type": "object",
        "properties": {
          "index": {
            "type": "string"
          },
          "reloaded_analyzers": {
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "reloaded_node_ids": {
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "required": [
          "index",
          "reloaded_analyzers",
          "reloaded_node_ids"
        ]
      },
      "synonyms._types:SynonymRuleRead": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "synonyms": {
            "$ref": "#/components/schemas/synonyms._types:SynonymString"
          }
        },
        "required": [
          "id",
          "synonyms"
        ]
      },
      "synonyms._types:SynonymString": {
        "type": "string"
      },
      "synonyms.get_synonyms_sets:SynonymsSetItem": {
        "type": "object",
        "properties": {
          "synonyms_set": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "count": {
            "description": "Number of synonym rules that the synonym set contains",
            "type": "number"
          }
        },
        "required": [
          "synonyms_set",
          "count"
        ]
      },
      "synonyms._types:SynonymRule": {
        "type": "object",
        "properties": {
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "synonyms": {
            "$ref": "#/components/schemas/synonyms._types:SynonymString"
          }
        },
        "required": [
          "synonyms"
        ]
      },
      "text_structure.find_structure:FieldStat": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "cardinality": {
            "type": "number"
          },
          "top_hits": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/text_structure.find_structure:TopHit"
            }
          },
          "mean_value": {
            "type": "number"
          },
          "median_value": {
            "type": "number"
          },
          "max_value": {
            "type": "number"
          },
          "min_value": {
            "type": "number"
          },
          "earliest": {
            "type": "string"
          },
          "latest": {
            "type": "string"
          }
        },
        "required": [
          "count",
          "cardinality",
          "top_hits"
        ]
      },
      "text_structure.find_structure:TopHit": {
        "type": "object",
        "properties": {
          "count": {
            "type": "number"
          },
          "value": {
            "type": "object"
          }
        },
        "required": [
          "count",
          "value"
        ]
      },
      "ingest._types:PipelineConfig": {
        "type": "object",
        "properties": {
          "description": {
            "description": "Description of the ingest pipeline.",
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionNumber"
          },
          "processors": {
            "description": "Processors used to perform transformations on documents before indexing.\nProcessors run sequentially in the order specified.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ingest._types:ProcessorContainer"
            }
          }
        },
        "required": [
          "processors"
        ]
      },
      "transform.get_transform:TransformSummary": {
        "type": "object",
        "properties": {
          "authorization": {
            "$ref": "#/components/schemas/ml._types:TransformAuthorization"
          },
          "create_time": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "description": {
            "description": "Free text description of the transform.",
            "type": "string"
          },
          "dest": {
            "$ref": "#/components/schemas/_global.reindex:Destination"
          },
          "frequency": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "latest": {
            "$ref": "#/components/schemas/transform._types:Latest"
          },
          "pivot": {
            "$ref": "#/components/schemas/transform._types:Pivot"
          },
          "retention_policy": {
            "$ref": "#/components/schemas/transform._types:RetentionPolicyContainer"
          },
          "settings": {
            "$ref": "#/components/schemas/transform._types:Settings"
          },
          "source": {
            "$ref": "#/components/schemas/transform._types:Source"
          },
          "sync": {
            "$ref": "#/components/schemas/transform._types:SyncContainer"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          },
          "_meta": {
            "$ref": "#/components/schemas/_types:Metadata"
          }
        },
        "required": [
          "dest",
          "id",
          "source"
        ]
      },
      "ml._types:TransformAuthorization": {
        "type": "object",
        "properties": {
          "api_key": {
            "$ref": "#/components/schemas/ml._types:ApiKeyAuthorization"
          },
          "roles": {
            "description": "If a user ID was used for the most recent update to the transform, its roles at the time of the update are listed in the response.",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "service_account": {
            "description": "If a service account was used for the most recent update to the transform, the account name is listed in the response.",
            "type": "string"
          }
        }
      },
      "_global.reindex:Destination": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "op_type": {
            "$ref": "#/components/schemas/_types:OpType"
          },
          "pipeline": {
            "description": "The name of the pipeline to use.",
            "type": "string"
          },
          "routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "version_type": {
            "$ref": "#/components/schemas/_types:VersionType"
          }
        },
        "required": [
          "index"
        ]
      },
      "transform._types:Latest": {
        "type": "object",
        "properties": {
          "sort": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "unique_key": {
            "description": "Specifies an array of one or more fields that are used to group the data.",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/_types:Field"
            }
          }
        },
        "required": [
          "sort",
          "unique_key"
        ]
      },
      "transform._types:Pivot": {
        "type": "object",
        "properties": {
          "aggregations": {
            "description": "Defines how to aggregate the grouped data. The following aggregations are currently supported: average, bucket\nscript, bucket selector, cardinality, filter, geo bounds, geo centroid, geo line, max, median absolute deviation,\nmin, missing, percentiles, rare terms, scripted metric, stats, sum, terms, top metrics, value count, weighted\naverage.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/_types.aggregations:AggregationContainer"
            }
          },
          "group_by": {
            "description": "Defines how to group the data. More than one grouping can be defined per pivot. The following groupings are\ncurrently supported: date histogram, geotile grid, histogram, terms.",
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/transform._types:PivotGroupByContainer"
            }
          }
        }
      },
      "transform._types:PivotGroupByContainer": {
        "type": "object",
        "properties": {
          "date_histogram": {
            "$ref": "#/components/schemas/_types.aggregations:DateHistogramAggregation"
          },
          "geotile_grid": {
            "$ref": "#/components/schemas/_types.aggregations:GeoTileGridAggregation"
          },
          "histogram": {
            "$ref": "#/components/schemas/_types.aggregations:HistogramAggregation"
          },
          "terms": {
            "$ref": "#/components/schemas/_types.aggregations:TermsAggregation"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "transform._types:RetentionPolicyContainer": {
        "type": "object",
        "properties": {
          "time": {
            "$ref": "#/components/schemas/transform._types:RetentionPolicy"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "transform._types:RetentionPolicy": {
        "type": "object",
        "properties": {
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          },
          "max_age": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "field",
          "max_age"
        ]
      },
      "transform._types:Settings": {
        "type": "object",
        "properties": {
          "align_checkpoints": {
            "description": "Specifies whether the transform checkpoint ranges should be optimized for performance. Such optimization can align\ncheckpoint ranges with the date histogram interval when date histogram is specified as a group source in the\ntransform config. As a result, less document updates in the destination index will be performed thus improving\noverall performance.",
            "type": "boolean"
          },
          "dates_as_epoch_millis": {
            "description": "Defines if dates in the ouput should be written as ISO formatted string or as millis since epoch. epoch_millis was\nthe default for transforms created before version 7.11. For compatible output set this value to `true`.",
            "type": "boolean"
          },
          "deduce_mappings": {
            "description": "Specifies whether the transform should deduce the destination index mappings from the transform configuration.",
            "type": "boolean"
          },
          "docs_per_second": {
            "description": "Specifies a limit on the number of input documents per second. This setting throttles the transform by adding a\nwait time between search requests. The default value is null, which disables throttling.",
            "type": "number"
          },
          "max_page_search_size": {
            "description": "Defines the initial page size to use for the composite aggregation for each checkpoint. If circuit breaker\nexceptions occur, the page size is dynamically adjusted to a lower value. The minimum value is `10` and the\nmaximum is `65,536`.",
            "type": "number"
          },
          "unattended": {
            "description": "If `true`, the transform runs in unattended mode. In unattended mode, the transform retries indefinitely in case\nof an error which means the transform never fails. Setting the number of retries other than infinite fails in\nvalidation.",
            "type": "boolean"
          }
        }
      },
      "transform._types:Source": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          }
        },
        "required": [
          "index"
        ]
      },
      "transform._types:SyncContainer": {
        "type": "object",
        "properties": {
          "time": {
            "$ref": "#/components/schemas/transform._types:TimeSync"
          }
        },
        "minProperties": 1,
        "maxProperties": 1
      },
      "transform._types:TimeSync": {
        "type": "object",
        "properties": {
          "delay": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "field": {
            "$ref": "#/components/schemas/_types:Field"
          }
        },
        "required": [
          "field"
        ]
      },
      "transform.get_transform_stats:TransformStats": {
        "type": "object",
        "properties": {
          "checkpointing": {
            "$ref": "#/components/schemas/transform.get_transform_stats:Checkpointing"
          },
          "health": {
            "$ref": "#/components/schemas/transform.get_transform_stats:TransformStatsHealth"
          },
          "id": {
            "$ref": "#/components/schemas/_types:Id"
          },
          "reason": {
            "type": "string"
          },
          "state": {
            "type": "string"
          },
          "stats": {
            "$ref": "#/components/schemas/transform.get_transform_stats:TransformIndexerStats"
          }
        },
        "required": [
          "checkpointing",
          "id",
          "state",
          "stats"
        ]
      },
      "transform.get_transform_stats:Checkpointing": {
        "type": "object",
        "properties": {
          "changes_last_detected_at": {
            "type": "number"
          },
          "changes_last_detected_at_date_time": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "last": {
            "$ref": "#/components/schemas/transform.get_transform_stats:CheckpointStats"
          },
          "next": {
            "$ref": "#/components/schemas/transform.get_transform_stats:CheckpointStats"
          },
          "operations_behind": {
            "type": "number"
          },
          "last_search_time": {
            "type": "number"
          }
        },
        "required": [
          "last"
        ]
      },
      "transform.get_transform_stats:CheckpointStats": {
        "type": "object",
        "properties": {
          "checkpoint": {
            "type": "number"
          },
          "checkpoint_progress": {
            "$ref": "#/components/schemas/transform.get_transform_stats:TransformProgress"
          },
          "timestamp": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "timestamp_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "time_upper_bound": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "time_upper_bound_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          }
        },
        "required": [
          "checkpoint"
        ]
      },
      "transform.get_transform_stats:TransformProgress": {
        "type": "object",
        "properties": {
          "docs_indexed": {
            "type": "number"
          },
          "docs_processed": {
            "type": "number"
          },
          "docs_remaining": {
            "type": "number"
          },
          "percent_complete": {
            "type": "number"
          },
          "total_docs": {
            "type": "number"
          }
        },
        "required": [
          "docs_indexed",
          "docs_processed",
          "docs_remaining",
          "percent_complete",
          "total_docs"
        ]
      },
      "transform.get_transform_stats:TransformStatsHealth": {
        "type": "object",
        "properties": {
          "status": {
            "$ref": "#/components/schemas/_types:HealthStatus"
          }
        },
        "required": [
          "status"
        ]
      },
      "transform.get_transform_stats:TransformIndexerStats": {
        "type": "object",
        "properties": {
          "delete_time_in_ms": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "documents_indexed": {
            "type": "number"
          },
          "documents_deleted": {
            "type": "number"
          },
          "documents_processed": {
            "type": "number"
          },
          "exponential_avg_checkpoint_duration_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitFloatMillis"
          },
          "exponential_avg_documents_indexed": {
            "type": "number"
          },
          "exponential_avg_documents_processed": {
            "type": "number"
          },
          "index_failures": {
            "type": "number"
          },
          "index_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "index_total": {
            "type": "number"
          },
          "pages_processed": {
            "type": "number"
          },
          "processing_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "processing_total": {
            "type": "number"
          },
          "search_failures": {
            "type": "number"
          },
          "search_time_in_ms": {
            "$ref": "#/components/schemas/_types:DurationValueUnitMillis"
          },
          "search_total": {
            "type": "number"
          },
          "trigger_count": {
            "type": "number"
          }
        },
        "required": [
          "documents_indexed",
          "documents_processed",
          "exponential_avg_checkpoint_duration_ms",
          "exponential_avg_documents_indexed",
          "exponential_avg_documents_processed",
          "index_failures",
          "index_time_in_ms",
          "index_total",
          "pages_processed",
          "processing_time_in_ms",
          "processing_total",
          "search_failures",
          "search_time_in_ms",
          "search_total",
          "trigger_count"
        ]
      },
      "transform._types:Destination": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:IndexName"
          },
          "pipeline": {
            "description": "The unique identifier for an ingest pipeline.",
            "type": "string"
          }
        }
      },
      "_global.reindex:Source": {
        "type": "object",
        "properties": {
          "index": {
            "$ref": "#/components/schemas/_types:Indices"
          },
          "query": {
            "$ref": "#/components/schemas/_types.query_dsl:QueryContainer"
          },
          "remote": {
            "$ref": "#/components/schemas/_global.reindex:RemoteSource"
          },
          "size": {
            "description": "The number of documents to index per batch.\nUse when indexing from remote to ensure that the batches fit within the on-heap buffer, which defaults to a maximum size of 100 MB.",
            "type": "number"
          },
          "slice": {
            "$ref": "#/components/schemas/_types:SlicedScroll"
          },
          "sort": {
            "$ref": "#/components/schemas/_types:Sort"
          },
          "_source": {
            "$ref": "#/components/schemas/_types:Fields"
          },
          "runtime_mappings": {
            "$ref": "#/components/schemas/_types.mapping:RuntimeFields"
          }
        },
        "required": [
          "index"
        ]
      },
      "_global.reindex:RemoteSource": {
        "type": "object",
        "properties": {
          "connect_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          },
          "headers": {
            "description": "An object containing the headers of the request.",
            "type": "object",
            "additionalProperties": {
              "type": "string"
            }
          },
          "host": {
            "$ref": "#/components/schemas/_types:Host"
          },
          "username": {
            "$ref": "#/components/schemas/_types:Username"
          },
          "password": {
            "$ref": "#/components/schemas/_types:Password"
          },
          "socket_timeout": {
            "$ref": "#/components/schemas/_types:Duration"
          }
        },
        "required": [
          "host"
        ]
      },
      "_global.update:UpdateWriteResponseBase": {
        "allOf": [
          {
            "$ref": "#/components/schemas/_types:WriteResponseBase"
          },
          {
            "type": "object",
            "properties": {
              "get": {
                "$ref": "#/components/schemas/_types:InlineGet"
              }
            }
          }
        ]
      },
      "_types:InlineGet": {
        "type": "object",
        "properties": {
          "fields": {
            "type": "object",
            "additionalProperties": {
              "type": "object"
            }
          },
          "found": {
            "type": "boolean"
          },
          "_seq_no": {
            "$ref": "#/components/schemas/_types:SequenceNumber"
          },
          "_primary_term": {
            "type": "number"
          },
          "_routing": {
            "$ref": "#/components/schemas/_types:Routing"
          },
          "_source": {
            "type": "object"
          }
        },
        "required": [
          "found",
          "_source"
        ]
      },
      "xpack.info:BuildInformation": {
        "type": "object",
        "properties": {
          "date": {
            "$ref": "#/components/schemas/_types:DateTime"
          },
          "hash": {
            "type": "string"
          }
        },
        "required": [
          "date",
          "hash"
        ]
      },
      "xpack.info:Features": {
        "type": "object",
        "properties": {
          "aggregate_metric": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "analytics": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "ccr": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "data_frame": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "data_science": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "data_streams": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "data_tiers": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "enrich": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "eql": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "flattened": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "frozen_indices": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "graph": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "ilm": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "logstash": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "ml": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "monitoring": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "rollup": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "runtime_fields": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "searchable_snapshots": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "security": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "slm": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "spatial": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "sql": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "transform": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "vectors": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "voting_only": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "watcher": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          },
          "archive": {
            "$ref": "#/components/schemas/xpack.info:Feature"
          }
        },
        "required": [
          "aggregate_metric",
          "analytics",
          "ccr",
          "data_streams",
          "data_tiers",
          "enrich",
          "eql",
          "frozen_indices",
          "graph",
          "ilm",
          "logstash",
          "ml",
          "monitoring",
          "rollup",
          "searchable_snapshots",
          "security",
          "slm",
          "spatial",
          "sql",
          "transform",
          "voting_only",
          "watcher",
          "archive"
        ]
      },
      "xpack.info:Feature": {
        "type": "object",
        "properties": {
          "available": {
            "type": "boolean"
          },
          "description": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          },
          "native_code_info": {
            "$ref": "#/components/schemas/xpack.info:NativeCodeInformation"
          }
        },
        "required": [
          "available",
          "enabled"
        ]
      },
      "xpack.info:NativeCodeInformation": {
        "type": "object",
        "properties": {
          "build_hash": {
            "type": "string"
          },
          "version": {
            "$ref": "#/components/schemas/_types:VersionString"
          }
        },
        "required": [
          "build_hash",
          "version"
        ]
      },
      "xpack.info:MinimalLicenseInformation": {
        "type": "object",
        "properties": {
          "expiry_date_in_millis": {
            "$ref": "#/components/schemas/_types:EpochTimeUnitMillis"
          },
          "mode": {
            "$ref": "#/components/schemas/license._types:LicenseType"
          },
          "status": {
            "$ref": "#/components/schemas/license._types:LicenseStatus"
          },
          "type": {
            "$ref": "#/components/schemas/license._types:LicenseType"
          },
          "uid": {
            "type": "string"
          }
        },
        "required": [
          "expiry_date_in_millis",
          "mode",
          "status",
          "type",
          "uid"
        ]
      },
      "license._types:LicenseType": {
        "type": "string",
        "enum": [
          "missing",
          "trial",
          "basic",
          "standard",
          "dev",
          "silver",
          "gold",
          "platinum",
          "enterprise"
        ]
      },
      "license._types:LicenseStatus": {
        "type": "string",
        "enum": [
          "active",
          "valid",
          "invalid",
          "expired"
        ]
      }
    }
  }
}